<!DOCTYPE html>
<html lang=en>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
    <meta name="description" content="Template:   &gt;  Run time: $O()$, space: $O()$ 1  Binary Search, Sorting   &gt;  Run time: $O()$, space: $O()$ 1   162. Find Peak Element  Check if nums[m] &lt; nums[m+1]. If so, it means the possible answ">
<meta property="og:type" content="article">
<meta property="og:title" content="(Python) LeetCode Summary">
<meta property="og:url" content="http://yu24l.github.io/lc-summary-python/index.html">
<meta property="og:site_name" content="Lu Yu">
<meta property="og:description" content="Template:   &gt;  Run time: $O()$, space: $O()$ 1  Binary Search, Sorting   &gt;  Run time: $O()$, space: $O()$ 1   162. Find Peak Element  Check if nums[m] &lt; nums[m+1]. If so, it means the possible answ">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/006y8mN6ly1g743sn90wcj30zk0hsmzr.jpg">
<meta property="article:published_time" content="2021-12-20T15:30:00.000Z">
<meta property="article:modified_time" content="2022-01-17T23:03:47.244Z">
<meta property="article:author" content="Lu Yu">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://tva1.sinaimg.cn/large/006y8mN6ly1g743sn90wcj30zk0hsmzr.jpg">
    
    
      
        
          <link rel="shortcut icon" href="/images/favicon.ico">
        
      
      
        
          <link rel="icon" type="image/png" href="/images/favicon-192x192.png" sizes="192x192">
        
      
      
        
          <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
        
      
    
    <!-- title -->
    <title>(Python) LeetCode Summary</title>
    <!-- styles -->
    
<link rel="stylesheet" href="/css/style.css">

    <!-- persian styles -->
    
      
<link rel="stylesheet" href="/css/rtl.css">

    
    <!-- rss -->
    
    
<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 5.2.0"><link rel="stylesheet" href="/css/prism.css" type="text/css"></head>

<body class="max-width mx-auto px3 ltr">    
      <div id="header-post">
  <a id="menu-icon" href="#"><i class="fas fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#"><i class="fas fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fas fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/about/">About</a></li>
         
          <li><a href="/archives/">Posts</a></li>
         
          <li><a href="/projects/">Projects</a></li>
         
          <li><a href="/life/">Life</a></li>
        
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        <li><a class="icon" href="/python-basics/"><i class="fas fa-chevron-left" aria-hidden="true" onmouseover="$('#i-prev').toggle();" onmouseout="$('#i-prev').toggle();"></i></a></li>
        
        
        <li><a class="icon" href="/leetcode-summary/"><i class="fas fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" href="#"><i class="fas fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">Previous post</span>
      <span id="i-next" class="info" style="display:none;">Next post</span>
      <span id="i-top" class="info" style="display:none;">Back to top</span>
      <span id="i-share" class="info" style="display:none;">Share post</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=http://yu24l.github.io/lc-summary-python/"><i class="fab fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=http://yu24l.github.io/lc-summary-python/&text=(Python) LeetCode Summary"><i class="fab fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=http://yu24l.github.io/lc-summary-python/&title=(Python) LeetCode Summary"><i class="fab fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=http://yu24l.github.io/lc-summary-python/&is_video=false&description=(Python) LeetCode Summary"><i class="fab fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=(Python) LeetCode Summary&body=Check out this article: http://yu24l.github.io/lc-summary-python/"><i class="fas fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=http://yu24l.github.io/lc-summary-python/&title=(Python) LeetCode Summary"><i class="fab fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=http://yu24l.github.io/lc-summary-python/&title=(Python) LeetCode Summary"><i class="fab fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=http://yu24l.github.io/lc-summary-python/&title=(Python) LeetCode Summary"><i class="fab fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=http://yu24l.github.io/lc-summary-python/&title=(Python) LeetCode Summary"><i class="fab fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=http://yu24l.github.io/lc-summary-python/&name=(Python) LeetCode Summary&description="><i class="fab fa-tumblr " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=http://yu24l.github.io/lc-summary-python/&t=(Python) LeetCode Summary"><i class="fab fa-hacker-news " aria-hidden="true"></i></a></li>
</ul>

    </div>
    <div id="toc">
      <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">1.</span> <span class="toc-text">Binary Search, Sorting</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Sorting"><span class="toc-number">1.1.</span> <span class="toc-text">Sorting</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Topological-Sort"><span class="toc-number">1.1.1.</span> <span class="toc-text">Topological Sort</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Other"><span class="toc-number">1.1.2.</span> <span class="toc-text">Other</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Sweep-Line-Deque-Advanced-BS"><span class="toc-number">1.2.</span> <span class="toc-text">Sweep Line, Deque, Advanced BS</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">2.</span> <span class="toc-text">BFS</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">3.</span> <span class="toc-text">DFS</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Backtracking"><span class="toc-number">3.1.</span> <span class="toc-text">Backtracking</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">4.</span> <span class="toc-text">Linked List &amp; Array</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">5.</span> <span class="toc-text">Stack</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">6.</span> <span class="toc-text">2 Pointers</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">7.</span> <span class="toc-text">Hash &amp; Heap</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Advanced-Hash-Heap"><span class="toc-number">7.1.</span> <span class="toc-text">Advanced Hash&#x2F;Heap</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">8.</span> <span class="toc-text">Union Find</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">9.</span> <span class="toc-text">DP</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">10.</span> <span class="toc-text">DP coord + connected</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#DP-sliding-array-memory-search"><span class="toc-number">10.1.</span> <span class="toc-text">DP sliding array + memory search</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DP-interval-backpack"><span class="toc-number">10.2.</span> <span class="toc-text">DP interval + backpack</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">11.</span> <span class="toc-text">Tree</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Binary-Tree-Divide-Conquer"><span class="toc-number">11.1.</span> <span class="toc-text">Binary Tree &#x2F; Divide &amp; Conquer</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Trie"><span class="toc-number">11.2.</span> <span class="toc-text">Trie</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Segment-Tree"><span class="toc-number">11.3.</span> <span class="toc-text">Segment Tree</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">12.</span> <span class="toc-text">String</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">13.</span> <span class="toc-text">Recursion &#x2F; Math</span></a></li></ol>
    </div>
  </span>
</div>

    
    <div class="content index py4">
        
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle" itemprop="name headline">
        (Python) LeetCode Summary
    </h1>



    <div class="meta">
      <span class="author" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span itemprop="name">Lu Yu</span>
      </span>
      
    <div class="postdate">
      
        <time datetime="2021-12-20T15:30:00.000Z" itemprop="datePublished">2021-12-20</time>
        
      
    </div>


      

      

    </div>
  </header>
  

  <div class="content" itemprop="articleBody">
    <p>Template:</p>
<details>
<summary></summary>
> 
<p>Run time: $O()$, space: $O()$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
</details>
<h1>Binary Search, Sorting</h1>
<details>
<summary></summary>
> 
<p>Run time: $O()$, space: $O()$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>162. Find Peak Element</summary>
<blockquote>
<p>Check if nums[m] &lt; nums[m+1]. If so, it means the possible answer might not be on the left side, so set lo=mid+1.</p>
</blockquote>
<p>Run time: $O(\log n)$, space: $O(1)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findPeakElement</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">    lo, hi = <span class="number">0</span>, <span class="built_in">len</span>(nums)-<span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> lo &lt; hi:</span><br><span class="line">        m = lo + (hi-lo)//<span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> nums[m] &lt; nums[m+<span class="number">1</span>]: <span class="comment"># here m is low mid so here is nerver a case m+1 = h while l&lt;h</span></span><br><span class="line">            lo = m+<span class="number">1</span> <span class="comment"># possible answer right side without the mid            </span></span><br><span class="line">        <span class="keyword">if</span> nums[m] &gt; nums[m+<span class="number">1</span>]:</span><br><span class="line">            hi = m <span class="comment"># possible answer left side the mid</span></span><br><span class="line">    <span class="keyword">return</span> lo</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findPeakElement</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span>(<span class="params">nums, lo, hi</span>):</span></span><br><span class="line">        <span class="keyword">if</span> lo == hi:</span><br><span class="line">            <span class="keyword">return</span> lo</span><br><span class="line">        mid = lo + (hi-lo) //<span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> nums[mid] &gt; nums[mid+<span class="number">1</span>]:</span><br><span class="line">            <span class="keyword">return</span> helper(nums, lo, mid)</span><br><span class="line">        <span class="keyword">return</span> helper(nums, mid+<span class="number">1</span>, hi)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> helper(nums, <span class="number">0</span>, <span class="built_in">len</span>(nums)-<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<p>Run time: $O(n)$, space: $O(1)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findPeakElement</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)-<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">if</span> nums[i] &gt; nums[i+<span class="number">1</span>]:</span><br><span class="line">            <span class="keyword">return</span> i</span><br><span class="line">    <span class="keyword">return</span> nums[<span class="built_in">len</span>(nums)-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>240. Search a 2D Matrix II</summary>
> Search from bottom left corner. Move up if target is smaller, move right if target is greater.
<p>Run time: $O(m+n)$, space: $O(1)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">searchMatrix</span>(<span class="params">self, matrix: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]], target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">len</span>(matrix) <span class="keyword">or</span> <span class="keyword">not</span> <span class="built_in">len</span>(matrix[<span class="number">0</span>]):</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    </span><br><span class="line">    h, w = <span class="built_in">len</span>(matrix), <span class="built_in">len</span>(matrix[<span class="number">0</span>])</span><br><span class="line">    i, j = h-<span class="number">1</span>, <span class="number">0</span> <span class="comment"># bottom left corner</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">if</span> i &lt; <span class="number">0</span> <span class="keyword">or</span> j &gt;= w:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        </span><br><span class="line">        current = matrix[i][j]</span><br><span class="line">        <span class="keyword">if</span> target &lt; current: <span class="comment"># target is smaller, then go up</span></span><br><span class="line">            i -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> target &gt; current: <span class="comment"># target is larger, then go right</span></span><br><span class="line">            j += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">else</span>:<span class="comment"># hit target</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>Recursion.</p>
</blockquote>
<p>Run time: $O(mn)$, space: $O(mn)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">searchMatrix</span>(<span class="params">self, matrix: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]], target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span>(<span class="params">matrix, target, i, j, s</span>):</span></span><br><span class="line">        <span class="keyword">if</span> i &gt;= m <span class="keyword">or</span> j &gt;= n <span class="keyword">or</span> i &lt; <span class="number">0</span> <span class="keyword">or</span> j &lt; <span class="number">0</span> <span class="keyword">or</span> (i,j) <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        s.add((i,j))</span><br><span class="line">        <span class="keyword">if</span> matrix[i][j] == target:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">elif</span> matrix[i][j] &lt; target:</span><br><span class="line">            <span class="keyword">return</span> helper(matrix, target, i+<span class="number">1</span>, j, s) <span class="keyword">or</span> \</span><br><span class="line">                   helper(matrix, target, i, j+<span class="number">1</span>, s)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> helper(matrix, target, i-<span class="number">1</span>, j, s) <span class="keyword">or</span> \</span><br><span class="line">                   helper(matrix, target, i, j-<span class="number">1</span>, s)</span><br><span class="line">            </span><br><span class="line">    <span class="keyword">if</span> target &gt; matrix[-<span class="number">1</span>][-<span class="number">1</span>]:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    m,n = <span class="built_in">len</span>(matrix), <span class="built_in">len</span>(matrix[<span class="number">0</span>])</span><br><span class="line">    <span class="keyword">return</span> helper(matrix, target, <span class="number">0</span>,<span class="number">0</span>, <span class="built_in">set</span>())</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>81. Search in Rotated Sorted Array II</summary>
> Three cases: if `nums[mid] == target`, return True. If `nums[mid]` is equal to `nums[lo]`, we could not determine which part of the array is rotated, therefore we increment `lo` by 1. If `nums[mid]`is smaller than or equal to `nums[hi]`, then we know the right part may be monotone increasing. We check if the target falls into this interval and update the index. The last case is whether the target falls into the intervals of `lo` and `mid`.
<p>Run time: $O(\log n)$, space: $O(1)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">search</span>(<span class="params">self, nums, target</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    :type nums: List[int]</span></span><br><span class="line"><span class="string">    :type target: int</span></span><br><span class="line"><span class="string">    :rtype: bool</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    </span><br><span class="line">    lo = <span class="number">0</span></span><br><span class="line">    hi = <span class="built_in">len</span>(nums)-<span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> lo &lt;= hi:</span><br><span class="line">        mid = lo + (hi-lo)//<span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> nums[mid] == target:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">if</span> nums[lo] == nums[mid]:</span><br><span class="line">            lo += <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> nums[mid] &lt;= nums[hi]:</span><br><span class="line">            <span class="keyword">if</span> nums[mid] &lt; target &lt;= nums[hi]:</span><br><span class="line">                lo = mid+<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                hi = mid-<span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> nums[lo] &lt;= target &lt; nums[mid]:</span><br><span class="line">                hi = mid-<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                lo = mid+<span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>34. Find First and Last Position of Element in Sorted Array</summary>
> If the while condition has equal sign, then every case needs to increment or decrement by 1.
<p>Run time: $O(\log n)$, space: $O(1)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">searchRange</span>(<span class="params">self, nums, target</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    :type nums: List[int]</span></span><br><span class="line"><span class="string">    :type target: int</span></span><br><span class="line"><span class="string">    :rtype: List[int]</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lower_bound</span>():</span></span><br><span class="line">        lo = <span class="number">0</span></span><br><span class="line">        hi = <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">while</span> lo &lt;= hi:</span><br><span class="line">            mid = lo + (hi-lo)//<span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid] &gt;= target:</span><br><span class="line">                hi = mid-<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                lo = mid+<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> lo</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">upper_bound</span>():</span></span><br><span class="line">        lo = <span class="number">0</span></span><br><span class="line">        hi = <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">while</span> lo &lt;= hi:</span><br><span class="line">            mid = lo + (hi-lo)//<span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid] &lt;= target:</span><br><span class="line">                lo = mid+<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                hi = mid-<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> hi</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">        <span class="keyword">return</span> [-<span class="number">1</span>,-<span class="number">1</span>]</span><br><span class="line">    first = lower_bound()</span><br><span class="line">    last = upper_bound()</span><br><span class="line">    <span class="keyword">if</span> first &gt;= last:</span><br><span class="line">        <span class="keyword">return</span> [-<span class="number">1</span>,-<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">return</span> [first, last]</span><br></pre></td></tr></table></figure>
</details>
<h2 id="Sorting">Sorting</h2>
<details>
<summary></summary>
> 
<p>Run time: $O()$, space: $O()$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
</details>
<h3 id="Topological-Sort">Topological Sort</h3>
<details>
<summary>210. Course Schedule II</summary>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/course-schedule-ii/discuss/762346/Python-BFS-beats-98-with-Detailed-Explanation-and-Comments">https://leetcode.com/problems/course-schedule-ii/discuss/762346/Python-BFS-beats-98-with-Detailed-Explanation-and-Comments</a>!</p>
</blockquote>
<p>Run time: $O(v+e)$, space: $O(v+e)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">findOrder</span>(<span class="params">self, numCourses: <span class="built_in">int</span>, prerequisites: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span></span><br><span class="line">      <span class="comment"># Create a prerequisite dict. (containing courses (nodes) that need to be taken (visited)</span></span><br><span class="line"><span class="comment"># before we can visit the key.</span></span><br><span class="line">      preq = &#123;i:<span class="built_in">set</span>() <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(numCourses)&#125;</span><br><span class="line"><span class="comment"># Create a graph for adjacency and traversing.</span></span><br><span class="line">      graph = collections.defaultdict(<span class="built_in">set</span>)</span><br><span class="line">      <span class="keyword">for</span> i,j <span class="keyword">in</span> prerequisites:</span><br><span class="line">    <span class="comment"># Preqs store requirments as their given.</span></span><br><span class="line">          preq[i].add(j)</span><br><span class="line">	<span class="comment"># Graph stores nodes and neighbors.</span></span><br><span class="line">          graph[j].add(i)</span><br><span class="line">      </span><br><span class="line">      q = collections.deque([])</span><br><span class="line"><span class="comment"># We need to find a starting location, aka courses that have no prereqs.</span></span><br><span class="line">      <span class="keyword">for</span> k, v <span class="keyword">in</span> preq.items():</span><br><span class="line">          <span class="keyword">if</span> <span class="built_in">len</span>(v) == <span class="number">0</span>:</span><br><span class="line">              q.append(k)</span><br><span class="line"><span class="comment"># Keep track of which courses have been taken.</span></span><br><span class="line">      taken = []</span><br><span class="line">      <span class="keyword">while</span> q:</span><br><span class="line">          course = q.popleft()</span><br><span class="line">          taken.append(course)</span><br><span class="line">	<span class="comment"># If we have visited the numCourses we&#x27;re done.</span></span><br><span class="line">          <span class="keyword">if</span> <span class="built_in">len</span>(taken) == numCourses:</span><br><span class="line">              <span class="keyword">return</span> taken</span><br><span class="line">	<span class="comment"># For neighboring courses.</span></span><br><span class="line">          <span class="keyword">for</span> cor <span class="keyword">in</span> graph[course]:</span><br><span class="line">	    <span class="comment"># If the course we&#x27;ve just taken was a prereq for the next course, remove it from its prereqs.</span></span><br><span class="line">              preq[cor].remove(course)</span><br><span class="line">		<span class="comment"># If we&#x27;ve taken all of the preqs for the new course, we&#x27;ll visit it.</span></span><br><span class="line">              <span class="keyword">if</span> <span class="keyword">not</span> preq[cor]:</span><br><span class="line">                  q.append(cor)</span><br><span class="line"><span class="comment"># If we didn&#x27;t hit numCourses in our search we know we can&#x27;t take all of the courses.</span></span><br><span class="line">      <span class="keyword">return</span> []</span><br></pre></td></tr></table></figure>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/course-schedule-ii/discuss/266867/Python-Topological-Sort-BFS-and-DFS-(reserve-order)">https://leetcode.com/problems/course-schedule-ii/discuss/266867/Python-Topological-Sort-BFS-and-DFS-(reserve-order)</a></p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findOrder</span>(<span class="params">self, numCourses: <span class="built_in">int</span>, prerequisites: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span></span><br><span class="line">    n = numCourses</span><br><span class="line">    G = [<span class="built_in">set</span>() <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">    <span class="keyword">for</span> d, s <span class="keyword">in</span> prerequisites:</span><br><span class="line">        G[s].add(d)</span><br><span class="line">    vis, orders = [<span class="number">0</span>] * n, []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs_circle</span>(<span class="params">x</span>):</span></span><br><span class="line">        vis[x] = -<span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> y <span class="keyword">in</span> G[x]:</span><br><span class="line">            <span class="keyword">if</span> vis[y] &lt; <span class="number">0</span> <span class="keyword">or</span> (<span class="keyword">not</span> vis[y] <span class="keyword">and</span> dfs_circle(y)):</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        vis[x] = <span class="number">1</span></span><br><span class="line">        orders.append(x)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(numCourses):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> vis[x] <span class="keyword">and</span> dfs_circle(x):</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">    <span class="keyword">return</span> orders[::-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
</details>
<h3 id="Other">Other</h3>
<details>
<summary></summary>
> 
<p>Run time: $O()$, space: $O()$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>56. Merge Intervals</summary>
<blockquote>
<p>Question: How do you add intervals and merge them for a large stream of intervals? (Facebook Follow-up Question)</p>
</blockquote>
<p>Run time: $O(n\log n)$, space: $O(n)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge</span>(<span class="params">self, intervals: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span></span><br><span class="line">    heapify(intervals)</span><br><span class="line">    merged = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(intervals)):</span><br><span class="line">        root = heappop(intervals)</span><br><span class="line">        <span class="keyword">if</span> merged <span class="keyword">and</span> merged[-<span class="number">1</span>][<span class="number">1</span>]&gt;=root[<span class="number">0</span>]:</span><br><span class="line">            merged[-<span class="number">1</span>][<span class="number">1</span>] = <span class="built_in">max</span>(merged[-<span class="number">1</span>][<span class="number">1</span>], root[<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            merged.append(root)</span><br><span class="line">    <span class="keyword">return</span> merged</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge</span>(<span class="params">self, intervals: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span></span><br><span class="line">    intervals.sort(key=<span class="keyword">lambda</span> x: x[<span class="number">0</span>])</span><br><span class="line">    merged = []</span><br><span class="line">    <span class="keyword">for</span> interval <span class="keyword">in</span> intervals:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> merged <span class="keyword">or</span> merged[-<span class="number">1</span>][<span class="number">1</span>] &lt; interval[<span class="number">0</span>]:</span><br><span class="line">            merged.append(interval)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            merged[-<span class="number">1</span>][<span class="number">1</span>] = <span class="built_in">max</span>(merged[-<span class="number">1</span>][<span class="number">1</span>], interval[<span class="number">1</span>])</span><br><span class="line">    <span class="keyword">return</span> merged</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>169. Majority Element</summary>
<blockquote>
<p>Boyer-Moore Voting Algorithm<br>
If we had some way of counting instances of the majority element as +1+1 and instances of any other element as -1âˆ’1, summing them would make it obvious that the majority element is indeed the majority element.</p>
</blockquote>
<p>Run time: $O(n)$, space: $O(1)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">majorityElement</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    candidate = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">        <span class="keyword">if</span> count == <span class="number">0</span>:</span><br><span class="line">            candidate = num</span><br><span class="line">        <span class="keyword">if</span> num == candidate:</span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            count -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> candidate</span><br></pre></td></tr></table></figure>
<blockquote>
<p>In-place sort, and the one in the middle would be the mode.</p>
</blockquote>
<p>Run time: $O(n\log n)$, space: $O(1)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">majorityElement</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">    nums.sort()</span><br><span class="line">    <span class="keyword">return</span> nums[<span class="built_in">len</span>(nums)//<span class="number">2</span>]</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Put into a dictionary, and find the one with max value.</p>
</blockquote>
<p>Run time: $O(n)$, space: $O(n)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">majorityElement</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">    count = Counter(nums).items()</span><br><span class="line">    max_count, maj = <span class="number">0</span>, -<span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> k, v <span class="keyword">in</span> count:</span><br><span class="line">        <span class="keyword">if</span> v &gt; max_count:</span><br><span class="line">            max_count = v</span><br><span class="line">            maj = k</span><br><span class="line">    <span class="keyword">return</span> maj</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>347. Top K Frequent Elements</summary>
<blockquote>
<p>bucket sort. Create a list of list of length <code>len(nums)+1</code>, where index serves as frequency. Use a dictionary or Counter to get the frequencies of each number, and loop through each key value pair, and put the key to the corresponding buckets. Loop through the buckets reversely, if it is not empty, append the number.</p>
</blockquote>
<p>Run time: $O(n)$, space: $O(n)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">buckets = [[] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums) + <span class="number">1</span>)]</span><br><span class="line">number_count = collections.defaultdict(<span class="built_in">int</span>)</span><br><span class="line"><span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">    number_count[num] += <span class="number">1</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">for</span> num, freq <span class="keyword">in</span> number_count.items():</span><br><span class="line">    buckets[freq].append(num)</span><br><span class="line"></span><br><span class="line"><span class="comment"># buckets is a double array</span></span><br><span class="line">flat_list = []</span><br><span class="line"><span class="comment"># traverse from right to left so number with higher frequency come first</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(buckets) - <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">    bucket = buckets[i]</span><br><span class="line">    <span class="keyword">if</span> bucket:</span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> bucket:</span><br><span class="line">            flat_list.append(num)</span><br><span class="line"><span class="keyword">return</span> flat_list[:k]</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Use <code>Counter</code> to calculate the count for each number, which returns a dict. Then put the keys into a heap, sort by values, <code>key=count.get</code>, use <code>heapq.nlargest</code>.</p>
</blockquote>
<p>Run time: $O(n\log k)$, space: $O(n+k)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">topKFrequent</span>(<span class="params">self, nums, k</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    :type nums: List[int]</span></span><br><span class="line"><span class="string">    :type k: int</span></span><br><span class="line"><span class="string">    :rtype: List[int]</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> k == <span class="built_in">len</span>(nums):</span><br><span class="line">        <span class="keyword">return</span> nums</span><br><span class="line">    count = Counter(nums)</span><br><span class="line">    <span class="keyword">return</span> heapq.nlargest(k, count.keys(), key=count.get)</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>215. Kth Largest Element in an Array</summary>
<blockquote>
<p>Quick Select.</p>
</blockquote>
<p>Run time: $O(n)$, space: $O(n)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findKthLargest</span>(<span class="params">self, nums, k</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> nums: <span class="keyword">return</span></span><br><span class="line">    pivot = random.choice(nums)</span><br><span class="line">    left =  [x <span class="keyword">for</span> x <span class="keyword">in</span> nums <span class="keyword">if</span> x &gt; pivot]</span><br><span class="line">    mid  =  [x <span class="keyword">for</span> x <span class="keyword">in</span> nums <span class="keyword">if</span> x == pivot]</span><br><span class="line">    right = [x <span class="keyword">for</span> x <span class="keyword">in</span> nums <span class="keyword">if</span> x &lt; pivot]</span><br><span class="line">    </span><br><span class="line">    L, M = <span class="built_in">len</span>(left), <span class="built_in">len</span>(mid)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> k &lt;= L:</span><br><span class="line">        <span class="keyword">return</span> self.findKthLargest(left, k)</span><br><span class="line">    <span class="keyword">elif</span> k &gt; L + M:</span><br><span class="line">        <span class="keyword">return</span> self.findKthLargest(right, k - L - M)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> mid[<span class="number">0</span>]</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Use <code>heapq.nlargest(k, nums)</code> and get the last element in the return array.</p>
</blockquote>
<p>Run time: $O(n\log k)$, space: $O(k)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findKthLargest</span>(<span class="params">self, nums, k</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    :type nums: List[int]</span></span><br><span class="line"><span class="string">    :type k: int</span></span><br><span class="line"><span class="string">    :rtype: int</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># heap = []</span></span><br><span class="line">    <span class="comment"># for n in nums:</span></span><br><span class="line">    <span class="comment">#     if len(heap) == k:</span></span><br><span class="line">    <span class="comment">#         if heap[0] &lt; n:</span></span><br><span class="line">    <span class="comment">#             heappop(heap)</span></span><br><span class="line">    <span class="comment">#             heappush(heap, n)</span></span><br><span class="line">    <span class="comment">#     else:</span></span><br><span class="line">    <span class="comment">#         heappush(heap, n)</span></span><br><span class="line">    <span class="comment"># return heap[-k]</span></span><br><span class="line">    <span class="keyword">return</span> heapq.nlargest(k, nums)[-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>528. Random Pick with Weight</summary>
<blockquote>
<p>Use binary search to find the target index</p>
</blockquote>
<p>Run time: $O(n)$, $O(\log n)$, space: $O(n)$, $O(1)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, w</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type w: List[int]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self.prefix_sums = []</span><br><span class="line">        total = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> weight <span class="keyword">in</span> w:</span><br><span class="line">            total += weight</span><br><span class="line">            self.prefix_sums.append(total)</span><br><span class="line">        self.total_sum = total</span><br><span class="line">            </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pickIndex</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        rand = random.random() * self.total_sum</span><br><span class="line">        lo, hi = <span class="number">0</span>, <span class="built_in">len</span>(self.prefix_sums)</span><br><span class="line">        <span class="keyword">while</span> lo &lt; hi:</span><br><span class="line">            mid = lo + (hi-lo)//<span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> rand &gt; self.prefix_sums[mid]:</span><br><span class="line">                lo = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                hi = mid</span><br><span class="line">        <span class="keyword">return</span> lo</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>Keep track of cumulative sum and put it in an array, also get the total sum. Generate a number from 0 to 1, and scale with the total sum. If it is smaller than current cumulative sum, return the index.</p>
</blockquote>
<p>Run time: $O(n)$, $O(n)$, space: $O(n)$, $O(1)$</p>
<details>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, w</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type w: List[int]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        d = <span class="built_in">sum</span>(w)</span><br><span class="line">        <span class="built_in">print</span>(d)</span><br><span class="line">        self.weighted = [<span class="built_in">float</span>(a)/d <span class="keyword">for</span> a <span class="keyword">in</span> w]</span><br><span class="line">            </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pickIndex</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        rand = random.random()</span><br><span class="line">        <span class="keyword">for</span> i, w <span class="keyword">in</span> <span class="built_in">enumerate</span>(self.weighted):</span><br><span class="line">            <span class="keyword">if</span> rand &lt; w:</span><br><span class="line">                <span class="keyword">return</span> i</span><br></pre></td></tr></table></figure>
</details>
</details>
<details>
<summary>973. K Closest Points to Origin</summary>
<blockquote>
<p>QuickSelect</p>
</blockquote>
<p>Run time: $O(n)$, space: $O(1)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">kClosest</span>(<span class="params">self, points, k</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.quick_select(points, k)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">quick_select</span>(<span class="params">self, points, k</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;Perform the QuickSelect algorithm on the list&quot;&quot;&quot;</span></span><br><span class="line">        left, right = <span class="number">0</span>, <span class="built_in">len</span>(points) - <span class="number">1</span></span><br><span class="line">        pivot_index = <span class="built_in">len</span>(points)</span><br><span class="line">        <span class="keyword">while</span> pivot_index != k:</span><br><span class="line">            <span class="comment"># Repeatedly partition the list</span></span><br><span class="line">            <span class="comment"># while narrowing in on the kth element</span></span><br><span class="line">            pivot_index = self.partition(points, left, right)</span><br><span class="line">            <span class="keyword">if</span> pivot_index &lt; k:</span><br><span class="line">                left = pivot_index</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                right = pivot_index - <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># Return the first k elements of the partially sorted list</span></span><br><span class="line">        <span class="keyword">return</span> points[:k]</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">partition</span>(<span class="params">self, points, left, right</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;Partition the list around the pivot value&quot;&quot;&quot;</span></span><br><span class="line">        pivot = self.choose_pivot(points, left, right)</span><br><span class="line">        pivot_dist = self.squared_distance(pivot)</span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            <span class="comment"># Iterate through the range and swap elements to make sure</span></span><br><span class="line">            <span class="comment"># that all points closer than the pivot are to the left</span></span><br><span class="line">            <span class="keyword">if</span> self.squared_distance(points[left]) &gt;= pivot_dist:</span><br><span class="line">                points[left], points[right] = points[right], points[left]</span><br><span class="line">                right -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># Ensure the left pointer is just past the end of</span></span><br><span class="line">        <span class="comment"># the left range then return it as the new pivotIndex</span></span><br><span class="line">        <span class="keyword">if</span> self.squared_distance(points[left]) &lt; pivot_dist:</span><br><span class="line">            left += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> left</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">choose_pivot</span>(<span class="params">self, points, left, right</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;Choose a pivot element of the list&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> points[left + (right - left) // <span class="number">2</span>]</span><br><span class="line">        </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">squared_distance</span>(<span class="params">self, point</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;Calculate and return the squared Euclidean distance.&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> point[<span class="number">0</span>] ** <span class="number">2</span> + point[<span class="number">1</span>] ** <span class="number">2</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>Binary Search: set the <code>lo</code> and <code>hi</code> to be the min (0) and max euclidean distance in the list of points. Then perform binary search to loop through all points in this range and classify them into two lists: distance smaller than mid, and distance greater than mid. If the length of closer list is equal to or less than <code>k</code>, then all of them would be included in the final result and we will skip them in the next search and update the <code>k</code>.<br>
Run time: $O(n)$, space: $O(n)$</p>
</blockquote>
<details>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">kClosest</span>(<span class="params">self, points, k</span>):</span></span><br><span class="line">    <span class="comment"># Precompute the Euclidean distance for each point</span></span><br><span class="line">    distances = [self.euclidean_distance(point) <span class="keyword">for</span> point <span class="keyword">in</span> points]</span><br><span class="line">    <span class="comment"># Create a reference list of point indices</span></span><br><span class="line">    remaining = [i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(points))]</span><br><span class="line">    <span class="comment"># Define the initial binary search range</span></span><br><span class="line">    low, high = <span class="number">0</span>, <span class="built_in">max</span>(distances)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Perform a binary search of the distances</span></span><br><span class="line">    <span class="comment"># to find the k closest points</span></span><br><span class="line">    closest = []</span><br><span class="line">    <span class="keyword">while</span> k:</span><br><span class="line">        mid = low + (high - low) / <span class="number">2</span></span><br><span class="line">        closer, farther = self.split_distances(remaining, distances, mid)</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(closer) &gt; k:</span><br><span class="line">            <span class="comment"># If more than k points are in the closer distances</span></span><br><span class="line">            <span class="comment"># then discard the farther points and continue</span></span><br><span class="line">            remaining = closer</span><br><span class="line">            high = mid</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># Add the closer points to the answer array and keep</span></span><br><span class="line">            <span class="comment"># searching the farther distances for the remaining points</span></span><br><span class="line">            k -= <span class="built_in">len</span>(closer)</span><br><span class="line">            closest.extend(closer)</span><br><span class="line">            remaining = farther</span><br><span class="line">            low = mid</span><br><span class="line">            </span><br><span class="line">    <span class="comment"># Return the k closest points using the reference indices</span></span><br><span class="line">    <span class="keyword">return</span> [points[i] <span class="keyword">for</span> i <span class="keyword">in</span> closest]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">split_distances</span>(<span class="params">self, remaining, distances, mid</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;Split the distances around the midpoint</span></span><br><span class="line"><span class="string">    and return them in separate lists.&quot;&quot;&quot;</span></span><br><span class="line">    closer, farther = [], []</span><br><span class="line">    <span class="keyword">for</span> index <span class="keyword">in</span> remaining:</span><br><span class="line">        <span class="keyword">if</span> distances[index] &lt;= mid:</span><br><span class="line">            closer.append(index)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            farther.append(index)</span><br><span class="line">    <span class="keyword">return</span> [closer, farther]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">euclidean_distance</span>(<span class="params">self, point</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;Calculate and return the Euclidean distance.&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> sqrt(point[<span class="number">0</span>] ** <span class="number">2</span> + point[<span class="number">1</span>] ** <span class="number">2</span>)</span><br></pre></td></tr></table></figure>
</details>
<blockquote>
<p>Maintain a max heap with size $k$ that stores the negative value of the squares of coordinates. Once heap size exceeds $k$, pop the element.</p>
</blockquote>
<p>Run time: $O(n\log k)$, space: $O(k)$</p>
<details>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">kClosest</span>(<span class="params">self, points, k</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    :type points: List[List[int]]</span></span><br><span class="line"><span class="string">    :type k: int</span></span><br><span class="line"><span class="string">    :rtype: List[List[int]]</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    heap = []</span><br><span class="line">    <span class="keyword">for</span> point <span class="keyword">in</span> points:</span><br><span class="line">        dist = point[<span class="number">0</span>] * point[<span class="number">0</span>] + point[<span class="number">1</span>] * point[<span class="number">1</span>]</span><br><span class="line">        heapq.heappush(heap, (-dist, point))</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(heap) &gt; k:</span><br><span class="line">            heapq.heappop(heap)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> [<span class="built_in">tuple</span>[<span class="number">1</span>] <span class="keyword">for</span> <span class="built_in">tuple</span> <span class="keyword">in</span> heap]</span><br></pre></td></tr></table></figure>
</details>
</details>
<h2 id="Sweep-Line-Deque-Advanced-BS">Sweep Line, Deque, Advanced BS</h2>
<details>
<summary></summary>
> 
<p>Run time: $O()$, space: $O()$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
</details>
<h1>BFS</h1>
<details>
<summary></summary>
> 
<p>Run time: $O()$, space: $O()$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>126. Word Ladder II</summary>
> bi-directional search
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findLadders</span>(<span class="params">self, beginWord: <span class="built_in">str</span>, endWord: <span class="built_in">str</span>, wordList: <span class="type">List</span>[<span class="built_in">str</span>]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">str</span>]]:</span></span><br><span class="line">    <span class="keyword">if</span> endWord <span class="keyword">not</span> <span class="keyword">in</span> wordList:</span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line"></span><br><span class="line">    wordList = <span class="built_in">set</span>(wordList)</span><br><span class="line">    n = <span class="built_in">len</span>(beginWord)</span><br><span class="line"></span><br><span class="line">    found, swapped = <span class="literal">False</span>, <span class="literal">False</span></span><br><span class="line">    start_q, end_q= &#123;beginWord&#125;, &#123;endWord&#125;</span><br><span class="line">    paths, res = collections.defaultdict(<span class="built_in">set</span>), []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> start_q <span class="keyword">and</span> <span class="keyword">not</span> found:</span><br><span class="line">        next_q = <span class="built_in">set</span>()</span><br><span class="line">        wordList -= <span class="built_in">set</span>(start_q)</span><br><span class="line">        <span class="keyword">for</span> word <span class="keyword">in</span> start_q:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                first, second = word[:i], word[i+<span class="number">1</span>:]</span><br><span class="line">                <span class="keyword">for</span> c <span class="keyword">in</span> <span class="string">&#x27;abcdefghijklmnopqrstuvwxyz&#x27;</span>:</span><br><span class="line">                    new_word = first+c+second</span><br><span class="line">                    <span class="keyword">if</span> new_word <span class="keyword">in</span> wordList:</span><br><span class="line">                        <span class="keyword">if</span> new_word <span class="keyword">in</span> end_q:</span><br><span class="line">                            found = <span class="literal">True</span></span><br><span class="line">                        <span class="keyword">else</span>:</span><br><span class="line">                            next_q.add(new_word)</span><br><span class="line"></span><br><span class="line">                        paths[new_word].add(word) <span class="keyword">if</span> swapped <span class="keyword">else</span> paths[word].add(new_word)</span><br><span class="line"></span><br><span class="line">        start_q = next_q</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(start_q) &gt; <span class="built_in">len</span>(end_q):</span><br><span class="line">            start_q, end_q = end_q, start_q</span><br><span class="line">            swapped = <span class="keyword">not</span> swapped</span><br><span class="line">    </span><br><span class="line">    res = []</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">bfs</span>(<span class="params">word, cur_path</span>):</span></span><br><span class="line">        <span class="keyword">if</span> word == endWord:</span><br><span class="line">            cur_path.append(word)</span><br><span class="line">            res.append(cur_path[::])</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">for</span> parent <span class="keyword">in</span> paths[word]:</span><br><span class="line">                bfs(parent, cur_path+[word])</span><br><span class="line">    bfs(beginWord, [])</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Create a set that contains wordList, and a dictionary <code>layer</code> that contains &lt;endWord, all possible sequences&gt; pairs. While layer is not empty, we loop through all keys, and see if the endWord is in it. Then, we loop through each character in the word, trying to replace it with every alphabet. If this new word is valid, we create an entry in the new dictionary, and the values are formed by the values of the old word. Outside of this for loop, we remove the keys in the new dictionary so that they will not be reused, and we assign the new dictionary to the old one.</p>
</blockquote>
<p>Run time: $O(nk^2)$, space: $O(nk)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findLadders</span>(<span class="params">self, beginWord: <span class="built_in">str</span>, endWord: <span class="built_in">str</span>, wordList: <span class="type">List</span>[<span class="built_in">str</span>]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">str</span>]]:</span></span><br><span class="line">    <span class="keyword">if</span> endWord <span class="keyword">not</span> <span class="keyword">in</span> wordList:</span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line">    </span><br><span class="line">    wordSet = <span class="built_in">set</span>(wordList)</span><br><span class="line">    layer = &#123;&#125;</span><br><span class="line">    layer[beginWord] = [[beginWord]]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> layer:</span><br><span class="line">        new_l = collections.defaultdict(<span class="built_in">list</span>)</span><br><span class="line">        <span class="keyword">for</span> word <span class="keyword">in</span> layer:</span><br><span class="line">            <span class="keyword">if</span> word == endWord:</span><br><span class="line">                <span class="keyword">return</span> layer[word]</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(word)):</span><br><span class="line">                <span class="keyword">for</span> c <span class="keyword">in</span> <span class="string">&#x27;abcdefghijklmnopqrstuvwxyz&#x27;</span>:</span><br><span class="line">                    new_word = word[:i] + c + word[i+<span class="number">1</span>:]</span><br><span class="line">                    <span class="keyword">if</span> new_word <span class="keyword">in</span> wordSet:</span><br><span class="line">                        <span class="comment"># add new word to all sequences and form new layer element</span></span><br><span class="line">                        new_l[new_word] += [j + [new_word] <span class="keyword">for</span> j <span class="keyword">in</span> layer[word]]</span><br><span class="line">        wordSet -= <span class="built_in">set</span>(new_l.keys())</span><br><span class="line">        layer = new_l</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> []</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>934. Shortest Bridge</summary>
<blockquote>
<p>First use DFS find one island, change all cells to 2 in order to differentiate from the other island, and also add the position to the stack. Get the size of the stack, while it is not empty, pop one position from the stack and explore in four directions, if it is not valid or still the same island (==2), continue. If it is 1, then it means we found the island, return the number of steps. Otherwise, we set this empty land to be 2, and append the position to the level. When we run out of current possible movements, we increment the steps by 1, and assign level to the stack.</p>
</blockquote>
<p>Run time: $O(mn)$, space: $O(mn)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">shortestBridge</span>(<span class="params">self, grid</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    :type grid: List[List[int]]</span></span><br><span class="line"><span class="string">    :rtype: int</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">grid, i, j, stack</span>):</span></span><br><span class="line">        <span class="keyword">if</span> i &lt; <span class="number">0</span> <span class="keyword">or</span> i &gt;= m <span class="keyword">or</span> j &lt; <span class="number">0</span> <span class="keyword">or</span> j &gt;= n <span class="keyword">or</span> grid[i][j] != <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        grid[i][j] = <span class="number">2</span></span><br><span class="line">        stack.append((i, j))</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">            dfs(grid, i+dirs[k], j+dirs[k+<span class="number">1</span>], stack)</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> grid:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    </span><br><span class="line">    dirs = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, <span class="number">0</span>]</span><br><span class="line">    stack = []</span><br><span class="line">    m,n = <span class="built_in">len</span>(grid), <span class="built_in">len</span>(grid[<span class="number">0</span>])</span><br><span class="line">    found = <span class="literal">False</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">if</span> grid[i][j] == <span class="number">1</span>:</span><br><span class="line">                dfs(grid,i, j, stack)</span><br><span class="line">                found = <span class="literal">True</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span> found:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    </span><br><span class="line">    steps = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> stack:</span><br><span class="line">        size = <span class="built_in">len</span>(stack)</span><br><span class="line">        level = []</span><br><span class="line">        <span class="keyword">while</span> (size):</span><br><span class="line">            x,y = stack.pop()</span><br><span class="line">            size -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">                x1 = x + dirs[i]</span><br><span class="line">                y1 = y + dirs[i+<span class="number">1</span>]</span><br><span class="line">                <span class="keyword">if</span> x1 &lt; <span class="number">0</span> <span class="keyword">or</span> x1 &gt;= m <span class="keyword">or</span> y1 &lt; <span class="number">0</span> <span class="keyword">or</span> y1 &gt;= n <span class="keyword">or</span> grid[x1][y1] == <span class="number">2</span>:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                <span class="keyword">if</span> grid[x1][y1] == <span class="number">1</span>: <span class="comment"># found</span></span><br><span class="line">                    <span class="keyword">return</span> steps</span><br><span class="line">                grid[x1][y1] = <span class="number">2</span></span><br><span class="line">                level.append((x1, y1))</span><br><span class="line">        steps += <span class="number">1</span></span><br><span class="line">        stack = level</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>317. Shortest Distance from All Buildings</summary>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/shortest-distance-from-all-buildings/discuss/963506/Python-BFS-code-with-comments">https://leetcode.com/problems/shortest-distance-from-all-buildings/discuss/963506/Python-BFS-code-with-comments</a></p>
</blockquote>
<p>Run time: $O(N^2M^2)$, space: $O(NM)$, where $N$, $M$ are the number of rows and columns in grid.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">shortestDistance</span>(<span class="params">self, grid: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> grid:</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">    <span class="comment"># create a list of buildings and a set of empty lands for easy search later</span></span><br><span class="line">    build, land = [], <span class="built_in">set</span>()</span><br><span class="line">    <span class="keyword">for</span> x,y <span class="keyword">in</span> itertools.product(<span class="built_in">range</span>(<span class="built_in">len</span>(grid)), <span class="built_in">range</span>(<span class="built_in">len</span>(grid[<span class="number">0</span>]))):</span><br><span class="line">        <span class="keyword">if</span> grid[x][y] == <span class="number">0</span>:</span><br><span class="line">            land.add((x,y))</span><br><span class="line">        <span class="keyword">elif</span> grid[x][y] == <span class="number">1</span>:</span><br><span class="line">            build.append((x,y))</span><br><span class="line">    <span class="comment"># if there is no empty land available, we can&#x27;t proceed further</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> land:</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># create a dictionary where each land&#x27;s position tuple is a key and its value</span></span><br><span class="line">    <span class="comment"># is a list of length equal to the number of buildings we found above. </span></span><br><span class="line">    <span class="comment"># This list is populated with Inf, to start with, that will be updated by the</span></span><br><span class="line">    <span class="comment"># shortest distance between the land and building pair, found by BFS routine below.</span></span><br><span class="line">    d = &#123;x: [<span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)]*<span class="built_in">len</span>(build) <span class="keyword">for</span> x <span class="keyword">in</span> land&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># BFS for a given building&#x27;s location</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">BFS</span>(<span class="params">loc</span>):</span></span><br><span class="line">        x, y = build[loc]</span><br><span class="line">        <span class="comment"># (x,y) is building&#x27;s location on the grid and 0 is the starting distance</span></span><br><span class="line">        q = collections.deque([(x,y,<span class="number">0</span>)]) </span><br><span class="line">        <span class="keyword">while</span> q:</span><br><span class="line">            x, y, dist = q.popleft()</span><br><span class="line">            <span class="keyword">for</span> i, j <span class="keyword">in</span> [(x-<span class="number">1</span>, y), (x+<span class="number">1</span>, y), (x, y-<span class="number">1</span>), (x, y+<span class="number">1</span>)]:</span><br><span class="line">                <span class="comment"># we are interested in only traversing lands whose recorded distance from</span></span><br><span class="line">                <span class="comment"># current building is more than dist+1. We update their distance and include</span></span><br><span class="line">                <span class="comment"># these lands in our queue for the next layer, if that&#x27;s the case</span></span><br><span class="line">                <span class="keyword">if</span> (i,j) <span class="keyword">in</span> land <span class="keyword">and</span> d[(i,j)][loc] &gt; dist + <span class="number">1</span>:</span><br><span class="line">                    d[(i,j)][loc] = dist + <span class="number">1</span></span><br><span class="line">                    q.append((i,j,dist+<span class="number">1</span>))</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># run BFS routine for all buildings</span></span><br><span class="line">    <span class="keyword">for</span> loc <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(build)):</span><br><span class="line">        BFS(loc)</span><br><span class="line">        </span><br><span class="line">    <span class="comment"># compute the shortest distance to all buildings for each empty land</span></span><br><span class="line">    min_dist = <span class="built_in">min</span>(<span class="built_in">sum</span>(d[x]) <span class="keyword">for</span> x <span class="keyword">in</span> land)</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span> <span class="keyword">if</span> min_dist == <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>) <span class="keyword">else</span> min_dist</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>1293. Shortest Path in a Grid with Obstacles Elimination</summary>
<blockquote>
<p>Use BFS like a sonar to explore all possible next steps, and once target is in the explored area, meaning we find a solution. Use a queue to store candidates and a set to store visited positions. Keep track of total steps taken, current position, and quota. If quota is still valid and position is not visited, add it to visited set and the queue.</p>
</blockquote>
<p>Run time: $O(nk)$, where n is the number of cells in the grid, k is the quota, space: $O(nk)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">shortestPath</span>(<span class="params">self, grid, k</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    :type grid: List[List[int]]</span></span><br><span class="line"><span class="string">    :type k: int</span></span><br><span class="line"><span class="string">    :rtype: int</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    r, c = <span class="built_in">len</span>(grid), <span class="built_in">len</span>(grid[<span class="number">0</span>])</span><br><span class="line">    target = (r-<span class="number">1</span>, c-<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">if</span> k &gt;= r+c-<span class="number">2</span>: <span class="comment"># if quota is greater than min # steps</span></span><br><span class="line">        <span class="keyword">return</span> r+c-<span class="number">2</span></span><br><span class="line">    </span><br><span class="line">    state = (<span class="number">0</span>, <span class="number">0</span>, k) <span class="comment"># position, and quota</span></span><br><span class="line">    queue = deque([(<span class="number">0</span>, state)]) <span class="comment"># steps taken, position, and quota</span></span><br><span class="line">    visited = <span class="built_in">set</span>([state])</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> queue:</span><br><span class="line">        steps, (row, col, k) = queue.popleft()</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (row, col) == target: <span class="comment"># reach the end</span></span><br><span class="line">            <span class="keyword">return</span> steps</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># explore next steps</span></span><br><span class="line">        <span class="keyword">for</span> new_r, new_c <span class="keyword">in</span> [(row, col+<span class="number">1</span>), (row+<span class="number">1</span>, col), (row, col-<span class="number">1</span>), (row-<span class="number">1</span>, col)]:</span><br><span class="line">            <span class="keyword">if</span> <span class="number">0</span> &lt;= new_r &lt; r <span class="keyword">and</span> <span class="number">0</span> &lt;= new_c &lt; c:</span><br><span class="line">                new_k = k - grid[new_r][new_c] <span class="comment"># unchange if no block here</span></span><br><span class="line">                new_state = (new_r, new_c, new_k)</span><br><span class="line">                <span class="keyword">if</span> new_k &gt;= <span class="number">0</span> <span class="keyword">and</span> new_state <span class="keyword">not</span> <span class="keyword">in</span> visited:</span><br><span class="line">                    visited.add(new_state)</span><br><span class="line">                    queue.append((steps+<span class="number">1</span>, new_state))</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure>
</details>
<h1>DFS</h1>
<details>
<summary></summary>
> 
<p>Run time: $O()$, space: $O()$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>785. Is Graph Bipartite?</summary>
<blockquote>
<p>Weâ€™ll keep an array (or hashmap) to lookup the color of each node: color[node]. The colors could be 0, 1, or uncolored (-1 or null).<br>
We should be careful to consider disconnected components of the graph, by searching each node. For each uncolored node, weâ€™ll start the coloring process by doing a depth-first-search on that node. Every neighbor gets colored the opposite color from the current node. If we find a neighbor colored the same color as the current node, then our coloring was impossible.</p>
</blockquote>
<p>Run time: $O(n+e)$, space: $O(n)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isBipartite</span>(<span class="params">self, graph: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">    color = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> node <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(graph)):</span><br><span class="line">        <span class="keyword">if</span> node <span class="keyword">not</span> <span class="keyword">in</span> color:</span><br><span class="line">            stack = [node]</span><br><span class="line">            color[node] = <span class="number">0</span></span><br><span class="line">            <span class="keyword">while</span> stack:</span><br><span class="line">                node = stack.pop()</span><br><span class="line">                <span class="keyword">for</span> neighbor <span class="keyword">in</span> graph[node]:</span><br><span class="line">                    <span class="keyword">if</span> neighbor <span class="keyword">not</span> <span class="keyword">in</span> color:</span><br><span class="line">                        stack.append(neighbor)</span><br><span class="line">                        color[neighbor] = color[node] ^ <span class="number">1</span></span><br><span class="line">                    <span class="keyword">elif</span> color[neighbor] == color[node]:</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>417. Pacific Atlantic Water Flow</summary>
> Use two matrices of the same size to determine whether one position is reachable from the top left and bottom right corner. If the cell from both matrices are true, then it is reachable to both corners. In the helper function, if this position is already marked true, then return. Otherwise, marked it as true, and explore the four neighbors.
<p>Run time: $O(mn)$, space: $O(mn)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pacificAtlantic</span>(<span class="params">self, heights</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    :type heights: List[List[int]]</span></span><br><span class="line"><span class="string">    :rtype: List[List[int]]</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    dirs = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, <span class="number">0</span>]</span><br><span class="line">    m, n = <span class="built_in">len</span>(heights), <span class="built_in">len</span>(heights[<span class="number">0</span>])</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">heights, reach, x, y</span>):</span></span><br><span class="line">        <span class="keyword">if</span> reach[x][y]:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        reach[x][y] = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">            next_x, next_y = x+dirs[i], y+dirs[i+<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">if</span> <span class="number">0</span> &lt;= next_x &lt; m <span class="keyword">and</span> <span class="number">0</span> &lt;= next_y &lt; n <span class="keyword">and</span> heights[x][y] &lt;= heights[next_x][next_y]:</span><br><span class="line">                dfs(heights, reach, next_x, next_y)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> heights <span class="keyword">or</span> <span class="built_in">len</span>(heights[<span class="number">0</span>]) == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line">    </span><br><span class="line">    reachable_p = [[<span class="literal">False</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m)] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">    reachable_a = [[<span class="literal">False</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m)] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">    ans = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">        dfs(heights, reachable_p, i, <span class="number">0</span>)</span><br><span class="line">        dfs(heights, reachable_a, i, n-<span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(heights[<span class="number">0</span>])):</span><br><span class="line">        dfs(heights, reachable_p, <span class="number">0</span>, i)</span><br><span class="line">        dfs(heights, reachable_a, m-<span class="number">1</span>, i)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">if</span> reachable_p[i][j] <span class="keyword">and</span> reachable_a[i][j]:</span><br><span class="line">                ans.append([i,j])</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>547. Number of Provinces</summary>
<blockquote>
<p>In order to find the number of connected components in an undirected graph, one of the simplest methods is to make use of Depth First Search starting from every node. We make use of visitedvisited array of size N(M is of size NxN).</p>
</blockquote>
<p>Run time: $O(n^2)$, space: $O(n)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findCircleNum</span>(<span class="params">self, isConnected</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    :type isConnected: List[List[int]]</span></span><br><span class="line"><span class="string">    :rtype: int</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">isConnected, i, visited</span>):</span></span><br><span class="line">        visited.add(i)</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(isConnected)):</span><br><span class="line">            <span class="keyword">if</span> isConnected[i][j] == <span class="number">1</span> <span class="keyword">and</span> j <span class="keyword">not</span> <span class="keyword">in</span> visited:</span><br><span class="line">                dfs(isConnected, j, visited)</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> isConnected:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    visited = <span class="built_in">set</span>()</span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(isConnected)):</span><br><span class="line">        <span class="keyword">if</span> i <span class="keyword">not</span> <span class="keyword">in</span> visited:</span><br><span class="line">            dfs(isConnected, i, visited)</span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> count</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>695. Max Area of Island</summary>
> in the helper function, change the grid value from 1 to 0, then call the function again for the four directions plus 1.
<p>Run time: $O(n^2)$, space: $O(1)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">maxAreaOfIsland</span>(<span class="params">self, grid</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    :type grid: List[List[int]]</span></span><br><span class="line"><span class="string">    :rtype: int</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">grid, i, j</span>):</span></span><br><span class="line">        <span class="keyword">if</span> i &lt; <span class="number">0</span> <span class="keyword">or</span> i &gt;= <span class="built_in">len</span>(grid) <span class="keyword">or</span> j &lt; <span class="number">0</span> <span class="keyword">or</span> j &gt;= <span class="built_in">len</span>(grid[<span class="number">0</span>]) <span class="keyword">or</span> grid[i][j] == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        grid[i][j] = <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>+dfs(grid,i+<span class="number">1</span>,j)+dfs(grid,i-<span class="number">1</span>,j)+dfs(grid,i,j+<span class="number">1</span>)+dfs(grid,i,j-<span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> grid <span class="keyword">or</span> <span class="built_in">len</span>(grid) == <span class="number">0</span> <span class="keyword">or</span> <span class="built_in">len</span>(grid[<span class="number">0</span>]) == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    max_area = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(grid)):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(grid[<span class="number">0</span>])):</span><br><span class="line">            max_area = <span class="built_in">max</span>(max_area, dfs(grid, i, j))</span><br><span class="line">    <span class="keyword">return</span> max_area</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>827. Making A Large Island</summary>
> 
<p>Run time: $O()$, space: $O()$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">largestIsland</span>(<span class="params">self, grid: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">    DIR = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, <span class="number">0</span>]</span><br><span class="line">    m, n, nextColor = <span class="built_in">len</span>(grid), <span class="built_in">len</span>(grid[<span class="number">0</span>]), <span class="number">2</span></span><br><span class="line">    componentSize = defaultdict(<span class="built_in">int</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">paint</span>(<span class="params">r, c, color</span>):</span></span><br><span class="line">        <span class="keyword">if</span> r &lt; <span class="number">0</span> <span class="keyword">or</span> r == m <span class="keyword">or</span> c &lt; <span class="number">0</span> <span class="keyword">or</span> c == n <span class="keyword">or</span> grid[r][c] != <span class="number">1</span>: <span class="keyword">return</span></span><br><span class="line">        grid[r][c] = color</span><br><span class="line">        componentSize[color] += <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">            paint(r + DIR[i], c + DIR[i + <span class="number">1</span>], color)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> r <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">if</span> grid[r][c] != <span class="number">1</span>: <span class="keyword">continue</span>  <span class="comment"># Only paint when it&#x27;s an island cell</span></span><br><span class="line">            paint(r, c, nextColor)</span><br><span class="line">            nextColor += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    ans = <span class="built_in">max</span>(componentSize.values() <span class="keyword">or</span> [<span class="number">0</span>])</span><br><span class="line">    <span class="keyword">for</span> r <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">if</span> grid[r][c] != <span class="number">0</span>: <span class="keyword">continue</span></span><br><span class="line">            neiColors = <span class="built_in">set</span>()</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">                nr, nc = r + DIR[i], c + DIR[i + <span class="number">1</span>]</span><br><span class="line">                <span class="keyword">if</span> nr &lt; <span class="number">0</span> <span class="keyword">or</span> nr == m <span class="keyword">or</span> nc &lt; <span class="number">0</span> <span class="keyword">or</span> nc == n <span class="keyword">or</span> grid[nr][nc] == <span class="number">0</span>: <span class="keyword">continue</span></span><br><span class="line">                neiColors.add(grid[nr][nc])</span><br><span class="line">            sizeFormed = <span class="number">1</span>  <span class="comment"># Start with 1, which is matrix[r][c] when turning from 0 into 1</span></span><br><span class="line">            <span class="keyword">for</span> color <span class="keyword">in</span> neiColors:</span><br><span class="line">                sizeFormed += componentSize[color]</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, sizeFormed)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>366. Find Leaves of Binary Tree</summary>
> Create helper function that gets the height of a node. In the function, use post-order traversal to get the height of the left and right child, then set the max of them + 1 as the height of given node. Put <height, node.val> in a dictionary.
<p>Run time: $O(n)$, space: $O(n)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findLeaves</span>(<span class="params">self, root: <span class="string">&#x27;TreeNode&#x27;</span></span>) -&gt; &#x27;<span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]&#x27;:</span></span><br><span class="line">    res = []</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">root</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        height = <span class="built_in">max</span>(dfs(root.left), dfs(root.right)) + <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> height &gt;= <span class="built_in">len</span>(res):</span><br><span class="line">            res.append([])</span><br><span class="line">        res[height].append(root.val)</span><br><span class="line">        <span class="keyword">return</span> height</span><br><span class="line">    dfs(root)</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<details>
<summary>my implementation</summary>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findLeaves</span>(<span class="params">self, root</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    :type root: TreeNode</span></span><br><span class="line"><span class="string">    :rtype: List[List[int]]</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    d = &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getHeight</span>(<span class="params">node</span>):</span></span><br><span class="line">        <span class="keyword">if</span> node <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        leftH = getHeight(node.left)</span><br><span class="line">        rightH = getHeight(node.right)</span><br><span class="line">        currH = <span class="built_in">max</span>(leftH, rightH)+<span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> currH <span class="keyword">in</span> d:</span><br><span class="line">            d[currH].append(node.val)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            d[currH] = [node.val]</span><br><span class="line">        <span class="keyword">return</span> currH</span><br><span class="line">    </span><br><span class="line">    ans = []</span><br><span class="line">    getHeight(root)</span><br><span class="line">    <span class="keyword">for</span> k, v <span class="keyword">in</span> d.items():</span><br><span class="line">        ans.append(v)</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
</details>
</details>
<h2 id="Backtracking">Backtracking</h2>
<details>
<summary></summary>
> 
<p>Run time: $O()$, space: $O()$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>301. Remove Invalid Parentheses</summary>
<blockquote>
<p>BFS.</p>
</blockquote>
<p>Run time: $O(2^n)$, space: $O(2^n)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">removeInvalidParentheses</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">str</span>]:</span></span><br><span class="line">    <span class="comment"># initialize a set with one element</span></span><br><span class="line">    <span class="comment"># set is used here in order to avoid duplicate element</span></span><br><span class="line">    level = &#123;s&#125;</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        valid = []</span><br><span class="line">        <span class="keyword">for</span> elem <span class="keyword">in</span> level:</span><br><span class="line">            <span class="keyword">if</span> self.isValid(elem):</span><br><span class="line">                valid.append(elem)</span><br><span class="line">        <span class="keyword">if</span> valid:</span><br><span class="line">            <span class="keyword">return</span> valid</span><br><span class="line">        <span class="comment"># initialize an empty set</span></span><br><span class="line">        new_level = <span class="built_in">set</span>()</span><br><span class="line">        <span class="comment"># BFS</span></span><br><span class="line">        <span class="keyword">for</span> elem <span class="keyword">in</span> level:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(elem)):</span><br><span class="line">                new_level.add(elem[:i] + elem[i + <span class="number">1</span>:])</span><br><span class="line">        level = new_level</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isValid</span>(<span class="params">self,s</span>):</span></span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> c <span class="keyword">in</span> s:</span><br><span class="line">        <span class="keyword">if</span> c == <span class="string">&#x27;(&#x27;</span>:</span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> c == <span class="string">&#x27;)&#x27;</span>:</span><br><span class="line">            count -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> count &lt; <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> count == <span class="number">0</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>Backtracking, DFS</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">removeInvalidParentheses</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">str</span>]:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isValid</span>(<span class="params">s</span>):</span></span><br><span class="line">        stack = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)):</span><br><span class="line">            <span class="keyword">if</span>( s[i] == <span class="string">&#x27;(&#x27;</span> ):</span><br><span class="line">                stack.append( (i,<span class="string">&#x27;(&#x27;</span>) )</span><br><span class="line">            <span class="keyword">elif</span>( s[i] == <span class="string">&#x27;)&#x27;</span> ):</span><br><span class="line">                <span class="keyword">if</span>(stack <span class="keyword">and</span> stack[-<span class="number">1</span>][<span class="number">1</span>] == <span class="string">&#x27;(&#x27;</span>):</span><br><span class="line">                    stack.pop()</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    stack.append( (i,<span class="string">&#x27;)&#x27;</span>) )         <span class="comment"># pushing invalid close braces also</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(stack) == <span class="number">0</span>, stack</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params"> s, left, right</span>):</span></span><br><span class="line">        visited.add(s)</span><br><span class="line">        <span class="keyword">if</span> left == <span class="number">0</span> <span class="keyword">and</span> right == <span class="number">0</span> <span class="keyword">and</span> isValid(s)[<span class="number">0</span>]:  res.append(s)</span><br><span class="line">        <span class="keyword">for</span> i, ch <span class="keyword">in</span> <span class="built_in">enumerate</span>(s):</span><br><span class="line">            <span class="keyword">if</span> ch != <span class="string">&#x27;(&#x27;</span> <span class="keyword">and</span> ch != <span class="string">&#x27;)&#x27;</span>: <span class="keyword">continue</span>                                    <span class="comment"># if it is any other char ignore.</span></span><br><span class="line">            <span class="keyword">if</span> (ch == <span class="string">&#x27;(&#x27;</span> <span class="keyword">and</span> left == <span class="number">0</span>) <span class="keyword">or</span> (ch == <span class="string">&#x27;)&#x27;</span> <span class="keyword">and</span> right == <span class="number">0</span>): <span class="keyword">continue</span>    <span class="comment"># if left == 0 then removing &#x27;(&#x27; will only cause imbalance. Hence, skip.</span></span><br><span class="line">            <span class="keyword">if</span> s[:i] + s[i+<span class="number">1</span>:] <span class="keyword">not</span> <span class="keyword">in</span> visited:</span><br><span class="line">                dfs( s[:i] + s[i+<span class="number">1</span>:], left - (ch == <span class="string">&#x27;(&#x27;</span>), right - (ch == <span class="string">&#x27;)&#x27;</span>) )</span><br><span class="line">    </span><br><span class="line">    stack = isValid(s)[<span class="number">1</span>]</span><br><span class="line">    lc = <span class="built_in">sum</span>([<span class="number">1</span> <span class="keyword">for</span> val <span class="keyword">in</span> stack <span class="keyword">if</span> val[<span class="number">1</span>] == <span class="string">&quot;(&quot;</span>]) <span class="comment"># num of left braces</span></span><br><span class="line">    rc = <span class="built_in">len</span>(stack) - lc</span><br><span class="line">    </span><br><span class="line">    res, visited = [], <span class="built_in">set</span>()</span><br><span class="line">    dfs(s, lc, rc)</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>79. Word Search</summary>
<blockquote>
<p>Go through each entry, and in the helper function, check edge cases. If word length is zero, then it means this word has been found. Set the current entry to be #, call functions in four directions recursively, then reverse the change, return the result.</p>
</blockquote>
<p>Run time: $O(n\cdot 3^L)$, space: $O(L)$, where $n$ is the number of cells in the board, $L$ is the length of the word to be matched, 3 is the number of further choices in the next step</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exist</span>(<span class="params">self, board, word</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    :type board: List[List[str]]</span></span><br><span class="line"><span class="string">    :type word: str</span></span><br><span class="line"><span class="string">    :rtype: bool</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># check whether can find word, start at (i,j) position    </span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">board, i, j, word</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(word) == <span class="number">0</span>: <span class="comment"># all the characters are checked</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">if</span> i&lt;<span class="number">0</span> <span class="keyword">or</span> i&gt;=<span class="built_in">len</span>(board) <span class="keyword">or</span> j&lt;<span class="number">0</span> <span class="keyword">or</span> j&gt;=<span class="built_in">len</span>(board[<span class="number">0</span>]) <span class="keyword">or</span> word[<span class="number">0</span>]!=board[i][j]:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        tmp = board[i][j]  <span class="comment"># first character is found, check the remaining part</span></span><br><span class="line">        board[i][j] = <span class="string">&quot;#&quot;</span>  <span class="comment"># avoid visit agian </span></span><br><span class="line">        <span class="comment"># check whether can find &quot;word&quot; along one direction</span></span><br><span class="line">        res = dfs(board, i+<span class="number">1</span>, j, word[<span class="number">1</span>:]) <span class="keyword">or</span> dfs(board, i-<span class="number">1</span>, j, word[<span class="number">1</span>:]) \</span><br><span class="line">        <span class="keyword">or</span> dfs(board, i, j+<span class="number">1</span>, word[<span class="number">1</span>:]) <span class="keyword">or</span> dfs(board, i, j-<span class="number">1</span>, word[<span class="number">1</span>:])</span><br><span class="line">        board[i][j] = tmp</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> board:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(board)):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(board[<span class="number">0</span>])):</span><br><span class="line">            <span class="keyword">if</span> dfs(board, i, j, word):</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>77. Combinations</summary>
<blockquote>
<p>in the helper function, check whether current combination length equals to k, then append to the answer list. In the for loop, pass the array that skips the current element, the path that combines this element.</p>
</blockquote>
<p>Run time: $O(k {n \choose k})$, space: $O({n \choose k})$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">combine</span>(<span class="params">self, n, k</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    :type n: int</span></span><br><span class="line"><span class="string">    :type k: int</span></span><br><span class="line"><span class="string">    :rtype: List[List[int]]</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">nums, k, path, ans</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(path) == k:</span><br><span class="line">            ans.append(path)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            dfs(nums[i+<span class="number">1</span>:], k, path+[nums[i]], ans)</span><br><span class="line">            </span><br><span class="line">    ans = []</span><br><span class="line">    dfs(<span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">1</span>, n+<span class="number">1</span>)), k, [], ans)</span><br><span class="line">    <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>46. Permutations</summary>
> `[:]` makes a deep copy of the list. If you passed back the original list, it would be modified by future swaps. Otherwise the reference to the array is appended rather than the actual list.
<p>Run time: $O(\sum_{k=1}^n P(n, k))$, space: $O(n!)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">permute</span>(<span class="params">self, nums</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    :type nums: List[int]</span></span><br><span class="line"><span class="string">    :rtype: List[List[int]]</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">backtracking</span>(<span class="params">nums, level, ans</span>):</span></span><br><span class="line">        <span class="keyword">if</span> level == <span class="built_in">len</span>(nums)-<span class="number">1</span>:</span><br><span class="line">            ans.append(nums[:])</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(level, <span class="built_in">len</span>(nums)):</span><br><span class="line">            nums[i], nums[level] = nums[level], nums[i]</span><br><span class="line">            backtracking(nums, level+<span class="number">1</span>, ans)</span><br><span class="line">            nums[i], nums[level] = nums[level], nums[i]</span><br><span class="line">            </span><br><span class="line">            </span><br><span class="line">    ans = []</span><br><span class="line">    backtracking(nums, <span class="number">0</span>, ans)</span><br><span class="line">    <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">permute</span>(<span class="params">self, nums</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(nums) == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> [nums]</span><br><span class="line">    result = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">        others = nums[:i] + nums[i+<span class="number">1</span>:]</span><br><span class="line">        other_permutations = self.permute(others)</span><br><span class="line">        <span class="keyword">for</span> permutation <span class="keyword">in</span> other_permutations:</span><br><span class="line">            result.append([nums[i]] + permutation)</span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>282. Expression Add Operators</summary>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/expression-add-operators/discuss/71968/Clean-Python-DFS-with-comments">https://leetcode.com/problems/expression-add-operators/discuss/71968/Clean-Python-DFS-with-comments</a></p>
</blockquote>
<p>Run time: $O(n\cdot 4^n)$, space: $O(n)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">addOperators</span>(<span class="params">self, num, target</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    :type num: str</span></span><br><span class="line"><span class="string">    :type target: int</span></span><br><span class="line"><span class="string">    :rtype: List[str]</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">backtracking</span>(<span class="params">idx=<span class="number">0</span>, path=<span class="string">&#x27;&#x27;</span>, value=<span class="number">0</span>, prev=<span class="literal">None</span></span>):</span></span><br><span class="line">        <span class="keyword">if</span> idx == <span class="built_in">len</span>(num) <span class="keyword">and</span> value == target:</span><br><span class="line">            rtn.append(path)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">    </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(idx+<span class="number">1</span>, <span class="built_in">len</span>(num)+<span class="number">1</span>):</span><br><span class="line">            temp = <span class="built_in">int</span>(num[idx:i])</span><br><span class="line">            <span class="keyword">if</span> i == idx+<span class="number">1</span> <span class="keyword">or</span> (i &gt; idx+<span class="number">1</span> <span class="keyword">and</span> num[idx] != <span class="string">&#x27;0&#x27;</span>):</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> prev:</span><br><span class="line">                    backtracking(i, num[idx:i], temp, temp)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    backtracking(i, path+<span class="string">&#x27;+&#x27;</span>+num[idx:i], value+temp, temp)</span><br><span class="line">                    backtracking(i, path+<span class="string">&#x27;-&#x27;</span>+num[idx:i], value-temp, -temp)</span><br><span class="line">                    backtracking(i, path+<span class="string">&#x27;*&#x27;</span>+num[idx:i], value-prev+prev*temp, prev*temp)</span><br><span class="line">                    </span><br><span class="line">    rtn = []</span><br><span class="line">    backtracking()</span><br><span class="line">    <span class="keyword">return</span> rtn</span><br></pre></td></tr></table></figure>
</details>
<h1>Linked List &amp; Array</h1>
<details>
<summary></summary>
> 
<p>Run time: $O()$, space: $O()$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>138. Copy List with Random Pointer</summary>
<blockquote>
<p>Instead of a separate dictionary to keep the old node --&gt; new node mapping, we can tweak the original linked list and keep every cloned node next to its original node. This interleaving of old and new nodes allows us to solve this problem without any extra space.</p>
</blockquote>
<p>Run time: $O(n)$, space: $O(1)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">copyRandomList</span>(<span class="params">self, head: <span class="string">&#x27;Optional[Node]&#x27;</span></span>) -&gt; &#x27;<span class="type">Optional</span>[Node]&#x27;:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> head:</span><br><span class="line">        <span class="keyword">return</span> head</span><br><span class="line"></span><br><span class="line">    ptr = head</span><br><span class="line">    <span class="keyword">while</span> ptr:</span><br><span class="line">        <span class="comment"># Cloned node</span></span><br><span class="line">        new_node = Node(ptr.val, <span class="literal">None</span>, <span class="literal">None</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Inserting the cloned node just next to the original node.</span></span><br><span class="line">        <span class="comment"># If A-&gt;B-&gt;C is the original linked list,</span></span><br><span class="line">        <span class="comment"># Linked list after weaving cloned nodes would be A-&gt;A&#x27;-&gt;B-&gt;B&#x27;-&gt;C-&gt;C&#x27;</span></span><br><span class="line">        new_node.<span class="built_in">next</span> = ptr.<span class="built_in">next</span></span><br><span class="line">        ptr.<span class="built_in">next</span> = new_node</span><br><span class="line">        ptr = new_node.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">    ptr = head</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Now link the random pointers of the new nodes created.</span></span><br><span class="line">    <span class="comment"># Iterate the newly created list and use the original nodes random pointers,</span></span><br><span class="line">    <span class="comment"># to assign references to random pointers for cloned nodes.</span></span><br><span class="line">    <span class="keyword">while</span> ptr:</span><br><span class="line">        ptr.<span class="built_in">next</span>.random = ptr.random.<span class="built_in">next</span> <span class="keyword">if</span> ptr.random <span class="keyword">else</span> <span class="literal">None</span></span><br><span class="line">        ptr = ptr.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Unweave the linked list to get back the original linked list and the cloned list.</span></span><br><span class="line">    <span class="comment"># i.e. A-&gt;A&#x27;-&gt;B-&gt;B&#x27;-&gt;C-&gt;C&#x27; would be broken to A-&gt;B-&gt;C and A&#x27;-&gt;B&#x27;-&gt;C&#x27;</span></span><br><span class="line">    ptr_old_list = head <span class="comment"># A-&gt;B-&gt;C</span></span><br><span class="line">    ptr_new_list = head.<span class="built_in">next</span> <span class="comment"># A&#x27;-&gt;B&#x27;-&gt;C&#x27;</span></span><br><span class="line">    head_new = head.<span class="built_in">next</span></span><br><span class="line">    <span class="keyword">while</span> ptr_old_list:</span><br><span class="line">        ptr_old_list.<span class="built_in">next</span> = ptr_old_list.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">        ptr_new_list.<span class="built_in">next</span> = ptr_new_list.<span class="built_in">next</span>.<span class="built_in">next</span> <span class="keyword">if</span> ptr_new_list.<span class="built_in">next</span> <span class="keyword">else</span> <span class="literal">None</span></span><br><span class="line">        ptr_old_list = ptr_old_list.<span class="built_in">next</span></span><br><span class="line">        ptr_new_list = ptr_new_list.<span class="built_in">next</span></span><br><span class="line">    <span class="keyword">return</span> head_new</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Using dict.</p>
</blockquote>
<p>Run time: $O(n)$, space: $O(n)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">copyRandomList</span>(<span class="params">self, head: <span class="string">&#x27;Optional[Node]&#x27;</span></span>) -&gt; &#x27;<span class="type">Optional</span>[Node]&#x27;:</span></span><br><span class="line">    cache = &#123;&#125;</span><br><span class="line">    new_ptr = dummy = Node(-<span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> head:</span><br><span class="line">        <span class="keyword">if</span> head <span class="keyword">in</span> cache: </span><br><span class="line">            newnode = cache[head]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            newnode = Node(head.val)</span><br><span class="line">            cache[head] = newnode</span><br><span class="line">        new_ptr.<span class="built_in">next</span> = newnode</span><br><span class="line">        new_ptr = new_ptr.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">if</span> head.random:    </span><br><span class="line">            <span class="keyword">if</span> head.random <span class="keyword">in</span> cache: </span><br><span class="line">                new_random = cache[head.random]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                new_random = Node(head.random.val)</span><br><span class="line">                cache[head.random] = new_random</span><br><span class="line">            new_ptr.random = new_random</span><br><span class="line">        head = head.<span class="built_in">next</span></span><br><span class="line">    <span class="keyword">return</span> dummy.<span class="built_in">next</span></span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>339. Nested List Weight Sum</summary>
<blockquote>
<p>DFS.</p>
</blockquote>
<p>Run time: $O(n)$, space: $O(n)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">depthSum</span>(<span class="params">self, nestedList: <span class="type">List</span>[NestedInteger]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span>(<span class="params">l, dep</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> l:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">for</span> a <span class="keyword">in</span> l:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> a.isInteger():</span><br><span class="line">                helper(a.getList(), dep+<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                self.depth += a.getInteger() * dep</span><br><span class="line">    </span><br><span class="line">    self.depth = <span class="number">0</span></span><br><span class="line">    helper(nestedList, <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> self.depth</span><br></pre></td></tr></table></figure>
<blockquote>
<p>BFS.</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">depthSum</span>(<span class="params">self, nestedList: <span class="type">List</span>[NestedInteger]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">    queue = deque(nestedList)</span><br><span class="line"></span><br><span class="line">    depth = <span class="number">1</span></span><br><span class="line">    total = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="built_in">len</span>(queue) &gt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(queue)):</span><br><span class="line">            nested = queue.pop()</span><br><span class="line">            <span class="keyword">if</span> nested.isInteger():</span><br><span class="line">                total += nested.getInteger() * depth</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                queue.extendleft(nested.getList())</span><br><span class="line">        depth += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> total</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>148. Sort List</summary>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/sort-list/discuss/46711/Python-easy-to-understand-merge-sort-solution">https://leetcode.com/problems/sort-list/discuss/46711/Python-easy-to-understand-merge-sort-solution</a></p>
</blockquote>
<p>Run time: $O(n\log n)$, space: $O(1)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sortList</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span></span><br><span class="line">     <span class="keyword">if</span> <span class="keyword">not</span> head <span class="keyword">or</span> <span class="keyword">not</span> head.<span class="built_in">next</span>:</span><br><span class="line">         <span class="keyword">return</span> head</span><br><span class="line">     fast, slow = head.<span class="built_in">next</span>, head</span><br><span class="line">     <span class="keyword">while</span> fast <span class="keyword">and</span> fast.<span class="built_in">next</span>:</span><br><span class="line">         fast = fast.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">         slow = slow.<span class="built_in">next</span></span><br><span class="line">     start = slow.<span class="built_in">next</span></span><br><span class="line">     slow.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line">     l, r = self.sortList(head), self.sortList(start)</span><br><span class="line">     <span class="keyword">return</span> self.merge(l, r)</span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line"> <span class="function"><span class="keyword">def</span> <span class="title">merge</span>(<span class="params">self, l, r</span>):</span></span><br><span class="line">     <span class="keyword">if</span> <span class="keyword">not</span> l <span class="keyword">or</span> <span class="keyword">not</span> r:</span><br><span class="line">         <span class="keyword">return</span> l <span class="keyword">or</span> r</span><br><span class="line">     <span class="keyword">if</span> l.val &gt; r.val:</span><br><span class="line">         l, r = r, l</span><br><span class="line">     <span class="comment"># get the return node &quot;head&quot;</span></span><br><span class="line">     head = pre = l</span><br><span class="line">     l = l.<span class="built_in">next</span></span><br><span class="line">     <span class="keyword">while</span> l <span class="keyword">and</span> r:</span><br><span class="line">         <span class="keyword">if</span> l.val &lt; r.val:</span><br><span class="line">             pre.<span class="built_in">next</span> = l</span><br><span class="line">             l = l.<span class="built_in">next</span></span><br><span class="line">         <span class="keyword">else</span>:</span><br><span class="line">             pre.<span class="built_in">next</span> = r</span><br><span class="line">             r = r.<span class="built_in">next</span></span><br><span class="line">         pre = pre.<span class="built_in">next</span></span><br><span class="line">     <span class="comment"># l and r at least one is None</span></span><br><span class="line">     pre.<span class="built_in">next</span> = l <span class="keyword">or</span> r</span><br><span class="line">     <span class="keyword">return</span> head</span><br></pre></td></tr></table></figure>
<blockquote>
<p>No recursion.</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sortList</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getsize</span>(<span class="params">head</span>):</span></span><br><span class="line">        c = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> head:</span><br><span class="line">            head = head.<span class="built_in">next</span></span><br><span class="line">            c += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> c</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">split</span>(<span class="params">head, size</span>):</span></span><br><span class="line">        tail = head</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(size-<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> tail:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">            tail = tail.<span class="built_in">next</span></span><br><span class="line">            </span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> tail: <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        next_head, tail.<span class="built_in">next</span> = tail.<span class="built_in">next</span>, <span class="literal">None</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> next_head</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">merge</span>(<span class="params">l1, l2, newtail</span>):</span></span><br><span class="line">        <span class="keyword">while</span> l1 <span class="keyword">and</span> l2:</span><br><span class="line">            <span class="keyword">if</span> l1.val &lt;= l2.val:</span><br><span class="line">                newtail.<span class="built_in">next</span> = l1</span><br><span class="line">                l1 = l1.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                newtail.<span class="built_in">next</span> = l2</span><br><span class="line">                l2 = l2.<span class="built_in">next</span></span><br><span class="line">            newtail = newtail.<span class="built_in">next</span></span><br><span class="line">            </span><br><span class="line">        newtail.<span class="built_in">next</span> = l1 <span class="keyword">or</span> l2</span><br><span class="line">        <span class="keyword">while</span> newtail.<span class="built_in">next</span>:</span><br><span class="line">            newtail = newtail.<span class="built_in">next</span></span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> newtail</span><br><span class="line">    </span><br><span class="line">    length = getsize(head)</span><br><span class="line">    newhead = ListNode(<span class="built_in">next</span>=head)</span><br><span class="line">    size = <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> size &lt; length:</span><br><span class="line">        newtail, cur = newhead, newhead.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            h1 = cur</span><br><span class="line">            h2 = split(h1, size)</span><br><span class="line">            cur = split(h2, size)</span><br><span class="line">            newtail = merge(h1, h2, newtail)</span><br><span class="line">        size *= <span class="number">2</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> newhead.<span class="built_in">next</span></span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>19. Remove Nth Node From End of List</summary>
<blockquote>
<p>One pass. The first pointer advances the list by n+1n+1 steps from the beginning, while the second pointer starts from the beginning of the list. Now, both pointers are exactly separated by nn nodes apart. We maintain this constant gap by advancing both pointers together until the first pointer arrives past the last node. The second pointer will be pointing at the nnth node counting from the last. We relink the next pointer of the node referenced by the second pointer to point to the nodeâ€™s next next node.</p>
</blockquote>
<p>Run time: $O(n)$, space: $O(1)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">removeNthFromEnd</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode], n: <span class="built_in">int</span></span>) -&gt; <span class="type">Optional</span>[ListNode]:</span></span><br><span class="line">    fast = slow = head</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        fast = fast.<span class="built_in">next</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> fast:</span><br><span class="line">        <span class="keyword">return</span> head.<span class="built_in">next</span></span><br><span class="line">    <span class="keyword">while</span> fast.<span class="built_in">next</span>:</span><br><span class="line">        fast = fast.<span class="built_in">next</span></span><br><span class="line">        slow = slow.<span class="built_in">next</span></span><br><span class="line">    slow.<span class="built_in">next</span> = slow.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">    <span class="keyword">return</span> head</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Two pass. First time calculate the length. Second time reduce the count till 0, and remove that node.</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">removeNthFromEnd</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode], n: <span class="built_in">int</span></span>) -&gt; <span class="type">Optional</span>[ListNode]:</span></span><br><span class="line">    ans = ListNode(<span class="number">0</span>)</span><br><span class="line">    ans.<span class="built_in">next</span> = head</span><br><span class="line">    ptr = head</span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> ptr:</span><br><span class="line">        count += <span class="number">1</span></span><br><span class="line">        ptr = ptr.<span class="built_in">next</span></span><br><span class="line">    </span><br><span class="line">    count -= n</span><br><span class="line">    ptr = ans</span><br><span class="line">    <span class="keyword">while</span> count &gt; <span class="number">0</span>:</span><br><span class="line">        count -= <span class="number">1</span></span><br><span class="line">        ptr = ptr.<span class="built_in">next</span></span><br><span class="line">    ptr.<span class="built_in">next</span> = ptr.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">    <span class="keyword">return</span> ans.<span class="built_in">next</span></span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>83. Remove Duplicates from Sorted List</summary>
<blockquote>
<p>Recursion. Set the next element to be the function call. Return head.next if it is the same as head, otherwise return head.</p>
</blockquote>
<p>Run time: $O(n)$, space: $O(1)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">deleteDuplicates</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span></span><br><span class="line">    <span class="keyword">if</span> head <span class="keyword">and</span> head.<span class="built_in">next</span>:</span><br><span class="line">        head.<span class="built_in">next</span> = self.deleteDuplicates(head.<span class="built_in">next</span>)</span><br><span class="line">        <span class="keyword">if</span> head.<span class="built_in">next</span>.val == head.val:</span><br><span class="line">            <span class="keyword">return</span> head.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">    <span class="keyword">return</span> head</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Iterative. Remember to put moving head in the else statement.</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">deleteDuplicates</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> head <span class="keyword">or</span> <span class="keyword">not</span> head.<span class="built_in">next</span>:</span><br><span class="line">        <span class="keyword">return</span> head</span><br><span class="line">    </span><br><span class="line">    cur = head</span><br><span class="line">    <span class="keyword">while</span> cur <span class="keyword">and</span> cur.<span class="built_in">next</span>:</span><br><span class="line">        <span class="keyword">if</span> cur.val == cur.<span class="built_in">next</span>.val:</span><br><span class="line">            cur.<span class="built_in">next</span> = cur.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            cur = cur.<span class="built_in">next</span></span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> head</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>234. Palindrome Linked List</summary>
<blockquote>
<p>Recursion. If we iterate the nodes in reverse using recursion, and iterate forward at the same time using a variable outside the recursive function, then we can check whether or not we have a palindrome.</p>
</blockquote>
<p>Run time: $O(n)$, space: $O(n)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isPalindrome</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">    self.front_ptr = head</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">recursive_check</span>(<span class="params">node</span>):</span></span><br><span class="line">        <span class="keyword">if</span> node:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> recursive_check(node.<span class="built_in">next</span>):</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">if</span> self.front_ptr.val != node.val:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            self.front_ptr = self.front_ptr.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> recursive_check(head)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Copy into Array List and then Use Two Pointer Technique.</p>
</blockquote>
<p>Run time: $O(n)$, space: $O(n)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isPalindrome</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">    vals = []</span><br><span class="line">    <span class="keyword">while</span> head:</span><br><span class="line">        vals.append(head.val)</span><br><span class="line">        head = head.<span class="built_in">next</span></span><br><span class="line">    <span class="keyword">return</span> vals == vals[::-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>160. Intersection of Two Linked Lists</summary>
<blockquote>
<p>If we say that cc is the shared part, aa is exclusive part of list A and bb is exclusive part of list B, then we can have one pointer that goes over a + c + b and the other that goes over b + c + a. Have a look at the diagram below, and this should be fairly intuitive.</p>
</blockquote>
<p>Run time: $O(m+n)$, space: $O(1)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getIntersectionNode</span>(<span class="params">self, headA: ListNode, headB: ListNode</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span></span><br><span class="line">    p1, p2 = headA, headB</span><br><span class="line">    <span class="keyword">while</span> p1 != p2:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> p1:</span><br><span class="line">            p1 = headB</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            p1 = p1.<span class="built_in">next</span></span><br><span class="line">            </span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> p2:</span><br><span class="line">            p2 = headA</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            p2 = p2.<span class="built_in">next</span></span><br><span class="line">    <span class="keyword">return</span> p1</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Use set to put all nodes in B. Then loop through A once and see if a node is already in the set.</p>
</blockquote>
<p>Run time: $O(m+n)$, space: $O(m)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getIntersectionNode</span>(<span class="params">self, headA: ListNode, headB: ListNode</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span></span><br><span class="line">    s = <span class="built_in">set</span>()</span><br><span class="line">    <span class="keyword">while</span> headB:</span><br><span class="line">        s.add(headB)</span><br><span class="line">        headB = headB.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> headA:</span><br><span class="line">        <span class="keyword">if</span> headA <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">return</span> headA</span><br><span class="line">        headA = headA.<span class="built_in">next</span></span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>Brute force. For each node in A, loop through B and see if two nodes are the same.</p>
</blockquote>
<p>Run time: $O(mn)$, space: $O(1)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getIntersectionNode</span>(<span class="params">self, headA: ListNode, headB: ListNode</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span></span><br><span class="line">    <span class="keyword">while</span> headA:</span><br><span class="line">        p = headB</span><br><span class="line">        <span class="keyword">while</span> p:</span><br><span class="line">            <span class="keyword">if</span> headA == p:</span><br><span class="line">                <span class="keyword">return</span> headA</span><br><span class="line">            p = p.<span class="built_in">next</span></span><br><span class="line">        headA = headA.<span class="built_in">next</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>24. Swap Nodes in Pairs</summary>
<blockquote>
<p>Recursive. In every function call we take out two nodes which would be swapped and the remaining nodes are passed to the next recursive call. The reason we are adopting a recursive approach here is because a sub-list of the original list would still be a linked list and hence, it would adapt to our recursive strategy.</p>
</blockquote>
<p>Run time: $O(n)$, space: $O(n)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">swapPairs</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span></span><br><span class="line">    <span class="keyword">if</span> head <span class="keyword">and</span> head.<span class="built_in">next</span>:</span><br><span class="line">        temp = head.<span class="built_in">next</span></span><br><span class="line">        head.<span class="built_in">next</span> = self.swapPairs(temp.<span class="built_in">next</span>)</span><br><span class="line">        temp.<span class="built_in">next</span> = head</span><br><span class="line">        <span class="keyword">return</span> temp</span><br><span class="line">    <span class="keyword">return</span> head</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Iterative. We break the linked list into pairs by jumping in steps of two. The only difference is, unlike recursion, we swap the nodes on the go. After swapping a pair of nodes, say A and B, we need to link the node B to the node that was right before A. To establish this linkage we save the previous node of node A in prevNode.</p>
</blockquote>
<p>Run time: $O(n)$, space: $O(1)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">swapPairs</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> head <span class="keyword">or</span> <span class="keyword">not</span> head.<span class="built_in">next</span>:</span><br><span class="line">        <span class="keyword">return</span> head</span><br><span class="line">    </span><br><span class="line">    ans = ListNode(<span class="number">0</span>)</span><br><span class="line">    ans.<span class="built_in">next</span> = head</span><br><span class="line">    ptr = ans</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> head <span class="keyword">and</span> head.<span class="built_in">next</span>:</span><br><span class="line">        first = head</span><br><span class="line">        second = head.<span class="built_in">next</span></span><br><span class="line">        </span><br><span class="line">        ptr.<span class="built_in">next</span> = second</span><br><span class="line">        first.<span class="built_in">next</span> = second.<span class="built_in">next</span></span><br><span class="line">        second.<span class="built_in">next</span> = first</span><br><span class="line">        </span><br><span class="line">        ptr = first</span><br><span class="line">        head = first.<span class="built_in">next</span></span><br><span class="line">    <span class="keyword">return</span> ans.<span class="built_in">next</span></span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>21. Merge Two Sorted Lists</summary>
<blockquote>
<p>Iterative.</p>
</blockquote>
<p>Run time: $O(m+n)$, space: $O(m+n)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mergeTwoLists</span>(<span class="params">self, list1: <span class="type">Optional</span>[ListNode], list2: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span></span><br><span class="line">    ans = ListNode(<span class="number">0</span>)</span><br><span class="line">    ptr = ans</span><br><span class="line">    <span class="keyword">while</span> list1 <span class="keyword">and</span> list2:</span><br><span class="line">        <span class="keyword">if</span> list1.val &lt; list2.val:</span><br><span class="line">            ans.<span class="built_in">next</span> = list1</span><br><span class="line">            list1 = list1.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">else</span>: <span class="comment"># list1 &gt; list2</span></span><br><span class="line">            ans.<span class="built_in">next</span> = list2</span><br><span class="line">            list2 = list2.<span class="built_in">next</span></span><br><span class="line">        ans = ans.<span class="built_in">next</span></span><br><span class="line">    ans.<span class="built_in">next</span> = list1 <span class="keyword">or</span> list2</span><br><span class="line">    <span class="keyword">return</span> ptr.<span class="built_in">next</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>Recursion. We can recursively define the result of a merge operation on two lists as the following (avoiding the corner case logic surrounding empty lists):</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mergeTwoLists</span>(<span class="params">self, list1: <span class="type">Optional</span>[ListNode], list2: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> list1 <span class="keyword">or</span> <span class="keyword">not</span> list2:</span><br><span class="line">        <span class="keyword">return</span> list1 <span class="keyword">or</span> list2</span><br><span class="line">    <span class="keyword">if</span> list1.val &lt; list2.val:</span><br><span class="line">        list1.<span class="built_in">next</span> = self.mergeTwoLists(list1.<span class="built_in">next</span>, list2)</span><br><span class="line">        <span class="keyword">return</span> list1</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        list2.<span class="built_in">next</span> = self.mergeTwoLists(list1, list2.<span class="built_in">next</span>)</span><br><span class="line">        <span class="keyword">return</span> list2</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>206. Reverse Linked List</summary>
>  Iterative solution. Use one variable prev and one called curr that points to head. While curr is not None, use another variable to store the next node, set the next node of curr to be prev, set prev to be curr, in the end set curr to be the temp variable.
<p>Run time: $O(n)$, space: $O(n)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reverseList</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span></span><br><span class="line">    prev, curr = <span class="literal">None</span>, head</span><br><span class="line">    <span class="keyword">while</span> curr:</span><br><span class="line">        temp_next = curr.<span class="built_in">next</span></span><br><span class="line">        curr.<span class="built_in">next</span> = prev</span><br><span class="line">        prev = curr</span><br><span class="line">        curr = temp_next</span><br><span class="line">    <span class="keyword">return</span> prev</span><br></pre></td></tr></table></figure>
<blockquote>
<p>The recursive version is slightly trickier and the key is to work backwards. Assume that the rest of the list had already been reversed, now how do I reverse the front part? Letâ€™s assume the list is: n1 â†’ â€¦ â†’ nk-1 â†’ nk â†’ nk+1 â†’ â€¦ â†’ nm â†’ Ã˜<br>
Assume from node nk+1 to nm had been reversed and you are at node nk.whilifans.list<br>
n1 â†’ â€¦ â†’ nk-1 â†’ nk â†’ nk+1 â† â€¦ â† nm<br>
We want nk+1â€™s next node to point to nk.<br>
So, nk.next.next = nk;<br>
Be very careful that n1â€™s next must point to Ã˜. If you forget about this, your linked list has a cycle in it. This bug could be caught if you test your code with a linked list of size 2.</p>
</blockquote>
<p>Run time: $O(n)$, space: $O(n)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reverseList</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> head <span class="keyword">or</span> <span class="keyword">not</span> head.<span class="built_in">next</span>:</span><br><span class="line">        <span class="keyword">return</span> head</span><br><span class="line">    </span><br><span class="line">    temp_next = self.reverseList(head.<span class="built_in">next</span>)</span><br><span class="line">    head.<span class="built_in">next</span>.<span class="built_in">next</span> = head</span><br><span class="line">    head.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line">    <span class="keyword">return</span> temp_next</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>304. Range Sum Query 2D - Immutable</summary>
<blockquote>
<p>Sum(ABCD)=Sum(OD)âˆ’Sum(OB)âˆ’Sum(OC)+Sum(OA)</p>
</blockquote>
<p>Run time: $O(mn)$, space: $O(mn)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumMatrix</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, matrix: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> matrix: <span class="keyword">return</span> </span><br><span class="line">        m, n = <span class="built_in">len</span>(matrix), <span class="built_in">len</span>(matrix[<span class="number">0</span>])</span><br><span class="line">        dp = self.dp = [[<span class="number">0</span>] * (n + <span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m + <span class="number">1</span>)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                dp[i+<span class="number">1</span>][j+<span class="number">1</span>] = dp[i][j+<span class="number">1</span>] + dp[i+<span class="number">1</span>][j] + matrix[i][j] - dp[i][j]</span><br><span class="line">                       </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sumRegion</span>(<span class="params">self, row1: <span class="built_in">int</span>, col1: <span class="built_in">int</span>, row2: <span class="built_in">int</span>, col2: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        dp = self.dp</span><br><span class="line">        <span class="keyword">return</span> dp[row2+<span class="number">1</span>][col2+<span class="number">1</span>] - dp[row2+<span class="number">1</span>][col1] - dp[row1][col2+<span class="number">1</span>] + dp[row1][col1]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Your NumMatrix object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"># obj = NumMatrix(matrix)</span></span><br><span class="line"><span class="comment"># param_1 = obj.sumRegion(row1,col1,row2,col2)</span></span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>303. Range Sum Query - Immutable</summary>
<blockquote>
<p>Store the cumulative sum. Return (right+1)-left.</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumArray</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>):</span></span><br><span class="line">        self.cum_sum = [<span class="number">0</span>]*(<span class="built_in">len</span>(nums)+<span class="number">1</span>)</span><br><span class="line">        self.cum_sum[<span class="number">0</span>] = nums[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            self.cum_sum[i+<span class="number">1</span>] = nums[i]+self.cum_sum[i]</span><br><span class="line">        <span class="built_in">print</span>(self.cum_sum)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sumRange</span>(<span class="params">self, left: <span class="built_in">int</span>, right: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.cum_sum[right+<span class="number">1</span>] - self.cum_sum[left]</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>560. Subarray Sum Equals K</summary>
> Create a dict to store <cumulative sum, count>. In the loop, find if cumulative sum - k is in the dict, then add the value to the count.
<p>Run time: $O(n)$, space: $O(n)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">subarraySum</span>(<span class="params">self, nums, k</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    :type nums: List[int]</span></span><br><span class="line"><span class="string">    :type k: int</span></span><br><span class="line"><span class="string">    :rtype: int</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    sums = <span class="number">0</span> <span class="comment"># cumulative sum</span></span><br><span class="line">    d = <span class="built_in">dict</span>()</span><br><span class="line">    d[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">        sums += nums[i]</span><br><span class="line">        count += d.get(sums-k,<span class="number">0</span>)</span><br><span class="line">        d[sums] = d.get(sums,<span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span>(count)</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>1570. Dot Product of Two Sparse Vectors</summary>
> Store the index and nonzero values in a dictionary, and check if the keys in another dict is in this dict as well, the compute the product.
<p>Run time: $O(n)$, space: $O(L)$, where $L$ is the number of nonzero values</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SparseVector</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, nums</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self.d = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i, num <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums):</span><br><span class="line">            self.d[i] = num</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    <span class="comment"># Return the dotProduct of two sparse vectors</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dotProduct</span>(<span class="params">self, vec</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type vec: &#x27;SparseVector&#x27;</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i, num <span class="keyword">in</span> self.d.items():</span><br><span class="line">            <span class="keyword">if</span> i <span class="keyword">in</span> vec.d:</span><br><span class="line">                ans += vec.d[i] * num</span><br><span class="line">        <span class="keyword">return</span> ans</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line"><span class="comment"># Your SparseVector object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"># v1 = SparseVector(nums1)</span></span><br><span class="line"><span class="comment"># v2 = SparseVector(nums2)</span></span><br><span class="line"><span class="comment"># ans = v1.dotProduct(v2)</span></span><br></pre></td></tr></table></figure>
</details>
<h1>Stack</h1>
<details>
<summary></summary>
> 
<p>Run time: $O()$, space: $O()$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>1047. Remove All Adjacent Duplicates In String
</summary>
<blockquote>
<p>Current string character is equal to the last element in stack? Pop that last element out of stack.<br>
Current string character is not equal to the last element in stack? Add the current character into stack.</p>
</blockquote>
<p>Run time: $O(n)$, space: $O(n-d)$, where $d$ is the number of dup char.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">removeDuplicates</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span></span><br><span class="line">    stack = []</span><br><span class="line">    <span class="keyword">for</span> ch <span class="keyword">in</span> s:</span><br><span class="line">        <span class="keyword">if</span> stack <span class="keyword">and</span> ch == stack[-<span class="number">1</span>]:</span><br><span class="line">            stack.pop()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            stack.append(ch)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&quot;</span>.join(stack)</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>716. Max Stack</summary>
<blockquote>
<p>Create a stack and put [value, current index of the max].</p>
</blockquote>
<p>Run time: $O(n)$ for popMax, $O(1)$ for all other calls, space: $O(n)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MaxStack</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.stack = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span>(<span class="params">self, x: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.stack <span class="keyword">and</span> x &gt;= self.stack[self.stack[-<span class="number">1</span>][<span class="number">1</span>]][<span class="number">0</span>]:</span><br><span class="line">            i = <span class="built_in">len</span>(self.stack)  <span class="comment"># index of max</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> self.stack:</span><br><span class="line">                i = self.stack[-<span class="number">1</span>][<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">else</span>: </span><br><span class="line">                i = <span class="number">0</span></span><br><span class="line">        self.stack.append((x, i))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.stack.pop()[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">top</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.stack[-<span class="number">1</span>][<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">peekMax</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.stack[self.stack[-<span class="number">1</span>][<span class="number">1</span>]][<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">popMax</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        index = self.stack[-<span class="number">1</span>][<span class="number">1</span>]  <span class="comment"># index where the max exists</span></span><br><span class="line">        result = self.stack[index][<span class="number">0</span>]  <span class="comment"># max value to return</span></span><br><span class="line">        <span class="keyword">if</span> index &gt; <span class="number">0</span>:</span><br><span class="line">            new_max = self.stack[self.stack[index-<span class="number">1</span>][<span class="number">1</span>]][<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            new_max = -<span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)</span><br><span class="line">        <span class="comment"># Scan the stack starting at &#x27;index&#x27; to recompute the max values and shift all</span></span><br><span class="line">        <span class="comment"># values to the left by one:</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(index, <span class="built_in">len</span>(self.stack)-<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> self.stack[i+<span class="number">1</span>][<span class="number">0</span>] &gt;= new_max:</span><br><span class="line">                new_max = self.stack[i+<span class="number">1</span>][<span class="number">0</span>]</span><br><span class="line">                self.stack[i] = (self.stack[i+<span class="number">1</span>][<span class="number">0</span>], i)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                self.stack[i] = (self.stack[i+<span class="number">1</span>][<span class="number">0</span>], self.stack[i-<span class="number">1</span>][<span class="number">1</span>])</span><br><span class="line">        self.stack.pop()</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>772. Basic Calculator III</summary>
<blockquote>
<p>It is much easier to implement the solution if you build the BNF grammar.<br>
inspired by <a target="_blank" rel="noopener" href="https://leetcode.com/problems/build-binary-expression-tree-from-infix-expression/discuss/864596/Python-Standard-parser-implementation">https://leetcode.com/problems/build-binary-expression-tree-from-infix-expression/discuss/864596/Python-Standard-parser-implementation</a></p>
</blockquote>
<p>Run time: $O(n)$, space: $O(n)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calculate</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">parse_factor</span>(<span class="params">dq</span>):</span></span><br><span class="line">        <span class="keyword">if</span> dq[<span class="number">0</span>].isdigit():</span><br><span class="line">            curr = <span class="number">0</span></span><br><span class="line">            <span class="keyword">while</span> dq <span class="keyword">and</span> dq[<span class="number">0</span>].isdigit():</span><br><span class="line">                curr = curr * <span class="number">10</span> + <span class="built_in">int</span>(dq[<span class="number">0</span>])</span><br><span class="line">                dq.popleft()</span><br><span class="line">            <span class="keyword">return</span> curr</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            dq.popleft()</span><br><span class="line">            tmp = parse_expr(dq)</span><br><span class="line">            dq.popleft()</span><br><span class="line">            <span class="keyword">return</span> tmp</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">parse_term</span>(<span class="params">dq</span>):</span></span><br><span class="line">        lhs = parse_factor(dq)</span><br><span class="line">        <span class="keyword">while</span> dq <span class="keyword">and</span> dq[<span class="number">0</span>] <span class="keyword">in</span> <span class="string">&quot;*/&quot;</span>:</span><br><span class="line">            op = dq.popleft()</span><br><span class="line">            rhs = parse_factor(dq)</span><br><span class="line">            <span class="keyword">if</span> op == <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">                lhs = lhs * rhs </span><br><span class="line">            <span class="keyword">else</span>: </span><br><span class="line">                lhs = <span class="built_in">int</span>(lhs/rhs) <span class="comment"># for this case &quot;(0-3)/4&quot;</span></span><br><span class="line">        <span class="keyword">return</span> lhs</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">parse_expr</span>(<span class="params">dq</span>):</span></span><br><span class="line">        lhs = parse_term(dq)</span><br><span class="line">        <span class="keyword">while</span> dq <span class="keyword">and</span> dq[<span class="number">0</span>] <span class="keyword">in</span> [<span class="string">&#x27;+&#x27;</span>, <span class="string">&#x27;-&#x27;</span>]:</span><br><span class="line">            op = dq.popleft()</span><br><span class="line">            rhs = parse_term(dq)</span><br><span class="line">            lhs = lhs + rhs <span class="keyword">if</span> op == <span class="string">&#x27;+&#x27;</span> <span class="keyword">else</span> lhs - rhs</span><br><span class="line">        <span class="keyword">return</span> lhs</span><br><span class="line">    </span><br><span class="line">    dq = deque(<span class="built_in">list</span>(s))</span><br><span class="line">    <span class="keyword">return</span> parse_expr(dq)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Recursion. <a target="_blank" rel="noopener" href="https://leetcode.com/problems/basic-calculator-iii/discuss/371346/Python-recursive-solution">https://leetcode.com/problems/basic-calculator-iii/discuss/371346/Python-recursive-solution</a></p>
</blockquote>
<p>Run time: $O(n)$, space: $O(n)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calculate</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getSubExpr</span>(<span class="params">s</span>):</span></span><br><span class="line">        left = <span class="number">1</span></span><br><span class="line">        x = []</span><br><span class="line">        <span class="keyword">while</span> left != <span class="number">0</span>:</span><br><span class="line">            x.append(<span class="built_in">next</span>(s))</span><br><span class="line">            <span class="keyword">if</span> x[-<span class="number">1</span>] == <span class="string">&#x27;(&#x27;</span>:</span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> x[-<span class="number">1</span>] == <span class="string">&#x27;)&#x27;</span>:</span><br><span class="line">                left -= <span class="number">1</span></span><br><span class="line">        <span class="comment"># print(x[:-1])</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>.join(x[:-<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">    s = <span class="built_in">iter</span>(re.findall(<span class="string">&#x27;\d+|\S&#x27;</span>, s))</span><br><span class="line">    operand, sign = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">    total = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> token <span class="keyword">in</span> s:</span><br><span class="line">        <span class="comment"># print(token, operand, sign, total)</span></span><br><span class="line">        <span class="keyword">if</span> token <span class="keyword">in</span> <span class="string">&#x27;+-&#x27;</span>:</span><br><span class="line">            total += sign * operand</span><br><span class="line">            sign = [<span class="number">1</span>, -<span class="number">1</span>][token == <span class="string">&#x27;-&#x27;</span>]</span><br><span class="line">        <span class="keyword">elif</span> token <span class="keyword">in</span> <span class="string">&#x27;/*&#x27;</span>:</span><br><span class="line">            n = <span class="built_in">next</span>(s)</span><br><span class="line">            n = self.calculate(getSubExpr(s)) <span class="keyword">if</span> n == <span class="string">&#x27;(&#x27;</span> <span class="keyword">else</span> <span class="built_in">int</span>(n)</span><br><span class="line">            operand = operand*n <span class="keyword">if</span> token == <span class="string">&#x27;*&#x27;</span> <span class="keyword">else</span> operand/n</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            operand = self.calculate(getSubExpr(s)) <span class="keyword">if</span> token == <span class="string">&#x27;(&#x27;</span> <span class="keyword">else</span> <span class="built_in">int</span>(token)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">int</span>(total + sign * operand)</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>503. Next Greater Element II</summary>
<blockquote>
<p>This approach makes use of a stack. This stack stores the indices of the appropriate elements from numsnums array. The top of the stack refers to the index of the Next Greater Element found so far. We store the indices instead of the elements since there could be duplicates in the numsnums array. The description of the method will make the above statement clearer.</p>
</blockquote>
<p>We start traversing the numsnums array from right towards the left. For an element nums[i] encountered, we pop all the elements stack[top]stack[top] from the stack such that num[stack[top]] â‰¤ nums[i]. We continue the popping till we encounter a stack[top] satisfying nums[stack[top]]&gt;nums[i]. Now, it is obvious that the current stack[top] only can act as the Next Greater Element for nums[i](right now, considering only the elements lying to the right of nums[i]).</p>
<p>If no element remains on the top of the stack, it means no larger element than nums[i]nums[i] exists to its right. Along with this, we also push the index of the element just encountered(nums[i]), i.e. ii over the top of the stack, so that nums[i](or stack[top]) now acts as the Next Greater Element for the elements lying to its left.</p>
<p>We go through two such passes over the complete nums array. This is done so as to complete a circular traversal over the nums array. The first pass could make some wrong entries in the res array since it considers only the elements lying to the right of nums[i], without a circular traversal. But, these entries are corrected in the second pass.</p>
<p>Run time: $O(n)$, space: $O(n)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">nextGreaterElements</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span></span><br><span class="line">    stack, r = [], [-<span class="number">1</span>] * <span class="built_in">len</span>(nums)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">        <span class="keyword">while</span> stack <span class="keyword">and</span> (nums[stack[-<span class="number">1</span>]] &lt; nums[i]):</span><br><span class="line">            r[stack.pop()] = nums[i]</span><br><span class="line">        stack.append(i)</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">        <span class="keyword">while</span> stack <span class="keyword">and</span> (nums[stack[-<span class="number">1</span>]] &lt; nums[i]):</span><br><span class="line">            r[stack.pop()] = nums[i]</span><br><span class="line">        <span class="keyword">if</span> stack == []:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">return</span> r</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>739. Daily Temperatures</summary>
<blockquote>
<p>At each index currDay, check if the current day is the hottest one seen so far. If it is, update hottest and move on. Otherwise, do the following:</p>
</blockquote>
<ul>
<li>Initialize a variable days = 1 because the next warmer day must be at least one day in the future.</li>
<li>While temperatures[currDay + days] &lt;= temperatures[currDay]:</li>
<li>Add answer[currDay + days] to days. This effectively jumps directly to the next warmer day.</li>
<li>Set answer[currDay] = days.</li>
</ul>
<p>Run time: $O(n)$, space: $O(1)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dailyTemperatures</span>(<span class="params">self, temperatures: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span></span><br><span class="line">    n = <span class="built_in">len</span>(temperatures)</span><br><span class="line">    hot = <span class="number">0</span></span><br><span class="line">    ans = [<span class="number">0</span>] * n</span><br><span class="line">    <span class="keyword">for</span> curr_day <span class="keyword">in</span> <span class="built_in">range</span>(n-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>):</span><br><span class="line">        temp = temperatures[curr_day]</span><br><span class="line">        <span class="keyword">if</span> temp &gt;= hot:</span><br><span class="line">            hot = temp</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        </span><br><span class="line">        days = <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> temperatures[curr_day+days] &lt;= temp:</span><br><span class="line">            days += ans[curr_day+days]</span><br><span class="line">        </span><br><span class="line">        ans[curr_day] = days</span><br><span class="line">    <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<blockquote>
<p>If the stack is not empty, that means there are previous days for which we have not yet seen a warmer day.</p>
</blockquote>
<p>Run time: $O(n)$, space: $O(n)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dailyTemperatures</span>(<span class="params">self, temperatures: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span></span><br><span class="line">    n = <span class="built_in">len</span>(temperatures)</span><br><span class="line">    ans = [<span class="number">0</span>] * n</span><br><span class="line">    stack = []</span><br><span class="line">    <span class="keyword">for</span> day, temp <span class="keyword">in</span> <span class="built_in">enumerate</span>(temperatures):</span><br><span class="line">        <span class="keyword">while</span> stack <span class="keyword">and</span> temperatures[stack[-<span class="number">1</span>]] &lt; temp:</span><br><span class="line">            prev_day = stack.pop()</span><br><span class="line">            ans[prev_day] = day - prev_day</span><br><span class="line">        stack.append(day)</span><br><span class="line">    <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>20. Valid Parentheses</summary>
<blockquote>
<p>Pop the last element from the stack only if stack is not empty and the last element matches in the pair. In the end, check if stack is empty or not.</p>
</blockquote>
<p>Run time: $O(n)$, space: $O(n)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isValid</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">    stack = []</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(s) == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> c <span class="keyword">in</span> s:</span><br><span class="line">        <span class="keyword">if</span> stack <span class="keyword">and</span> c==<span class="string">&#x27;]&#x27;</span> <span class="keyword">and</span> stack[-<span class="number">1</span>]==<span class="string">&#x27;[&#x27;</span>:</span><br><span class="line">            stack.pop()</span><br><span class="line">        <span class="keyword">elif</span> stack <span class="keyword">and</span> c==<span class="string">&#x27;&#125;&#x27;</span> <span class="keyword">and</span> stack[-<span class="number">1</span>]==<span class="string">&#x27;&#123;&#x27;</span>:</span><br><span class="line">            stack.pop()</span><br><span class="line">        <span class="keyword">elif</span> stack <span class="keyword">and</span> c==<span class="string">&#x27;)&#x27;</span> <span class="keyword">and</span> stack[-<span class="number">1</span>]==<span class="string">&#x27;(&#x27;</span>:</span><br><span class="line">            stack.pop()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            stack.append(c)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">len</span>(stack)==<span class="number">0</span></span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>155. Min Stack</summary>
> Create a list. Keep track of current element, and the min element so far.
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.stack = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span>(<span class="params">self, val: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.stack:</span><br><span class="line">            self.stack.append((val,val))</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        min_val = self.stack[-<span class="number">1</span>][-<span class="number">1</span>]</span><br><span class="line">        self.stack.append((val,<span class="built_in">min</span>(val, min_val)))</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span>(<span class="params">self</span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">        self.stack.pop()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">top</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.stack[-<span class="number">1</span>][<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getMin</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.stack[-<span class="number">1</span>][<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<blockquote>
<p>two list, one normal list, one containing min element.</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.stack = []</span><br><span class="line">        self.min_stack = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span>(<span class="params">self, val: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">        self.stack.append(val)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.min_stack <span class="keyword">or</span> val &lt;= self.min_stack[-<span class="number">1</span>]:</span><br><span class="line">            self.min_stack.append(val)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span>(<span class="params">self</span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.min_stack[-<span class="number">1</span>] == self.stack[-<span class="number">1</span>]:</span><br><span class="line">            self.min_stack.pop()</span><br><span class="line">        self.stack.pop()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">top</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.stack[-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getMin</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.min_stack[-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>227. Basic Calculator II</summary>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calculate</span>(<span class="params">self, s</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    :type s: str</span></span><br><span class="line"><span class="string">    :rtype: int</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    num, stack, sign = <span class="number">0</span>, [], <span class="string">&quot;+&quot;</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)):</span><br><span class="line">        <span class="keyword">if</span> s[i].isdigit():</span><br><span class="line">            num = num * <span class="number">10</span> + <span class="built_in">int</span>(s[i])</span><br><span class="line">        <span class="keyword">if</span> s[i] <span class="keyword">in</span> <span class="string">&quot;+-*/&quot;</span> <span class="keyword">or</span> i == <span class="built_in">len</span>(s) - <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">if</span> sign == <span class="string">&quot;+&quot;</span>:</span><br><span class="line">                stack.append(num)</span><br><span class="line">            <span class="keyword">elif</span> sign == <span class="string">&quot;-&quot;</span>:</span><br><span class="line">                stack.append(-num)</span><br><span class="line">            <span class="keyword">elif</span> sign == <span class="string">&quot;*&quot;</span>:</span><br><span class="line">                stack.append(stack.pop()*num)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                stack.append(<span class="built_in">int</span>(stack.pop()/num))</span><br><span class="line">            num = <span class="number">0</span></span><br><span class="line">            sign = s[i]</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sum</span>(stack)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Stack. Use helper function <code>update</code> to append the operation result.</p>
</blockquote>
<p>Run time: $O(n)$, space: $O(n)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calculate</span>(<span class="params">self, s</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    :type s: str</span></span><br><span class="line"><span class="string">    :rtype: int</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">calc</span>(<span class="params">it</span>):</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">update</span>(<span class="params">op, v</span>):</span></span><br><span class="line">            <span class="keyword">if</span> op == <span class="string">&quot;+&quot;</span>: stack.append(v)</span><br><span class="line">            <span class="keyword">if</span> op == <span class="string">&quot;-&quot;</span>: stack.append(-v)</span><br><span class="line">            <span class="keyword">if</span> op == <span class="string">&quot;*&quot;</span>: stack.append(stack.pop() * v)</span><br><span class="line">            <span class="keyword">if</span> op == <span class="string">&quot;/&quot;</span>: stack.append(<span class="built_in">int</span>(stack.pop() / v))</span><br><span class="line">    </span><br><span class="line">        num, stack, sign = <span class="number">0</span>, [], <span class="string">&quot;+&quot;</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> it &lt; <span class="built_in">len</span>(s):</span><br><span class="line">            <span class="keyword">if</span> s[it].isdigit():</span><br><span class="line">                num = num * <span class="number">10</span> + <span class="built_in">int</span>(s[it])</span><br><span class="line">            <span class="keyword">elif</span> s[it] <span class="keyword">in</span> <span class="string">&quot;+-*/&quot;</span>:</span><br><span class="line">                update(sign, num)</span><br><span class="line">                num, sign = <span class="number">0</span>, s[it]</span><br><span class="line">            <span class="keyword">elif</span> s[it] == <span class="string">&quot;(&quot;</span>:</span><br><span class="line">                num, j = calc(it + <span class="number">1</span>)</span><br><span class="line">                it = j - <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> s[it] == <span class="string">&quot;)&quot;</span>:</span><br><span class="line">                update(sign, num)</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">sum</span>(stack), it + <span class="number">1</span></span><br><span class="line">            it += <span class="number">1</span></span><br><span class="line">        update(sign, num)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sum</span>(stack)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> calc(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<details>
<summary>my approach</summary>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calculate</span>(<span class="params">self, s</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    :type s: str</span></span><br><span class="line"><span class="string">    :rtype: int</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    stack = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)):</span><br><span class="line">        a = s[i]</span><br><span class="line">        <span class="keyword">if</span> a <span class="keyword">in</span> <span class="string">&quot;+-*/&quot;</span>:</span><br><span class="line">            stack.append(a)</span><br><span class="line">        <span class="keyword">elif</span> a.isnumeric():</span><br><span class="line">            j = i+<span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> j &lt; <span class="built_in">len</span>(s) <span class="keyword">and</span> s[j].isnumeric():</span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">            a = <span class="built_in">int</span>(s[i:j])</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(stack) &gt; <span class="number">1</span> <span class="keyword">and</span> stack[-<span class="number">1</span>] <span class="keyword">in</span> <span class="string">&quot;*/&quot;</span>:</span><br><span class="line">                op = stack.pop()</span><br><span class="line">                num = stack.pop()</span><br><span class="line">                <span class="keyword">if</span> op == <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">                    num *= a</span><br><span class="line">                <span class="keyword">elif</span> op == <span class="string">&#x27;/&#x27;</span>:</span><br><span class="line">                    num /= a</span><br><span class="line">                stack.append(num)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                stack.append(a)</span><br><span class="line">            </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> <span class="built_in">len</span>(stack) &gt; <span class="number">2</span>:</span><br><span class="line">        num2 = stack.pop()</span><br><span class="line">        op = stack.pop()</span><br><span class="line">        num1 = stack.pop()</span><br><span class="line">        <span class="keyword">if</span> op == <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">            num1 += num2</span><br><span class="line">        <span class="keyword">elif</span> op == <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">            num1 -= num2</span><br><span class="line">        stack.append(num1)</span><br><span class="line">    <span class="keyword">return</span> stack.pop()</span><br></pre></td></tr></table></figure>
</details>
</details>
<details>
<summary>71. Simplify Path</summary>
> First split the string by `/` and remove `.` and empty string, then create a stack to append each element, or pop from the nonempty stack if we see `..`.
<p>Run time: $O(n)$, space: $O(n)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">simplifyPath</span>(<span class="params">self, path</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    :type path: str</span></span><br><span class="line"><span class="string">    :rtype: str</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    places = [p <span class="keyword">for</span> p <span class="keyword">in</span> path.split(<span class="string">&quot;/&quot;</span>) <span class="keyword">if</span> p!=<span class="string">&quot;.&quot;</span> <span class="keyword">and</span> p!=<span class="string">&quot;&quot;</span>]</span><br><span class="line">    stack = []</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> p <span class="keyword">in</span> places:</span><br><span class="line">        <span class="keyword">if</span> p == <span class="string">&quot;..&quot;</span>:</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(stack) &gt; <span class="number">0</span>:</span><br><span class="line">                stack.pop()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            stack.append(p)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;/&quot;</span> + <span class="string">&quot;/&quot;</span>.join(stack)</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>735. Asteroid Collision</summary>
> Put every positive asteroid to a stack, if the next one is negative, compare if the absolute value is greater, then pop the top element since it will be collapsed. Keep doing this until stack is empty.
<p>Run time: $O(n)$, space: $O(n)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">asteroidCollision</span>(<span class="params">self, asteroids</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    :type asteroids: List[int]</span></span><br><span class="line"><span class="string">    :rtype: List[int]</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    ans = []</span><br><span class="line">    <span class="keyword">for</span> a <span class="keyword">in</span> asteroids:</span><br><span class="line">        <span class="keyword">while</span> ans <span class="keyword">and</span> a &lt; <span class="number">0</span> &lt; ans[-<span class="number">1</span>]: <span class="comment"># opposite direction</span></span><br><span class="line">            <span class="keyword">if</span> ans[-<span class="number">1</span>] &lt; -a: <span class="comment"># new asteroid is greater than existing one</span></span><br><span class="line">                ans.pop()</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">elif</span> ans[-<span class="number">1</span>] == -a:</span><br><span class="line">                ans.pop()</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            ans.append(a)</span><br><span class="line">    <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>1762. Buildings With an Ocean View</summary>
> Check from right to left and record the max height.
<p>Run time: $O(n)$, space: $O(n)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findBuildings</span>(<span class="params">self, heights: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span></span><br><span class="line">    res = collections.deque([<span class="built_in">len</span>(heights) - <span class="number">1</span>])</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(heights) - <span class="number">2</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">if</span> heights[i] &gt; heights[res[<span class="number">0</span>]]:</span><br><span class="line">            res.appendleft(i)</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<details>
<summary>my implementation</summary>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findBuildings</span>(<span class="params">self, heights</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    :type heights: List[int]</span></span><br><span class="line"><span class="string">    :rtype: List[int]</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(heights) == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> [heights[<span class="number">0</span>]]</span><br><span class="line"></span><br><span class="line">    curr_max = heights[-<span class="number">1</span>]</span><br><span class="line">    ans = [<span class="built_in">len</span>(heights)-<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(heights)-<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">        curr_h = heights[i]</span><br><span class="line">        <span class="keyword">if</span> curr_h &gt; curr_max:</span><br><span class="line">            ans.append(i)</span><br><span class="line">            curr_max = curr_h</span><br><span class="line">    <span class="keyword">return</span> ans[::-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
</details>
</details>
<h1>2 Pointers</h1>
<details>
<summary></summary>
> 
<p>Run time: $O()$, space: $O()$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>125. Valid Palindrome</summary>
<blockquote>
<p>two pointers.</p>
</blockquote>
<p>Run time: $O(n)$, space: $O(1)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isPalindrome</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">    i, j = <span class="number">0</span>, <span class="built_in">len</span>(s) - <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> i &lt; j:</span><br><span class="line">        <span class="keyword">while</span> i &lt; j <span class="keyword">and</span> <span class="keyword">not</span> s[i].isalnum():</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; j <span class="keyword">and</span> <span class="keyword">not</span> s[j].isalnum():</span><br><span class="line">            j -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> s[i].lower() != s[j].lower():</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">        j -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>Copy updated string to another variable and reverse.</p>
</blockquote>
<p>Run time: $O(n)$, space: $O(n)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isPalindrome</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">    string = <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">for</span> c <span class="keyword">in</span> s:</span><br><span class="line">        <span class="keyword">if</span> c.isalnum():</span><br><span class="line">            string += c.lower()</span><br><span class="line">    <span class="keyword">return</span> string == string[::-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>202. Happy Number</summary>
<blockquote>
<p>Floydâ€™s Cycle-Finding Algorithm<br>
Regardless of where the tortoise and hare start in the cycle, they are guaranteed to eventually meet. This is because the hare moves one node closer to the tortoise (in their direction of movement) each step.</p>
</blockquote>
<p>Instead of keeping track of just one value in the chain, we keep track of 2, called the slow runner and the fast runner. At each step of the algorithm, the slow runner goes forward by 1 number in the chain, and the fast runner goes forward by 2 numbers (nested calls to the getNext(n) function).</p>
<p>Run time: $O(\log n)$, space: $O(1)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isHappy</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_next</span>(<span class="params">number</span>):</span></span><br><span class="line">        total_sum = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> number &gt; <span class="number">0</span>:</span><br><span class="line">            number, digit = <span class="built_in">divmod</span>(number, <span class="number">10</span>)</span><br><span class="line">            total_sum += digit ** <span class="number">2</span></span><br><span class="line">        <span class="keyword">return</span> total_sum</span><br><span class="line"></span><br><span class="line">    slow_runner = n</span><br><span class="line">    fast_runner = get_next(n)</span><br><span class="line">    <span class="keyword">while</span> fast_runner != <span class="number">1</span> <span class="keyword">and</span> slow_runner != fast_runner:</span><br><span class="line">        slow_runner = get_next(slow_runner)</span><br><span class="line">        fast_runner = get_next(get_next(fast_runner))</span><br><span class="line">    <span class="keyword">return</span> fast_runner == <span class="number">1</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>Helper function that find the next number, keep calling this until the number is in the set or it equals 1.<br>
Run time: $O(\log n)$, space: $O(\log n)$</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isHappy</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    s = <span class="built_in">set</span>()</span><br><span class="line">    <span class="keyword">while</span> n <span class="keyword">not</span> <span class="keyword">in</span> s:</span><br><span class="line">        s.add(n)</span><br><span class="line">        temp_sum = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> n &gt; <span class="number">0</span>:</span><br><span class="line">            temp_sum += (n % <span class="number">10</span>)**<span class="number">2</span></span><br><span class="line">            n //= <span class="number">10</span></span><br><span class="line">        <span class="keyword">if</span> temp_sum == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        n = temp_sum</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>31. Next Permutation</summary>
> First find the point where the descending sub-array starts, and then find the last ascending position, swap them, and swap the elements from the start descending position to the end.
<p>Run time: $O(n)$, space: $O(1)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">nextPermutation</span>(<span class="params">self, nums</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    :type nums: List[int]</span></span><br><span class="line"><span class="string">    :rtype: None Do not return anything, modify nums in-place instead.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    i = <span class="built_in">len</span>(nums)-<span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> nums[i-<span class="number">1</span>] &gt;= nums[i]:</span><br><span class="line">        i -= <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> i == <span class="number">0</span>:</span><br><span class="line">        nums.reverse()</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># find the last ascending position</span></span><br><span class="line">    i, j = i-<span class="number">1</span>, <span class="built_in">len</span>(nums)-<span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> nums[j] &lt;= nums[i]:</span><br><span class="line">        j -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># reverse</span></span><br><span class="line">    nums[i], nums[j] = nums[j], nums[i]</span><br><span class="line">    l = i+<span class="number">1</span></span><br><span class="line">    r = <span class="built_in">len</span>(nums)-<span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> l &lt; r:</span><br><span class="line">        nums[l], nums[r] = nums[r], nums[l]</span><br><span class="line">        l, r = l+<span class="number">1</span>, r-<span class="number">1</span></span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>680. Valid Palindrome II</summary>
> Use 2 pointers to walk through the string, if not match, then check if removing either start or end character might be palindrome. Then update the pointers.
<p>Run time: $O(n)$, space: $O(1)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">validPalindrome</span>(<span class="params">self, s</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    :type s: str</span></span><br><span class="line"><span class="string">    :rtype: bool</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isPalindrome</span>(<span class="params">s</span>):</span></span><br><span class="line">        <span class="keyword">return</span> s == s[::-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">    start, end = <span class="number">0</span>, <span class="built_in">len</span>(s)-<span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> start &lt; end:</span><br><span class="line">        <span class="keyword">if</span> s[start] != s[end]:</span><br><span class="line">            op_1 = s[start+<span class="number">1</span>:end+<span class="number">1</span>] <span class="comment"># remove start</span></span><br><span class="line">            op_2 = s[start:end] <span class="comment"># remove end</span></span><br><span class="line">            <span class="keyword">return</span> isPalindrome(op_1) <span class="keyword">or</span> isPalindrome(op_2)</span><br><span class="line">        start += <span class="number">1</span></span><br><span class="line">        end -= <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>
</details>
<h1>Hash &amp; Heap</h1>
<details>
<summary></summary>
> 
<p>Run time: $O()$, space: $O()$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>498. Diagonal Traverse</summary>
<blockquote>
<p>Create a dictionary, and use the sum of indices as key, and list of values as values. Reverse the list and append to output array if the key is odd.</p>
</blockquote>
<p>Run time: $O(mn)$, space: $O(mn)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">d = defaultdict(<span class="built_in">list</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(mat)):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(mat[<span class="number">0</span>])):</span><br><span class="line">        d[i+j].append(mat[i][j])</span><br><span class="line"></span><br><span class="line">ans = []</span><br><span class="line"><span class="keyword">for</span> k,v <span class="keyword">in</span> d.items():</span><br><span class="line">    <span class="keyword">if</span> k % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">        ans += v[::-<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        ans += v</span><br><span class="line"><span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">      d=&#123;&#125;</span><br><span class="line"><span class="comment">#loop through matrix</span></span><br><span class="line">      <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(matrix)):</span><br><span class="line">          <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(matrix[i])):</span><br><span class="line">		<span class="comment">#if no entry in dictionary for sum of indices aka the diagonal, create one</span></span><br><span class="line">              <span class="keyword">if</span> i + j <span class="keyword">not</span> <span class="keyword">in</span> d:</span><br><span class="line">                  d[i+j] = [matrix[i][j]]</span><br><span class="line">              <span class="keyword">else</span>:</span><br><span class="line">		<span class="comment">#If you&#x27;ve already passed over this diagonal, keep adding elements to it!</span></span><br><span class="line">                  d[i+j].append(matrix[i][j])</span><br><span class="line"><span class="comment"># we&#x27;re done with the pass, let&#x27;s build our answer array</span></span><br><span class="line">      ans= []</span><br><span class="line"><span class="comment">#look at the diagonal and each diagonal&#x27;s elements</span></span><br><span class="line">      <span class="keyword">for</span> entry <span class="keyword">in</span> d.items():</span><br><span class="line">	<span class="comment">#each entry looks like (diagonal level (sum of indices), [elem1, elem2, elem3, ...])</span></span><br><span class="line">	<span class="comment">#snake time, look at the diagonal level</span></span><br><span class="line">          <span class="keyword">if</span> entry[<span class="number">0</span>] % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">		<span class="comment">#Here we append in reverse order because its an even numbered level/diagonal. </span></span><br><span class="line">              [ans.append(x) <span class="keyword">for</span> x <span class="keyword">in</span> entry[<span class="number">1</span>][::-<span class="number">1</span>]]</span><br><span class="line">          <span class="keyword">else</span>:</span><br><span class="line">              [ans.append(x) <span class="keyword">for</span> x <span class="keyword">in</span> entry[<span class="number">1</span>]]</span><br><span class="line">      <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>523. Continuous Subarray Sum</summary>
<blockquote>
<p>Same as Subarray sum equals K with modification. Basic idea is that, If you get the same remainder again, it means that youâ€™ve encountered some sum which is a multiple of K.<br>
why {0:-1}? In the case the sum of the array a multiple of k, we should store {0:-1} so a modulus of two is noted as already existing.</p>
</blockquote>
<p>Run time: $O(n)$, space: $O(k)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">checkSubarraySum</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">    prefix_sum = <span class="number">0</span></span><br><span class="line">    <span class="comment"># Dictionary of prefix sums and their indices(0 is seen before the array)</span></span><br><span class="line">    prefix_sum_indices = &#123;<span class="number">0</span>: -<span class="number">1</span>&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> index, num <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums):</span><br><span class="line">        <span class="comment"># Compute the remainder when dividing the new sum by k</span></span><br><span class="line">        prefix_sum = (prefix_sum + num) % k</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># Check if this remainder has been encountered before and of length 2</span></span><br><span class="line">        <span class="keyword">if</span> prefix_sum <span class="keyword">in</span> prefix_sum_indices <span class="keyword">and</span> index - prefix_sum_indices[prefix_sum] &gt; <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># Add this index if it is hasn&#x27;t been encountered before</span></span><br><span class="line">        <span class="keyword">if</span> prefix_sum <span class="keyword">not</span> <span class="keyword">in</span> prefix_sum_indices:</span><br><span class="line">            prefix_sum_indices[prefix_sum] = index</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>249. Group Shifted Strings</summary>
<blockquote>
<p>Put the difference between each character as key, and the original string as value in the dictionary.</p>
</blockquote>
<p>Run time: $O(nk)$, space: $O(nk)$, where $n$ is the length of input strings array, $k$ is the max length of the string in the array.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">groupStrings</span>(<span class="params">self, strings: <span class="type">List</span>[<span class="built_in">str</span>]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">str</span>]]:</span></span><br><span class="line">    d = defaultdict(<span class="built_in">list</span>)</span><br><span class="line">    <span class="keyword">for</span> s <span class="keyword">in</span> strings:</span><br><span class="line">        key = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s) - <span class="number">1</span>):</span><br><span class="line">            <span class="comment"># Throw in 26 so that we can normalzie below</span></span><br><span class="line">            difference = <span class="number">26</span> + <span class="built_in">ord</span>(s[i+<span class="number">1</span>]) - <span class="built_in">ord</span>(s[i])</span><br><span class="line">            <span class="comment"># Wrap around</span></span><br><span class="line">            <span class="comment"># z + 1 = a</span></span><br><span class="line">            key.append(<span class="built_in">str</span>(difference % <span class="number">26</span>))</span><br><span class="line">        d[<span class="string">&#x27;,&#x27;</span>.join(key)].append(s)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> d.values()</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>380. Insert Delete GetRandom O(1)</summary>
> Use a dictionary and a list to keep track of the inserted elements. Use dictionary to check whether the element exists, and when we need to remove element, we find the index and put the last element in the original position of the list, and update the dictionary.
Delete: Retrieve an index of element to delete from the hashmap. Move the last element to the place of the element to delete, \mathcal{O}(1)O(1) time. Pop the last element out, \mathcal{O}(1)O(1) time.
<p>Run time: $O(1)$, space: $O(n)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RandomizedSet</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.d = &#123;&#125;</span><br><span class="line">        self.l = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insert</span>(<span class="params">self, val: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        <span class="keyword">if</span> val <span class="keyword">not</span> <span class="keyword">in</span> self.d:</span><br><span class="line">            self.d[val] = <span class="built_in">len</span>(self.l)</span><br><span class="line">            self.l.append(val)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">remove</span>(<span class="params">self, val: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        <span class="keyword">if</span> val <span class="keyword">not</span> <span class="keyword">in</span> self.d:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        last_element = self.l[-<span class="number">1</span>]</span><br><span class="line">        idx = self.d[val]</span><br><span class="line">        </span><br><span class="line">        self.l[idx] = last_element <span class="comment"># rearrange</span></span><br><span class="line">        <span class="keyword">del</span> self.d[val]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getRandom</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="keyword">return</span> random.choice(self.l)</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>242. Valid Anagram</summary>
> Use one or two dictionary to check whether all values are zero in the end, or compare if they are the same.
<p>Run time: $O(n)$, space: $O(n)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isAnagram1</span>(<span class="params">self, s, t</span>):</span></span><br><span class="line">    dic1, dic2 = &#123;&#125;, &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> s:</span><br><span class="line">        dic1[item] = dic1.get(item, <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> t:</span><br><span class="line">        dic2[item] = dic2.get(item, <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> dic1 == dic2</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isAnagram2</span>(<span class="params">self, s, t</span>):</span></span><br><span class="line">    dic1, dic2 = [<span class="number">0</span>]*<span class="number">26</span>, [<span class="number">0</span>]*<span class="number">26</span></span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> s:</span><br><span class="line">        dic1[<span class="built_in">ord</span>(item)-<span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>)] += <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> t:</span><br><span class="line">        dic2[<span class="built_in">ord</span>(item)-<span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>)] += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> dic1 == dic2</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isAnagram3</span>(<span class="params">self, s, t</span>):</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sorted</span>(s) == <span class="built_in">sorted</span>(t)</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>287. Find the Duplicate Number</summary>
<blockquote>
<p>Floydâ€™s Tortoise and Hare (Cycle Detection)<br>
hare = nums[nums[hare]] is twice as fast as tortoise = nums[tortoise]. Since the hare goes fast, it would be the first to enter the cycle and run around the cycle. At some point, the tortoise enters the cycle as well, and since itâ€™s moving slower the hare catches up to the tortoise at some intersection point. Now phase 1 is over, and the tortoise has lost.</p>
</blockquote>
<p>Run time: $O(n)$, space: $O(1)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findDuplicate</span>(<span class="params">self, nums</span>):</span></span><br><span class="line">    <span class="comment"># Find the intersection point of the two runners.</span></span><br><span class="line">    tortoise = hare = nums[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        tortoise = nums[tortoise]</span><br><span class="line">        hare = nums[nums[hare]]</span><br><span class="line">        <span class="keyword">if</span> tortoise == hare:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Find the &quot;entrance&quot; to the cycle.</span></span><br><span class="line">    tortoise = nums[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">while</span> tortoise != hare:</span><br><span class="line">        tortoise = nums[tortoise]</span><br><span class="line">        hare = nums[hare]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> hare</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Binary search. If the count of the numbers that are smaller than or equal to the mid, update right pointer.</p>
</blockquote>
<p>In the binary search approach, instead of doing a linear scan from 1 to n, we can apply a binary search with a goal of finding the smallest number that satisfies the aforementioned property. We start with a search space of [1,n] that has a midpoint midmid. If midmid satisfies the property, we narrow our search space to the left half [1, mid - 1] and continue searching, otherwise, we narrow our search space to the right half [mid + 1, n].</p>
<p>Run time: $O(n\log n)$, space: $O(1)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findDuplicate</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">    left, right = <span class="number">1</span>, <span class="built_in">len</span>(nums)-<span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> left &lt; right:</span><br><span class="line">        mid = (right + left)//<span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">sum</span>(i &lt;= mid <span class="keyword">for</span> i <span class="keyword">in</span> nums) &gt; mid:</span><br><span class="line">            right = mid</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            left = mid+<span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> right</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Put every element in a set, if it already exists, return it.</p>
</blockquote>
<p>Run time: $O(n)$, space: $O(n)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findDuplicate</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">    seen = <span class="built_in">set</span>()</span><br><span class="line">    <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">        <span class="keyword">if</span> num <span class="keyword">in</span> seen:</span><br><span class="line">            <span class="keyword">return</span> num</span><br><span class="line">        seen.add(num)</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>217. Contains Duplicate</summary>
<blockquote>
<p>Build a set using input array. If every element is distinct, then their length should be equal.</p>
</blockquote>
<p>Run time: $O(n)$, space: $O(n)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">containsDuplicate</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">    s = <span class="built_in">set</span>(nums)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">len</span>(s) != <span class="built_in">len</span>(nums)</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>448. Find All Numbers Disappeared in an Array</summary>
<blockquote>
<p>Negate the number that is in this index. In the end, if the number is still positive, put the corresponding index+1 to the output array.</p>
</blockquote>
<p>Run time: $O(n)$, space: $O(1)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findDisappearedNumbers</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span></span><br><span class="line">    ans = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">        temp = <span class="built_in">abs</span>(nums[i])-<span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> nums[temp] &gt; <span class="number">0</span>:</span><br><span class="line">            nums[temp] *= -<span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">        <span class="keyword">if</span> nums[i] &gt; <span class="number">0</span>:</span><br><span class="line">            ans.append(i+<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Hashset.</p>
</blockquote>
<p>Run time: $O(n)$, space: $O(n)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findDisappearedNumbers</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span></span><br><span class="line">    s = <span class="built_in">set</span>(nums)</span><br><span class="line">    n = <span class="built_in">len</span>(nums)</span><br><span class="line">    ans = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n+<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">if</span> i <span class="keyword">not</span> <span class="keyword">in</span> s:</span><br><span class="line">            ans.append(i)</span><br><span class="line">    <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
</details>
<h2 id="Advanced-Hash-Heap">Advanced Hash/Heap</h2>
<details>
<summary></summary>
> 
<p>Run time: $O()$, space: $O()$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>460. LFU Cache</summary>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/lfu-cache/discuss/1083490/Python-Solution-using-DefaultDict-and-a-Dict%3A-faster%3A77.45-Memory-usageless-88.00">https://leetcode.com/problems/lfu-cache/discuss/1083490/Python-Solution-using-DefaultDict-and-a-Dict%3A-faster%3A77.45-Memory-usageless-88.00</a></p>
</blockquote>
<p>Run time: $O(\log n)$ for put if key not present, $O(1)$ for other calls, space: $O(n)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LFUCache</span>:</span></span><br><span class="line">    <span class="keyword">import</span> collections</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, capacity</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type capacity: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self.capacity = capacity</span><br><span class="line">        <span class="comment"># cache will contain key:[value, frequency]</span></span><br><span class="line">        <span class="comment"># default dict will contain all the keys having the same frequency of occurrence.</span></span><br><span class="line">        <span class="comment"># &#123;frequency:[key1, key2, key3]&#125;</span></span><br><span class="line">        self.cache = &#123;&#125;</span><br><span class="line">        self.freqCache = collections.defaultdict(<span class="built_in">list</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span>(<span class="params">self, key</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type key: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        val = self.cache.get(key, -<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">if</span> val == -<span class="number">1</span>: </span><br><span class="line">            <span class="keyword">return</span> val</span><br><span class="line">        </span><br><span class="line">        value,freq = val</span><br><span class="line">        <span class="comment"># if key is found, increase the frequency in frequency cache and data cache</span></span><br><span class="line">        self.freqCache[freq].remove(key)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.freqCache[freq]: </span><br><span class="line">            <span class="keyword">del</span> self.freqCache[freq]</span><br><span class="line">        self.freqCache[freq+<span class="number">1</span>].append(key)</span><br><span class="line"></span><br><span class="line">        self.cache[key] = [value, freq+<span class="number">1</span>]  </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> value</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">put</span>(<span class="params">self, key, value</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type key: int</span></span><br><span class="line"><span class="string">        :type value: int</span></span><br><span class="line"><span class="string">        :rtype: None</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> self.capacity &lt;=<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        val = self.cache.get(key, -<span class="number">1</span>)</span><br><span class="line">        initfreq=<span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>  val == -<span class="number">1</span>:</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(self.cache) == self.capacity:</span><br><span class="line">                <span class="comment">#print self.freqCache.items()</span></span><br><span class="line">                minFreq, delList = <span class="built_in">min</span>(self.freqCache.items(), key=<span class="keyword">lambda</span> x:x[<span class="number">0</span>])</span><br><span class="line">                <span class="comment">#print delList</span></span><br><span class="line">                delkey = delList[<span class="number">0</span>]</span><br><span class="line">                <span class="keyword">del</span> self.cache[delkey]</span><br><span class="line">                self.freqCache[minFreq].remove(delkey)</span><br><span class="line">                </span><br><span class="line">                <span class="comment">#insert in cache</span></span><br><span class="line">                self.cache.update(&#123;key:[value,initfreq]&#125;)</span><br><span class="line">                self.freqCache[initfreq].append(key)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                self.cache.update(&#123;key:[value,initfreq]&#125;)</span><br><span class="line">                self.freqCache[initfreq].append(key)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            oldval,freq = val</span><br><span class="line">            </span><br><span class="line">            self.freqCache[freq].remove(key)</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> self.freqCache[freq]: <span class="keyword">del</span> self.freqCache[freq]</span><br><span class="line">            self.freqCache[freq+<span class="number">1</span>].append(key)</span><br><span class="line">            </span><br><span class="line">            self.cache[key] = [value,freq+<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Your LFUCache object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"># obj = LFUCache(capacity)</span></span><br><span class="line"><span class="comment"># param_1 = obj.get(key)</span></span><br><span class="line"><span class="comment"># obj.put(key,value)</span></span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>146. LRU Cache</summary>
> Use OrderedDict. pop key: d.pop(key). Remove least used key: d.popitem(last=False).
<p>Run time: $O(1)$, space: $O(n)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, capacity: <span class="built_in">int</span></span>):</span></span><br><span class="line">        self.cap = capacity</span><br><span class="line">        self.d = collections.OrderedDict()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span>(<span class="params">self, key: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="keyword">if</span> key <span class="keyword">not</span> <span class="keyword">in</span> self.d:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        val = self.d.pop(key)</span><br><span class="line">        self.d[key] = val</span><br><span class="line">        <span class="keyword">return</span> val</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">put</span>(<span class="params">self, key: <span class="built_in">int</span>, value: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">        <span class="keyword">if</span> key <span class="keyword">in</span> self.d:</span><br><span class="line">            self.d.pop(key)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> self.cap &gt; <span class="number">0</span>:</span><br><span class="line">                self.cap -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                self.d.popitem(last=<span class="literal">False</span>)</span><br><span class="line">        self.d[key] = value</span><br><span class="line"></span><br><span class="line"><span class="comment"># Your LRUCache object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"># obj = LRUCache(capacity)</span></span><br><span class="line"><span class="comment"># param_1 = obj.get(key)</span></span><br><span class="line"><span class="comment"># obj.put(key,value)</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>Use dictionary + doubly linked list</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, k, v</span>):</span></span><br><span class="line">        self.key = k</span><br><span class="line">        self.value = v</span><br><span class="line">        self.prev = <span class="literal">None</span></span><br><span class="line">        self.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line">        </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, capacity: <span class="built_in">int</span></span>):</span></span><br><span class="line">        self.cap = capacity</span><br><span class="line">        self.dic = <span class="built_in">dict</span>()</span><br><span class="line">        self.prev = self.<span class="built_in">next</span> = self</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span>(<span class="params">self, key: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="keyword">if</span> key <span class="keyword">in</span> self.dic:</span><br><span class="line">            n = self.dic[key]</span><br><span class="line">            self._remove(n)</span><br><span class="line">            self._add(n)</span><br><span class="line">            <span class="keyword">return</span> n.value</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">put</span>(<span class="params">self, key: <span class="built_in">int</span>, value: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">        <span class="keyword">if</span> key <span class="keyword">in</span> self.dic:</span><br><span class="line">            self._remove(self.dic[key])</span><br><span class="line">        n = Node(key, value)</span><br><span class="line">        self._add(n)</span><br><span class="line">        self.dic[key] = n</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(self.dic) &gt; self.cap:</span><br><span class="line">            n = self.<span class="built_in">next</span></span><br><span class="line">            self._remove(n)</span><br><span class="line">            <span class="keyword">del</span> self.dic[n.key]</span><br><span class="line">            </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_remove</span>(<span class="params">self, node</span>):</span></span><br><span class="line">        p = node.prev</span><br><span class="line">        n = node.<span class="built_in">next</span></span><br><span class="line">        p.<span class="built_in">next</span> = n</span><br><span class="line">        n.prev = p</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_add</span>(<span class="params">self, node</span>):</span></span><br><span class="line">        p = self.prev</span><br><span class="line">        p.<span class="built_in">next</span> = node</span><br><span class="line">        self.prev = node</span><br><span class="line">        node.prev = p</span><br><span class="line">        node.<span class="built_in">next</span> = self</span><br></pre></td></tr></table></figure>
</details>
<h1>Union Find</h1>
<h1>DP</h1>
<details>
<summary></summary>
> 
<p>Run time: $O()$, space: $O()$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>140. Word Break II</summary>
<blockquote>
<p>For any word (denoted as \text{w}w) in the dictionary, if it matches with a prefix of the input string, we then can divide the string into two parts: the word and the postfix, i.e. s = \text{w} + \text{postfix}s=w+postfix.</p>
</blockquote>
<p>Run time: $ \mathcal{O}(N^2 + 2 ^ N + W)$, space: $ \mathcal{O}(2^N \cdot N + N^2 + W)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">wordBreak</span>(<span class="params">self, s: <span class="built_in">str</span>, wordDict: <span class="type">List</span>[<span class="built_in">str</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">str</span>]:</span></span><br><span class="line">    memo = &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">s</span>):</span></span><br><span class="line">        <span class="keyword">if</span> s <span class="keyword">in</span> memo:</span><br><span class="line">            <span class="keyword">return</span> memo[s]</span><br><span class="line">        </span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> wordDict:</span><br><span class="line">            <span class="keyword">if</span> s.startswith(x):</span><br><span class="line">                <span class="keyword">if</span> s == x:</span><br><span class="line">                    res += [x]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">for</span> y <span class="keyword">in</span> dfs(s[<span class="built_in">len</span>(x):]):</span><br><span class="line">                        res += [x + <span class="string">&#x27; &#x27;</span> + y]</span><br><span class="line">        memo[s] = res</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">                    </span><br><span class="line">    <span class="keyword">return</span> dfs(s) </span><br></pre></td></tr></table></figure>
<blockquote>
<p>Recursion</p>
</blockquote>
<p>Run time: $ \mathcal{O}(N^2 + 2 ^ N + W)$, space: $ \mathcal{O}(2^N \cdot N + N^2 + W)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">helper</span>(<span class="params">s, string, ans</span>):</span></span><br><span class="line">    <span class="keyword">if</span> s == <span class="string">&quot;&quot;</span>:</span><br><span class="line">        ans.append(string.strip())</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)+<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">if</span> s[:i] <span class="keyword">in</span> wordDict:</span><br><span class="line">            temp = string + <span class="string">&quot; &quot;</span>+ s[:i]</span><br><span class="line">            helper(s[i:], temp, ans)</span><br><span class="line"></span><br><span class="line">ans = []</span><br><span class="line">helper(s, <span class="string">&quot;&quot;</span>, ans)</span><br><span class="line"><span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>53. Maximum Subarray</summary>
> One variable to keep track of current subarray, one variable to track max subarray.
<p>Run time: $O(n)$, space: $O(1)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">maxSubArray</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">    current_subarray = max_subarray = nums[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> num <span class="keyword">in</span> nums[<span class="number">1</span>:]:</span><br><span class="line">        current_subarray = <span class="built_in">max</span>(num, current_subarray + num)</span><br><span class="line">        max_subarray = <span class="built_in">max</span>(max_subarray, current_subarray)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> max_subarray</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>121. Best Time to Buy and Sell Stock</summary>
> Keep track of lowest price, and update max profit.
<p>Run time: $O(n)$, space: $O(1)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span>(<span class="params">self, prices: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">    buy = <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)</span><br><span class="line">    profit = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> p <span class="keyword">in</span> prices:</span><br><span class="line">        buy = <span class="built_in">min</span>(buy, p)</span><br><span class="line">        profit = <span class="built_in">max</span>(profit, p-buy)</span><br><span class="line">    <span class="keyword">return</span> profit</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>10. Regular Expression Matching</summary>
<blockquote>
<p>dp[i][j] represents whether the string s ending at index i could be expressed by string p ending at index j.</p>
</blockquote>
<p>Run time: $O(mn)$, space: $O(mn)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isMatch</span>(<span class="params">self, s: <span class="built_in">str</span>, p: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">    m,n = <span class="built_in">len</span>(s), <span class="built_in">len</span>(p)</span><br><span class="line">    dp = [[<span class="literal">False</span>]*(n+<span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m+<span class="number">1</span>)]</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">True</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n+<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">if</span> p[i-<span class="number">1</span>] == <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">            dp[<span class="number">0</span>][i] = dp[<span class="number">0</span>][i-<span class="number">2</span>] <span class="comment"># same as the char before *</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, m+<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> p[j-<span class="number">1</span>] == <span class="string">&#x27;.&#x27;</span>: <span class="comment"># skip current one</span></span><br><span class="line">                dp[i][j] = dp[i-<span class="number">1</span>][j-<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">elif</span> p[j-<span class="number">1</span>] != <span class="string">&#x27;*&#x27;</span>: <span class="comment"># normal char must match</span></span><br><span class="line">                dp[i][j] = dp[i-<span class="number">1</span>][j-<span class="number">1</span>] <span class="keyword">and</span> p[j-<span class="number">1</span>] == s[i-<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">elif</span> p[j-<span class="number">2</span>] != <span class="string">&#x27;.&#x27;</span> <span class="keyword">and</span> p[j-<span class="number">2</span>] != s[i-<span class="number">1</span>]: <span class="comment"># ended at *</span></span><br><span class="line">                dp[i][j] = dp[i][j-<span class="number">2</span>]</span><br><span class="line">            <span class="keyword">else</span>: <span class="comment"># all other cases</span></span><br><span class="line">                dp[i][j] = dp[i-<span class="number">1</span>][j] <span class="keyword">or</span> dp[i][j-<span class="number">1</span>] <span class="keyword">or</span> dp[i][j-<span class="number">2</span>]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> dp[-<span class="number">1</span>][-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>416. Partition Equal Subset Sum</summary>
<blockquote>
<p>We could further optimize Approach 3. We must understand that for any array element ii, we need results of the previous iteration (i-1) only. Hence, we could achieve the same using a one-dimensional array as well.</p>
</blockquote>
<p>Run time: $O(mn)$, space: $O(m)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">canPartition</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">    sum_ = <span class="built_in">sum</span>(nums)</span><br><span class="line">    <span class="keyword">if</span> sum_ % <span class="number">2</span> != <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    </span><br><span class="line">    half = sum_ // <span class="number">2</span></span><br><span class="line">    n = <span class="built_in">len</span>(nums)</span><br><span class="line">    </span><br><span class="line">    dp = [<span class="literal">False</span>]*(sum_+<span class="number">1</span>)</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="literal">True</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n+<span class="number">1</span>):</span><br><span class="line">        curr = nums[i-<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(sum_, curr-<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">            dp[j] = dp[j] <span class="keyword">or</span> dp[j-curr]</span><br><span class="line">    <span class="keyword">return</span> dp[sum_]</span><br></pre></td></tr></table></figure>
<blockquote>
<p>We maintain a 2D array ,dp[n][subSetSum] For an array element ii and sum jj in array nums,</p>
</blockquote>
<p>dp[i][j]=true if the sum jj can be formed by array elements in subset nums[0]â€¦nums[i],otherwise dp[i][j]=false</p>
<p>Run time: $O(mn)$, space: $O(mn)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">canPartition</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">    sum_ = <span class="built_in">sum</span>(nums)</span><br><span class="line">    <span class="keyword">if</span> sum_ % <span class="number">2</span> != <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    </span><br><span class="line">    half = sum_ // <span class="number">2</span></span><br><span class="line">    n = <span class="built_in">len</span>(nums)</span><br><span class="line">    </span><br><span class="line">    dp = [[<span class="literal">False</span>]*(sum_+<span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n+<span class="number">1</span>)]</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">True</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n+<span class="number">1</span>):</span><br><span class="line">        curr = nums[i-<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(sum_ + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> j &lt; curr:</span><br><span class="line">                dp[i][j] = dp[i-<span class="number">1</span>][j]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                dp[i][j] = dp[i-<span class="number">1</span>][j] <span class="keyword">or</span> dp[i-<span class="number">1</span>][j-curr]</span><br><span class="line">    <span class="keyword">return</span> dp[n][sum_]</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>300. Longest Increasing Subsequence</summary>
<blockquote>
<p>Use finary search <code>bisect_left</code></p>
</blockquote>
<p>Run time: $O(n\log n)$, space: $O(n)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lengthOfLIS</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">    tails = [<span class="number">0</span>] * <span class="built_in">len</span>(nums)</span><br><span class="line">    size = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> nums:</span><br><span class="line">        lo, hi = <span class="number">0</span>, size</span><br><span class="line">        <span class="keyword">while</span> lo != hi:</span><br><span class="line">            mid = (lo + hi) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> tails[mid] &lt; x:</span><br><span class="line">                lo = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                hi = mid</span><br><span class="line">        tails[lo] = x</span><br><span class="line">        size = <span class="built_in">max</span>(lo + <span class="number">1</span>, size)</span><br><span class="line">    <span class="keyword">return</span> size</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Double for loop and update max if the inner value is smaller than current value.</p>
</blockquote>
<p>Run time: $O(n^2)$, space: $O(n)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lengthOfLIS</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">    n = <span class="built_in">len</span>(nums)</span><br><span class="line">    dp = [<span class="number">1</span>] * (n+<span class="number">1</span>)</span><br><span class="line">    max_len = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i):</span><br><span class="line">            <span class="keyword">if</span> nums[j] &lt; nums[i]:</span><br><span class="line">                dp[i] = <span class="built_in">max</span>(dp[j]+<span class="number">1</span>, dp[i])</span><br><span class="line">        max_len = <span class="built_in">max</span>(dp[i], max_len)</span><br><span class="line">    <span class="keyword">return</span> max_len</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>139. Word Break</summary>
<blockquote>
<p>First put list into a set for easier access. Initialize an array of size n+1 and set the first entry to be True. Loop from 1 to n, and loop from 0 to i-1, check if dp[j] is True and the substring between j and i is valid. If so, set this entry of the dp array to be true.</p>
</blockquote>
<p>Run time: $O(n^3)$, space: $O(n)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">wordBreak</span>(<span class="params">self, s: <span class="built_in">str</span>, wordDict: <span class="type">List</span>[<span class="built_in">str</span>]</span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">    word_set = <span class="built_in">set</span>(wordDict)</span><br><span class="line">    n = <span class="built_in">len</span>(s)</span><br><span class="line">    dp = [<span class="literal">False</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n+<span class="number">1</span>)]</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n+<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i):</span><br><span class="line">            <span class="keyword">if</span> dp[j] <span class="keyword">and</span> s[j:i] <span class="keyword">in</span> word_set:</span><br><span class="line">                dp[i] = <span class="literal">True</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">return</span> dp[<span class="built_in">len</span>(s)]</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>279. Perfect Squares</summary>
> To calculate the value of numSquares(n), first we need to calculate all the values before n.
<p>Run time: $O(n\sqrt{n})$ or $O(\frac{\sqrt{n}^{h+1}-1}{\sqrt{n}-1})=O(n^{\frac{h}{2}})$, space: $O(n)$ or $O((\sqrt{n})^h)$, where h is the height of the N-ary tree.</p>
<blockquote>
<p>Again, first of all, we prepare a list of square numbers (named square_nums) that are less than the given number n.<br>
We then create a queue variable which would keep all the remainders to enumerate at each level.<br>
In the main loop, we iterate over the queue variable. At each iteration, we check if the remainder is one of the square numbers. If the remainder is not a square number, we subtract it with one of the square numbers to obtain a new remainder and then add the new remainder to the next_queue for the iteration of the next level. We break out of the loop once we encounter a remainder that is of a square number, which also means that we find the solution.</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numSquares</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        queue = deque([(n, <span class="number">0</span>)])</span><br><span class="line">        visited = &#123;n&#125;</span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            curr, step = queue.popleft()</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">int</span>(curr ** <span class="number">0.5</span>) == curr ** <span class="number">0.5</span>:</span><br><span class="line">                <span class="keyword">return</span> step + <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">int</span>(curr ** <span class="number">0.5</span>) + <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> curr - (i ** <span class="number">2</span>) <span class="keyword">not</span> <span class="keyword">in</span> visited:</span><br><span class="line">                    queue.append((curr - (i ** <span class="number">2</span>), step + <span class="number">1</span>))</span><br><span class="line">                    visited.add(curr - (i ** <span class="number">2</span>))</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">numSquares</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">    dp = [i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n+<span class="number">1</span>)]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>, n+<span class="number">1</span>):</span><br><span class="line">        j = <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> j**<span class="number">2</span> &lt;= i:</span><br><span class="line">            dp[i] = <span class="built_in">min</span>(dp[i], dp[i-j**<span class="number">2</span>]+<span class="number">1</span>)</span><br><span class="line">            j += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> dp[-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>221. Maximal Square</summary>
<blockquote>
<p>Find squares whose bottom right corner is formed by the current cell. If we can modify the input, the space complexity can be further reduced to $O(1)$.</p>
</blockquote>
<p>Run time: $O(mn)$, space: $O(mn)$ or $O(n)$ or $O(1)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">maximalSquare</span>(<span class="params">self, matrix: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">str</span>]]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">    m, n, ans = <span class="built_in">len</span>(matrix), <span class="built_in">len</span>(matrix[<span class="number">0</span>]), <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i, j <span class="keyword">in</span> product(<span class="built_in">range</span>(m-<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>), <span class="built_in">range</span>(n-<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>)):</span><br><span class="line">        <span class="keyword">if</span> i == m-<span class="number">1</span> <span class="keyword">or</span> j == n-<span class="number">1</span>:</span><br><span class="line">            matrix[i][j] = <span class="built_in">int</span>(matrix[i][j])</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, matrix[i][j])</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> matrix[i][j] == <span class="string">&#x27;1&#x27;</span>:</span><br><span class="line">                matrix[i][j] = <span class="number">1</span> + <span class="built_in">min</span>(matrix[i+<span class="number">1</span>][j], matrix[i][j+<span class="number">1</span>], matrix[i+<span class="number">1</span>][j+<span class="number">1</span>])</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                matrix[i][j] = <span class="number">0</span></span><br><span class="line">            ans = <span class="built_in">max</span>(ans, matrix[i][j])</span><br><span class="line">    <span class="keyword">return</span> ans * ans</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">maximalSquare</span>(<span class="params">self, matrix: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">str</span>]]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">    m, n, ans = <span class="built_in">len</span>(matrix), <span class="built_in">len</span>(matrix[<span class="number">0</span>]), <span class="number">0</span></span><br><span class="line">    dp = [[<span class="number">0</span>]*(n+<span class="number">1</span>) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m+<span class="number">1</span>)]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i, j <span class="keyword">in</span> product(<span class="built_in">range</span>(m-<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>), <span class="built_in">range</span>(n-<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>)):</span><br><span class="line">        <span class="keyword">if</span> matrix[i][j] == <span class="string">&#x27;1&#x27;</span>:</span><br><span class="line">            dp[i][j] = <span class="number">1</span> + <span class="built_in">min</span>(dp[i+<span class="number">1</span>][j], dp[i][j+<span class="number">1</span>], dp[i+<span class="number">1</span>][j+<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            dp[i][j] = <span class="number">0</span></span><br><span class="line">        ans = <span class="built_in">max</span>(ans, dp[i][j])</span><br><span class="line">    <span class="keyword">return</span> ans * ans</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>542. 01 Matrix</summary>
<blockquote>
<p>Two for loops, one goes from top left to bottom right, one goes from bottom right to top left. In this way we could find the minimum distance over all four directions.</p>
</blockquote>
<p>Run time: $O(n^2)$, space: $O(1)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">updateMatrix</span>(<span class="params">self, mat: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span></span><br><span class="line">    m, n = <span class="built_in">len</span>(mat), <span class="built_in">len</span>(mat[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> r <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">if</span> mat[r][c] &gt; <span class="number">0</span>:</span><br><span class="line">                top = mat[r - <span class="number">1</span>][c] <span class="keyword">if</span> r &gt; <span class="number">0</span> <span class="keyword">else</span> math.inf</span><br><span class="line">                left = mat[r][c - <span class="number">1</span>] <span class="keyword">if</span> c &gt; <span class="number">0</span> <span class="keyword">else</span> math.inf</span><br><span class="line">                mat[r][c] = <span class="built_in">min</span>(top, left) + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> r <span class="keyword">in</span> <span class="built_in">range</span>(m - <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> <span class="built_in">range</span>(n - <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> mat[r][c] &gt; <span class="number">0</span>:</span><br><span class="line">                bottom = mat[r + <span class="number">1</span>][c] <span class="keyword">if</span> r &lt; m - <span class="number">1</span> <span class="keyword">else</span> math.inf</span><br><span class="line">                right = mat[r][c + <span class="number">1</span>] <span class="keyword">if</span> c &lt; n - <span class="number">1</span> <span class="keyword">else</span> math.inf</span><br><span class="line">                mat[r][c] = <span class="built_in">min</span>(mat[r][c], bottom + <span class="number">1</span>, right + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> mat</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>64. Minimum Path Sum</summary>
<blockquote>
<p>Instead of using a 2D matrix for dp, we can do the same work using a dp array of the row size, since for making the current entry all we need is the dp entry for the bottom and the right element. Thus, we start by initializing only the last element of the array as the last element of the given matrix. The last entry is the bottom rightmost element of the given matrix.</p>
</blockquote>
<p>Run time: $O(n^2)$, space: $O(n^2)$ or $O(n)$ or $O(1)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">minPathSum</span>(<span class="params">self, grid: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">    m,n = <span class="built_in">len</span>(grid), <span class="built_in">len</span>(grid[<span class="number">0</span>])</span><br><span class="line">    dp = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m-<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n-<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> i == m-<span class="number">1</span> <span class="keyword">and</span> j != n-<span class="number">1</span>:</span><br><span class="line">                dp[j] = grid[i][j] + dp[j+<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">elif</span> j == n-<span class="number">1</span> <span class="keyword">and</span> i != m-<span class="number">1</span>:</span><br><span class="line">                dp[j] = grid[i][j] + dp[j]</span><br><span class="line">            <span class="keyword">elif</span> i != m-<span class="number">1</span> <span class="keyword">and</span> j != n-<span class="number">1</span>:</span><br><span class="line">                dp[j] = grid[i][j] + <span class="built_in">min</span>(dp[j], dp[j+<span class="number">1</span>])</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                dp[j] = grid[i][j]</span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">0</span>]</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">minPathSum</span>(<span class="params">self, grid: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">    m = <span class="built_in">len</span>(grid)</span><br><span class="line">    n = <span class="built_in">len</span>(grid[<span class="number">0</span>])</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n):</span><br><span class="line">        grid[<span class="number">0</span>][i] += grid[<span class="number">0</span>][i-<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, m):</span><br><span class="line">        grid[i][<span class="number">0</span>] += grid[i-<span class="number">1</span>][<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, m):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n):</span><br><span class="line">            grid[i][j] += <span class="built_in">min</span>(grid[i-<span class="number">1</span>][j], grid[i][j-<span class="number">1</span>])</span><br><span class="line">    <span class="keyword">return</span> grid[-<span class="number">1</span>][-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>413. Arithmetic Slices</summary>
<blockquote>
<p>we only require the element dp[iâˆ’1] to determine the value to be entered at dp[i]. Thus, instead of making use of a 1-D array to store the required data, we can simply keep a track of just the last element.</p>
</blockquote>
<p>Run time: $O(n)$, space: $O(n)$ or $O(1)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">numberOfArithmeticSlices</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">    dp = <span class="number">0</span></span><br><span class="line">    total = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, <span class="built_in">len</span>(nums)):</span><br><span class="line">        <span class="keyword">if</span> nums[i] - nums[i-<span class="number">1</span>] == nums[i-<span class="number">1</span>] - nums[i-<span class="number">2</span>]:</span><br><span class="line">            dp += <span class="number">1</span></span><br><span class="line">            total += dp</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            dp = <span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> total</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">numberOfArithmeticSlices</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(nums) &lt; <span class="number">3</span>: </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    dp = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums))]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, <span class="built_in">len</span>(nums)):</span><br><span class="line">        <span class="keyword">if</span> nums[i] - nums[i-<span class="number">1</span>] == nums[i-<span class="number">1</span>] - nums[i-<span class="number">2</span>]:</span><br><span class="line">            dp[i] = dp[i-<span class="number">1</span>]+<span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sum</span>(dp)</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>198. House Robber</summary>
> Either steal this house and the n-2 ones, or not steal this one. We could just use two variables and keep shifting them.
<p>Run time: $O(n)$, space: $O(n)$ or $O(1)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rob</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            </span><br><span class="line">    rob_prev_two = <span class="number">0</span></span><br><span class="line">    rob_prev_one = nums[<span class="number">0</span>]</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># DP table calculations.</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(nums)):</span><br><span class="line">        current = <span class="built_in">max</span>(rob_prev_one, rob_prev_two + nums[i])</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># Update the variables</span></span><br><span class="line">        rob_prev_two = rob_prev_one</span><br><span class="line">        rob_prev_one = current</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> rob_prev_one</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rob</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(nums) == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> nums[<span class="number">0</span>]</span><br><span class="line">    </span><br><span class="line">    ans = [nums[<span class="number">0</span>], <span class="built_in">max</span>(nums[<span class="number">0</span>], nums[<span class="number">1</span>])]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, <span class="built_in">len</span>(nums)):</span><br><span class="line">        ans.append(<span class="built_in">max</span>(nums[i] + ans[i-<span class="number">2</span>], ans[i-<span class="number">1</span>]))</span><br><span class="line">    <span class="keyword">return</span> ans[-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>70. Climbing Stairs</summary>
> Since the `i`th stairs can be reached either from the `i-1`th stair or `i-2`th stair, so the number of ways is the sum of ways at `i-1`th stair and `i-2`th stair.
<p>Run time: $O(n)$, space: $O(n)$ or $O(1)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">climbStairs</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">    a, b = <span class="number">1</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        a, b = b, a + b</span><br><span class="line">    <span class="keyword">return</span> a</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">climbStairs</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">    <span class="keyword">if</span> n &lt;= <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">    ans = [<span class="number">1</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n+<span class="number">1</span>)]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, n+<span class="number">1</span>):</span><br><span class="line">        ans[i] = ans[i-<span class="number">1</span>] + ans[i-<span class="number">2</span>]</span><br><span class="line">    <span class="keyword">return</span> ans[n]</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>1048. Longest String Chain</summary>
<blockquote>
<p>Store the word and the length of longest chain in a dictionary. For each word in the sorted list by length, first initialize the length to be 1, then loop through each char and form substring by removing it. If this substring is in the dictionary, update the key of this word, and update the final result.</p>
</blockquote>
<p>Run time: $O(n\log n)+O(NSS)$, where word length $S\leq 16$, space: $O(NS)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">longestStrChain</span>(<span class="params">self, words: <span class="type">List</span>[<span class="built_in">str</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">    dp = &#123;&#125;</span><br><span class="line">    result = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> word <span class="keyword">in</span> <span class="built_in">sorted</span>(words, key=<span class="built_in">len</span>):</span><br><span class="line">        dp[word] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(word)):</span><br><span class="line">            prev = word[:i] + word[i + <span class="number">1</span>:]</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> prev <span class="keyword">in</span> dp:</span><br><span class="line">                dp[word] = <span class="built_in">max</span>(dp[prev] + <span class="number">1</span>, dp[word])</span><br><span class="line">                result = <span class="built_in">max</span>(result, dp[word])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
</details>
<h1>DP coord + connected</h1>
<h2 id="DP-sliding-array-memory-search">DP sliding array + memory search</h2>
<h2 id="DP-interval-backpack">DP interval + backpack</h2>
<h1>Tree</h1>
<h2 id="Binary-Tree-Divide-Conquer">Binary Tree / Divide &amp; Conquer</h2>
<details>
<summary></summary>
> 
<p>Run time: $O()$, space: $O()$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>173. Binary Search Tree Iterator</summary>
<blockquote>
<p>Push all left nodes to the stack. Once a node is popped from the stack, push its right node back to the stack, and return its value.</p>
</blockquote>
<p>Run time: $O(1)$, space: $O(\log n)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BSTIterator</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>):</span></span><br><span class="line">        self.stack = []</span><br><span class="line">        self.pushAll(root)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">next</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        tmpNode = self.stack.pop()</span><br><span class="line">        self.pushAll(tmpNode.right)</span><br><span class="line">        <span class="keyword">return</span> tmpNode.val</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hasNext</span>(<span class="params">self</span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.stack</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pushAll</span>(<span class="params">self, node</span>):</span></span><br><span class="line">        <span class="keyword">while</span> node:</span><br><span class="line">            self.stack.append(node)</span><br><span class="line">            node = node.left</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Flatten the BST and use a pointer for index.</p>
</blockquote>
<p>Run time: $O(1)$, space: $O(n)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BSTIterator</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>):</span></span><br><span class="line">        self.arr = []</span><br><span class="line">        self.ind = -<span class="number">1</span></span><br><span class="line">        self._inorder(root)</span><br><span class="line">            </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_inorder</span>(<span class="params">self, root</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        self._inorder(root.left)</span><br><span class="line">        self.arr.append(root.val)</span><br><span class="line">        self._inorder(root.right)</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">next</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.hasNext():</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        self.ind += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> self.arr[self.ind]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hasNext</span>(<span class="params">self</span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.ind+<span class="number">1</span> &lt; <span class="built_in">len</span>(self.arr)</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>199. Binary Tree Right Side View</summary>
<blockquote>
<p>DFS, Recursion.</p>
</blockquote>
<p>Run time: $O(n)$, space: $O(n)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rightSideView</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span></span><br><span class="line">    self.ans = []</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span>(<span class="params">node, level</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">if</span> level &gt;= <span class="built_in">len</span>(self.ans):</span><br><span class="line">            self.ans.append(node.val)</span><br><span class="line"></span><br><span class="line">        helper(node.right, level+<span class="number">1</span>)</span><br><span class="line">        helper(node.left, level+<span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line">    helper(root, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> self.ans</span><br></pre></td></tr></table></figure>
<blockquote>
<p>BFS, iterative.</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rightSideView</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span></span><br><span class="line">    view = []</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line">    </span><br><span class="line">    q = collections.deque()</span><br><span class="line">    q.append((root, <span class="number">0</span>))</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> q:</span><br><span class="line">        curr, level = q.popleft()</span><br><span class="line">        <span class="keyword">if</span> level == <span class="number">0</span> <span class="keyword">or</span> <span class="keyword">not</span> q <span class="keyword">or</span> q[<span class="number">0</span>][<span class="number">1</span>] &gt; level:</span><br><span class="line">            view.append(curr.val)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> curr.left:</span><br><span class="line">            q.append((curr.left, level + <span class="number">1</span>))</span><br><span class="line">        <span class="keyword">if</span> curr.right:</span><br><span class="line">            q.append((curr.right, level + <span class="number">1</span>))</span><br><span class="line">    <span class="keyword">return</span> view</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>987. Vertical Order Traversal of a Binary Tree</summary>
<blockquote>
<p>Use defaultdict instead of normal dict to get rid of key not exist case. Put &lt;level, value&gt; as value into the dictionary, use placement as key. In the end sort placement, and sort the level.</p>
</blockquote>
<p>Run time: $O(n\log n)$, space: $O()$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">verticalTraversal</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span>(<span class="params">placement, level, node, dic</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        dic[placement].append((level, node.val))</span><br><span class="line">        helper(placement-<span class="number">1</span>, level+<span class="number">1</span>, node.left, dic)</span><br><span class="line">        helper(placement+<span class="number">1</span>, level+<span class="number">1</span>, node.right, dic)</span><br><span class="line">        </span><br><span class="line">    dic = defaultdict(<span class="built_in">list</span>)</span><br><span class="line">    helper(<span class="number">0</span>,<span class="number">0</span>,root,dic)</span><br><span class="line">    res = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">sorted</span>(dic.keys()):</span><br><span class="line">        temp = []</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">sorted</span>(dic[i]):</span><br><span class="line">            temp.append(j[<span class="number">1</span>])</span><br><span class="line">        res.append(temp)</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>938. Range Sum of BST</summary>
<blockquote>
<p>Recursion. Need to check if strictly less than or greater than the range, then call helper function recursively.</p>
</blockquote>
<p>Run time: $O(n)$, space: $O(n)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rangeSumBST</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode], low: <span class="built_in">int</span>, high: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">    self.rangeSum = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span>(<span class="params">node, lo, hi</span>):</span></span><br><span class="line">        <span class="keyword">if</span> node:</span><br><span class="line">            <span class="keyword">if</span> lo &lt;= node.val &lt;= hi:</span><br><span class="line">                self.rangeSum += node.val</span><br><span class="line">            <span class="keyword">if</span> lo &lt; node.val:</span><br><span class="line">                    helper(node.left, lo, hi)</span><br><span class="line">            <span class="keyword">if</span> node.val &lt; hi:</span><br><span class="line">                helper(node.right, lo, hi)</span><br><span class="line">            </span><br><span class="line">    helper(root, low, high)</span><br><span class="line">    <span class="keyword">return</span> self.rangeSum</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Iterative</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rangeSumBST</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode], low: <span class="built_in">int</span>, high: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">    ans = <span class="number">0</span></span><br><span class="line">    stack = [root]</span><br><span class="line">    <span class="keyword">while</span> stack:</span><br><span class="line">        node = stack.pop()</span><br><span class="line">        <span class="keyword">if</span> node:</span><br><span class="line">            <span class="keyword">if</span> L &lt;= node.val &lt;= R:</span><br><span class="line">                ans += node.val</span><br><span class="line">            <span class="keyword">if</span> L &lt; node.val:</span><br><span class="line">                stack.append(node.left)</span><br><span class="line">            <span class="keyword">if</span> node.val &lt; R:</span><br><span class="line">                stack.append(node.right)</span><br><span class="line">    <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>426. Convert Binary Search Tree to Sorted Doubly Linked List</summary>
<blockquote>
<p>Recursion</p>
</blockquote>
<p>Run time: $O(n)$, space: $O(n)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">treeToDoublyList</span>(<span class="params">self, root: <span class="string">&#x27;Optional[Node]&#x27;</span></span>) -&gt; &#x27;<span class="type">Optional</span>[Node]&#x27;:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span>(<span class="params">node</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Performs standard inorder traversal:</span></span><br><span class="line"><span class="string">        left -&gt; node -&gt; right</span></span><br><span class="line"><span class="string">        and links all nodes into DLL</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> node:</span><br><span class="line">            <span class="comment"># left</span></span><br><span class="line">            helper(node.left)</span><br><span class="line">            <span class="comment"># node </span></span><br><span class="line">            <span class="keyword">if</span> self.last:</span><br><span class="line">                <span class="comment"># link the previous node (last)</span></span><br><span class="line">                <span class="comment"># with the current one (node)</span></span><br><span class="line">                self.last.right = node</span><br><span class="line">                node.left = self.last</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># keep the smallest node</span></span><br><span class="line">                <span class="comment"># to close DLL later on</span></span><br><span class="line">                self.first = node        </span><br><span class="line">            self.last = node</span><br><span class="line">            <span class="comment"># right</span></span><br><span class="line">            helper(node.right)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># the smallest (first) and the largest (last) nodes</span></span><br><span class="line">    self.first, self.last = <span class="literal">None</span>, <span class="literal">None</span></span><br><span class="line">    helper(root)</span><br><span class="line">    <span class="comment"># close DLL</span></span><br><span class="line">    self.last.right = self.first</span><br><span class="line">    self.first.left = self.last</span><br><span class="line">    <span class="keyword">return</span> self.first</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>1110. Delete Nodes And Return Forest</summary>
<blockquote>
<p>DFS.</p>
</blockquote>
<p>Run time: $O(n)$, space: $O(n)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">delNodes</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode], to_delete: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[TreeNode]:</span></span><br><span class="line">      ans = []</span><br><span class="line">      to_delete = <span class="built_in">set</span>(to_delete)</span><br><span class="line">      </span><br><span class="line">      <span class="function"><span class="keyword">def</span> <span class="title">helper</span>(<span class="params">node</span>):</span></span><br><span class="line">          <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">              <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">          node.left = helper(node.left)</span><br><span class="line">          node.right = helper(node.right)</span><br><span class="line">	</span><br><span class="line">	<span class="comment"># add children of a node that is to be deleted</span></span><br><span class="line">          <span class="keyword">if</span> node.val <span class="keyword">in</span> to_delete:</span><br><span class="line">              <span class="keyword">if</span> node.left: </span><br><span class="line">                  ans.append(node.left)</span><br><span class="line">              <span class="keyword">if</span> node.right:</span><br><span class="line">                  ans.append(node.right)</span><br><span class="line">              <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">          <span class="keyword">return</span> node</span><br><span class="line">              </span><br><span class="line">      helper(root)</span><br><span class="line"><span class="comment"># if root is not to be deleted then add it</span></span><br><span class="line">      <span class="keyword">if</span> root.val <span class="keyword">not</span> <span class="keyword">in</span> to_delete:</span><br><span class="line">          ans.append(root)</span><br><span class="line">      <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<blockquote>
<p>BFS.</p>
</blockquote>
<p>Run time: $O(n)$, space: $O(n)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delNodes</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode], to_delete: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[TreeNode]:</span></span><br><span class="line">    output = []</span><br><span class="line">    to_delete_set = <span class="built_in">set</span>(to_delete)</span><br><span class="line">    tree_queue = [root]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> tree_queue:</span><br><span class="line">        curr_tree = tree_queue.pop(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> curr_tree:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">if</span> curr_tree.val <span class="keyword">in</span> to_delete_set:</span><br><span class="line">            tree_queue.append(curr_tree.left)</span><br><span class="line">            tree_queue.append(curr_tree.right)</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        </span><br><span class="line">        node_queue = [curr_tree]</span><br><span class="line">        <span class="keyword">while</span> node_queue:</span><br><span class="line">            curr_node = node_queue.pop(<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> curr_node:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> curr_node.left <span class="keyword">and</span> curr_node.left.val <span class="keyword">in</span> to_delete_set:</span><br><span class="line">                tree_queue.append(curr_node.left.left)</span><br><span class="line">                tree_queue.append(curr_node.left.right)</span><br><span class="line">                curr_node.left = <span class="literal">None</span></span><br><span class="line">            <span class="keyword">if</span> curr_node.right <span class="keyword">and</span> curr_node.right.val <span class="keyword">in</span> to_delete_set:</span><br><span class="line">                tree_queue.append(curr_node.right.left)</span><br><span class="line">                tree_queue.append(curr_node.right.right)</span><br><span class="line">                curr_node.right = <span class="literal">None</span></span><br><span class="line">                </span><br><span class="line">            node_queue.append(curr_node.left)</span><br><span class="line">            node_queue.append(curr_node.right)</span><br><span class="line">            </span><br><span class="line">        output.append(curr_tree)</span><br><span class="line">    <span class="keyword">return</span> output</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>235. Lowest Common Ancestor of a Binary Search Tree</summary>
<blockquote>
<p>Recursion. Since the input tree is a binary search tree, we can utilize the property and determine the LCA. If both p and q values are smaller or greater than the current node val, we know that the LCA could be further reduced.</p>
</blockquote>
<p>Run time: $O(n)$, space: $O(n)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lowestCommonAncestor</span>(<span class="params">self, root: <span class="string">&#x27;TreeNode&#x27;</span>, p: <span class="string">&#x27;TreeNode&#x27;</span>, q: <span class="string">&#x27;TreeNode&#x27;</span></span>) -&gt; &#x27;TreeNode&#x27;:</span></span><br><span class="line">    <span class="keyword">if</span> root.val &lt; p.val <span class="keyword">and</span> root.val &lt; q.val:</span><br><span class="line">        <span class="keyword">return</span> self.lowestCommonAncestor(root.right, p, q)</span><br><span class="line">    <span class="keyword">elif</span> root.val &gt; p.val <span class="keyword">and</span> root.val &gt; q.val:</span><br><span class="line">        <span class="keyword">return</span> self.lowestCommonAncestor(root.left, p, q)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Iterative.</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lowestCommonAncestor</span>(<span class="params">self, root: <span class="string">&#x27;TreeNode&#x27;</span>, p: <span class="string">&#x27;TreeNode&#x27;</span>, q: <span class="string">&#x27;TreeNode&#x27;</span></span>) -&gt; &#x27;TreeNode&#x27;:</span></span><br><span class="line">    node = root</span><br><span class="line">    <span class="keyword">while</span> node:</span><br><span class="line">        <span class="keyword">if</span> node.val &lt; p.val <span class="keyword">and</span> node.val &lt; q.val:</span><br><span class="line">            node = node.right</span><br><span class="line">        <span class="keyword">elif</span> node.val &gt; p.val <span class="keyword">and</span> node.val &gt; q.val:</span><br><span class="line">            node = node.left</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> node</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>637. Average of Levels in Binary Tree</summary>
> DFS. Create a list of list where the index is the height. If the current node height is greater than or equal to the output array length, then append an empty array. Then access the array at index height and append the value. Use list comprehension to get the average for each list.
<p>Run time: $O(n)$, space: $O(n)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">averageOfLevels</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="built_in">float</span>]:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getH</span>(<span class="params">node, height</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">if</span> height &gt;= <span class="built_in">len</span>(self.ans):</span><br><span class="line">            self.ans.append([])</span><br><span class="line">        self.ans[height].append(node.val)</span><br><span class="line">        getH(node.left, height+<span class="number">1</span>)</span><br><span class="line">        getH(node.right, height+<span class="number">1</span>)</span><br><span class="line">        </span><br><span class="line">    self.ans = []</span><br><span class="line">    getH(root, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> [<span class="built_in">sum</span>(s)/<span class="built_in">len</span>(s) <span class="keyword">for</span> s <span class="keyword">in</span> self.ans]</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>450. Delete Node in a BST</summary>
> There are three possible situations here :
- Node is a leaf, and one could delete it straightforward : node = null.
- Node is not a leaf and has a right child. Then the node could be replaced by its successor which is somewhere lower in the right subtree. Then one could proceed down recursively to delete the successor.
- Node is not a leaf, has no right child and has a left child. That means that its successor is somewhere upper in the tree but we don't want to go back. Let's use the predecessor here which is somewhere lower in the left subtree. The node could be replaced by its predecessor and then one could proceed down recursively to delete the predecessor.
<p>Run time: $O(\log n)$, space: $O(h)$, where $h$ is the tree height, when $h=\log n$, it is a balanced tree.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">deleteNode</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode], key: <span class="built_in">int</span></span>) -&gt; <span class="type">Optional</span>[TreeNode]:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">successor</span>(<span class="params">root</span>):</span></span><br><span class="line">        root = root.right</span><br><span class="line">        <span class="keyword">while</span> root.left:</span><br><span class="line">            root = root.left</span><br><span class="line">        <span class="keyword">return</span> root.val</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">predecessor</span>(<span class="params">root</span>):</span></span><br><span class="line">        root = root.left</span><br><span class="line">        <span class="keyword">while</span> root.right:</span><br><span class="line">            root = root.right</span><br><span class="line">        <span class="keyword">return</span> root.val</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">        <span class="keyword">return</span> root</span><br><span class="line">    <span class="keyword">if</span> root.val &gt; key:</span><br><span class="line">        root.left = self.deleteNode(root.left, key)</span><br><span class="line">    <span class="keyword">elif</span> root.val &lt; key:</span><br><span class="line">        root.right = self.deleteNode(root.right, key)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root.left <span class="keyword">and</span> <span class="keyword">not</span> root.right:</span><br><span class="line">            root = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">elif</span> root.right:</span><br><span class="line">            root.val = successor(root)</span><br><span class="line">            root.right = self.deleteNode(root.right, root.val)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            root.val = predecessor(root)</span><br><span class="line">            root.left = self.deleteNode(root.left, root.val)</span><br><span class="line">            </span><br><span class="line">    <span class="keyword">return</span> root</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>328. Odd Even Linked List</summary>
<blockquote>
<p>Put the odd nodes in a linked list and the even nodes in another. Then link the evenList to the tail of the oddList.</p>
</blockquote>
<p>Run time: $O(n)$, space: $O(1)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">oddEvenList</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span></span><br><span class="line">    d1 = odd = ListNode(<span class="number">0</span>)</span><br><span class="line">    d2 = even = ListNode(<span class="number">0</span>)</span><br><span class="line">    i = <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> head:</span><br><span class="line">        <span class="keyword">if</span> i%<span class="number">2</span>:</span><br><span class="line">            odd.<span class="built_in">next</span>, odd = head,head</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            even.<span class="built_in">next</span>, even = head,head</span><br><span class="line">        head = head.<span class="built_in">next</span></span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">    odd.<span class="built_in">next</span>, even.<span class="built_in">next</span> = d2.<span class="built_in">next</span>,<span class="literal">None</span></span><br><span class="line">    <span class="keyword">return</span> d1.<span class="built_in">next</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">oddEvenList</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> head:</span><br><span class="line">        <span class="keyword">return</span> head</span><br><span class="line">    odd = head</span><br><span class="line">    even = head.<span class="built_in">next</span></span><br><span class="line">    evenHead = even</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> even <span class="keyword">and</span> even.<span class="built_in">next</span>:</span><br><span class="line">        odd.<span class="built_in">next</span> = even.<span class="built_in">next</span></span><br><span class="line">        odd = odd.<span class="built_in">next</span></span><br><span class="line">        even.<span class="built_in">next</span> = odd.<span class="built_in">next</span></span><br><span class="line">        even = even.<span class="built_in">next</span></span><br><span class="line">    odd.<span class="built_in">next</span> = evenHead</span><br><span class="line">    <span class="keyword">return</span> head</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>101. Symmetric Tree</summary>
<blockquote>
<p>Iterative. Maintain a queue and pop two elements at a time and compare, then append their child nodes pairs to the queue.</p>
</blockquote>
<p>Run time: $O(n)$, space: $O(n)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isSymmetric</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">    q = [root, root]</span><br><span class="line">    <span class="keyword">while</span> q:</span><br><span class="line">        n1 = q.pop()</span><br><span class="line">        n2 = q.pop()</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> n1 <span class="keyword">and</span> <span class="keyword">not</span> n2:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">elif</span> <span class="keyword">not</span> n1 <span class="keyword">or</span> <span class="keyword">not</span> n2:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">elif</span> n1.val != n2.val:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        q.append(n1.left)</span><br><span class="line">        q.append(n2.right)</span><br><span class="line">        q.append(n1.right)</span><br><span class="line">        q.append(n2.left)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>Recursion. Use a helper function to check whether the current two nodes have the same value, and check left==right and right==left.</p>
</blockquote>
<p>Run time: $O(n)$, space: $O(n)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isSymmetric</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span>(<span class="params">n1, n2</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> n1 <span class="keyword">and</span> <span class="keyword">not</span> n2:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">elif</span> <span class="keyword">not</span> n1 <span class="keyword">or</span> <span class="keyword">not</span> n2:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> n1.val == n2.val <span class="keyword">and</span> \</span><br><span class="line">               helper(n1.right, n2.left) <span class="keyword">and</span> \</span><br><span class="line">               helper(n1.left, n2.right)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> helper(root, root)</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>437. Path Sum III</summary>
<blockquote>
<p>Use a variable to track the current prefix sum and a hashmap â€œprefix sum -&gt; how many times was it seen so farâ€. Parse the input structure and count the requested subarrays/submatrices/tree paths along the way with the help of that hashmap. How to count?<br>
The logic is simple: the current prefix sum is curr_sum, and some elements before the prefix sum was curr_sum - target. All the elements in between sum up to curr_sum - (curr_sum - target) = target.</p>
</blockquote>
<p>Run time: $O(n)$, space: $O(n)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pathSum</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode], targetSum: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">preorder</span>(<span class="params">node: TreeNode, curr_sum</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        curr_sum += node.val</span><br><span class="line">        <span class="keyword">if</span> curr_sum == k:</span><br><span class="line">            self.count += <span class="number">1</span></span><br><span class="line">        self.count += h[curr_sum-k]</span><br><span class="line">        h[curr_sum] += <span class="number">1</span></span><br><span class="line">        preorder(node.left, curr_sum)</span><br><span class="line">        preorder(node.right, curr_sum)</span><br><span class="line">        </span><br><span class="line">    self.count = <span class="number">0</span></span><br><span class="line">    k = targetSum</span><br><span class="line">    h = defaultdict(<span class="built_in">int</span>)</span><br><span class="line">    preorder(root, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> self.count</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pathSum</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode], targetSum: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">    <span class="keyword">return</span> self.helper(root, targetSum, [targetSum])</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">helper</span>(<span class="params">self, node, origin, targets</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> node: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    hit = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> t <span class="keyword">in</span> targets:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> t-node.val: hit += <span class="number">1</span>                          <span class="comment"># count if sum == target</span></span><br><span class="line">    targets = [t-node.val <span class="keyword">for</span> t <span class="keyword">in</span> targets]+[origin]         <span class="comment"># update the targets</span></span><br><span class="line">    <span class="keyword">return</span> hit+self.helper(node.left, origin, targets)+self.helper(node.right, origin, targets)</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>543. Diameter of Binary Tree</summary>
<blockquote>
<p>we know that the longest path in the tree would consist of a node, its longest left branch, and its longest right branch. So, our algorithm to solve this problem will find the node where the sum of its longest left and right branches is maximized. This would hint at us to apply Depth-first search (DFS) to count each nodeâ€™s branch lengths, because it would allow us to dive deep into the leaves first, and then start counting the edges upwards.</p>
</blockquote>
<p>Run time: $O(n)$, space: $O(n)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">diameterOfBinaryTree</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">    self.diameter = <span class="number">0</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longest</span>(<span class="params">node</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        left = longest(node.left)</span><br><span class="line">        right = longest(node.right)</span><br><span class="line">        </span><br><span class="line">        self.diameter = <span class="built_in">max</span>(self.diameter, left+right)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(left, right)+<span class="number">1</span></span><br><span class="line">   </span><br><span class="line">    longest(root)</span><br><span class="line">    <span class="keyword">return</span> self.diameter</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>110. Balanced Binary Tree</summary>
<blockquote>
<p>Bottom up. If node is None, return 0. Then check for its left and right child, if any of them returns -1, then it means the subtree is not balanced. Or if the difference is greater than 1, the subtree is also not balanced. In the end return 1 + max of left and right child.</p>
</blockquote>
<p>Run time: $O()$, space: $O()$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isBalanced</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">check</span>(<span class="params">root</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        left  = check(root.left)</span><br><span class="line">        right = check(root.right)</span><br><span class="line">        <span class="keyword">if</span> left == -<span class="number">1</span> <span class="keyword">or</span> right == -<span class="number">1</span> <span class="keyword">or</span> <span class="built_in">abs</span>(left - right) &gt; <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + <span class="built_in">max</span>(left, right)</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> check(root) != -<span class="number">1</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>if recursive calls before conditional check, then its bottom up. If recursive call after conditional check, its top down.</p>
</blockquote>
<p>Run time: $O(n\log n)$, space: $O(n)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isBalanced</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">height</span>(<span class="params">node</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(height(node.left), height(node.right))+<span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">abs</span>(height(root.left) - height(root.right)) &lt; <span class="number">2</span> \</span><br><span class="line">        <span class="keyword">and</span> self.isBalanced(root.left) \</span><br><span class="line">        <span class="keyword">and</span> self.isBalanced(root.right)</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>236. Lowest Common Ancestor of a Binary Tree</summary>
> Recursive solution, DFS
<p>Run time: $O(n)$, space: $O(h)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lowestCommonAncestor</span>(<span class="params">self, root, p, q</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    :type root: TreeNode</span></span><br><span class="line"><span class="string">    :type p: TreeNode</span></span><br><span class="line"><span class="string">    :type q: TreeNode</span></span><br><span class="line"><span class="string">    :rtype: TreeNode</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    <span class="keyword">if</span> p == root <span class="keyword">or</span> q == root:</span><br><span class="line">        <span class="keyword">return</span> root</span><br><span class="line">    left = self.lowestCommonAncestor(root.left, p, q)</span><br><span class="line">    right = self.lowestCommonAncestor(root.right, p, q)</span><br><span class="line">    <span class="keyword">if</span> left <span class="keyword">and</span> right:</span><br><span class="line">        <span class="keyword">return</span> root</span><br><span class="line">    <span class="keyword">elif</span> <span class="keyword">not</span> left:</span><br><span class="line">        <span class="keyword">return</span> right</span><br><span class="line">    <span class="keyword">elif</span> <span class="keyword">not</span> right:</span><br><span class="line">        <span class="keyword">return</span> left</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Iterative, BFS. Use a stack to keep track of each viewed node, and a parent dict to track a nodeâ€™s parent. If <code>p</code> and <code>q</code> are not in the parent dict, keep popping from the stack, add to parent dict, and append to stack. Then we create a set called <code>ancestors</code>, keep finding pâ€™s parent. Then find qâ€™s parent until q is in the ancestors, then return q.</p>
</blockquote>
<p>Run time: $O(n)$, space: $O(h)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lowestCommonAncestor</span>(<span class="params">self, root, p, q</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    :type root: TreeNode</span></span><br><span class="line"><span class="string">    :type p: TreeNode</span></span><br><span class="line"><span class="string">    :type q: TreeNode</span></span><br><span class="line"><span class="string">    :rtype: TreeNode</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    stack = [root]</span><br><span class="line">    parent_dict = &#123;root: <span class="literal">None</span>&#125;</span><br><span class="line">    <span class="keyword">while</span> p <span class="keyword">not</span> <span class="keyword">in</span> parent_dict <span class="keyword">or</span> q <span class="keyword">not</span> <span class="keyword">in</span> parent_dict:</span><br><span class="line">        node = stack.pop()</span><br><span class="line">        <span class="keyword">if</span> node.left:</span><br><span class="line">            parent_dict[node.left] = node</span><br><span class="line">            stack.append(node.left)</span><br><span class="line">        <span class="keyword">if</span> node.right:</span><br><span class="line">            parent_dict[node.right] = node</span><br><span class="line">            stack.append(node.right)</span><br><span class="line">    </span><br><span class="line">    ancestors = <span class="built_in">set</span>()</span><br><span class="line">    <span class="keyword">while</span> p:</span><br><span class="line">        ancestors.add(p)</span><br><span class="line">        p = parent_dict[p]</span><br><span class="line">    <span class="keyword">while</span> q <span class="keyword">not</span> <span class="keyword">in</span> ancestors:</span><br><span class="line">        ancestors.add(q)</span><br><span class="line">        q = parent_dict[q]</span><br><span class="line">    <span class="keyword">return</span> q</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>1650. Lowest Common Ancestor of a Binary Tree III</summary>
> Use two pointers to keep track of the parents, until they point to the same node. When either of the pointers points to the root, i.e., parent is None, then set it to the other original node.
<p>Run time: $O(n)$, space: $O(1)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lowestCommonAncestor</span>(<span class="params">self, p, q</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    :type node: Node</span></span><br><span class="line"><span class="string">    :rtype: Node</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    p1, p2 = p, q</span><br><span class="line">    <span class="keyword">while</span> p1 != p2:</span><br><span class="line">        p1 =  p1.parent <span class="keyword">if</span> p1.parent <span class="keyword">else</span> q</span><br><span class="line">        p2 = p2.parent <span class="keyword">if</span> p2.parent <span class="keyword">else</span> p</span><br><span class="line">    <span class="keyword">return</span> p1</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>314. Binary Tree Vertical Order Traversal</summary>
> BFS, obtain the range of the column indices, walk through the column range [min_column, max_column] and retrieve the results accordingly.
<p>Run time: $O(n)$, space: $O(n)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">verticalOrder</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span></span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line"></span><br><span class="line">        columnTable = defaultdict(<span class="built_in">list</span>)</span><br><span class="line">        min_column = max_column = <span class="number">0</span></span><br><span class="line">        queue = deque([(root, <span class="number">0</span>)])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            node, column = queue.popleft()</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> node <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                columnTable[column].append(node.val)</span><br><span class="line">                min_column = <span class="built_in">min</span>(min_column, column)</span><br><span class="line">                max_column = <span class="built_in">max</span>(max_column, column)</span><br><span class="line"></span><br><span class="line">                queue.append((node.left, column - <span class="number">1</span>))</span><br><span class="line">                queue.append((node.right, column + <span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> [columnTable[x] <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(min_column, max_column + <span class="number">1</span>)]</span><br></pre></td></tr></table></figure>
<blockquote>
<p>BFS, store the current node in the answer, and if left/right child is not None, enqueue.</p>
</blockquote>
<p>Run time: $O(n \log n)$, space: $O(n)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">verticalOrder</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line">    </span><br><span class="line">    result = collections.defaultdict(<span class="built_in">list</span>)</span><br><span class="line">    queue = [(root, <span class="number">0</span>)]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> node, distance <span class="keyword">in</span> queue:</span><br><span class="line">        result[distance].append(node.val)</span><br><span class="line">        <span class="keyword">if</span> node.left:</span><br><span class="line">            queue.append((node.left, distance-<span class="number">1</span>))</span><br><span class="line">        <span class="keyword">if</span> node.right:</span><br><span class="line">            queue.append((node.right, distance+<span class="number">1</span>))</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> [order <span class="keyword">for</span> distance, order <span class="keyword">in</span> <span class="built_in">sorted</span>(result.items())]</span><br></pre></td></tr></table></figure>
<details>
<summary>my implementation</summary>
Run time: $O(n)$, space: $O(n)$
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">verticalOrder</span>(<span class="params">self, root</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: List[List[int]]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">helper</span>(<span class="params">node, level</span>):</span></span><br><span class="line">            <span class="keyword">if</span> node <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> node.left <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">if</span> level-<span class="number">1</span> <span class="keyword">not</span> <span class="keyword">in</span> d:</span><br><span class="line">                    d[level-<span class="number">1</span>] = []</span><br><span class="line">                d[level-<span class="number">1</span>].append(node.left.val)</span><br><span class="line">            <span class="keyword">if</span> node.right <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">if</span> level+<span class="number">1</span> <span class="keyword">not</span> <span class="keyword">in</span> d:</span><br><span class="line">                    d[level+<span class="number">1</span>] = []</span><br><span class="line">                d[level+<span class="number">1</span>].append(node.right.val)</span><br><span class="line">            helper(node.left, level-<span class="number">1</span>)</span><br><span class="line">            helper(node.right, level+<span class="number">1</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        d = &#123;&#125;</span><br><span class="line">        d[<span class="number">0</span>] = [root.val]</span><br><span class="line">        helper(root, <span class="number">0</span>)</span><br><span class="line">        </span><br><span class="line">        ans = []</span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">sorted</span>(d):</span><br><span class="line">            ans.append(d[k])</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
</details>
</details>
<h2 id="Trie">Trie</h2>
<details>
<summary></summary>
> 
<p>Run time: $O()$, space: $O()$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>208. Implement Trie (Prefix Tree)</summary>
<blockquote>
<p>Maintain a dictionary and keep adding empty entries if the character does not exist, and update the pointer to the key.</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Trie</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.trie = &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insert</span>(<span class="params">self, word: <span class="built_in">str</span></span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">        curr_d = self.trie</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> word:</span><br><span class="line">            <span class="keyword">if</span> c <span class="keyword">not</span> <span class="keyword">in</span> curr_d:</span><br><span class="line">                curr_d[c] = &#123;&#125;</span><br><span class="line">            curr_d = curr_d[c]</span><br><span class="line">        curr_d[<span class="string">&#x27;-&#x27;</span>] = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search</span>(<span class="params">self, word: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        curr_d = self.trie</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> word:</span><br><span class="line">            <span class="keyword">if</span> c <span class="keyword">not</span> <span class="keyword">in</span> curr_d:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            curr_d = curr_d[c]</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;-&#x27;</span> <span class="keyword">in</span> curr_d</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">startsWith</span>(<span class="params">self, prefix: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        curr_d = self.trie</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> prefix:</span><br><span class="line">            <span class="keyword">if</span> c <span class="keyword">not</span> <span class="keyword">in</span> curr_d:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            curr_d = curr_d[c]</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>
</details>
<h2 id="Segment-Tree">Segment Tree</h2>
<h1>String</h1>
<details>
<summary></summary>
> 
<p>Run time: $O()$, space: $O()$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>791. Custom Sort String</summary>
> 
<p>Run time: $O(\max(m,n))$, space: $O(n)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">customSortString</span>(<span class="params">self, order: <span class="built_in">str</span>, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span></span><br><span class="line">      freq = Counter(s) <span class="comment">#O(n) + O(1)</span></span><br><span class="line"><span class="comment"># equivalent:</span></span><br><span class="line"><span class="comment"># freq = &#123;&#125;</span></span><br><span class="line">      <span class="comment"># for ch in s: #O(n) where n is len(s)</span></span><br><span class="line">      <span class="comment">#     freq[ch] = freq.get(ch, 0) + 1</span></span><br><span class="line"></span><br><span class="line">      chars = []</span><br><span class="line">      <span class="keyword">for</span> ch <span class="keyword">in</span> order: <span class="comment">#O(m) where m is the len(order)</span></span><br><span class="line">          chars.append(ch*freq.pop(ch, <span class="number">0</span>)) <span class="comment">#O(1)</span></span><br><span class="line">      </span><br><span class="line">      <span class="keyword">for</span> key <span class="keyword">in</span> freq.keys(): <span class="comment">#O(k) where k is the size of keys present in s but not in order</span></span><br><span class="line">          chars.append(key*freq[key]) <span class="comment">#O(1)</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;&quot;</span>.join(chars)</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>766. Toeplitz Matrix</summary>
<blockquote></blockquote>
<p>Run time: $O(mn)$, space: $O(1)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isToeplitzMatrix</span>(<span class="params">self, matrix: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(matrix)-<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(matrix[<span class="number">0</span>])-<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> matrix[i][j] != matrix[i + <span class="number">1</span>][j + <span class="number">1</span>]:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">def</span> <span class="title">isToeplitzMatrix</span>(<span class="params">self, matrix: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">     <span class="keyword">if</span> <span class="keyword">not</span> matrix <span class="keyword">or</span> <span class="keyword">not</span> matrix[<span class="number">0</span>]:</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">False</span>                </span><br><span class="line">     </span><br><span class="line">     <span class="comment"># Create a deque tracking the expected values for the next row</span></span><br><span class="line">     expected = deque(matrix[<span class="number">0</span>])</span><br><span class="line">     </span><br><span class="line">     <span class="comment"># Iterate through all the remaining rows, verifying they align with the</span></span><br><span class="line">     <span class="comment">#   expected row.</span></span><br><span class="line">     <span class="keyword">for</span> row_i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(matrix)):</span><br><span class="line">         row = matrix[row_i]</span><br><span class="line">         expected.pop()</span><br><span class="line">         expected.appendleft(row[<span class="number">0</span>])</span><br><span class="line">         </span><br><span class="line"><span class="comment"># Only check from index 1 and down as we&#x27;ve just added index 0 to expected</span></span><br><span class="line">         <span class="keyword">for</span> col_i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(row)):</span><br><span class="line">             <span class="keyword">if</span> row[col_i] != expected[col_i]:</span><br><span class="line">                 <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">     </span><br><span class="line">     <span class="comment"># If we&#x27;ve reached here, all diagonals aligned</span></span><br><span class="line">     <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>953. Verifying an Alien Dictionary</summary>
<blockquote>
<p>Two cases: 1. prev and curr in correct order but prev length is longer, 2. prev and curr not in order.</p>
</blockquote>
<p>Run time: $O(n)$, space: $O(1)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">def</span> <span class="title">isAlienSorted</span>(<span class="params">self, words: <span class="type">List</span>[<span class="built_in">str</span>], order: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">     d = &#123;&#125;</span><br><span class="line">     <span class="keyword">for</span> i, c <span class="keyword">in</span> <span class="built_in">enumerate</span>(order):</span><br><span class="line">         d[c] = i</span><br><span class="line"></span><br><span class="line">     <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(words)):</span><br><span class="line">         <span class="comment">#flag = 1 here means inner loop is break out due to pre less than cur</span></span><br><span class="line"><span class="comment">#flag = 0 here means inner loop done iteration but two strings length are not equal</span></span><br><span class="line">         pre, cur, flag = words[i-<span class="number">1</span>], words[i], <span class="number">0</span></span><br><span class="line">         <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">min</span>(<span class="built_in">len</span>(pre),<span class="built_in">len</span>(cur))):</span><br><span class="line">             <span class="keyword">if</span> d[pre[j]] &lt; d[cur[j]]:</span><br><span class="line">                 flag = <span class="number">1</span></span><br><span class="line">                 <span class="keyword">break</span></span><br><span class="line">             <span class="keyword">elif</span> d[pre[j]] &gt; d[cur[j]]:</span><br><span class="line">                 <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">         <span class="keyword">if</span> <span class="keyword">not</span> flag <span class="keyword">and</span> <span class="built_in">len</span>(pre) &gt; <span class="built_in">len</span>(cur): </span><br><span class="line">             <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">     <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>65. Valid Number</summary>
> 
<p>Run time: $O(n)$, space: $O(1)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isNumber</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">    seen_digit = seen_exponent = seen_dot =  <span class="literal">False</span></span><br><span class="line">    <span class="keyword">for</span> i, c <span class="keyword">in</span> <span class="built_in">enumerate</span>(s):</span><br><span class="line">        <span class="keyword">if</span> c.isdigit():</span><br><span class="line">            seen_digit = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">elif</span> c <span class="keyword">in</span> <span class="string">&quot;+-&quot;</span>:</span><br><span class="line">            <span class="keyword">if</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> s[i - <span class="number">1</span>] != <span class="string">&quot;e&quot;</span> <span class="keyword">and</span> s[i - <span class="number">1</span>] != <span class="string">&quot;E&quot;</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">elif</span> c <span class="keyword">in</span> <span class="string">&quot;Ee&quot;</span>:</span><br><span class="line">            <span class="keyword">if</span> seen_exponent <span class="keyword">or</span> <span class="keyword">not</span> seen_digit:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            seen_exponent = <span class="literal">True</span></span><br><span class="line">            seen_digit = <span class="literal">False</span></span><br><span class="line">        <span class="keyword">elif</span> c == <span class="string">&quot;.&quot;</span>:</span><br><span class="line">            <span class="keyword">if</span> seen_dot <span class="keyword">or</span> seen_exponent:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            seen_dot = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> seen_digit</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Deterministic Finite Automaton (DFA). Initialize the DFA as an array of hash tables. Each hash tableâ€™s keys will be a character group, and the values will be the state it should transition to. We can use the indexes of the array to handle state transitions. Set the currentState = 0.<br>
Iterate through the input. For each character, first determine what group it belongs to. Then, check if that group exists in the current stateâ€™s hash table. If it does, transition to the next state. Otherwise, return false.<br>
At the end, check if we are currently in a valid end state: 1, 4, or 7.</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isNumber</span>(<span class="params">self, s</span>):</span></span><br><span class="line">        <span class="comment"># This is the DFA we have designed above</span></span><br><span class="line">        dfa = [</span><br><span class="line">            &#123;<span class="string">&quot;digit&quot;</span>: <span class="number">1</span>, <span class="string">&quot;sign&quot;</span>: <span class="number">2</span>, <span class="string">&quot;dot&quot;</span>: <span class="number">3</span>&#125;,</span><br><span class="line">            &#123;<span class="string">&quot;digit&quot;</span>: <span class="number">1</span>, <span class="string">&quot;dot&quot;</span>: <span class="number">4</span>, <span class="string">&quot;exponent&quot;</span>: <span class="number">5</span>&#125;,</span><br><span class="line">            &#123;<span class="string">&quot;digit&quot;</span>: <span class="number">1</span>, <span class="string">&quot;dot&quot;</span>: <span class="number">3</span>&#125;,</span><br><span class="line">            &#123;<span class="string">&quot;digit&quot;</span>: <span class="number">4</span>&#125;,</span><br><span class="line">            &#123;<span class="string">&quot;digit&quot;</span>: <span class="number">4</span>, <span class="string">&quot;exponent&quot;</span>: <span class="number">5</span>&#125;,</span><br><span class="line">            &#123;<span class="string">&quot;sign&quot;</span>: <span class="number">6</span>, <span class="string">&quot;digit&quot;</span>: <span class="number">7</span>&#125;,</span><br><span class="line">            &#123;<span class="string">&quot;digit&quot;</span>: <span class="number">7</span>&#125;,</span><br><span class="line">            &#123;<span class="string">&quot;digit&quot;</span>: <span class="number">7</span>&#125;</span><br><span class="line">        ]</span><br><span class="line">        </span><br><span class="line">        current_state = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> c.isdigit():</span><br><span class="line">                group = <span class="string">&quot;digit&quot;</span></span><br><span class="line">            <span class="keyword">elif</span> c <span class="keyword">in</span> [<span class="string">&quot;+&quot;</span>, <span class="string">&quot;-&quot;</span>]:</span><br><span class="line">                group = <span class="string">&quot;sign&quot;</span></span><br><span class="line">            <span class="keyword">elif</span> c <span class="keyword">in</span> [<span class="string">&quot;e&quot;</span>, <span class="string">&quot;E&quot;</span>]:</span><br><span class="line">                group = <span class="string">&quot;exponent&quot;</span></span><br><span class="line">            <span class="keyword">elif</span> c == <span class="string">&quot;.&quot;</span>:</span><br><span class="line">                group = <span class="string">&quot;dot&quot;</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> group <span class="keyword">not</span> <span class="keyword">in</span> dfa[current_state]:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            </span><br><span class="line">            current_state = dfa[current_state][group]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> current_state <span class="keyword">in</span> [<span class="number">1</span>, <span class="number">4</span>, <span class="number">7</span>]</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>5. Longest Palindromic Substring</summary>
<blockquote>
<p>Helper function that gets the start and end indices. Then use max function and set key=lambda x: x[1] - x[0]).</p>
</blockquote>
<p>Run time: $O(n)$, space: $O(1)$ or $O(n)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">longestPalindrome</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">f</span>(<span class="params">i, j</span>):</span></span><br><span class="line">        <span class="keyword">while</span> i &gt;= <span class="number">0</span> <span class="keyword">and</span> j &lt; <span class="built_in">len</span>(s) <span class="keyword">and</span> s[i] == s[j]:</span><br><span class="line">            i -= <span class="number">1</span></span><br><span class="line">            j += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> i, j</span><br><span class="line">    </span><br><span class="line">    i = j = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)):</span><br><span class="line">        i, j = <span class="built_in">max</span>((i, j), f(k, k), f(k, k+<span class="number">1</span>), key=<span class="keyword">lambda</span> x: x[<span class="number">1</span>] - x[<span class="number">0</span>])</span><br><span class="line">    <span class="keyword">return</span> s[i+<span class="number">1</span>:j] </span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">longestPalindrome</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span>(<span class="params">s, start, end</span>):</span></span><br><span class="line">        <span class="keyword">while</span> start &gt;= <span class="number">0</span> <span class="keyword">and</span> end &lt; <span class="built_in">len</span>(s) <span class="keyword">and</span> s[start] == s[end]:</span><br><span class="line">            start -= <span class="number">1</span></span><br><span class="line">            end += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> s[start+<span class="number">1</span>:end]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> s:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span></span><br><span class="line">    longest = <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)):</span><br><span class="line">        curr_substr1 = helper(s, i, i)</span><br><span class="line">        curr_substr2 = helper(s, i, i+<span class="number">1</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(curr_substr1) &gt; <span class="built_in">len</span>(longest):</span><br><span class="line">            longest = curr_substr1</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(curr_substr2) &gt; <span class="built_in">len</span>(longest):</span><br><span class="line">            longest = curr_substr2</span><br><span class="line">    <span class="keyword">return</span> longest</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>3. Longest Substring Without Repeating Characters</summary>
<blockquote>
<p>Sliding window. We use a dictionary to store the character as the key, the last appear index has been seen so far as value. seen[charactor] = index<br>
Move the pointer when you met a repeated character in your window.</p>
</blockquote>
<p>Run time: $O(n)$, space: $O(m)$, where $n$ is the length of the input string, $m$ is the number of unique characters of the input.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lengthOfLongestSubstring</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">    used = &#123;&#125;</span><br><span class="line">    max_length = start = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i, c <span class="keyword">in</span> <span class="built_in">enumerate</span>(s):</span><br><span class="line">        <span class="keyword">if</span> c <span class="keyword">in</span> used <span class="keyword">and</span> start &lt;= used[c]:</span><br><span class="line">            start = used[c] + <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            max_length = <span class="built_in">max</span>(max_length, i - start + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        used[c] = i</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> max_length</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Brute force.</p>
</blockquote>
<p>Run time: $O(n^2)$, space: $O(min(m,n))$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lengthOfLongestSubstring</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> s:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    count = <span class="number">1</span></span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> i &lt; <span class="built_in">len</span>(s):</span><br><span class="line">        seen = <span class="built_in">set</span>()</span><br><span class="line">        seen.add(s[i])</span><br><span class="line">        j = i+<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> j &lt; <span class="built_in">len</span>(s) <span class="keyword">and</span> s[j] <span class="keyword">not</span> <span class="keyword">in</span> seen:</span><br><span class="line">            seen.add(s[j])</span><br><span class="line">            j += <span class="number">1</span></span><br><span class="line">        count = <span class="built_in">max</span>(count, j-i)</span><br><span class="line">        i = j</span><br><span class="line">    <span class="keyword">return</span> count</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>647. Palindromic Substrings</summary>
> There are 2N-1 possible centers for the palindrome: we could have a center at S[0], between S[0] and S[1], at S[1], between S[1] and S[2], at S[2], etc.
<p>Run time: $O(n)$, space: $O(1)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">countSubstrings</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> s:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    n = <span class="built_in">len</span>(s)</span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>*n-<span class="number">1</span>):</span><br><span class="line">        left = i//<span class="number">2</span></span><br><span class="line">        right = (i+<span class="number">1</span>)//<span class="number">2</span></span><br><span class="line">        <span class="keyword">while</span> left &gt;= <span class="number">0</span> <span class="keyword">and</span> right &lt; n <span class="keyword">and</span> s[left] == s[right]:</span><br><span class="line">            left -= <span class="number">1</span></span><br><span class="line">            right += <span class="number">1</span></span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> count</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Intuitive solution.</p>
</blockquote>
<p>Run time: $O(n^2)$, space: $O(1)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">countSubstrings</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span>(<span class="params">s, i</span>):</span></span><br><span class="line">        <span class="keyword">if</span> i &lt; <span class="number">0</span> <span class="keyword">or</span> i &gt;= <span class="built_in">len</span>(s):</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        count = <span class="number">1</span></span><br><span class="line">        left,right = i-<span class="number">1</span>,i+<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> left &gt;=<span class="number">0</span> <span class="keyword">and</span> right &lt; <span class="built_in">len</span>(s):</span><br><span class="line">            <span class="keyword">if</span> s[left] == s[right]:</span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">            left, right = left-<span class="number">1</span>, right+<span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> i+<span class="number">1</span> &lt; <span class="built_in">len</span>(s) <span class="keyword">and</span> s[i] == s[i+<span class="number">1</span>]:</span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line">            left,right = i-<span class="number">1</span>,i+<span class="number">2</span></span><br><span class="line">            <span class="keyword">while</span> left &gt;=<span class="number">0</span> <span class="keyword">and</span> right &lt; <span class="built_in">len</span>(s):</span><br><span class="line">                <span class="keyword">if</span> s[left] == s[right]:</span><br><span class="line">                    count += <span class="number">1</span></span><br><span class="line">                left, right = left-<span class="number">1</span>, right+<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> count</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> s:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    ans = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)):</span><br><span class="line">        ans += helper(s, i)</span><br><span class="line">    <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>415. Add Strings</summary>
> use `chr()` to convert integer to character. `ord()` converts a charactor to integer.
<p>Run time: $O(max(two strings))$, space: $O(max(two strings))$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">addStrings</span>(<span class="params">self, num1, num2</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    :type num1: str</span></span><br><span class="line"><span class="string">    :type num2: str</span></span><br><span class="line"><span class="string">    :rtype: str</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    ans = []</span><br><span class="line">    i1, i2 = <span class="built_in">len</span>(num1)-<span class="number">1</span>, <span class="built_in">len</span>(num2)-<span class="number">1</span></span><br><span class="line">    carry = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> i1 &gt;= <span class="number">0</span> <span class="keyword">or</span> i2 &gt;= <span class="number">0</span> <span class="keyword">or</span> carry &gt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">if</span> i1 &gt;= <span class="number">0</span>:</span><br><span class="line">            carry += <span class="built_in">ord</span>(num1[i1]) - <span class="built_in">ord</span>(<span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">            i1 -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> i2 &gt;= <span class="number">0</span>:</span><br><span class="line">            carry += <span class="built_in">ord</span>(num2[i2]) - <span class="built_in">ord</span>(<span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">            i2 -= <span class="number">1</span></span><br><span class="line">        ans.append(<span class="built_in">chr</span>(carry % <span class="number">10</span> + <span class="built_in">ord</span>(<span class="string">&#x27;0&#x27;</span>)))</span><br><span class="line">        carry //= <span class="number">10</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&quot;</span>.join(ans)[::-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<details>
<summary>My approach</summary>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">addStrings</span>(<span class="params">self, num1, num2</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    :type num1: str</span></span><br><span class="line"><span class="string">    :type num2: str</span></span><br><span class="line"><span class="string">    :rtype: str</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    ans = <span class="number">0</span></span><br><span class="line">    digit = <span class="number">0</span></span><br><span class="line">    i, j = <span class="built_in">len</span>(num1)-<span class="number">1</span>, <span class="built_in">len</span>(num2)-<span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> i &gt;= <span class="number">0</span> <span class="keyword">and</span> j &gt;= <span class="number">0</span>:</span><br><span class="line">        d1 = <span class="built_in">int</span>(num1[i])</span><br><span class="line">        d2 = <span class="built_in">int</span>(num2[j])</span><br><span class="line">        temp_sum = d1+d2</span><br><span class="line">        temp = <span class="number">10</span>**digit * (temp_sum % <span class="number">10</span>) + <span class="number">10</span>**(digit+<span class="number">1</span>) *(temp_sum//<span class="number">10</span>)</span><br><span class="line">        ans += temp</span><br><span class="line">        digit += <span class="number">1</span></span><br><span class="line">        i, j = i-<span class="number">1</span>, j-<span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> i &lt; <span class="number">0</span> <span class="keyword">and</span> j &lt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">str</span>(ans)</span><br><span class="line">    <span class="keyword">elif</span> i &lt; <span class="number">0</span>:</span><br><span class="line">        ans += (<span class="number">10</span>**digit) * <span class="built_in">int</span>(num2[:j+<span class="number">1</span>])</span><br><span class="line">    <span class="keyword">elif</span> j &lt; <span class="number">0</span>:</span><br><span class="line">        ans += (<span class="number">10</span>**digit) * <span class="built_in">int</span>(num1[:i+<span class="number">1</span>])</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">str</span>(ans)</span><br></pre></td></tr></table></figure>
</details>
</details>
<details>
<summary>68. Text Justification</summary>
> Use one list for final output, one list for current line, one variable to keep track of current character count. Since the current length also represents the minimum space added between words, if the length of current line, plus current character count, plus current word length exceeds `maxWidth`, then we should not add this word, and need to add more space to make the words on the current line distributed evenly. 
Therefore, we loop from 0 to `maxWidth-char_count`, which is the number of space to be added on this line, then we take modulo. For example, if there are three words on this line, and we need to add 5 space. We first get 0%(3-1), which is 0. Then we calculate 1%(3-1), which is 1. Then we calculate 2%(3-1), which is 0. Then we calculate 3%(3-1), which is 1. Then we calculate 4%(3-1), which is 0. 
<p>Run time: $O(n)$, space: $O(n)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fullJustify</span>(<span class="params">self, words, maxWidth</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    :type words: List[str]</span></span><br><span class="line"><span class="string">    :type maxWidth: int</span></span><br><span class="line"><span class="string">    :rtype: List[str]</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    ans = []</span><br><span class="line">    cur = []</span><br><span class="line">    char_count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> w <span class="keyword">in</span> words:</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(cur) + char_count + <span class="built_in">len</span>(w) &gt; maxWidth:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(maxWidth - char_count):</span><br><span class="line">                cur[i % (<span class="built_in">len</span>(cur)-<span class="number">1</span> <span class="keyword">or</span> <span class="number">1</span>)] += <span class="string">&#x27; &#x27;</span></span><br><span class="line">            ans.append(<span class="string">&#x27;&#x27;</span>.join(cur))</span><br><span class="line">            cur = []</span><br><span class="line">            char_count = <span class="number">0</span></span><br><span class="line">        cur += [w]</span><br><span class="line">        char_count += <span class="built_in">len</span>(w)</span><br><span class="line">    <span class="comment"># form last line by join with space and left justify to maxWidth using ljust (python method)</span></span><br><span class="line">    <span class="comment"># that means pad additional spaces to the right to make string length equal to maxWidth</span></span><br><span class="line">    <span class="keyword">return</span> ans + [<span class="string">&#x27; &#x27;</span>.join(cur).ljust(maxWidth)]</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>408. Valid Word Abbreviation</summary>
> Use two pointers, one for index in the word, one for the abbr.
<p>Run time: $O(n)$, space: $O(1)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">validWordAbbreviation</span>(<span class="params">self, word, abbr</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    :type word: str</span></span><br><span class="line"><span class="string">    :type abbr: str</span></span><br><span class="line"><span class="string">    :rtype: bool</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    i = j = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> i &lt; <span class="built_in">len</span>(word) <span class="keyword">and</span> j &lt; <span class="built_in">len</span>(abbr):</span><br><span class="line">        <span class="keyword">if</span> word[i] == abbr[j]:</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">            j += <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> abbr[j] == <span class="string">&quot;0&quot;</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">elif</span> abbr[j].isdigit():</span><br><span class="line">            k = j+<span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> k &lt; <span class="built_in">len</span>(abbr) <span class="keyword">and</span> abbr[k].isdigit():</span><br><span class="line">                k += <span class="number">1</span></span><br><span class="line">            i += <span class="built_in">int</span>(abbr[j:k])</span><br><span class="line">            j = k</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> i == <span class="built_in">len</span>(word) <span class="keyword">and</span> j == <span class="built_in">len</span>(abbr)</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>921. Minimum Add to Make Parentheses Valid</summary>
> Maintain a count of current ungrouped parentheses, and a count of parentheses needed to be inserted. If we see a (, increment the count, otherwise decrement the count if it is greater than 0, or increment the final count.
<p>Run time: $O(n)$, space: $O(1)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">minAddToMakeValid</span>(<span class="params">self, s</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    :type s: str</span></span><br><span class="line"><span class="string">    :rtype: int</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    ans = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> c <span class="keyword">in</span> s:</span><br><span class="line">        <span class="keyword">if</span> c == <span class="string">&#x27;(&#x27;</span>:</span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> count == <span class="number">0</span>:</span><br><span class="line">            ans += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            count -= <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> ans + count</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>1249. Minimum Remove to Make Valid Parentheses</summary>
> Use stack to store "(" only, and when encounter ")" and stack is empty, record this index. If stack is not empy, then pop one "(". In the end union the stack and the list and skip these indices when building the final string.
<p>Run time: $O(n)$, space: $O(n)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">minRemoveToMakeValid</span>(<span class="params">self, s</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    :type s: str</span></span><br><span class="line"><span class="string">    :rtype: str</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">remove_invalid</span>(<span class="params">s, good, bad</span>):</span></span><br><span class="line">        sb = []</span><br><span class="line">        bal = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> c == good:</span><br><span class="line">                bal += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> c == bad:</span><br><span class="line">                <span class="keyword">if</span> bal == <span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                bal -= <span class="number">1</span></span><br><span class="line">            sb.append(c)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>.join(sb)</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    s = remove_invalid(s, <span class="string">&quot;(&quot;</span>, <span class="string">&quot;)&quot;</span>)    </span><br><span class="line">    s = remove_invalid(s[::-<span class="number">1</span>], <span class="string">&quot;)&quot;</span>, <span class="string">&quot;(&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> s[::-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">minRemoveToMakeValid</span>(<span class="params">self, s</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    :type s: str</span></span><br><span class="line"><span class="string">    :rtype: str</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    ind_remove = <span class="built_in">set</span>()</span><br><span class="line">    stack = []</span><br><span class="line">    <span class="keyword">for</span> i, c <span class="keyword">in</span> <span class="built_in">enumerate</span>(s):</span><br><span class="line">        <span class="keyword">if</span> c <span class="keyword">not</span> <span class="keyword">in</span> <span class="string">&quot;()&quot;</span>:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">if</span> c == <span class="string">&quot;(&quot;</span>: <span class="comment"># add ( to stack</span></span><br><span class="line">            stack.append(i)</span><br><span class="line">        <span class="keyword">elif</span> <span class="keyword">not</span> stack: <span class="comment"># ) and stack empty, need to remove</span></span><br><span class="line">            ind_remove.add(i)</span><br><span class="line">        <span class="keyword">else</span>: <span class="comment"># ) and stack not empty, pop one</span></span><br><span class="line">            stack.pop()</span><br><span class="line">        </span><br><span class="line">    ind_remove = ind_remove.union(<span class="built_in">set</span>(stack))</span><br><span class="line">    sb = []</span><br><span class="line">    <span class="keyword">for</span> i, c <span class="keyword">in</span> <span class="built_in">enumerate</span>(s):</span><br><span class="line">        <span class="keyword">if</span> i <span class="keyword">not</span> <span class="keyword">in</span> ind_remove:</span><br><span class="line">            sb.append(c)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&quot;</span>.join(sb)</span><br></pre></td></tr></table></figure>
</details>
<h1>Recursion / Math</h1>
<details>
<summary></summary>
> 
<p>Run time: $O()$, space: $O()$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>670. Maximum Swap</summary>
<blockquote>
<p>Iterate the list of digits backwards and keep tracking of the max digit, as well as the digit that is smaller than the max.<br>
<a target="_blank" rel="noopener" href="https://leetcode.com/problems/maximum-swap/discuss/1593049/Python-simple-1-pass-solution">https://leetcode.com/problems/maximum-swap/discuss/1593049/Python-simple-1-pass-solution</a></p>
</blockquote>
<p>Run time: $O(n)$, space: $O(1)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">maximumSwap</span>(<span class="params">self, num: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">    digits = <span class="built_in">list</span>(<span class="built_in">str</span>(num))</span><br><span class="line">    min_ind, max_ind, max_i = -<span class="number">1</span>, -<span class="number">1</span>, <span class="built_in">len</span>(digits)-<span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(max_i-<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">if</span> digits[i] &gt; digits[max_i]:</span><br><span class="line">            max_i = i</span><br><span class="line">        <span class="keyword">elif</span> digits[i] &lt; digits[max_i]:</span><br><span class="line">            min_ind, max_ind = i, max_i</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> min_ind &gt; -<span class="number">1</span>:</span><br><span class="line">        digits[min_ind], digits[max_ind] = digits[max_ind], digits[min_ind]</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">int</span>(<span class="string">&#x27;&#x27;</span>.join(digits))</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>48. Rotate Image</summary>
> rotate the image by 90 degrees (clockwise) is equivalent to transpose + reflection.
<p>Run time: $O(mn)$, space: $O(1)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rotate</span>(<span class="params">self, matrix: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Do not return anything, modify matrix in-place instead.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">transpose</span>(<span class="params">ma</span>):</span></span><br><span class="line">        n = <span class="built_in">len</span>(ma)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i+<span class="number">1</span>, n):</span><br><span class="line">                ma[j][i], ma[i][j] = ma[i][j], ma[j][i]</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reflect</span>(<span class="params">ma</span>):</span></span><br><span class="line">        n = <span class="built_in">len</span>(ma)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n//<span class="number">2</span>):</span><br><span class="line">                ma[i][j], ma[i][-j-<span class="number">1</span>] = ma[i][-j-<span class="number">1</span>], ma[i][j]</span><br><span class="line"></span><br><span class="line">    transpose(matrix)</span><br><span class="line">    reflect(matrix)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Directly rotate. ~ means invert, ~j = -j-1</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rotate</span>(<span class="params">self, matrix: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Do not return anything, modify matrix in-place instead.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    n = <span class="built_in">len</span>(matrix)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n//<span class="number">2</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n - n//<span class="number">2</span>):</span><br><span class="line">            matrix[i][j], matrix[~j][i], matrix[~i][~j], matrix[j][~i] = \</span><br><span class="line">                     matrix[~j][i], matrix[~i][~j], matrix[j][~i], matrix[i][j]</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>268. Missing Number</summary>
<blockquote>
<p>Gaussâ€™ Formula. Compute expected sum and actual sum, the difference is the missing number.</p>
</blockquote>
<p>Run time: $O(n)$, space: $O(1)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">missingNumber</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">    n = <span class="built_in">len</span>(nums)</span><br><span class="line">    expected = n*(n+<span class="number">1</span>) // <span class="number">2</span></span><br><span class="line">    actual = <span class="built_in">sum</span>(nums)</span><br><span class="line">    <span class="keyword">return</span> expected-actual</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Bit Manipulation.<br>
Intuition<br>
We can harness the fact that XOR is its own inverse to find the missing element in linear time.</p>
</blockquote>
<p>Algorithm<br>
Because we know that nums contains nn numbers and that it is missing exactly one number on the range [0â€¦n-1][0â€¦nâˆ’1], we know that nn definitely replaces the missing number in nums. Therefore, if we initialize an integer to nn and XOR it with every index and value, we will be left with the missing number. Consider the following example (the values have been sorted for intuitive convenience, but need not be):</p>
<p>Run time: $O(n)$, space: $O(1)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">missingNumber</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">    missing = <span class="built_in">len</span>(nums)</span><br><span class="line">    <span class="keyword">for</span> i, num <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums):</span><br><span class="line">        missing ^= i ^ num</span><br><span class="line">    <span class="keyword">return</span> missing</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Initialize a set using the input array. Loop through the length of array + 1, if not in set, return this number.</p>
</blockquote>
<p>Run time: $O(n)$, space: $O(n)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">missingNumber</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">    num_set = <span class="built_in">set</span>(nums)</span><br><span class="line">    n = <span class="built_in">len</span>(nums) + <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> number <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        <span class="keyword">if</span> number <span class="keyword">not</span> <span class="keyword">in</span> num_set:</span><br><span class="line">            <span class="keyword">return</span> number</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>238. Product of Array Except Self</summary>
> The output array does not count toward the space complexity. Use original output array to find the cumulative sum from left, then use one variable to keep track of the cumulative sum from right, and multiply it to the output array.
<p>Run time: $O(n)$, space: $O(1)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">productExceptSelf</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span></span><br><span class="line">    n = <span class="built_in">len</span>(nums)</span><br><span class="line">    ans = [<span class="number">1</span>] * n</span><br><span class="line">    right = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n): <span class="comment"># cumulative sum from left</span></span><br><span class="line">        ans[i] = ans[i-<span class="number">1</span>]*nums[i-<span class="number">1</span>]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n-<span class="number">2</span>,-<span class="number">1</span>,-<span class="number">1</span>): <span class="comment"># cumulative sum from right</span></span><br><span class="line">        right *= nums[i+<span class="number">1</span>]</span><br><span class="line">        ans[i] *= right</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">productExceptSelf</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span></span><br><span class="line">    n = <span class="built_in">len</span>(nums)</span><br><span class="line">    left, right = <span class="number">1</span>, <span class="number">1</span></span><br><span class="line">    ans = [<span class="number">1</span>]*n</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n):</span><br><span class="line">        left *= nums[i-<span class="number">1</span>]</span><br><span class="line">        ans[i] = left</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n-<span class="number">2</span>,-<span class="number">1</span>,-<span class="number">1</span>):</span><br><span class="line">        right *= nums[i+<span class="number">1</span>]</span><br><span class="line">        ans[i] *= right</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<blockquote>
<p>One array to track the cumulative sum from left, one array to track the cumulative sum from right. In the end, multiply them together on the same index.</p>
</blockquote>
<p>Run time: $O(n)$, space: $O(n)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">productExceptSelf</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span></span><br><span class="line">    n = <span class="built_in">len</span>(nums)</span><br><span class="line">    left, right = [<span class="number">1</span>]*n, [<span class="number">1</span>]*n</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n):</span><br><span class="line">        left[i] = nums[i-<span class="number">1</span>] * left[i-<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n-<span class="number">2</span>,-<span class="number">1</span>,-<span class="number">1</span>):</span><br><span class="line">        right[i] = nums[i+<span class="number">1</span>] * right[i+<span class="number">1</span>]</span><br><span class="line">    <span class="built_in">print</span>(left, right)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        left[i] *= right[i]</span><br><span class="line">    <span class="keyword">return</span> left</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>67. Add Binary</summary>
<blockquote>
<p>XOR: ^, AND: &amp;, left-shifted: &lt;&lt;</p>
</blockquote>
<p>Run time: $O(m+n)$, space: $O(max(m,n))$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">addBinary</span>(<span class="params">self, a: <span class="built_in">str</span>, b: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span></span><br><span class="line">    x, y = <span class="built_in">int</span>(a,<span class="number">2</span>), <span class="built_in">int</span>(b,<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">while</span> y:</span><br><span class="line">        ans = x ^ y</span><br><span class="line">        carry = (x &amp; y) &lt;&lt; <span class="number">1</span></span><br><span class="line">        x, y = ans, carry</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">bin</span>(x)[<span class="number">2</span>:]</span><br></pre></td></tr></table></figure>
<blockquote>
<p>two pointers, and one carry</p>
</blockquote>
<p>Run time: $O(max(m,n))$, space: $O(max(m,n))$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">addBinary</span>(<span class="params">self, a: <span class="built_in">str</span>, b: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span></span><br><span class="line">    ans = <span class="string">&quot;&quot;</span></span><br><span class="line">    i,j = <span class="built_in">len</span>(a)-<span class="number">1</span>, <span class="built_in">len</span>(b)-<span class="number">1</span></span><br><span class="line">    carry = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> i&gt;= <span class="number">0</span> <span class="keyword">or</span> j&gt;=<span class="number">0</span> <span class="keyword">or</span> carry&gt;<span class="number">0</span>:</span><br><span class="line">        <span class="keyword">if</span> i&gt;=<span class="number">0</span>:</span><br><span class="line">            carry += <span class="built_in">int</span>(a[i])</span><br><span class="line">        <span class="keyword">if</span> j&gt;=<span class="number">0</span>:</span><br><span class="line">            carry += <span class="built_in">int</span>(b[j])</span><br><span class="line">        <span class="keyword">if</span> carry == <span class="number">3</span>:</span><br><span class="line">            ans += <span class="string">&quot;1&quot;</span></span><br><span class="line">            carry = <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> carry == <span class="number">2</span>:</span><br><span class="line">            ans += <span class="string">&quot;0&quot;</span></span><br><span class="line">            carry = <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> carry == <span class="number">1</span>:</span><br><span class="line">            ans += <span class="string">&quot;1&quot;</span></span><br><span class="line">            carry = <span class="number">0</span></span><br><span class="line">        i,j = i-<span class="number">1</span>,j-<span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> ans[::-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
</details>
</details>
<details>
<summary>69. Sqrt(x)</summary>
<blockquote>
<p>Newton method. $x_{n+1} = x_n - \frac{f(x_n)}{fâ€™(x_n)}$, where $f(x) = x^2-a = 0$.</p>
</blockquote>
<p>Run time: $O(\log n)$, space: $O(1)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mySqrt</span>(<span class="params">self, x</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    :type x: int</span></span><br><span class="line"><span class="string">    :rtype: int</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    a = x</span><br><span class="line">    <span class="keyword">while</span> a**<span class="number">2</span> &gt; x:</span><br><span class="line">        a = (a + x/a)//<span class="number">2</span></span><br><span class="line">    <span class="keyword">return</span> a</span><br></pre></td></tr></table></figure>
<blockquote>
<p>binary search.</p>
</blockquote>
<p>Run time: $O(\log n)$, space: $O(1)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mySqrt</span>(<span class="params">self, x</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    :type x: int</span></span><br><span class="line"><span class="string">    :rtype: int</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> x == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    lo, hi = <span class="number">1</span>, x</span><br><span class="line">    <span class="keyword">while</span> lo &lt;= hi:</span><br><span class="line">        mid = lo + (hi-lo)//<span class="number">2</span></span><br><span class="line">        sqrt = x // mid</span><br><span class="line">        <span class="keyword">if</span> sqrt == mid:</span><br><span class="line">            <span class="keyword">return</span> mid</span><br><span class="line">        <span class="keyword">elif</span> sqrt &lt; mid:</span><br><span class="line">            hi = mid-<span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            lo = mid +<span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> hi</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>50. Pow(x, n)</summary>
<blockquote>
<p>First check if power is 0, and check if power is negative. If so, flip the sign of the power and return the reciprocal. Then calculate the half of the power, and if the original power is odd, multiply by one more <code>x</code>.</p>
</blockquote>
<p>Run time: $O(\log n)$, space: $O(1)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">myPow</span>(<span class="params">self, x, n</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    :type x: float</span></span><br><span class="line"><span class="string">    :type n: int</span></span><br><span class="line"><span class="string">    :rtype: float</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span>: <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> n &lt; <span class="number">0</span>: <span class="keyword">return</span> <span class="number">1.0</span> / self.myPow(x, -n)</span><br><span class="line">    half = self.myPow(x, n // <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">if</span> n % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> half * half</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> half * half * x</span><br></pre></td></tr></table></figure>
</details>
  </div>
</article>



        
          <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/about/">About</a></li>
         
          <li><a href="/archives/">Posts</a></li>
         
          <li><a href="/projects/">Projects</a></li>
         
          <li><a href="/life/">Life</a></li>
        
      </ul>
    </div>

    <div id="toc-footer" style="display: none">
      <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">1.</span> <span class="toc-text">Binary Search, Sorting</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Sorting"><span class="toc-number">1.1.</span> <span class="toc-text">Sorting</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Topological-Sort"><span class="toc-number">1.1.1.</span> <span class="toc-text">Topological Sort</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Other"><span class="toc-number">1.1.2.</span> <span class="toc-text">Other</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Sweep-Line-Deque-Advanced-BS"><span class="toc-number">1.2.</span> <span class="toc-text">Sweep Line, Deque, Advanced BS</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">2.</span> <span class="toc-text">BFS</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">3.</span> <span class="toc-text">DFS</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Backtracking"><span class="toc-number">3.1.</span> <span class="toc-text">Backtracking</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">4.</span> <span class="toc-text">Linked List &amp; Array</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">5.</span> <span class="toc-text">Stack</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">6.</span> <span class="toc-text">2 Pointers</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">7.</span> <span class="toc-text">Hash &amp; Heap</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Advanced-Hash-Heap"><span class="toc-number">7.1.</span> <span class="toc-text">Advanced Hash&#x2F;Heap</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">8.</span> <span class="toc-text">Union Find</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">9.</span> <span class="toc-text">DP</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">10.</span> <span class="toc-text">DP coord + connected</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#DP-sliding-array-memory-search"><span class="toc-number">10.1.</span> <span class="toc-text">DP sliding array + memory search</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DP-interval-backpack"><span class="toc-number">10.2.</span> <span class="toc-text">DP interval + backpack</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">11.</span> <span class="toc-text">Tree</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Binary-Tree-Divide-Conquer"><span class="toc-number">11.1.</span> <span class="toc-text">Binary Tree &#x2F; Divide &amp; Conquer</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Trie"><span class="toc-number">11.2.</span> <span class="toc-text">Trie</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Segment-Tree"><span class="toc-number">11.3.</span> <span class="toc-text">Segment Tree</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">12.</span> <span class="toc-text">String</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">13.</span> <span class="toc-text">Recursion &#x2F; Math</span></a></li></ol>
    </div>

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=http://yu24l.github.io/lc-summary-python/"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=http://yu24l.github.io/lc-summary-python/&text=(Python) LeetCode Summary"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=http://yu24l.github.io/lc-summary-python/&title=(Python) LeetCode Summary"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=http://yu24l.github.io/lc-summary-python/&is_video=false&description=(Python) LeetCode Summary"><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=(Python) LeetCode Summary&body=Check out this article: http://yu24l.github.io/lc-summary-python/"><i class="fas fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=http://yu24l.github.io/lc-summary-python/&title=(Python) LeetCode Summary"><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=http://yu24l.github.io/lc-summary-python/&title=(Python) LeetCode Summary"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=http://yu24l.github.io/lc-summary-python/&title=(Python) LeetCode Summary"><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=http://yu24l.github.io/lc-summary-python/&title=(Python) LeetCode Summary"><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=http://yu24l.github.io/lc-summary-python/&name=(Python) LeetCode Summary&description="><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=http://yu24l.github.io/lc-summary-python/&t=(Python) LeetCode Summary"><i class="fab fa-hacker-news fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fas fa-bars fa-lg" aria-hidden="true"></i> Menu</a>
        <a id="toc" class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fas fa-list fa-lg" aria-hidden="true"></i> TOC</a>
        <a id="share" class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fas fa-share-alt fa-lg" aria-hidden="true"></i> Share</a>
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up fa-lg" aria-hidden="true"></i> Top</a>
    </div>

  </div>
</div>

        
        <footer id="footer">
	<div class="footer-left">
		<link rel="stylesheet" 
		href="https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.css">
		<script src="https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.js"></script>
		<script src="https://cdn.jsdelivr.net/npm/meting@1.2.0/dist/Meting.min.js"></script>
	</div>
	<div class="footer-right">
		Copyright &copy;
		
		
		2019-2022
		Lu Yu
	  <!-- <nav>
		<ul>
		   
			<li><a href="/">Home</a></li>
		   
			<li><a href="/about/">About</a></li>
		   
			<li><a href="/archives/">Posts</a></li>
		   
			<li><a href="/projects/">Projects</a></li>
		   
			<li><a href="/life/">Life</a></li>
		  
		</ul>
	  </nav> -->
	</div>
  </footer>
    </div>
    <!-- styles -->

<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">


<link rel="stylesheet" href="/lib/justified-gallery/css/justifiedGallery.min.css">


    <!-- jquery -->

<script src="/lib/jquery/jquery.min.js"></script>


<script src="/lib/justified-gallery/js/jquery.justifiedGallery.min.js"></script>

<!-- clipboard -->

  
<script src="/lib/clipboard/clipboard.min.js"></script>

  <script type="text/javascript">
  $(function() {
    // copy-btn HTML
    var btn = "<span class=\"btn-copy tooltipped tooltipped-sw\" aria-label=\"Copy to clipboard!\">";
    btn += '<i class="far fa-clone"></i>';
    btn += '</span>'; 
    // mount it!
    $(".highlight table").before(btn);
    var clip = new ClipboardJS('.btn-copy', {
      text: function(trigger) {
        return Array.from(trigger.nextElementSibling.querySelectorAll('.code')).reduce((str,it)=>str+it.innerText+'\n','')
      }
    });
    clip.on('success', function(e) {
      e.trigger.setAttribute('aria-label', "Copied!");
      e.clearSelection();
    })
  })
  </script>


<script src="/js/main.js"></script>

<!-- search -->

<!-- Google Analytics -->

<!-- Baidu Analytics -->

<!-- Umami Analytics -->

<!-- Disqus Comments -->



<!-- <div class="aplayer" 
    data-id="60198"
    data-server="netease"
    data-type="playlist"
    data-fixed="true"	>
</div> -->

<!-- <script src="dist/Meting.min.js"></script> -->
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
</body>
    <!--å¦‚æžœå°†æœ¬ä½“æ”¾åœ¨bodyé‡Œé¢ï¼Œå¯¼è‡´é¡µé¢åŠ è½½å‡ºçŽ°é—®é¢˜ï¼Œè¯·å°è¯•æ”¾åˆ°bodyä½“åŽé¢-->
    <!-- <div class="aplayer" 
    data-id="3778678" 
    data-server="netease" 
    data-type="playlist" 
    data-fixed="true"	
    data-order="random"
    data-volume="0.65"
    data-autoplay="false"   
    date-preload="auto"
    data-theme="#cc543a">
    </div> -->
</html>

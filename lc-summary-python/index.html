<!DOCTYPE html>
<html lang=en>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
    <meta name="description" content="Template:   &gt;  Run time: $O()$, space: $O()$ 1  Binary Search, Sorting   &gt;  Run time: $O()$, space: $O()$ 1   729. My Calendar I  https:&#x2F;&#x2F;leetcode.com&#x2F;problems&#x2F;my-calendar-i&#x2F;discuss&#x2F;109476&#x2F;Binary-Sear">
<meta property="og:type" content="article">
<meta property="og:title" content="(Python) LeetCode Summary">
<meta property="og:url" content="http://yu24l.github.io/lc-summary-python/index.html">
<meta property="og:site_name" content="Lu Yu">
<meta property="og:description" content="Template:   &gt;  Run time: $O()$, space: $O()$ 1  Binary Search, Sorting   &gt;  Run time: $O()$, space: $O()$ 1   729. My Calendar I  https:&#x2F;&#x2F;leetcode.com&#x2F;problems&#x2F;my-calendar-i&#x2F;discuss&#x2F;109476&#x2F;Binary-Sear">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/006y8mN6ly1g743sn90wcj30zk0hsmzr.jpg">
<meta property="article:published_time" content="2021-12-20T15:30:00.000Z">
<meta property="article:modified_time" content="2022-01-25T19:16:11.771Z">
<meta property="article:author" content="Lu Yu">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://tva1.sinaimg.cn/large/006y8mN6ly1g743sn90wcj30zk0hsmzr.jpg">
    
    
      
        
          <link rel="shortcut icon" href="/images/favicon.ico">
        
      
      
        
          <link rel="icon" type="image/png" href="/images/favicon-192x192.png" sizes="192x192">
        
      
      
        
          <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
        
      
    
    <!-- title -->
    <title>(Python) LeetCode Summary</title>
    <!-- styles -->
    
<link rel="stylesheet" href="/css/style.css">

    <!-- persian styles -->
    
      
<link rel="stylesheet" href="/css/rtl.css">

    
    <!-- rss -->
    
    
<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 5.2.0"><link rel="stylesheet" href="/css/prism.css" type="text/css"></head>

<body class="max-width mx-auto px3 ltr">    
      <div id="header-post">
  <a id="menu-icon" href="#"><i class="fas fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#"><i class="fas fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fas fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/about/">About</a></li>
         
          <li><a href="/archives/">Posts</a></li>
         
          <li><a href="/projects/">Projects</a></li>
         
          <li><a href="/life/">Life</a></li>
        
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        <li><a class="icon" href="/python-basics/"><i class="fas fa-chevron-left" aria-hidden="true" onmouseover="$('#i-prev').toggle();" onmouseout="$('#i-prev').toggle();"></i></a></li>
        
        
        <li><a class="icon" href="/leetcode-summary/"><i class="fas fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" href="#"><i class="fas fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">Previous post</span>
      <span id="i-next" class="info" style="display:none;">Next post</span>
      <span id="i-top" class="info" style="display:none;">Back to top</span>
      <span id="i-share" class="info" style="display:none;">Share post</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=http://yu24l.github.io/lc-summary-python/"><i class="fab fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=http://yu24l.github.io/lc-summary-python/&text=(Python) LeetCode Summary"><i class="fab fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=http://yu24l.github.io/lc-summary-python/&title=(Python) LeetCode Summary"><i class="fab fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=http://yu24l.github.io/lc-summary-python/&is_video=false&description=(Python) LeetCode Summary"><i class="fab fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=(Python) LeetCode Summary&body=Check out this article: http://yu24l.github.io/lc-summary-python/"><i class="fas fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=http://yu24l.github.io/lc-summary-python/&title=(Python) LeetCode Summary"><i class="fab fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=http://yu24l.github.io/lc-summary-python/&title=(Python) LeetCode Summary"><i class="fab fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=http://yu24l.github.io/lc-summary-python/&title=(Python) LeetCode Summary"><i class="fab fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=http://yu24l.github.io/lc-summary-python/&title=(Python) LeetCode Summary"><i class="fab fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=http://yu24l.github.io/lc-summary-python/&name=(Python) LeetCode Summary&description="><i class="fab fa-tumblr " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=http://yu24l.github.io/lc-summary-python/&t=(Python) LeetCode Summary"><i class="fab fa-hacker-news " aria-hidden="true"></i></a></li>
</ul>

    </div>
    <div id="toc">
      <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">1.</span> <span class="toc-text">Binary Search, Sorting</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Sorting"><span class="toc-number">1.1.</span> <span class="toc-text">Sorting</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Topological-Sort"><span class="toc-number">1.1.1.</span> <span class="toc-text">Topological Sort</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Other"><span class="toc-number">1.1.2.</span> <span class="toc-text">Other</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Sweep-Line-Deque-Advanced-BS"><span class="toc-number">1.2.</span> <span class="toc-text">Sweep Line, Deque, Advanced BS</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">2.</span> <span class="toc-text">BFS</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">3.</span> <span class="toc-text">DFS</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Backtracking"><span class="toc-number">3.1.</span> <span class="toc-text">Backtracking</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">4.</span> <span class="toc-text">Linked List &amp; Array</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">5.</span> <span class="toc-text">Stack, Queue</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">6.</span> <span class="toc-text">2 Pointers</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">7.</span> <span class="toc-text">Hash &amp; Heap</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Advanced-Hash-Heap"><span class="toc-number">7.1.</span> <span class="toc-text">Advanced Hash&#x2F;Heap</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">8.</span> <span class="toc-text">Union Find</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">9.</span> <span class="toc-text">DP</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">10.</span> <span class="toc-text">DP coord + connected</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#DP-sliding-array-memory-search"><span class="toc-number">10.1.</span> <span class="toc-text">DP sliding array + memory search</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DP-interval-backpack"><span class="toc-number">10.2.</span> <span class="toc-text">DP interval + backpack</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">11.</span> <span class="toc-text">Tree</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Binary-Tree-Divide-Conquer"><span class="toc-number">11.1.</span> <span class="toc-text">Binary Tree &#x2F; Divide &amp; Conquer</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Trie"><span class="toc-number">11.2.</span> <span class="toc-text">Trie</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Segment-Tree"><span class="toc-number">11.3.</span> <span class="toc-text">Segment Tree</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">12.</span> <span class="toc-text">String</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">13.</span> <span class="toc-text">Recursion &#x2F; Math</span></a></li></ol>
    </div>
  </span>
</div>

    
    <div class="content index py4">
        
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle" itemprop="name headline">
        (Python) LeetCode Summary
    </h1>



    <div class="meta">
      <span class="author" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span itemprop="name">Lu Yu</span>
      </span>
      
    <div class="postdate">
      
        <time datetime="2021-12-20T15:30:00.000Z" itemprop="datePublished">2021-12-20</time>
        
      
    </div>


      

      

    </div>
  </header>
  

  <div class="content" itemprop="articleBody">
    <p>Template:</p>
<details>
<summary></summary>
> 
<p>Run time: $O()$, space: $O()$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
</details>
<h1>Binary Search, Sorting</h1>
<details>
<summary></summary>
> 
<p>Run time: $O()$, space: $O()$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>729. My Calendar I</summary>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/my-calendar-i/discuss/109476/Binary-Search-Tree-python">https://leetcode.com/problems/my-calendar-i/discuss/109476/Binary-Search-Tree-python</a></p>
</blockquote>
<p>Run time: $O(\log n)$, space: $O(n)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCalendar</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.ends = []</span><br><span class="line">        self.schedule = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">book</span>(<span class="params">self, start: <span class="built_in">int</span>, end: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        index = bisect.bisect(self.ends, start)</span><br><span class="line">        <span class="keyword">if</span> index == <span class="built_in">len</span>(self.ends): </span><br><span class="line">            self.ends.append(end)</span><br><span class="line">            self.schedule.append((start, end))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">if</span> self.schedule[index][<span class="number">0</span>] &lt; end: <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        self.ends = self.ends[:index] + [end] + self.ends[index:]</span><br><span class="line">        self.schedule = self.schedule[:index] + [(start, end)] + self.schedule[index:]</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCalendar</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.arr = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">book</span>(<span class="params">self, start: <span class="built_in">int</span>, end: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        index = self.bise(start)</span><br><span class="line">        <span class="keyword">if</span> index == <span class="built_in">len</span>(self.arr): </span><br><span class="line">            self.arr.append((start, end))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">if</span> end &gt; self.arr[index][<span class="number">0</span>]: </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        self.arr = self.arr[:index] + [(start, end)] + self.arr[index:]</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">#bisect_right self-implementation search by key= lambda x: x[1]</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">bise</span>(<span class="params">self, val</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.arr: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> val &gt;= self.arr[-<span class="number">1</span>][<span class="number">1</span>]: </span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">len</span>(self.arr)</span><br><span class="line">        l, r = <span class="number">0</span>, <span class="built_in">len</span>(self.arr)-<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> l &lt; r:</span><br><span class="line">            m = (l + r) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> self.arr[m][<span class="number">1</span>] &lt;= val: </span><br><span class="line">                l = m+<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>: </span><br><span class="line">                r = m</span><br><span class="line">        <span class="keyword">return</span> l</span><br><span class="line"></span><br><span class="line"><span class="comment"># Your MyCalendar object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"># obj = MyCalendar()</span></span><br><span class="line"><span class="comment"># param_1 = obj.book(start,end)</span></span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>302. Smallest Rectangle Enclosing Black Pixels</summary>
<blockquote>
<p>top = search row [0…x], find first row contain 1,<br>
bottom = search row[x+1, row], find first row contian all 0<br>
left = search col[0…y], find first col contain 1,<br>
right = search col[y+1, col], find first col contain all 0</p>
</blockquote>
<p>Run time: $O(n\log m+m\log n)$, space: $O(1)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">minArea</span>(<span class="params">self, image: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">str</span>]], x: <span class="built_in">int</span>, y: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">    rows, cols = <span class="built_in">len</span>(image), <span class="built_in">len</span>(image[<span class="number">0</span>])</span><br><span class="line">    </span><br><span class="line">    has_pixel_in_row = <span class="keyword">lambda</span> i : <span class="built_in">any</span>(image[i][j] == <span class="string">&#x27;1&#x27;</span> <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(cols))</span><br><span class="line">    has_pixel_in_col = <span class="keyword">lambda</span> j : <span class="built_in">any</span>(image[i][j] == <span class="string">&#x27;1&#x27;</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(rows))</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">bsearch</span>(<span class="params">left, right, condition</span>):</span></span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            mid = (left + right) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> condition(mid):</span><br><span class="line">                right = mid</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                left = mid + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> left</span><br><span class="line">    </span><br><span class="line">    left = bsearch(<span class="number">0</span>, x+<span class="number">1</span>, <span class="keyword">lambda</span> m : has_pixel_in_row(m))</span><br><span class="line">    right = bsearch(x, rows, <span class="keyword">lambda</span> m : <span class="keyword">not</span> has_pixel_in_row(m))</span><br><span class="line">    bottom = bsearch(<span class="number">0</span>, y+<span class="number">1</span>, <span class="keyword">lambda</span> m : has_pixel_in_col(m))</span><br><span class="line">    up = bsearch(y, cols, <span class="keyword">lambda</span> m : <span class="keyword">not</span> has_pixel_in_col(m))</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> (right-left) * (up-bottom)</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>658. Find K Closest Elements
</summary>
<blockquote>
<p>For those who are finding it hard to understand x - A[mid] &gt; A[mid + k] - x think in terms of midpoint of the two values x &gt; (A[mid + k] + A[mid])/2.<br>
<a target="_blank" rel="noopener" href="https://leetcode.com/problems/find-k-closest-elements/discuss/106426/JavaC%2B%2BPython-Binary-Search-O(log(N-K)-%2B-K">https://leetcode.com/problems/find-k-closest-elements/discuss/106426/JavaC%2B%2BPython-Binary-Search-O(log(N-K)-%2B-K</a>)</p>
</blockquote>
<p>Run time: $O(n\log(n-k))$, space: $O(k)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findClosestElements</span>(<span class="params">self, arr: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span>, x: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span></span><br><span class="line">    lo, hi = <span class="number">0</span>, <span class="built_in">len</span>(arr) - k</span><br><span class="line">    <span class="keyword">while</span> lo &lt; hi:</span><br><span class="line">        mid = lo + (hi-lo)//<span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> x - arr[mid] &gt; arr[mid + k] - x:</span><br><span class="line">            lo = mid + <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            hi = mid</span><br><span class="line">    <span class="keyword">return</span> arr[lo:lo + k]</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>354.  Russian Doll Envelopes</summary>
<blockquote>
<p>*<strong>calculate the longest increasing subsequence (LIS)</strong>. We first sort the envelopes by width, and we also make sure that when the width is the same, the envelope with greater height comes first. We could calculate the LISS using the standard DP algorithm (quadratic runtime), but we can just use the tails array method with a twist: we store the index of the tail, and we do leftmost insertion point as usual to find the right index in <code>nlogn</code> time. Why not rightmost? Think about the case [1, 1], [1, 1], [1, 1].<br>
<a target="_blank" rel="noopener" href="https://leetcode.com/problems/russian-doll-envelopes/discuss/82761/Python-O(nlogn)-O(n)-solution-beats-97-with-explanation">https://leetcode.com/problems/russian-doll-envelopes/discuss/82761/Python-O(nlogn)-O(n)-solution-beats-97-with-explanation</a></p>
</blockquote>
<p>Run time: $O(n\log n)$, space: $O(n)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">maxEnvelopes</span>(<span class="params">self, envelopes: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> envelopes:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    n = <span class="built_in">len</span>(envelopes)</span><br><span class="line">    envelopes.sort(key=<span class="keyword">lambda</span> x: (x[<span class="number">0</span>], -x[<span class="number">1</span>]))</span><br><span class="line">    dp = [<span class="number">0</span>] * n</span><br><span class="line">    ans = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> _, h <span class="keyword">in</span> envelopes:</span><br><span class="line">        lo, hi = <span class="number">0</span>, ans-<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> lo &lt;= hi:</span><br><span class="line">            mid = lo + (hi-lo)//<span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> dp[mid] &gt;= h:</span><br><span class="line">                hi = mid-<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                lo = mid+<span class="number">1</span></span><br><span class="line">        dp[lo] = h</span><br><span class="line">        ans = <span class="built_in">max</span>(ans, lo+<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>1011. Capacity To Ship Packages Within D Days</summary>
<blockquote>
<p>Set lo to be the max weight, set height to be the total weight. Use binary search to find the minimum capacity so that all packages could be shipped in time, and we need to return lo in the end as the lower bound.</p>
</blockquote>
<p>Run time: $O(n\log n)$, space: $O(1)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">shipWithinDays</span>(<span class="params">self, weights: <span class="type">List</span>[<span class="built_in">int</span>], days: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">doable</span>(<span class="params">cap</span>):</span></span><br><span class="line">        num_day = <span class="number">1</span></span><br><span class="line">        curr_w = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> w <span class="keyword">in</span> weights:</span><br><span class="line">            curr_w += w</span><br><span class="line">            <span class="keyword">if</span> curr_w &gt; cap:</span><br><span class="line">                curr_w = w</span><br><span class="line">                num_day += <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> num_day &gt; days:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    </span><br><span class="line">    lo, hi = <span class="built_in">max</span>(weights), <span class="built_in">sum</span>(weights)</span><br><span class="line">    <span class="keyword">while</span> lo &lt; hi:</span><br><span class="line">        mid = lo + (hi-lo) // <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> doable(mid):</span><br><span class="line">            hi = mid</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            lo = mid+<span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> lo</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>410. Split Array Largest Sum</summary>
<blockquote>
<p>Set lo to be the max element, hi. to be the sum of all elements. Find the minimum target sum that the array could be split into m parts.<br>
<a target="_blank" rel="noopener" href="https://leetcode.com/problems/split-array-largest-sum/discuss/769701/Python-Clear-explanation-Powerful-Ultimate-Binary-Search-Template.-Solved-many-problems">https://leetcode.com/problems/split-array-largest-sum/discuss/769701/Python-Clear-explanation-Powerful-Ultimate-Binary-Search-Template.-Solved-many-problems</a></p>
</blockquote>
<p>Run time: $O(n\log n)$, space: $O(1)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">splitArray</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], m: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">feasible</span>(<span class="params">threshold</span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        count = <span class="number">1</span></span><br><span class="line">        total = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            total += num</span><br><span class="line">            <span class="keyword">if</span> total &gt; threshold:</span><br><span class="line">                total = num</span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> count &gt; m:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    left, right = <span class="built_in">max</span>(nums), <span class="built_in">sum</span>(nums)</span><br><span class="line">    <span class="keyword">while</span> left &lt; right:</span><br><span class="line">        mid = left + (right - left) // <span class="number">2</span> <span class="comment"># target sum</span></span><br><span class="line">        <span class="keyword">if</span> feasible(mid):</span><br><span class="line">            right = mid     </span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            left = mid + <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> left</span><br></pre></td></tr></table></figure>
<blockquote>
<p>(TLE) Let dp(i, m) denote the minimum the largest sum among subarrays when dividing nums[i…n-1] into m subarrays.</p>
</blockquote>
<p>Run time: $O(mn^2)$, space: $O(mn)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">splitArray</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], m: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">    n = <span class="built_in">len</span>(nums)</span><br><span class="line">    cum_sum = [<span class="number">0</span>]*n</span><br><span class="line">    dp = [[<span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)]*n <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m+<span class="number">1</span>)]</span><br><span class="line">    cum_sum[<span class="number">0</span>] = nums[<span class="number">0</span>]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n):</span><br><span class="line">        cum_sum[i] = cum_sum[i-<span class="number">1</span>]+nums[i]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        dp[<span class="number">1</span>][i] = cum_sum[i]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, m+<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i-<span class="number">1</span>, n):</span><br><span class="line">            <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(j):</span><br><span class="line">                dp[i][j] = <span class="built_in">min</span>(dp[i][j], <span class="built_in">max</span>(dp[i-<span class="number">1</span>][k], cum_sum[j] - cum_sum[k]))</span><br><span class="line">    <span class="keyword">return</span> dp[m][n-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>1539. Kth Missing Positive Number</summary>
<blockquote>
<p>the indices can help us to get all the positive numbers in sorted order (i + 1 if i denotes the index)<br>
Hence, A[i] - (i + 1) will be # of missing positives at index i, and this will be our 3rd sorted sequences<br>
<a target="_blank" rel="noopener" href="https://leetcode.com/problems/kth-missing-positive-number/discuss/779999/JavaC%2B%2BPython-O(logN)">https://leetcode.com/problems/kth-missing-positive-number/discuss/779999/JavaC%2B%2BPython-O(logN)</a></p>
</blockquote>
<p>Run time: $O(\log n)$, space: $O(1)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findKthPositive</span>(<span class="params">self, arr: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">    l, r = <span class="number">0</span>, <span class="built_in">len</span>(arr)</span><br><span class="line">    <span class="keyword">while</span> l &lt; r:</span><br><span class="line">        m = l + (r - l)//<span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> arr[m] - (m+<span class="number">1</span>) &lt; k: <span class="comment"># get the correct index</span></span><br><span class="line">            l = m + <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            r = m</span><br><span class="line">    <span class="keyword">return</span> l + k</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>792. Number of Matching Subsequences</summary>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/number-of-matching-subsequences/discuss/1289527/Number-of-Matching-Subsequences-or-Easy-Solution-w-Explanation-or-Binary-Search">https://leetcode.com/problems/number-of-matching-subsequences/discuss/1289527/Number-of-Matching-Subsequences-or-Easy-Solution-w-Explanation-or-Binary-Search</a></p>
</blockquote>
<p>Run time: $O(L + mnlogL)$, space: $O(L)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">numMatchingSubseq</span>(<span class="params">self, s: <span class="built_in">str</span>, words: <span class="type">List</span>[<span class="built_in">str</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">    ans = <span class="number">0</span></span><br><span class="line">    mappings = defaultdict(<span class="built_in">list</span>)</span><br><span class="line">    <span class="keyword">for</span> index, char <span class="keyword">in</span> <span class="built_in">enumerate</span>(s):</span><br><span class="line">        mappings[char].append(index)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> word <span class="keyword">in</span> words:</span><br><span class="line">        prev = -<span class="number">1</span></span><br><span class="line">        found = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> word:</span><br><span class="line">            tmp = bisect.bisect(mappings[c], prev)</span><br><span class="line">            <span class="keyword">if</span> tmp == <span class="built_in">len</span>(mappings[c]): <span class="comment"># not found, returned last index</span></span><br><span class="line">                found = <span class="literal">False</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">else</span>: </span><br><span class="line">                prev = mappings[c][tmp]</span><br><span class="line">        <span class="keyword">if</span> found:</span><br><span class="line">            ans += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>162. Find Peak Element</summary>
<blockquote>
<p>Check if nums[m] &lt; nums[m+1]. If so, it means the possible answer might not be on the left side, so set lo=mid+1.</p>
</blockquote>
<p>Run time: $O(\log n)$, space: $O(1)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findPeakElement</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">    lo, hi = <span class="number">0</span>, <span class="built_in">len</span>(nums)-<span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> lo &lt; hi:</span><br><span class="line">        m = lo + (hi-lo)//<span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> nums[m] &lt; nums[m+<span class="number">1</span>]: <span class="comment"># here m is low mid so here is nerver a case m+1 = h while l&lt;h</span></span><br><span class="line">            lo = m+<span class="number">1</span> <span class="comment"># possible answer right side without the mid            </span></span><br><span class="line">        <span class="keyword">if</span> nums[m] &gt; nums[m+<span class="number">1</span>]:</span><br><span class="line">            hi = m <span class="comment"># possible answer left side the mid</span></span><br><span class="line">    <span class="keyword">return</span> lo</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findPeakElement</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span>(<span class="params">nums, lo, hi</span>):</span></span><br><span class="line">        <span class="keyword">if</span> lo == hi:</span><br><span class="line">            <span class="keyword">return</span> lo</span><br><span class="line">        mid = lo + (hi-lo) //<span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> nums[mid] &gt; nums[mid+<span class="number">1</span>]:</span><br><span class="line">            <span class="keyword">return</span> helper(nums, lo, mid)</span><br><span class="line">        <span class="keyword">return</span> helper(nums, mid+<span class="number">1</span>, hi)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> helper(nums, <span class="number">0</span>, <span class="built_in">len</span>(nums)-<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<p>Run time: $O(n)$, space: $O(1)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findPeakElement</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)-<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">if</span> nums[i] &gt; nums[i+<span class="number">1</span>]:</span><br><span class="line">            <span class="keyword">return</span> i</span><br><span class="line">    <span class="keyword">return</span> nums[<span class="built_in">len</span>(nums)-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>240. Search a 2D Matrix II</summary>
> Search from bottom left corner. Move up if target is smaller, move right if target is greater.
<p>Run time: $O(m+n)$, space: $O(1)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">searchMatrix</span>(<span class="params">self, matrix: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]], target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">len</span>(matrix) <span class="keyword">or</span> <span class="keyword">not</span> <span class="built_in">len</span>(matrix[<span class="number">0</span>]):</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    </span><br><span class="line">    h, w = <span class="built_in">len</span>(matrix), <span class="built_in">len</span>(matrix[<span class="number">0</span>])</span><br><span class="line">    i, j = h-<span class="number">1</span>, <span class="number">0</span> <span class="comment"># bottom left corner</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">if</span> i &lt; <span class="number">0</span> <span class="keyword">or</span> j &gt;= w:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        </span><br><span class="line">        current = matrix[i][j]</span><br><span class="line">        <span class="keyword">if</span> target &lt; current: <span class="comment"># target is smaller, then go up</span></span><br><span class="line">            i -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> target &gt; current: <span class="comment"># target is larger, then go right</span></span><br><span class="line">            j += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">else</span>:<span class="comment"># hit target</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>Recursion.</p>
</blockquote>
<p>Run time: $O(mn)$, space: $O(mn)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">searchMatrix</span>(<span class="params">self, matrix: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]], target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span>(<span class="params">matrix, target, i, j, s</span>):</span></span><br><span class="line">        <span class="keyword">if</span> i &gt;= m <span class="keyword">or</span> j &gt;= n <span class="keyword">or</span> i &lt; <span class="number">0</span> <span class="keyword">or</span> j &lt; <span class="number">0</span> <span class="keyword">or</span> (i,j) <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        s.add((i,j))</span><br><span class="line">        <span class="keyword">if</span> matrix[i][j] == target:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">elif</span> matrix[i][j] &lt; target:</span><br><span class="line">            <span class="keyword">return</span> helper(matrix, target, i+<span class="number">1</span>, j, s) <span class="keyword">or</span> \</span><br><span class="line">                   helper(matrix, target, i, j+<span class="number">1</span>, s)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> helper(matrix, target, i-<span class="number">1</span>, j, s) <span class="keyword">or</span> \</span><br><span class="line">                   helper(matrix, target, i, j-<span class="number">1</span>, s)</span><br><span class="line">            </span><br><span class="line">    <span class="keyword">if</span> target &gt; matrix[-<span class="number">1</span>][-<span class="number">1</span>]:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    m,n = <span class="built_in">len</span>(matrix), <span class="built_in">len</span>(matrix[<span class="number">0</span>])</span><br><span class="line">    <span class="keyword">return</span> helper(matrix, target, <span class="number">0</span>,<span class="number">0</span>, <span class="built_in">set</span>())</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>81. Search in Rotated Sorted Array II</summary>
> Three cases: if `nums[mid] == target`, return True. If `nums[mid]` is equal to `nums[lo]`, we could not determine which part of the array is rotated, therefore we increment `lo` by 1. If `nums[mid]`is smaller than or equal to `nums[hi]`, then we know the right part may be monotone increasing. We check if the target falls into this interval and update the index. The last case is whether the target falls into the intervals of `lo` and `mid`.
<p>Run time: $O(\log n)$, space: $O(1)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">search</span>(<span class="params">self, nums, target</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    :type nums: List[int]</span></span><br><span class="line"><span class="string">    :type target: int</span></span><br><span class="line"><span class="string">    :rtype: bool</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    </span><br><span class="line">    lo = <span class="number">0</span></span><br><span class="line">    hi = <span class="built_in">len</span>(nums)-<span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> lo &lt;= hi:</span><br><span class="line">        mid = lo + (hi-lo)//<span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> nums[mid] == target:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">if</span> nums[lo] == nums[mid]:</span><br><span class="line">            lo += <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> nums[mid] &lt;= nums[hi]:</span><br><span class="line">            <span class="keyword">if</span> nums[mid] &lt; target &lt;= nums[hi]:</span><br><span class="line">                lo = mid+<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                hi = mid-<span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> nums[lo] &lt;= target &lt; nums[mid]:</span><br><span class="line">                hi = mid-<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                lo = mid+<span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>34. Find First and Last Position of Element in Sorted Array</summary>
> If the while condition has equal sign, then every case needs to increment or decrement by 1.
<p>Run time: $O(\log n)$, space: $O(1)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">searchRange</span>(<span class="params">self, nums, target</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    :type nums: List[int]</span></span><br><span class="line"><span class="string">    :type target: int</span></span><br><span class="line"><span class="string">    :rtype: List[int]</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lower_bound</span>():</span></span><br><span class="line">        lo = <span class="number">0</span></span><br><span class="line">        hi = <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">while</span> lo &lt;= hi:</span><br><span class="line">            mid = lo + (hi-lo)//<span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid] &gt;= target:</span><br><span class="line">                hi = mid-<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                lo = mid+<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> lo</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">upper_bound</span>():</span></span><br><span class="line">        lo = <span class="number">0</span></span><br><span class="line">        hi = <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">while</span> lo &lt;= hi:</span><br><span class="line">            mid = lo + (hi-lo)//<span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid] &lt;= target:</span><br><span class="line">                lo = mid+<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                hi = mid-<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> hi</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">        <span class="keyword">return</span> [-<span class="number">1</span>,-<span class="number">1</span>]</span><br><span class="line">    first = lower_bound()</span><br><span class="line">    last = upper_bound()</span><br><span class="line">    <span class="keyword">if</span> first &gt;= last:</span><br><span class="line">        <span class="keyword">return</span> [-<span class="number">1</span>,-<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">return</span> [first, last]</span><br></pre></td></tr></table></figure>
</details>
<h2 id="Sorting">Sorting</h2>
<details>
<summary></summary>
> 
<p>Run time: $O()$, space: $O()$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>853.  Car Fleet</summary>
<blockquote>
<p>Pair [position, speed] and sort by position in descending order, then calculate the time it takes to get to the target. Loop through each time, if the current car takes less time than previous car to get to target, then it implies it could catch up with the car in front of it, so they can form a fleet. If it takes more time than the previous car, then it needs to form a new fleet itself.<br>
<a target="_blank" rel="noopener" href="https://leetcode.com/problems/car-fleet/discuss/139850/C%2B%2BJavaPython-Straight-Forward">https://leetcode.com/problems/car-fleet/discuss/139850/C%2B%2BJavaPython-Straight-Forward</a></p>
</blockquote>
<p>Run time: $O(n\log n)$, space: $O(n)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">carFleet</span>(<span class="params">self, target: <span class="built_in">int</span>, position: <span class="type">List</span>[<span class="built_in">int</span>], speed: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">    sorted_position = <span class="built_in">sorted</span>(<span class="built_in">zip</span>(position, speed), reverse = <span class="literal">True</span>)</span><br><span class="line">    time_to_dest = [<span class="built_in">float</span>((target-pos)/sp) <span class="keyword">for</span> pos, sp <span class="keyword">in</span> sorted_position]</span><br><span class="line">    </span><br><span class="line">    ans, cur = <span class="number">0</span>,<span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> t <span class="keyword">in</span> time_to_dest:</span><br><span class="line">        <span class="keyword">if</span> t &gt; cur:</span><br><span class="line">            ans += <span class="number">1</span></span><br><span class="line">            cur = t</span><br><span class="line">    <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>378. Kth Smallest Element in a Sorted Matrix</summary>
<blockquote>
<p>Apply the Binary Search on the number range instead of the index range. As we know that the smallest number of our matrix is at the top left corner and the biggest number is at the bottom lower corner. These two number can represent the range i.e., the start and the end for the Binary Search. This does sound a bit counter-intuitive now, however, it will start to make sense soon. We are all accustomed to the linear array binary search algorithm.</p>
</blockquote>
<p>Run time: $O(n\log \min(max-min))$, space: $O(1)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">kthSmallest</span>(<span class="params">self, matrix: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]], k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">    m, n = <span class="built_in">len</span>(matrix), <span class="built_in">len</span>(matrix[<span class="number">0</span>])  <span class="comment"># For general, the matrix need not be a square</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">countLessOrEqual</span>(<span class="params">x</span>):</span></span><br><span class="line">        cnt = <span class="number">0</span></span><br><span class="line">        c = n - <span class="number">1</span>  <span class="comment"># start with the rightmost column</span></span><br><span class="line">        <span class="keyword">for</span> r <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">            <span class="keyword">while</span> c &gt;= <span class="number">0</span> <span class="keyword">and</span> matrix[r][c] &gt; x: c -= <span class="number">1</span>  <span class="comment"># decrease column until matrix[r][c] &lt;= x</span></span><br><span class="line">            cnt += (c + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> cnt</span><br><span class="line"></span><br><span class="line">    left, right = matrix[<span class="number">0</span>][<span class="number">0</span>], matrix[-<span class="number">1</span>][-<span class="number">1</span>]</span><br><span class="line">    ans = -<span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">        mid = (left + right) // <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> countLessOrEqual(mid) &gt;= k:</span><br><span class="line">            ans = mid</span><br><span class="line">            right = mid - <span class="number">1</span>  <span class="comment"># try to looking for a smaller value in the left side</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            left = mid + <span class="number">1</span>  <span class="comment"># try to looking for a bigger value in the right side</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Maintain a min heap with size k.</p>
</blockquote>
<p>Run time: $O(mn\log k)$, space: $O(k)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">kthSmallest</span>(<span class="params">self, matrix: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]], k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">    m, n = <span class="built_in">len</span>(matrix), <span class="built_in">len</span>(matrix[<span class="number">0</span>])  <span class="comment"># For general, matrix doesn&#x27;t need to be a square</span></span><br><span class="line">    maxHeap = []</span><br><span class="line">    <span class="keyword">for</span> r <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            heapq.heappush(maxHeap, -matrix[r][c])</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(maxHeap) &gt; k:</span><br><span class="line">                heapq.heappop(maxHeap)</span><br><span class="line">    <span class="keyword">return</span> -heapq.heappop(maxHeap)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Flatten the matrix and sort the array.</p>
</blockquote>
<p>Run time: $O(mn\log (mn))$, space: $O(mn)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">kthSmallest</span>(<span class="params">self, matrix: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]], k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span>        </span><br><span class="line">    res = []</span><br><span class="line">    <span class="keyword">for</span> r <span class="keyword">in</span> matrix:</span><br><span class="line">        res += r</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sorted</span>(res)[k-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
</details>
<h3 id="Topological-Sort">Topological Sort</h3>
<details>
<summary>631. Design Excel Sum Formula</summary>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/design-excel-sum-formula/discuss/1092604/Python-1-O(1)-query-using-topological-sort-update">https://leetcode.com/problems/design-excel-sum-formula/discuss/1092604/Python-1-O(1)-query-using-topological-sort-update</a></p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Excel</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, height: <span class="built_in">int</span>, width: <span class="built_in">str</span></span>):</span></span><br><span class="line">        <span class="comment"># (r, &quot;c&quot;) -&gt; val</span></span><br><span class="line">        self.grid = defaultdict(<span class="built_in">int</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># sum dependency graphs</span></span><br><span class="line">        self.g = defaultdict(<span class="built_in">list</span>)</span><br><span class="line">        self.inv = defaultdict(<span class="built_in">list</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">set</span>(<span class="params">self, row: <span class="built_in">int</span>, column: <span class="built_in">str</span>, val: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">        u = (row,column)</span><br><span class="line">        self.unset(u)</span><br><span class="line">        self.grid[u] = val</span><br><span class="line">        self.propagate(u)</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span>(<span class="params">self, row: <span class="built_in">int</span>, column: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.grid[row,column]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sum</span>(<span class="params">self, row: <span class="built_in">int</span>, column: <span class="built_in">str</span>, numbers: <span class="type">List</span>[<span class="built_in">str</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        u = (row,column)</span><br><span class="line">        self.unset(u)</span><br><span class="line">        self.g[u] = self.itemize(numbers)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> v <span class="keyword">in</span> self.g[u]:</span><br><span class="line">            self.inv[v].append(u)</span><br><span class="line">        </span><br><span class="line">        self.grid[u] = <span class="built_in">sum</span>(self.grid[v] <span class="keyword">for</span> v <span class="keyword">in</span> self.g[u])</span><br><span class="line"></span><br><span class="line">        self.propagate(u)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> self.grid[u]</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># unsets sum dependencies of u</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">unset</span>(<span class="params">self, u</span>):</span>        </span><br><span class="line">        <span class="keyword">if</span> u <span class="keyword">in</span> self.g:</span><br><span class="line">            <span class="keyword">for</span> v <span class="keyword">in</span> self.g[u]:</span><br><span class="line">                self.inv[v].remove(u)</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">del</span> self.g[u]</span><br><span class="line">        </span><br><span class="line">    <span class="comment"># propagates updates to all direct and indirect dependents of root</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">propagate</span>(<span class="params">self, root</span>):</span>        </span><br><span class="line">        indegree = Counter()</span><br><span class="line">        </span><br><span class="line"><span class="meta">        @cache</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">recurse</span>(<span class="params">u</span>):</span></span><br><span class="line">            <span class="keyword">for</span> v <span class="keyword">in</span> self.inv[u]:</span><br><span class="line">                indegree[v] += <span class="number">1</span></span><br><span class="line">                recurse(v)</span><br><span class="line">        </span><br><span class="line">        recurse(root)</span><br><span class="line">        q = [root]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> u <span class="keyword">in</span> q:</span><br><span class="line">            <span class="keyword">if</span> u != root:</span><br><span class="line">                self.grid[u] = <span class="built_in">sum</span>(self.grid[v] <span class="keyword">for</span> v <span class="keyword">in</span> self.g[u])</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span> v <span class="keyword">in</span> self.inv[u]:</span><br><span class="line">                indegree[v] -= <span class="number">1</span></span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> indegree[v] == <span class="number">0</span>:</span><br><span class="line">                    q.append(v)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># returns (r,c) cells</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">itemize</span>(<span class="params">self, strs</span>):</span></span><br><span class="line">        ret = []</span><br><span class="line">        <span class="keyword">for</span> s <span class="keyword">in</span> strs:</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> <span class="string">&quot;:&quot;</span> <span class="keyword">in</span> s:</span><br><span class="line">                start,end = s.split(<span class="string">&quot;:&quot;</span>)</span><br><span class="line">                </span><br><span class="line">                sr,sc = <span class="built_in">int</span>(start[<span class="number">1</span>:]), start[<span class="number">0</span>]</span><br><span class="line">                er,ec = <span class="built_in">int</span>(end[<span class="number">1</span>:]), end[<span class="number">0</span>]</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">for</span> r <span class="keyword">in</span> <span class="built_in">range</span>(sr, er+<span class="number">1</span>):</span><br><span class="line">                    <span class="keyword">for</span> c <span class="keyword">in</span> <span class="built_in">map</span>(<span class="built_in">chr</span>, <span class="built_in">range</span>(<span class="built_in">ord</span>(sc), <span class="built_in">ord</span>(ec)+<span class="number">1</span>)):</span><br><span class="line">                        ret.append((r,c))</span><br><span class="line">                </span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                r,c = <span class="built_in">int</span>(s[<span class="number">1</span>:]), s[<span class="number">0</span>]</span><br><span class="line">                ret.append((r,c))</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ret</span><br><span class="line"><span class="comment"># Your Excel object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"># obj = Excel(height, width)</span></span><br><span class="line"><span class="comment"># obj.set(row,column,val)</span></span><br><span class="line"><span class="comment"># param_2 = obj.get(row,column)</span></span><br><span class="line"><span class="comment"># param_3 = obj.sum(row,column,numbers)</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>Use dictionary to store each letter’s value, and occurrences.</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Excel</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, height: <span class="built_in">int</span>, width: <span class="built_in">str</span></span>):</span></span><br><span class="line">        self.cells = [&#123;letter: &#123;<span class="string">&quot;value&quot;</span>: <span class="number">0</span>, <span class="string">&quot;sum&quot;</span>: <span class="literal">None</span>&#125; <span class="keyword">for</span> letter <span class="keyword">in</span> string.ascii_uppercase&#125; <span class="keyword">for</span> h <span class="keyword">in</span> <span class="built_in">range</span>(height + <span class="number">1</span>)]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">set</span>(<span class="params">self, row: <span class="built_in">int</span>, column: <span class="built_in">str</span>, val: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">        self.cells[row][column] = &#123;<span class="string">&quot;value&quot;</span>: val, <span class="string">&quot;sum&quot;</span>: <span class="literal">None</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span>(<span class="params">self, row: <span class="built_in">int</span>, column: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        cell = self.cells[row][column]</span><br><span class="line">        addrs = cell.get(<span class="string">&quot;sum&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> addrs:</span><br><span class="line">            <span class="keyword">return</span> cell[<span class="string">&quot;value&quot;</span>]</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sum</span>(self.get(*addr) * count <span class="keyword">for</span> addr, count <span class="keyword">in</span> addrs.items())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sum</span>(<span class="params">self, row: <span class="built_in">int</span>, column: <span class="built_in">str</span>, numbers: <span class="type">List</span>[<span class="built_in">str</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        self.cells[row][column][<span class="string">&quot;sum&quot;</span>] = self._parse(numbers)</span><br><span class="line">        <span class="keyword">return</span> self.get(row, column)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_parse</span>(<span class="params">self, strs: <span class="type">List</span>[<span class="built_in">str</span>]</span>):</span></span><br><span class="line">        counter = Counter()</span><br><span class="line">        <span class="keyword">for</span> s <span class="keyword">in</span> strs:</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> <span class="string">&quot;:&quot;</span> <span class="keyword">in</span> s:</span><br><span class="line">                start, end = s.split(<span class="string">&quot;:&quot;</span>)[<span class="number">0</span>], s.split(<span class="string">&quot;:&quot;</span>)[<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                start = end = s</span><br><span class="line">            <span class="keyword">for</span> r <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">int</span>(start[<span class="number">1</span>:]), <span class="built_in">int</span>(end[<span class="number">1</span>:]) + <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">for</span> ci <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">ord</span>(start[<span class="number">0</span>]), <span class="built_in">ord</span>(end[<span class="number">0</span>]) + <span class="number">1</span>):</span><br><span class="line">                    counter[(r, <span class="built_in">chr</span>(ci))] += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> counter</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Your Excel object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"># obj = Excel(height, width)</span></span><br><span class="line"><span class="comment"># obj.set(row,column,val)</span></span><br><span class="line"><span class="comment"># param_2 = obj.get(row,column)</span></span><br><span class="line"><span class="comment"># param_3 = obj.sum(row,column,numbers)</span></span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>329. Longest Increasing Path in a Matrix</summary>
<blockquote>
<p>We can model this problem as a graph in which each cell is a vertex. An edge exists only from node u to node v if u and v are adjacent up/down/left/right neighbors in matrix and if matrix[u] &lt; matrix[v] - this is because we are looking to model only increasing paths per problem statement.<br>
<a target="_blank" rel="noopener" href="https://leetcode.com/problems/longest-increasing-path-in-a-matrix/discuss/332696/Python-Topological-Sort-with-explanation">https://leetcode.com/problems/longest-increasing-path-in-a-matrix/discuss/332696/Python-Topological-Sort-with-explanation</a></p>
</blockquote>
<p>Run time: $O(mn)$, space: $O(mn)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">longestIncreasingPath</span>(<span class="params">self, matrix: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">    M, N = <span class="built_in">len</span>(matrix), <span class="built_in">len</span>(matrix[<span class="number">0</span>])</span><br><span class="line">    outdegree = &#123; (i, j): <span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(M) <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(N)&#125;</span><br><span class="line">    dirs = [(<span class="number">0</span>, <span class="number">1</span>), (<span class="number">1</span>, <span class="number">0</span>), (<span class="number">0</span>, -<span class="number">1</span>), (-<span class="number">1</span>, <span class="number">0</span>)]</span><br><span class="line">    adj = defaultdict(<span class="built_in">list</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(M):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(N):</span><br><span class="line">            <span class="keyword">for</span> x, y <span class="keyword">in</span> dirs:</span><br><span class="line">                dx = i + x </span><br><span class="line">                dy = j + y</span><br><span class="line">                <span class="keyword">if</span> (dx, dy) <span class="keyword">in</span> outdegree <span class="keyword">and</span> \</span><br><span class="line">                matrix[i][j] &lt; matrix[dx][dy]:</span><br><span class="line">                    outdegree[i,j] += <span class="number">1</span></span><br><span class="line">                    adj[dx, dy].append((i, j))</span><br><span class="line"></span><br><span class="line">    stack = []</span><br><span class="line">    <span class="keyword">for</span> key <span class="keyword">in</span> outdegree:</span><br><span class="line">        <span class="keyword">if</span> outdegree[key] == <span class="number">0</span>:</span><br><span class="line">            stack.append(key)</span><br><span class="line"></span><br><span class="line">    h = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> stack:</span><br><span class="line">        h += <span class="number">1</span></span><br><span class="line">        newstack = []</span><br><span class="line">        <span class="keyword">for</span> x, y <span class="keyword">in</span> stack:</span><br><span class="line">            <span class="keyword">for</span> next_x, next_y <span class="keyword">in</span> adj[x, y]:</span><br><span class="line">                outdegree[next_x, next_y] -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> outdegree[next_x, next_y] == <span class="number">0</span>:</span><br><span class="line">                    newstack.append((next_x, next_y))</span><br><span class="line">        stack = newstack</span><br><span class="line">    <span class="keyword">return</span> h</span><br></pre></td></tr></table></figure>
<blockquote>
<p>We can find longest decreasing path instead, the result will be the same. Use dp to record previous results and choose the max dp value of smaller neighbors.</p>
</blockquote>
<p>Run time: $O(mn)$, space: $O(mn)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">longestIncreasingPath</span>(<span class="params">self, matrix: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">    <span class="comment"># corner case</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> matrix <span class="keyword">or</span> <span class="keyword">not</span> matrix[<span class="number">0</span>]:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># initilization</span></span><br><span class="line">    M, N = <span class="built_in">len</span>(matrix), <span class="built_in">len</span>(matrix[<span class="number">0</span>]) <span class="comment"># length, width</span></span><br><span class="line">    dp = [[<span class="number">0</span>]*N <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(M)] <span class="comment"># 2-D matrix for store the number of steps</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># dfs function</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">i, j</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> dp[i][j]: <span class="comment"># if this position is not visited</span></span><br><span class="line">            val = matrix[i][j]</span><br><span class="line">            <span class="comment"># search four directions to find out the decreasing path</span></span><br><span class="line">            <span class="comment"># up</span></span><br><span class="line">            <span class="keyword">if</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> val &gt; matrix[i-<span class="number">1</span>][j]:</span><br><span class="line">                up = dfs(i-<span class="number">1</span>, j)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                up = <span class="number">0</span></span><br><span class="line">            <span class="comment"># down</span></span><br><span class="line">            <span class="keyword">if</span> i &lt; M-<span class="number">1</span> <span class="keyword">and</span> val &gt; matrix[i+<span class="number">1</span>][j]:</span><br><span class="line">                down = dfs(i+<span class="number">1</span>, j)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                down = <span class="number">0</span></span><br><span class="line">            <span class="comment"># left</span></span><br><span class="line">            <span class="keyword">if</span> j &gt; <span class="number">0</span> <span class="keyword">and</span> val &gt; matrix[i][j-<span class="number">1</span>]:</span><br><span class="line">                left = dfs(i, j-<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                left = <span class="number">0</span></span><br><span class="line">            <span class="comment"># right</span></span><br><span class="line">            <span class="keyword">if</span> j &lt; N-<span class="number">1</span> <span class="keyword">and</span> val &gt; matrix[i][j+<span class="number">1</span>]:</span><br><span class="line">                right = dfs(i, j+<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                right = <span class="number">0</span></span><br><span class="line">            <span class="comment"># &quot;walk&quot; to the target neighbor and accumulate the number of steps</span></span><br><span class="line">            dp[i][j] = <span class="number">1</span> + <span class="built_in">max</span>(up, down, left, right)</span><br><span class="line">        <span class="keyword">return</span> dp[i][j]</span><br><span class="line"></span><br><span class="line">    res_path = []</span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(M): <span class="comment"># search the grid by dfs</span></span><br><span class="line">        <span class="keyword">for</span> y <span class="keyword">in</span> <span class="built_in">range</span>(N):</span><br><span class="line">            res_path.append(dfs(x, y))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>(res_path)</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>269. Alien Dictionary</summary>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/alien-dictionary/discuss/1150590/Beginner-Friendly-%2B-beats-98.7">https://leetcode.com/problems/alien-dictionary/discuss/1150590/Beginner-Friendly-%2B-beats-98.7</a></p>
</blockquote>
<p>Run time: $O©$, where $c$ be the total length of all the words in the input list, added together, space: $O(1)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">alienOrder</span>(<span class="params">self, words: <span class="type">List</span>[<span class="built_in">str</span>]</span>) -&gt; <span class="built_in">str</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">build_graph</span>(<span class="params">words</span>):</span></span><br><span class="line">        graph, degree = &#123;&#125;, &#123;&#125;</span><br><span class="line">        <span class="comment"># initialize</span></span><br><span class="line">        <span class="keyword">for</span> w <span class="keyword">in</span> words:</span><br><span class="line">            <span class="keyword">for</span> ch <span class="keyword">in</span> w:</span><br><span class="line">                <span class="keyword">if</span> ch <span class="keyword">in</span> graph: <span class="keyword">continue</span></span><br><span class="line">                graph[ch] = []</span><br><span class="line">                <span class="keyword">if</span> ch <span class="keyword">in</span> degree: <span class="keyword">continue</span></span><br><span class="line">                degree[ch] = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># build graph</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(words) - <span class="number">1</span>):</span><br><span class="line">            w1, w2 = words[i], words[i + <span class="number">1</span>]</span><br><span class="line">            min_len = <span class="built_in">min</span>(<span class="built_in">len</span>(w1), <span class="built_in">len</span>(w2))</span><br><span class="line">        </span><br><span class="line">            found = <span class="literal">False</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(min_len):</span><br><span class="line">                <span class="keyword">if</span> w1[i] != w2[i]:</span><br><span class="line">                    <span class="comment"># w1[i] &lt; w2[i]</span></span><br><span class="line">                    <span class="keyword">if</span> w2[i] <span class="keyword">not</span> <span class="keyword">in</span> graph[w1[i]]:</span><br><span class="line">                        graph[w1[i]].append(w2[i])</span><br><span class="line">                        degree[w2[i]] += <span class="number">1</span></span><br><span class="line">                    found = <span class="literal">True</span></span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># a flag to prevent cases like &quot;abc&quot;, &quot;ab&quot;</span></span><br><span class="line">            <span class="comment"># while &quot;ab&quot;, &quot;abc&quot; is okay</span></span><br><span class="line">            <span class="keyword">if</span> found == <span class="literal">False</span> <span class="keyword">and</span> <span class="built_in">len</span>(w1) &gt; <span class="built_in">len</span>(w2):</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> graph, degree</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    graph, degree = build_graph(words)</span><br><span class="line">    source = deque()</span><br><span class="line">    <span class="keyword">for</span> key <span class="keyword">in</span> degree:</span><br><span class="line">        <span class="keyword">if</span> degree[key] == <span class="number">0</span>:</span><br><span class="line">            source.append(key)</span><br><span class="line">    </span><br><span class="line">    res = []</span><br><span class="line">    <span class="keyword">while</span> source:</span><br><span class="line">        char = source.popleft()</span><br><span class="line">        res.append(char)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> child <span class="keyword">in</span> graph[char]:</span><br><span class="line">            degree[child] -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> degree[child] == <span class="number">0</span>:</span><br><span class="line">                source.append(child)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(res) &lt; <span class="built_in">len</span>(degree):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>.join(res)</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>210. Course Schedule II</summary>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/course-schedule-ii/discuss/762346/Python-BFS-beats-98-with-Detailed-Explanation-and-Comments">https://leetcode.com/problems/course-schedule-ii/discuss/762346/Python-BFS-beats-98-with-Detailed-Explanation-and-Comments</a>!</p>
</blockquote>
<p>Run time: $O(v+e)$, space: $O(v+e)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findOrder</span>(<span class="params">self, numCourses, prerequisiites: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span></span><br><span class="line">	n = numCourses</span><br><span class="line">    src, dst = collections.Counter(), [<span class="built_in">set</span>() <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">    <span class="keyword">for</span> d, s <span class="keyword">in</span> prerequisites:</span><br><span class="line">        src[d] += <span class="number">1</span></span><br><span class="line">		dst[s].add(d)</span><br><span class="line">    ans = [x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(n) <span class="keyword">if</span> <span class="keyword">not</span> src[x]]</span><br><span class="line">    <span class="keyword">for</span> s <span class="keyword">in</span> ans:</span><br><span class="line">        <span class="keyword">for</span> d <span class="keyword">in</span> dst[s]:</span><br><span class="line">            src[d] -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> src[d]: </span><br><span class="line">                ans.append(d)</span><br><span class="line">    <span class="keyword">return</span> ans <span class="keyword">if</span> <span class="built_in">len</span>(ans) == n <span class="keyword">else</span> []</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">findOrder</span>(<span class="params">self, numCourses: <span class="built_in">int</span>, prerequisites: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span></span><br><span class="line">      <span class="comment"># Create a prerequisite dict. (containing courses (nodes) that need to be taken (visited)</span></span><br><span class="line"><span class="comment"># before we can visit the key.</span></span><br><span class="line">      preq = &#123;i:<span class="built_in">set</span>() <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(numCourses)&#125;</span><br><span class="line"><span class="comment"># Create a graph for adjacency and traversing.</span></span><br><span class="line">      graph = collections.defaultdict(<span class="built_in">set</span>)</span><br><span class="line">      <span class="keyword">for</span> i,j <span class="keyword">in</span> prerequisites:</span><br><span class="line">    <span class="comment"># Preqs store requirments as their given.</span></span><br><span class="line">          preq[i].add(j)</span><br><span class="line">	<span class="comment"># Graph stores nodes and neighbors.</span></span><br><span class="line">          graph[j].add(i)</span><br><span class="line">      </span><br><span class="line">      q = collections.deque([])</span><br><span class="line"><span class="comment"># We need to find a starting location, aka courses that have no prereqs.</span></span><br><span class="line">      <span class="keyword">for</span> k, v <span class="keyword">in</span> preq.items():</span><br><span class="line">          <span class="keyword">if</span> <span class="built_in">len</span>(v) == <span class="number">0</span>:</span><br><span class="line">              q.append(k)</span><br><span class="line"><span class="comment"># Keep track of which courses have been taken.</span></span><br><span class="line">      taken = []</span><br><span class="line">      <span class="keyword">while</span> q:</span><br><span class="line">          course = q.popleft()</span><br><span class="line">          taken.append(course)</span><br><span class="line">	<span class="comment"># If we have visited the numCourses we&#x27;re done.</span></span><br><span class="line">          <span class="keyword">if</span> <span class="built_in">len</span>(taken) == numCourses:</span><br><span class="line">              <span class="keyword">return</span> taken</span><br><span class="line">	<span class="comment"># For neighboring courses.</span></span><br><span class="line">          <span class="keyword">for</span> cor <span class="keyword">in</span> graph[course]:</span><br><span class="line">	    <span class="comment"># If the course we&#x27;ve just taken was a prereq for the next course, remove it from its prereqs.</span></span><br><span class="line">              preq[cor].remove(course)</span><br><span class="line">		<span class="comment"># If we&#x27;ve taken all of the preqs for the new course, we&#x27;ll visit it.</span></span><br><span class="line">              <span class="keyword">if</span> <span class="keyword">not</span> preq[cor]:</span><br><span class="line">                  q.append(cor)</span><br><span class="line"><span class="comment"># If we didn&#x27;t hit numCourses in our search we know we can&#x27;t take all of the courses.</span></span><br><span class="line">      <span class="keyword">return</span> []</span><br></pre></td></tr></table></figure>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/course-schedule-ii/discuss/266867/Python-Topological-Sort-BFS-and-DFS-(reserve-order)">https://leetcode.com/problems/course-schedule-ii/discuss/266867/Python-Topological-Sort-BFS-and-DFS-(reserve-order)</a></p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findOrder</span>(<span class="params">self, numCourses: <span class="built_in">int</span>, prerequisites: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span></span><br><span class="line">    n = numCourses</span><br><span class="line">    G = [<span class="built_in">set</span>() <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">    <span class="keyword">for</span> d, s <span class="keyword">in</span> prerequisites:</span><br><span class="line">        G[s].add(d)</span><br><span class="line">    vis, orders = [<span class="number">0</span>] * n, []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs_circle</span>(<span class="params">x</span>):</span></span><br><span class="line">        vis[x] = -<span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> y <span class="keyword">in</span> G[x]:</span><br><span class="line">            <span class="keyword">if</span> vis[y] &lt; <span class="number">0</span> <span class="keyword">or</span> (<span class="keyword">not</span> vis[y] <span class="keyword">and</span> dfs_circle(y)):</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        vis[x] = <span class="number">1</span></span><br><span class="line">        orders.append(x)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(numCourses):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> vis[x] <span class="keyword">and</span> dfs_circle(x):</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">    <span class="keyword">return</span> orders[::-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
</details>
<h3 id="Other">Other</h3>
<details>
<summary></summary>
> 
<p>Run time: $O()$, space: $O()$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>850. Rectangle Area II</summary>
<blockquote>
<p>Actually, we can do our interval merge in O(n) time instead of O(n^2). First, let us create all unique y coordinates: set ys, then we create correspondences between indexes and these y coordinates: this is y_i dictionary. Finally, count will be count: how many times each segment is covered. We again create sides like in previous approach.</p>
</blockquote>
<blockquote>
<p>Next, we again iterate through our sides and update area, but now when we meet new segment, we update count} for range: +1 for start of rectangle and -1 for end of rectangle. Finally, we update our cur_y_sum: we check if count is 0 and if it is more than 0, we add length of this segment to cur_y_sum.</p>
</blockquote>
<p>Run time: $O(n^2)$, space: $O(n)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rectangleArea</span>(<span class="params">self, rectangles</span>):</span></span><br><span class="line">    ys = <span class="built_in">sorted</span>(<span class="built_in">set</span>([y <span class="keyword">for</span> x1, y1, x2, y2 <span class="keyword">in</span> rectangles <span class="keyword">for</span> y <span class="keyword">in</span> [y1, y2]]))</span><br><span class="line">    y_i = &#123;v: i <span class="keyword">for</span> i, v <span class="keyword">in</span> <span class="built_in">enumerate</span>(ys)&#125;</span><br><span class="line">    count = [<span class="number">0</span>] * <span class="built_in">len</span>(y_i)</span><br><span class="line">    </span><br><span class="line">    sides_lft = [(x1,-<span class="number">1</span>,y1,y2) <span class="keyword">for</span> x1,y1,x2,y2 <span class="keyword">in</span> rectangles]</span><br><span class="line">    sides_rgh = [(x2,<span class="number">1</span>,y1,y2) <span class="keyword">for</span> x1,y1,x2,y2 <span class="keyword">in</span> rectangles]</span><br><span class="line">    sides = <span class="built_in">sorted</span>(sides_lft + sides_rgh)</span><br><span class="line">     </span><br><span class="line">    cur_x = cur_y_sum = area = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> x, op_cl, y1, y2 <span class="keyword">in</span> sides:</span><br><span class="line">        area += (x - cur_x) * cur_y_sum</span><br><span class="line">        cur_x = x</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(y_i[y1], y_i[y2]):</span><br><span class="line">            count[i] += op_cl</span><br><span class="line">        cur_y_sum = <span class="built_in">sum</span>(y2 - y1 <span class="keyword">if</span> c <span class="keyword">else</span> <span class="number">0</span> <span class="keyword">for</span> y1, y2, c <span class="keyword">in</span> <span class="built_in">zip</span>(ys, ys[<span class="number">1</span>:], count))</span><br><span class="line">    <span class="keyword">return</span> area % (<span class="number">10</span> ** <span class="number">9</span> + <span class="number">7</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/rectangle-area-ii/discuss/1419181/Python-4-solutions-n3-greater-n2-log-n-greater-n2-greater-n-log-n-explained">https://leetcode.com/problems/rectangle-area-ii/discuss/1419181/Python-4-solutions-n3-greater-n2-log-n-greater-n2-greater-n-log-n-explained</a></p>
</blockquote>
<p>Run time: $O(n^2\log n)$, space: $O(n)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rectangleArea</span>(<span class="params">self, rectangles: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">merge</span>(<span class="params">intervals</span>):</span></span><br><span class="line">        ans = []</span><br><span class="line">        <span class="keyword">for</span> beg, end <span class="keyword">in</span> <span class="built_in">sorted</span>(intervals):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> ans <span class="keyword">or</span> ans[-<span class="number">1</span>][<span class="number">1</span>] &lt; beg:</span><br><span class="line">                ans += [[beg, end]]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                ans[-<span class="number">1</span>][<span class="number">1</span>] = <span class="built_in">max</span>(ans[-<span class="number">1</span>][<span class="number">1</span>], end)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sum</span>(j-i <span class="keyword">for</span> i,j <span class="keyword">in</span> ans)</span><br><span class="line">    </span><br><span class="line">    sides_lft = [(x1,<span class="number">0</span>,y1,y2) <span class="keyword">for</span> x1,y1,x2,y2 <span class="keyword">in</span> rectangles]</span><br><span class="line">    sides_rgh = [(x2,<span class="number">1</span>,y1,y2) <span class="keyword">for</span> x1,y1,x2,y2 <span class="keyword">in</span> rectangles]</span><br><span class="line">    sides = <span class="built_in">sorted</span>(sides_lft + sides_rgh)</span><br><span class="line">    </span><br><span class="line">    intervals, ans, prev_x = [], <span class="number">0</span>, sides[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> x, op_cl, y1, y2 <span class="keyword">in</span> sides:</span><br><span class="line">        ans += merge(intervals) * (x - prev_x)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> op_cl == <span class="number">0</span>:</span><br><span class="line">            intervals.append((y1,y2))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            intervals.remove((y1,y2))     </span><br><span class="line">        prev_x = x</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> ans % (<span class="number">10</span>**<span class="number">9</span> + <span class="number">7</span>)</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>253. Meeting Rooms II</summary>
<blockquote>
<p>Use a min heap to put the end time of each meeting. Sort the array by the start time, and for each interval, if start time is smaller than or equal to the end time of the current meeting in the heap that’s ending soonest, pop from the heap.</p>
</blockquote>
<p>Run time: $O(n\log n)$, space: $O(n)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">minMeetingRooms</span>(<span class="params">self, intervals: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> intervals:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    h = []</span><br><span class="line">    intervals.sort(key= <span class="keyword">lambda</span> x: x[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">    heapq.heappush(h, intervals[<span class="number">0</span>][<span class="number">1</span>])</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> intervals[<span class="number">1</span>:]:</span><br><span class="line">        <span class="keyword">if</span> h <span class="keyword">and</span> i[<span class="number">0</span>] &gt;= h[<span class="number">0</span>]: </span><br><span class="line">            heapq.heappop(h)</span><br><span class="line">        <span class="comment"># a new room is allocated</span></span><br><span class="line">        heapq.heappush(h, i[<span class="number">1</span>])</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">len</span>(h)</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>56. Merge Intervals</summary>
<blockquote>
<p>Question: How do you add intervals and merge them for a large stream of intervals? (Facebook Follow-up Question)</p>
</blockquote>
<p>Run time: $O(n\log n)$, space: $O(n)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge</span>(<span class="params">self, intervals: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span></span><br><span class="line">    heapify(intervals)</span><br><span class="line">    merged = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(intervals)):</span><br><span class="line">        root = heappop(intervals)</span><br><span class="line">        <span class="keyword">if</span> merged <span class="keyword">and</span> merged[-<span class="number">1</span>][<span class="number">1</span>]&gt;=root[<span class="number">0</span>]:</span><br><span class="line">            merged[-<span class="number">1</span>][<span class="number">1</span>] = <span class="built_in">max</span>(merged[-<span class="number">1</span>][<span class="number">1</span>], root[<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            merged.append(root)</span><br><span class="line">    <span class="keyword">return</span> merged</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge</span>(<span class="params">self, intervals: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span></span><br><span class="line">    intervals.sort(key=<span class="keyword">lambda</span> x: x[<span class="number">0</span>])</span><br><span class="line">    merged = []</span><br><span class="line">    <span class="keyword">for</span> interval <span class="keyword">in</span> intervals:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> merged <span class="keyword">or</span> merged[-<span class="number">1</span>][<span class="number">1</span>] &lt; interval[<span class="number">0</span>]:</span><br><span class="line">            merged.append(interval)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            merged[-<span class="number">1</span>][<span class="number">1</span>] = <span class="built_in">max</span>(merged[-<span class="number">1</span>][<span class="number">1</span>], interval[<span class="number">1</span>])</span><br><span class="line">    <span class="keyword">return</span> merged</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>169. Majority Element</summary>
<blockquote>
<p>Boyer-Moore Voting Algorithm<br>
If we had some way of counting instances of the majority element as +1+1 and instances of any other element as -1−1, summing them would make it obvious that the majority element is indeed the majority element.</p>
</blockquote>
<p>Run time: $O(n)$, space: $O(1)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">majorityElement</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    candidate = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">        <span class="keyword">if</span> count == <span class="number">0</span>:</span><br><span class="line">            candidate = num</span><br><span class="line">        <span class="keyword">if</span> num == candidate:</span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            count -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> candidate</span><br></pre></td></tr></table></figure>
<blockquote>
<p>In-place sort, and the one in the middle would be the mode.</p>
</blockquote>
<p>Run time: $O(n\log n)$, space: $O(1)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">majorityElement</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">    nums.sort()</span><br><span class="line">    <span class="keyword">return</span> nums[<span class="built_in">len</span>(nums)//<span class="number">2</span>]</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Put into a dictionary, and find the one with max value.</p>
</blockquote>
<p>Run time: $O(n)$, space: $O(n)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">majorityElement</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">    count = Counter(nums).items()</span><br><span class="line">    max_count, maj = <span class="number">0</span>, -<span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> k, v <span class="keyword">in</span> count:</span><br><span class="line">        <span class="keyword">if</span> v &gt; max_count:</span><br><span class="line">            max_count = v</span><br><span class="line">            maj = k</span><br><span class="line">    <span class="keyword">return</span> maj</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>347. Top K Frequent Elements</summary>
<blockquote>
<p>bucket sort. Create a list of list of length <code>len(nums)+1</code>, where index serves as frequency. Use a dictionary or Counter to get the frequencies of each number, and loop through each key value pair, and put the key to the corresponding buckets. Loop through the buckets reversely, if it is not empty, append the number.</p>
</blockquote>
<p>Run time: $O(n)$, space: $O(n)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">buckets = [[] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums) + <span class="number">1</span>)]</span><br><span class="line">number_count = collections.defaultdict(<span class="built_in">int</span>)</span><br><span class="line"><span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">    number_count[num] += <span class="number">1</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">for</span> num, freq <span class="keyword">in</span> number_count.items():</span><br><span class="line">    buckets[freq].append(num)</span><br><span class="line"></span><br><span class="line"><span class="comment"># buckets is a double array</span></span><br><span class="line">flat_list = []</span><br><span class="line"><span class="comment"># traverse from right to left so number with higher frequency come first</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(buckets) - <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">    bucket = buckets[i]</span><br><span class="line">    <span class="keyword">if</span> bucket:</span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> bucket:</span><br><span class="line">            flat_list.append(num)</span><br><span class="line"><span class="keyword">return</span> flat_list[:k]</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Use <code>Counter</code> to calculate the count for each number, which returns a dict. Then put the keys into a heap, sort by values, <code>key=count.get</code>, use <code>heapq.nlargest</code>.</p>
</blockquote>
<p>Run time: $O(n\log k)$, space: $O(n+k)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">topKFrequent</span>(<span class="params">self, nums, k</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    :type nums: List[int]</span></span><br><span class="line"><span class="string">    :type k: int</span></span><br><span class="line"><span class="string">    :rtype: List[int]</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> k == <span class="built_in">len</span>(nums):</span><br><span class="line">        <span class="keyword">return</span> nums</span><br><span class="line">    count = Counter(nums)</span><br><span class="line">    <span class="keyword">return</span> heapq.nlargest(k, count.keys(), key=count.get)</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>215. Kth Largest Element in an Array</summary>
<blockquote>
<p>Quick Select.</p>
</blockquote>
<p>Run time: $O(n)$, space: $O(n)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findKthLargest</span>(<span class="params">self, nums, k</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> nums: <span class="keyword">return</span></span><br><span class="line">    pivot = random.choice(nums)</span><br><span class="line">    left =  [x <span class="keyword">for</span> x <span class="keyword">in</span> nums <span class="keyword">if</span> x &gt; pivot]</span><br><span class="line">    mid  =  [x <span class="keyword">for</span> x <span class="keyword">in</span> nums <span class="keyword">if</span> x == pivot]</span><br><span class="line">    right = [x <span class="keyword">for</span> x <span class="keyword">in</span> nums <span class="keyword">if</span> x &lt; pivot]</span><br><span class="line">    </span><br><span class="line">    L, M = <span class="built_in">len</span>(left), <span class="built_in">len</span>(mid)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> k &lt;= L:</span><br><span class="line">        <span class="keyword">return</span> self.findKthLargest(left, k)</span><br><span class="line">    <span class="keyword">elif</span> k &gt; L + M:</span><br><span class="line">        <span class="keyword">return</span> self.findKthLargest(right, k - L - M)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> mid[<span class="number">0</span>]</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Use <code>heapq.nlargest(k, nums)</code> and get the last element in the return array.</p>
</blockquote>
<p>Run time: $O(n\log k)$, space: $O(k)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findKthLargest</span>(<span class="params">self, nums, k</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    :type nums: List[int]</span></span><br><span class="line"><span class="string">    :type k: int</span></span><br><span class="line"><span class="string">    :rtype: int</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># heap = []</span></span><br><span class="line">    <span class="comment"># for n in nums:</span></span><br><span class="line">    <span class="comment">#     if len(heap) == k:</span></span><br><span class="line">    <span class="comment">#         if heap[0] &lt; n:</span></span><br><span class="line">    <span class="comment">#             heappop(heap)</span></span><br><span class="line">    <span class="comment">#             heappush(heap, n)</span></span><br><span class="line">    <span class="comment">#     else:</span></span><br><span class="line">    <span class="comment">#         heappush(heap, n)</span></span><br><span class="line">    <span class="comment"># return heap[-k]</span></span><br><span class="line">    <span class="keyword">return</span> heapq.nlargest(k, nums)[-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>528. Random Pick with Weight</summary>
<blockquote>
<p>Use binary search to find the target index</p>
</blockquote>
<p>Run time: $O(n)$, $O(\log n)$, space: $O(n)$, $O(1)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, w</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type w: List[int]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self.prefix_sums = []</span><br><span class="line">        total = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> weight <span class="keyword">in</span> w:</span><br><span class="line">            total += weight</span><br><span class="line">            self.prefix_sums.append(total)</span><br><span class="line">        self.total_sum = total</span><br><span class="line">            </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pickIndex</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        rand = random.random() * self.total_sum</span><br><span class="line">        lo, hi = <span class="number">0</span>, <span class="built_in">len</span>(self.prefix_sums)</span><br><span class="line">        <span class="keyword">while</span> lo &lt; hi:</span><br><span class="line">            mid = lo + (hi-lo)//<span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> rand &gt; self.prefix_sums[mid]:</span><br><span class="line">                lo = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                hi = mid</span><br><span class="line">        <span class="keyword">return</span> lo</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>Keep track of cumulative sum and put it in an array, also get the total sum. Generate a number from 0 to 1, and scale with the total sum. If it is smaller than current cumulative sum, return the index.</p>
</blockquote>
<p>Run time: $O(n)$, $O(n)$, space: $O(n)$, $O(1)$</p>
<details>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, w</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type w: List[int]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        d = <span class="built_in">sum</span>(w)</span><br><span class="line">        <span class="built_in">print</span>(d)</span><br><span class="line">        self.weighted = [<span class="built_in">float</span>(a)/d <span class="keyword">for</span> a <span class="keyword">in</span> w]</span><br><span class="line">            </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pickIndex</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        rand = random.random()</span><br><span class="line">        <span class="keyword">for</span> i, w <span class="keyword">in</span> <span class="built_in">enumerate</span>(self.weighted):</span><br><span class="line">            <span class="keyword">if</span> rand &lt; w:</span><br><span class="line">                <span class="keyword">return</span> i</span><br></pre></td></tr></table></figure>
</details>
</details>
<details>
<summary>973. K Closest Points to Origin</summary>
<blockquote>
<p>QuickSelect</p>
</blockquote>
<p>Run time: $O(n)$, space: $O(1)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">kClosest</span>(<span class="params">self, points, k</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.quick_select(points, k)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">quick_select</span>(<span class="params">self, points, k</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;Perform the QuickSelect algorithm on the list&quot;&quot;&quot;</span></span><br><span class="line">        left, right = <span class="number">0</span>, <span class="built_in">len</span>(points) - <span class="number">1</span></span><br><span class="line">        pivot_index = <span class="built_in">len</span>(points)</span><br><span class="line">        <span class="keyword">while</span> pivot_index != k:</span><br><span class="line">            <span class="comment"># Repeatedly partition the list</span></span><br><span class="line">            <span class="comment"># while narrowing in on the kth element</span></span><br><span class="line">            pivot_index = self.partition(points, left, right)</span><br><span class="line">            <span class="keyword">if</span> pivot_index &lt; k:</span><br><span class="line">                left = pivot_index</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                right = pivot_index - <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># Return the first k elements of the partially sorted list</span></span><br><span class="line">        <span class="keyword">return</span> points[:k]</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">partition</span>(<span class="params">self, points, left, right</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;Partition the list around the pivot value&quot;&quot;&quot;</span></span><br><span class="line">        pivot = self.choose_pivot(points, left, right)</span><br><span class="line">        pivot_dist = self.squared_distance(pivot)</span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            <span class="comment"># Iterate through the range and swap elements to make sure</span></span><br><span class="line">            <span class="comment"># that all points closer than the pivot are to the left</span></span><br><span class="line">            <span class="keyword">if</span> self.squared_distance(points[left]) &gt;= pivot_dist:</span><br><span class="line">                points[left], points[right] = points[right], points[left]</span><br><span class="line">                right -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># Ensure the left pointer is just past the end of</span></span><br><span class="line">        <span class="comment"># the left range then return it as the new pivotIndex</span></span><br><span class="line">        <span class="keyword">if</span> self.squared_distance(points[left]) &lt; pivot_dist:</span><br><span class="line">            left += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> left</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">choose_pivot</span>(<span class="params">self, points, left, right</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;Choose a pivot element of the list&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> points[left + (right - left) // <span class="number">2</span>]</span><br><span class="line">        </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">squared_distance</span>(<span class="params">self, point</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;Calculate and return the squared Euclidean distance.&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> point[<span class="number">0</span>] ** <span class="number">2</span> + point[<span class="number">1</span>] ** <span class="number">2</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>Binary Search: set the <code>lo</code> and <code>hi</code> to be the min (0) and max euclidean distance in the list of points. Then perform binary search to loop through all points in this range and classify them into two lists: distance smaller than mid, and distance greater than mid. If the length of closer list is equal to or less than <code>k</code>, then all of them would be included in the final result and we will skip them in the next search and update the <code>k</code>.<br>
Run time: $O(n)$, space: $O(n)$</p>
</blockquote>
<details>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">kClosest</span>(<span class="params">self, points, k</span>):</span></span><br><span class="line">    <span class="comment"># Precompute the Euclidean distance for each point</span></span><br><span class="line">    distances = [self.euclidean_distance(point) <span class="keyword">for</span> point <span class="keyword">in</span> points]</span><br><span class="line">    <span class="comment"># Create a reference list of point indices</span></span><br><span class="line">    remaining = [i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(points))]</span><br><span class="line">    <span class="comment"># Define the initial binary search range</span></span><br><span class="line">    low, high = <span class="number">0</span>, <span class="built_in">max</span>(distances)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Perform a binary search of the distances</span></span><br><span class="line">    <span class="comment"># to find the k closest points</span></span><br><span class="line">    closest = []</span><br><span class="line">    <span class="keyword">while</span> k:</span><br><span class="line">        mid = low + (high - low) / <span class="number">2</span></span><br><span class="line">        closer, farther = self.split_distances(remaining, distances, mid)</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(closer) &gt; k:</span><br><span class="line">            <span class="comment"># If more than k points are in the closer distances</span></span><br><span class="line">            <span class="comment"># then discard the farther points and continue</span></span><br><span class="line">            remaining = closer</span><br><span class="line">            high = mid</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># Add the closer points to the answer array and keep</span></span><br><span class="line">            <span class="comment"># searching the farther distances for the remaining points</span></span><br><span class="line">            k -= <span class="built_in">len</span>(closer)</span><br><span class="line">            closest.extend(closer)</span><br><span class="line">            remaining = farther</span><br><span class="line">            low = mid</span><br><span class="line">            </span><br><span class="line">    <span class="comment"># Return the k closest points using the reference indices</span></span><br><span class="line">    <span class="keyword">return</span> [points[i] <span class="keyword">for</span> i <span class="keyword">in</span> closest]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">split_distances</span>(<span class="params">self, remaining, distances, mid</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;Split the distances around the midpoint</span></span><br><span class="line"><span class="string">    and return them in separate lists.&quot;&quot;&quot;</span></span><br><span class="line">    closer, farther = [], []</span><br><span class="line">    <span class="keyword">for</span> index <span class="keyword">in</span> remaining:</span><br><span class="line">        <span class="keyword">if</span> distances[index] &lt;= mid:</span><br><span class="line">            closer.append(index)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            farther.append(index)</span><br><span class="line">    <span class="keyword">return</span> [closer, farther]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">euclidean_distance</span>(<span class="params">self, point</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;Calculate and return the Euclidean distance.&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> sqrt(point[<span class="number">0</span>] ** <span class="number">2</span> + point[<span class="number">1</span>] ** <span class="number">2</span>)</span><br></pre></td></tr></table></figure>
</details>
<blockquote>
<p>Maintain a max heap with size $k$ that stores the negative value of the squares of coordinates. Once heap size exceeds $k$, pop the element.</p>
</blockquote>
<p>Run time: $O(n\log k)$, space: $O(k)$</p>
<details>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">kClosest</span>(<span class="params">self, points, k</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    :type points: List[List[int]]</span></span><br><span class="line"><span class="string">    :type k: int</span></span><br><span class="line"><span class="string">    :rtype: List[List[int]]</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    heap = []</span><br><span class="line">    <span class="keyword">for</span> point <span class="keyword">in</span> points:</span><br><span class="line">        dist = point[<span class="number">0</span>] * point[<span class="number">0</span>] + point[<span class="number">1</span>] * point[<span class="number">1</span>]</span><br><span class="line">        heapq.heappush(heap, (-dist, point))</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(heap) &gt; k:</span><br><span class="line">            heapq.heappop(heap)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> [<span class="built_in">tuple</span>[<span class="number">1</span>] <span class="keyword">for</span> <span class="built_in">tuple</span> <span class="keyword">in</span> heap]</span><br></pre></td></tr></table></figure>
</details>
</details>
<h2 id="Sweep-Line-Deque-Advanced-BS">Sweep Line, Deque, Advanced BS</h2>
<details>
<summary></summary>
> 
<p>Run time: $O()$, space: $O()$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
</details>
<h1>BFS</h1>
<details>
<summary></summary>
> 
<p>Run time: $O()$, space: $O()$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>752. Open the Lock</summary>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/open-the-lock/discuss/110232/Accepted-PythonJava-BFS-%2B-how-to-avoid-TLE">https://leetcode.com/problems/open-the-lock/discuss/110232/Accepted-PythonJava-BFS-%2B-how-to-avoid-TLE</a></p>
</blockquote>
<p>Run time: $O(n)$, space: $O(n)$, , where N is the number of strings in deadends and O(N) is required to insert all the strings into the hashset.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">openLock</span>(<span class="params">self, deadends: <span class="type">List</span>[<span class="built_in">str</span>], target: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">    marker, depth = <span class="string">&#x27;x&#x27;</span>, -<span class="number">1</span></span><br><span class="line">    visited, q = <span class="built_in">set</span>(deadends), deque([<span class="string">&#x27;0000&#x27;</span>])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> q:</span><br><span class="line">        size = <span class="built_in">len</span>(q)</span><br><span class="line">        depth += <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(size):</span><br><span class="line">            node = q.popleft()</span><br><span class="line">            <span class="keyword">if</span> node == target: <span class="keyword">return</span> depth</span><br><span class="line">            <span class="keyword">if</span> node <span class="keyword">in</span> visited: <span class="keyword">continue</span></span><br><span class="line">            visited.add(node)</span><br><span class="line">            q.extend(self.successors(node))</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">successors</span>(<span class="params">self, src</span>):</span></span><br><span class="line">    res = []</span><br><span class="line">    <span class="keyword">for</span> i, ch <span class="keyword">in</span> <span class="built_in">enumerate</span>(src):</span><br><span class="line">        num = <span class="built_in">int</span>(ch)</span><br><span class="line">        res.append(src[:i] + <span class="built_in">str</span>((num - <span class="number">1</span>) % <span class="number">10</span>) + src[i+<span class="number">1</span>:])</span><br><span class="line">        res.append(src[:i] + <span class="built_in">str</span>((num + <span class="number">1</span>) % <span class="number">10</span>) + src[i+<span class="number">1</span>:])</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>1091. Shortest Path in Binary Matrix</summary>
<blockquote>
<p>Use a queue and a set to keep track of visited position and current length of path. The first time we see the lower right corner in the queue would be the shortest path.</p>
</blockquote>
<p>Run time: $O(n^2)$, space: $O(n^2)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">shortestPathBinaryMatrix</span>(<span class="params">self, grid: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> grid <span class="keyword">or</span> <span class="keyword">not</span> grid[<span class="number">0</span>]:</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">    n = <span class="built_in">len</span>(grid)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> grid[<span class="number">0</span>][<span class="number">0</span>] <span class="keyword">or</span> grid[n-<span class="number">1</span>][n-<span class="number">1</span>]:</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line"></span><br><span class="line">    dirs = [[-<span class="number">1</span>,<span class="number">0</span>],[<span class="number">1</span>,<span class="number">0</span>],[<span class="number">0</span>,-<span class="number">1</span>],[<span class="number">0</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">1</span>],[<span class="number">1</span>,-<span class="number">1</span>],[-<span class="number">1</span>,-<span class="number">1</span>],[-<span class="number">1</span>,<span class="number">1</span>]]</span><br><span class="line">    visited = <span class="built_in">set</span>()</span><br><span class="line">    q = deque()</span><br><span class="line">    </span><br><span class="line">    visited.add((<span class="number">0</span>,<span class="number">0</span>))</span><br><span class="line">    q.append((<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>))</span><br><span class="line">    <span class="keyword">while</span> q:</span><br><span class="line">        x,y,path = q.popleft()</span><br><span class="line">        <span class="keyword">if</span> x == n-<span class="number">1</span> <span class="keyword">and</span> y == n-<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> path</span><br><span class="line">        <span class="keyword">for</span> d1, d2 <span class="keyword">in</span> dirs:</span><br><span class="line">            x1, y1 = x+d1, y+d2</span><br><span class="line">            <span class="keyword">if</span> <span class="number">0</span> &lt;= x1 &lt; n <span class="keyword">and</span> <span class="number">0</span> &lt;= y1 &lt; n \</span><br><span class="line">            <span class="keyword">and</span> grid[x1][y1] == <span class="number">0</span> \</span><br><span class="line">            <span class="keyword">and</span> (x1,y1) <span class="keyword">not</span> <span class="keyword">in</span> visited:</span><br><span class="line">                q.append((x1,y1,path+<span class="number">1</span>))</span><br><span class="line">                visited.add((x1,y1))</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>126. Word Ladder II</summary>
> bi-directional search
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findLadders</span>(<span class="params">self, beginWord: <span class="built_in">str</span>, endWord: <span class="built_in">str</span>, wordList: <span class="type">List</span>[<span class="built_in">str</span>]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">str</span>]]:</span></span><br><span class="line">    <span class="keyword">if</span> endWord <span class="keyword">not</span> <span class="keyword">in</span> wordList:</span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line"></span><br><span class="line">    wordList = <span class="built_in">set</span>(wordList)</span><br><span class="line">    n = <span class="built_in">len</span>(beginWord)</span><br><span class="line"></span><br><span class="line">    found, swapped = <span class="literal">False</span>, <span class="literal">False</span></span><br><span class="line">    start_q, end_q= &#123;beginWord&#125;, &#123;endWord&#125;</span><br><span class="line">    paths, res = collections.defaultdict(<span class="built_in">set</span>), []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> start_q <span class="keyword">and</span> <span class="keyword">not</span> found:</span><br><span class="line">        next_q = <span class="built_in">set</span>()</span><br><span class="line">        wordList -= <span class="built_in">set</span>(start_q)</span><br><span class="line">        <span class="keyword">for</span> word <span class="keyword">in</span> start_q:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                first, second = word[:i], word[i+<span class="number">1</span>:]</span><br><span class="line">                <span class="keyword">for</span> c <span class="keyword">in</span> <span class="string">&#x27;abcdefghijklmnopqrstuvwxyz&#x27;</span>:</span><br><span class="line">                    new_word = first+c+second</span><br><span class="line">                    <span class="keyword">if</span> new_word <span class="keyword">in</span> wordList:</span><br><span class="line">                        <span class="keyword">if</span> new_word <span class="keyword">in</span> end_q:</span><br><span class="line">                            found = <span class="literal">True</span></span><br><span class="line">                        <span class="keyword">else</span>:</span><br><span class="line">                            next_q.add(new_word)</span><br><span class="line"></span><br><span class="line">                        paths[new_word].add(word) <span class="keyword">if</span> swapped <span class="keyword">else</span> paths[word].add(new_word)</span><br><span class="line"></span><br><span class="line">        start_q = next_q</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(start_q) &gt; <span class="built_in">len</span>(end_q):</span><br><span class="line">            start_q, end_q = end_q, start_q</span><br><span class="line">            swapped = <span class="keyword">not</span> swapped</span><br><span class="line">    </span><br><span class="line">    res = []</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">bfs</span>(<span class="params">word, cur_path</span>):</span></span><br><span class="line">        <span class="keyword">if</span> word == endWord:</span><br><span class="line">            cur_path.append(word)</span><br><span class="line">            res.append(cur_path[::])</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">for</span> parent <span class="keyword">in</span> paths[word]:</span><br><span class="line">                bfs(parent, cur_path+[word])</span><br><span class="line">    bfs(beginWord, [])</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Create a set that contains wordList, and a dictionary <code>layer</code> that contains &lt;endWord, all possible sequences&gt; pairs. While layer is not empty, we loop through all keys, and see if the endWord is in it. Then, we loop through each character in the word, trying to replace it with every alphabet. If this new word is valid, we create an entry in the new dictionary, and the values are formed by the values of the old word. Outside of this for loop, we remove the keys in the new dictionary so that they will not be reused, and we assign the new dictionary to the old one.</p>
</blockquote>
<p>Run time: $O(nk^2)$, space: $O(nk)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findLadders</span>(<span class="params">self, beginWord: <span class="built_in">str</span>, endWord: <span class="built_in">str</span>, wordList: <span class="type">List</span>[<span class="built_in">str</span>]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">str</span>]]:</span></span><br><span class="line">    <span class="keyword">if</span> endWord <span class="keyword">not</span> <span class="keyword">in</span> wordList:</span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line">    </span><br><span class="line">    wordSet = <span class="built_in">set</span>(wordList)</span><br><span class="line">    layer = &#123;&#125;</span><br><span class="line">    layer[beginWord] = [[beginWord]]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> layer:</span><br><span class="line">        new_l = collections.defaultdict(<span class="built_in">list</span>)</span><br><span class="line">        <span class="keyword">for</span> word <span class="keyword">in</span> layer:</span><br><span class="line">            <span class="keyword">if</span> word == endWord:</span><br><span class="line">                <span class="keyword">return</span> layer[word]</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(word)):</span><br><span class="line">                <span class="keyword">for</span> c <span class="keyword">in</span> <span class="string">&#x27;abcdefghijklmnopqrstuvwxyz&#x27;</span>:</span><br><span class="line">                    new_word = word[:i] + c + word[i+<span class="number">1</span>:]</span><br><span class="line">                    <span class="keyword">if</span> new_word <span class="keyword">in</span> wordSet:</span><br><span class="line">                        <span class="comment"># add new word to all sequences and form new layer element</span></span><br><span class="line">                        new_l[new_word] += [j + [new_word] <span class="keyword">for</span> j <span class="keyword">in</span> layer[word]]</span><br><span class="line">        wordSet -= <span class="built_in">set</span>(new_l.keys())</span><br><span class="line">        layer = new_l</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> []</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>934. Shortest Bridge</summary>
<blockquote>
<p>First use DFS find one island, change all cells to 2 in order to differentiate from the other island, and also add the position to the stack. Get the size of the stack, while it is not empty, pop one position from the stack and explore in four directions, if it is not valid or still the same island (==2), continue. If it is 1, then it means we found the island, return the number of steps. Otherwise, we set this empty land to be 2, and append the position to the level. When we run out of current possible movements, we increment the steps by 1, and assign level to the stack.</p>
</blockquote>
<p>Run time: $O(mn)$, space: $O(mn)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">shortestBridge</span>(<span class="params">self, grid</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    :type grid: List[List[int]]</span></span><br><span class="line"><span class="string">    :rtype: int</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">grid, i, j, stack</span>):</span></span><br><span class="line">        <span class="keyword">if</span> i &lt; <span class="number">0</span> <span class="keyword">or</span> i &gt;= m <span class="keyword">or</span> j &lt; <span class="number">0</span> <span class="keyword">or</span> j &gt;= n <span class="keyword">or</span> grid[i][j] != <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        grid[i][j] = <span class="number">2</span></span><br><span class="line">        stack.append((i, j))</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">            dfs(grid, i+dirs[k], j+dirs[k+<span class="number">1</span>], stack)</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> grid:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    </span><br><span class="line">    dirs = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, <span class="number">0</span>]</span><br><span class="line">    stack = []</span><br><span class="line">    m,n = <span class="built_in">len</span>(grid), <span class="built_in">len</span>(grid[<span class="number">0</span>])</span><br><span class="line">    found = <span class="literal">False</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">if</span> grid[i][j] == <span class="number">1</span>:</span><br><span class="line">                dfs(grid,i, j, stack)</span><br><span class="line">                found = <span class="literal">True</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span> found:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    </span><br><span class="line">    steps = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> stack:</span><br><span class="line">        size = <span class="built_in">len</span>(stack)</span><br><span class="line">        level = []</span><br><span class="line">        <span class="keyword">while</span> (size):</span><br><span class="line">            x,y = stack.pop()</span><br><span class="line">            size -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">                x1 = x + dirs[i]</span><br><span class="line">                y1 = y + dirs[i+<span class="number">1</span>]</span><br><span class="line">                <span class="keyword">if</span> x1 &lt; <span class="number">0</span> <span class="keyword">or</span> x1 &gt;= m <span class="keyword">or</span> y1 &lt; <span class="number">0</span> <span class="keyword">or</span> y1 &gt;= n <span class="keyword">or</span> grid[x1][y1] == <span class="number">2</span>:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                <span class="keyword">if</span> grid[x1][y1] == <span class="number">1</span>: <span class="comment"># found</span></span><br><span class="line">                    <span class="keyword">return</span> steps</span><br><span class="line">                grid[x1][y1] = <span class="number">2</span></span><br><span class="line">                level.append((x1, y1))</span><br><span class="line">        steps += <span class="number">1</span></span><br><span class="line">        stack = level</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>317. Shortest Distance from All Buildings</summary>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/shortest-distance-from-all-buildings/discuss/963506/Python-BFS-code-with-comments">https://leetcode.com/problems/shortest-distance-from-all-buildings/discuss/963506/Python-BFS-code-with-comments</a></p>
</blockquote>
<p>Run time: $O(N^2M^2)$, space: $O(NM)$, where $N$, $M$ are the number of rows and columns in grid.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">shortestDistance</span>(<span class="params">self, grid: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> grid:</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">    <span class="comment"># create a list of buildings and a set of empty lands for easy search later</span></span><br><span class="line">    build, land = [], <span class="built_in">set</span>()</span><br><span class="line">    <span class="keyword">for</span> x,y <span class="keyword">in</span> itertools.product(<span class="built_in">range</span>(<span class="built_in">len</span>(grid)), <span class="built_in">range</span>(<span class="built_in">len</span>(grid[<span class="number">0</span>]))):</span><br><span class="line">        <span class="keyword">if</span> grid[x][y] == <span class="number">0</span>:</span><br><span class="line">            land.add((x,y))</span><br><span class="line">        <span class="keyword">elif</span> grid[x][y] == <span class="number">1</span>:</span><br><span class="line">            build.append((x,y))</span><br><span class="line">    <span class="comment"># if there is no empty land available, we can&#x27;t proceed further</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> land:</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># create a dictionary where each land&#x27;s position tuple is a key and its value</span></span><br><span class="line">    <span class="comment"># is a list of length equal to the number of buildings we found above. </span></span><br><span class="line">    <span class="comment"># This list is populated with Inf, to start with, that will be updated by the</span></span><br><span class="line">    <span class="comment"># shortest distance between the land and building pair, found by BFS routine below.</span></span><br><span class="line">    d = &#123;x: [<span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)]*<span class="built_in">len</span>(build) <span class="keyword">for</span> x <span class="keyword">in</span> land&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># BFS for a given building&#x27;s location</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">BFS</span>(<span class="params">loc</span>):</span></span><br><span class="line">        x, y = build[loc]</span><br><span class="line">        <span class="comment"># (x,y) is building&#x27;s location on the grid and 0 is the starting distance</span></span><br><span class="line">        q = collections.deque([(x,y,<span class="number">0</span>)]) </span><br><span class="line">        <span class="keyword">while</span> q:</span><br><span class="line">            x, y, dist = q.popleft()</span><br><span class="line">            <span class="keyword">for</span> i, j <span class="keyword">in</span> [(x-<span class="number">1</span>, y), (x+<span class="number">1</span>, y), (x, y-<span class="number">1</span>), (x, y+<span class="number">1</span>)]:</span><br><span class="line">                <span class="comment"># we are interested in only traversing lands whose recorded distance from</span></span><br><span class="line">                <span class="comment"># current building is more than dist+1. We update their distance and include</span></span><br><span class="line">                <span class="comment"># these lands in our queue for the next layer, if that&#x27;s the case</span></span><br><span class="line">                <span class="keyword">if</span> (i,j) <span class="keyword">in</span> land <span class="keyword">and</span> d[(i,j)][loc] &gt; dist + <span class="number">1</span>:</span><br><span class="line">                    d[(i,j)][loc] = dist + <span class="number">1</span></span><br><span class="line">                    q.append((i,j,dist+<span class="number">1</span>))</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># run BFS routine for all buildings</span></span><br><span class="line">    <span class="keyword">for</span> loc <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(build)):</span><br><span class="line">        BFS(loc)</span><br><span class="line">        </span><br><span class="line">    <span class="comment"># compute the shortest distance to all buildings for each empty land</span></span><br><span class="line">    min_dist = <span class="built_in">min</span>(<span class="built_in">sum</span>(d[x]) <span class="keyword">for</span> x <span class="keyword">in</span> land)</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span> <span class="keyword">if</span> min_dist == <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>) <span class="keyword">else</span> min_dist</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>1293. Shortest Path in a Grid with Obstacles Elimination</summary>
<blockquote>
<p>Use BFS like a sonar to explore all possible next steps, and once target is in the explored area, meaning we find a solution. Use a queue to store candidates and a set to store visited positions. Keep track of total steps taken, current position, and quota. If quota is still valid and position is not visited, add it to visited set and the queue.</p>
</blockquote>
<p>Run time: $O(nk)$, where n is the number of cells in the grid, k is the quota, space: $O(nk)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">shortestPath</span>(<span class="params">self, grid, k</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    :type grid: List[List[int]]</span></span><br><span class="line"><span class="string">    :type k: int</span></span><br><span class="line"><span class="string">    :rtype: int</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    r, c = <span class="built_in">len</span>(grid), <span class="built_in">len</span>(grid[<span class="number">0</span>])</span><br><span class="line">    target = (r-<span class="number">1</span>, c-<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">if</span> k &gt;= r+c-<span class="number">2</span>: <span class="comment"># if quota is greater than min # steps</span></span><br><span class="line">        <span class="keyword">return</span> r+c-<span class="number">2</span></span><br><span class="line">    </span><br><span class="line">    state = (<span class="number">0</span>, <span class="number">0</span>, k) <span class="comment"># position, and quota</span></span><br><span class="line">    queue = deque([(<span class="number">0</span>, state)]) <span class="comment"># steps taken, position, and quota</span></span><br><span class="line">    visited = <span class="built_in">set</span>([state])</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> queue:</span><br><span class="line">        steps, (row, col, k) = queue.popleft()</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (row, col) == target: <span class="comment"># reach the end</span></span><br><span class="line">            <span class="keyword">return</span> steps</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># explore next steps</span></span><br><span class="line">        <span class="keyword">for</span> new_r, new_c <span class="keyword">in</span> [(row, col+<span class="number">1</span>), (row+<span class="number">1</span>, col), (row, col-<span class="number">1</span>), (row-<span class="number">1</span>, col)]:</span><br><span class="line">            <span class="keyword">if</span> <span class="number">0</span> &lt;= new_r &lt; r <span class="keyword">and</span> <span class="number">0</span> &lt;= new_c &lt; c:</span><br><span class="line">                new_k = k - grid[new_r][new_c] <span class="comment"># unchange if no block here</span></span><br><span class="line">                new_state = (new_r, new_c, new_k)</span><br><span class="line">                <span class="keyword">if</span> new_k &gt;= <span class="number">0</span> <span class="keyword">and</span> new_state <span class="keyword">not</span> <span class="keyword">in</span> visited:</span><br><span class="line">                    visited.add(new_state)</span><br><span class="line">                    queue.append((steps+<span class="number">1</span>, new_state))</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure>
</details>
<h1>DFS</h1>
<details>
<summary></summary>
> 
<p>Run time: $O()$, space: $O()$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>286. Walls and Gates</summary>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/walls-and-gates/discuss/387339/Python-BFS-and-DFS">https://leetcode.com/problems/walls-and-gates/discuss/387339/Python-BFS-and-DFS</a></p>
</blockquote>
<p>Run time: $O(mn)$, space: $O(mn)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">wallsAndGates</span>(<span class="params">self, rooms: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Do not return anything, modify rooms in-place instead.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">rooms, r, c, d</span>):</span></span><br><span class="line">        <span class="keyword">for</span> x, y <span class="keyword">in</span> [(-<span class="number">1</span>,<span class="number">0</span>), (<span class="number">1</span>,<span class="number">0</span>), (<span class="number">0</span>,-<span class="number">1</span>), (<span class="number">0</span>,<span class="number">1</span>)]:</span><br><span class="line">            <span class="keyword">if</span> <span class="number">0</span> &lt;= r+x &lt; <span class="built_in">len</span>(rooms) <span class="keyword">and</span> <span class="number">0</span> &lt;= c+y &lt; <span class="built_in">len</span>(rooms[<span class="number">0</span>]) <span class="keyword">and</span> rooms[r+x][c+y] &gt; rooms[r][c]:</span><br><span class="line">                rooms[r+x][c+y] = d + <span class="number">1</span></span><br><span class="line">                dfs(rooms, r+x, c+y, d+<span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> rooms:</span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line">    <span class="keyword">for</span> r <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(rooms)):</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(rooms[<span class="number">0</span>])):</span><br><span class="line">            <span class="keyword">if</span> rooms[r][c] == <span class="number">0</span>:</span><br><span class="line">                dfs(rooms, r, c, <span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>BFS.</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">wallsAndGates</span>(<span class="params">self, rooms: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Do not return anything, modify rooms in-place instead.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> rooms:</span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line">    <span class="comment"># Initialize the queue with all 0s</span></span><br><span class="line">    R, C = <span class="built_in">len</span>(rooms), <span class="built_in">len</span>(rooms[<span class="number">0</span>])</span><br><span class="line">    q = collections.deque()</span><br><span class="line">    <span class="keyword">for</span> r <span class="keyword">in</span> <span class="built_in">range</span>(R):</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> <span class="built_in">range</span>(C):</span><br><span class="line">            <span class="keyword">if</span> rooms[r][c] == <span class="number">0</span>:</span><br><span class="line">                q.append((r, c))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> q:</span><br><span class="line">        r, c = q.popleft()</span><br><span class="line">        <span class="keyword">for</span> x, y <span class="keyword">in</span> [(-<span class="number">1</span>, <span class="number">0</span>), (<span class="number">1</span>, <span class="number">0</span>), (<span class="number">0</span>, -<span class="number">1</span>), (<span class="number">0</span>, <span class="number">1</span>)]:</span><br><span class="line">            <span class="keyword">if</span> <span class="number">0</span> &lt;= r+x &lt; R <span class="keyword">and</span> <span class="number">0</span> &lt;= c+y &lt; C <span class="keyword">and</span> rooms[r+x][c+y] &gt; rooms[r][c]:</span><br><span class="line">                rooms[r+x][c+y] = rooms[r][c] + <span class="number">1</span></span><br><span class="line">                q.append((r+x, c+y))</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>1368. Minimum Cost to Make at Least One Valid Path in a Grid</summary>
<blockquote>
<p>First, we start from (0,0) and explore other nodes based on direction. We set the corresponding position in the dp matrix to be 0 if it is not visited, and we also add this node to a queue.<br>
Next, we iterate the queue, for each node, we try changing it to all three other directions, and call helper function recursively so that unvisited position are added to queue.</p>
</blockquote>
<p>Run time: $O(mn)$, space: $O(mn)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">minCost</span>(<span class="params">self, grid: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">    m,n = <span class="built_in">len</span>(grid), <span class="built_in">len</span>(grid[<span class="number">0</span>])</span><br><span class="line">    queue = deque()</span><br><span class="line">    dp = [[<span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)]*n <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m)]</span><br><span class="line">    dirs = [(<span class="number">0</span>, <span class="number">1</span>), (<span class="number">0</span>, -<span class="number">1</span>), (<span class="number">1</span>, <span class="number">0</span>), (-<span class="number">1</span>, <span class="number">0</span>)]</span><br><span class="line">    k = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">i, j</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> (<span class="number">0</span> &lt;= i &lt; m <span class="keyword">and</span> <span class="number">0</span> &lt;= j &lt; n) <span class="keyword">or</span> dp[i][j] != <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>):</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        dp[i][j] = k</span><br><span class="line">        queue.append((i, j))</span><br><span class="line">        </span><br><span class="line">        next_dir = grid[i][j] - <span class="number">1</span></span><br><span class="line">        x, y = dirs[next_dir]</span><br><span class="line">        di, dj = i+x, j+y</span><br><span class="line">        </span><br><span class="line">        dfs(di, dj)</span><br><span class="line">    </span><br><span class="line">    dfs(<span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> queue:</span><br><span class="line">        k += <span class="number">1</span></span><br><span class="line">        size = <span class="built_in">len</span>(queue)</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(size):</span><br><span class="line">            i, j = queue.popleft()</span><br><span class="line">            <span class="keyword">for</span> x, y <span class="keyword">in</span> dirs:</span><br><span class="line">                di, dj = i+x, j+y</span><br><span class="line">                dfs(di, dj)</span><br><span class="line">    <span class="keyword">return</span> dp[-<span class="number">1</span>][-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>834. Sum of Distances in Tree</summary>
<blockquote>
<p>Key idea: Once we get a node as a base and get the sum of distances, when we move the root/base to another node, nodes that are closer to the previous base will have less distance, nodes that are far from the previous base will have more distance.<br>
<strong>formula = parent_sum - #closer nodes + #further nodes</strong><br>
Create a dictionary that stores the edges in undirected graph. Maintain one array that tracks the number of closer nodes, and one answer array, and one set that tracks visited nodes.<br>
In the first dfs, we set 0 as the base node, to find out the number of total distances between each node. For each unvisited child, we call function recursively to get the number of child nodes, then update the number of closer nodes and the first entry of the answer array. After the for loop ends, we update the closer_nodes_count to be the number of closer nodes, and return it. This way we could fill in the closer_nodes_count array so that next dfs would help get the total distances for each node as root.<br>
Second dfs implement the formula and call it recursively.<br>
<a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=dkPYrvq5EmY">https://www.youtube.com/watch?v=dkPYrvq5EmY</a></p>
</blockquote>
<p>Run time: $O(n)$, space: $O(n)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sumOfDistancesInTree</span>(<span class="params">self, n: <span class="built_in">int</span>, edges: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span></span><br><span class="line">    <span class="comment"># formula = parent_sum - #closer nodes + #further nodes</span></span><br><span class="line">    graph = defaultdict(<span class="built_in">list</span>)</span><br><span class="line">    <span class="keyword">for</span> u, v <span class="keyword">in</span> edges:</span><br><span class="line">        graph[u].append(v)</span><br><span class="line">        graph[v].append(u)</span><br><span class="line">    </span><br><span class="line">    closer_nodes_count = [<span class="number">0</span>] * n</span><br><span class="line">    ans = [<span class="number">0</span>] * n</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">cur</span>):</span></span><br><span class="line">        num_closer_nodes = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> child <span class="keyword">in</span> graph[cur]:</span><br><span class="line">            <span class="keyword">if</span> child <span class="keyword">not</span> <span class="keyword">in</span> seen:</span><br><span class="line">                seen.add(child)</span><br><span class="line">                child_nodes_count = dfs(child)</span><br><span class="line">                num_closer_nodes += child_nodes_count</span><br><span class="line">                ans[<span class="number">0</span>] += child_nodes_count</span><br><span class="line">                </span><br><span class="line">        closer_nodes_count[cur] = num_closer_nodes</span><br><span class="line">        <span class="keyword">return</span> num_closer_nodes</span><br><span class="line">    </span><br><span class="line">    seen = <span class="built_in">set</span>()</span><br><span class="line">    seen.add(<span class="number">0</span>)</span><br><span class="line">    dfs(<span class="number">0</span>) <span class="comment"># populating closer_nodes_count and asn[0]</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs2</span>(<span class="params">cur</span>):</span></span><br><span class="line">        <span class="keyword">for</span> child <span class="keyword">in</span> graph[cur]:</span><br><span class="line">            <span class="comment"># use parent to calculate the answer for child nodes</span></span><br><span class="line">            <span class="keyword">if</span> child <span class="keyword">not</span> <span class="keyword">in</span> seen:</span><br><span class="line">                seen.add(child)</span><br><span class="line">                ans[child] = ans[cur] - closer_nodes_count[child] + (n-closer_nodes_count[child])</span><br><span class="line">                dfs2(child)</span><br><span class="line">    </span><br><span class="line">    seen = <span class="built_in">set</span>()</span><br><span class="line">    seen.add(<span class="number">0</span>)</span><br><span class="line">    dfs2(<span class="number">0</span>) <span class="comment"># use ans[0] as base to populate all other nodes&#x27; answer</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>133. Clone Graph</summary>
<blockquote>
<p>Create a dictionary to store &lt;original node, duplicate node&gt;, then call helper function to loop through all neighbors. If it exists in the dictionary, we just add it to the neighbor list. Otherwise, we duplicate it, add it to the dictionary, append it to neighbor list, call function recursively.</p>
</blockquote>
<p>Run time: $O(n)$, space: $O(n)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">cloneGraph</span>(<span class="params">self, node: <span class="string">&#x27;Node&#x27;</span></span>) -&gt; &#x27;Node&#x27;:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">node, dic</span>):</span></span><br><span class="line">            <span class="keyword">for</span> neighbor <span class="keyword">in</span> node.neighbors:</span><br><span class="line">                <span class="keyword">if</span> neighbor <span class="keyword">in</span> dic:</span><br><span class="line">                    dic[node].neighbors.append(dic[neighbor])</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    neighborCopy = Node(neighbor.val, [])</span><br><span class="line">                    dic[neighbor] = neighborCopy</span><br><span class="line">                    dic[node].neighbors.append(neighborCopy)</span><br><span class="line">                    dfs(neighbor, dic)         </span><br><span class="line">                </span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">            <span class="keyword">return</span> </span><br><span class="line">        nodeCopy = Node(node.val, [])</span><br><span class="line">        dic = &#123;node: nodeCopy&#125;</span><br><span class="line">        dfs(node, dic)</span><br><span class="line">        <span class="keyword">return</span> nodeCopy</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>1284. Minimum Number of Flips to Convert Binary Matrix to Zero Matrix</summary>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/minimum-number-of-flips-to-convert-binary-matrix-to-zero-matrix/discuss/819269/python-dfsbacktracking-with-no-memo">https://leetcode.com/problems/minimum-number-of-flips-to-convert-binary-matrix-to-zero-matrix/discuss/819269/python-dfsbacktracking-with-no-memo</a></p>
</blockquote>
<p>Run time: $O(2^{mn}mn)$, space: $O(mn)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">minFlips</span>(<span class="params">self, mat: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">flip</span>(<span class="params">i,j</span>):</span></span><br><span class="line">        dirs = [(i,j),(i,j+<span class="number">1</span>),(i,j-<span class="number">1</span>),(i+<span class="number">1</span>,j),(i-<span class="number">1</span>,j)]</span><br><span class="line">        <span class="keyword">for</span> x,y <span class="keyword">in</span> dirs:</span><br><span class="line">            <span class="keyword">if</span> <span class="number">0</span> &lt;= x &lt; m <span class="keyword">and</span> <span class="number">0</span> &lt;= y &lt; n:</span><br><span class="line">                mat[x][y] ^= <span class="number">1</span></span><br><span class="line">                </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">allZeros</span>():</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sum</span>(<span class="built_in">sum</span>(row) <span class="keyword">for</span> row <span class="keyword">in</span> mat) == <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span>(<span class="params">pos, moves</span>):</span></span><br><span class="line">        <span class="keyword">if</span> allZeros():</span><br><span class="line">            self.res=<span class="built_in">min</span>(self.res,moves)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> pos:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(pos)):</span><br><span class="line">            x,y = pos[i]</span><br><span class="line">            flip(x,y)</span><br><span class="line">            helper(pos[i+<span class="number">1</span>:], moves+<span class="number">1</span>)</span><br><span class="line">            flip(x,y)</span><br><span class="line">            </span><br><span class="line">            </span><br><span class="line">    m,n = <span class="built_in">len</span>(mat), <span class="built_in">len</span>(mat[<span class="number">0</span>])</span><br><span class="line">    self.res = <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)</span><br><span class="line">    pos = [(x,y) <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(mat)) <span class="keyword">for</span> y <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(mat[<span class="number">0</span>]))]</span><br><span class="line">    helper(pos, <span class="number">0</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> self.res != <span class="built_in">float</span>(<span class="string">&#x27;+inf&#x27;</span>):</span><br><span class="line">        <span class="keyword">return</span> self.res </span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>785. Is Graph Bipartite?</summary>
<blockquote>
<p>We’ll keep an array (or hashmap) to lookup the color of each node: color[node]. The colors could be 0, 1, or uncolored (-1 or null).<br>
We should be careful to consider disconnected components of the graph, by searching each node. For each uncolored node, we’ll start the coloring process by doing a depth-first-search on that node. Every neighbor gets colored the opposite color from the current node. If we find a neighbor colored the same color as the current node, then our coloring was impossible.</p>
</blockquote>
<p>Run time: $O(n+e)$, space: $O(n)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isBipartite</span>(<span class="params">self, graph: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">    color = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> node <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(graph)):</span><br><span class="line">        <span class="keyword">if</span> node <span class="keyword">not</span> <span class="keyword">in</span> color:</span><br><span class="line">            stack = [node]</span><br><span class="line">            color[node] = <span class="number">0</span></span><br><span class="line">            <span class="keyword">while</span> stack:</span><br><span class="line">                node = stack.pop()</span><br><span class="line">                <span class="keyword">for</span> neighbor <span class="keyword">in</span> graph[node]:</span><br><span class="line">                    <span class="keyword">if</span> neighbor <span class="keyword">not</span> <span class="keyword">in</span> color:</span><br><span class="line">                        stack.append(neighbor)</span><br><span class="line">                        color[neighbor] = color[node] ^ <span class="number">1</span></span><br><span class="line">                    <span class="keyword">elif</span> color[neighbor] == color[node]:</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>417. Pacific Atlantic Water Flow</summary>
> Use two matrices of the same size to determine whether one position is reachable from the top left and bottom right corner. If the cell from both matrices are true, then it is reachable to both corners. In the helper function, if this position is already marked true, then return. Otherwise, marked it as true, and explore the four neighbors.
<p>Run time: $O(mn)$, space: $O(mn)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pacificAtlantic</span>(<span class="params">self, heights</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    :type heights: List[List[int]]</span></span><br><span class="line"><span class="string">    :rtype: List[List[int]]</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    dirs = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, <span class="number">0</span>]</span><br><span class="line">    m, n = <span class="built_in">len</span>(heights), <span class="built_in">len</span>(heights[<span class="number">0</span>])</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">heights, reach, x, y</span>):</span></span><br><span class="line">        <span class="keyword">if</span> reach[x][y]:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        reach[x][y] = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">            next_x, next_y = x+dirs[i], y+dirs[i+<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">if</span> <span class="number">0</span> &lt;= next_x &lt; m <span class="keyword">and</span> <span class="number">0</span> &lt;= next_y &lt; n <span class="keyword">and</span> heights[x][y] &lt;= heights[next_x][next_y]:</span><br><span class="line">                dfs(heights, reach, next_x, next_y)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> heights <span class="keyword">or</span> <span class="built_in">len</span>(heights[<span class="number">0</span>]) == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line">    </span><br><span class="line">    reachable_p = [[<span class="literal">False</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m)] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">    reachable_a = [[<span class="literal">False</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m)] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">    ans = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">        dfs(heights, reachable_p, i, <span class="number">0</span>)</span><br><span class="line">        dfs(heights, reachable_a, i, n-<span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(heights[<span class="number">0</span>])):</span><br><span class="line">        dfs(heights, reachable_p, <span class="number">0</span>, i)</span><br><span class="line">        dfs(heights, reachable_a, m-<span class="number">1</span>, i)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">if</span> reachable_p[i][j] <span class="keyword">and</span> reachable_a[i][j]:</span><br><span class="line">                ans.append([i,j])</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>547. Number of Provinces</summary>
<blockquote>
<p>In order to find the number of connected components in an undirected graph, one of the simplest methods is to make use of Depth First Search starting from every node. We make use of visitedvisited array of size N(M is of size NxN).</p>
</blockquote>
<p>Run time: $O(n^2)$, space: $O(n)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findCircleNum</span>(<span class="params">self, isConnected</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    :type isConnected: List[List[int]]</span></span><br><span class="line"><span class="string">    :rtype: int</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">isConnected, i, visited</span>):</span></span><br><span class="line">        visited.add(i)</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(isConnected)):</span><br><span class="line">            <span class="keyword">if</span> isConnected[i][j] == <span class="number">1</span> <span class="keyword">and</span> j <span class="keyword">not</span> <span class="keyword">in</span> visited:</span><br><span class="line">                dfs(isConnected, j, visited)</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> isConnected:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    visited = <span class="built_in">set</span>()</span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(isConnected)):</span><br><span class="line">        <span class="keyword">if</span> i <span class="keyword">not</span> <span class="keyword">in</span> visited:</span><br><span class="line">            dfs(isConnected, i, visited)</span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> count</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>695. Max Area of Island</summary>
> in the helper function, change the grid value from 1 to 0, then call the function again for the four directions plus 1.
<p>Run time: $O(n^2)$, space: $O(1)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">maxAreaOfIsland</span>(<span class="params">self, grid</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    :type grid: List[List[int]]</span></span><br><span class="line"><span class="string">    :rtype: int</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">grid, i, j</span>):</span></span><br><span class="line">        <span class="keyword">if</span> i &lt; <span class="number">0</span> <span class="keyword">or</span> i &gt;= <span class="built_in">len</span>(grid) <span class="keyword">or</span> j &lt; <span class="number">0</span> <span class="keyword">or</span> j &gt;= <span class="built_in">len</span>(grid[<span class="number">0</span>]) <span class="keyword">or</span> grid[i][j] == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        grid[i][j] = <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>+dfs(grid,i+<span class="number">1</span>,j)+dfs(grid,i-<span class="number">1</span>,j)+dfs(grid,i,j+<span class="number">1</span>)+dfs(grid,i,j-<span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> grid <span class="keyword">or</span> <span class="built_in">len</span>(grid) == <span class="number">0</span> <span class="keyword">or</span> <span class="built_in">len</span>(grid[<span class="number">0</span>]) == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    max_area = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(grid)):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(grid[<span class="number">0</span>])):</span><br><span class="line">            max_area = <span class="built_in">max</span>(max_area, dfs(grid, i, j))</span><br><span class="line">    <span class="keyword">return</span> max_area</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>366. Find Leaves of Binary Tree</summary>
> Create helper function that gets the height of a node. In the function, use post-order traversal to get the height of the left and right child, then set the max of them + 1 as the height of given node. Put <height, node.val> in a dictionary.
<p>Run time: $O(n)$, space: $O(n)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findLeaves</span>(<span class="params">self, root: <span class="string">&#x27;TreeNode&#x27;</span></span>) -&gt; &#x27;<span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]&#x27;:</span></span><br><span class="line">    res = []</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">root</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        height = <span class="built_in">max</span>(dfs(root.left), dfs(root.right)) + <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> height &gt;= <span class="built_in">len</span>(res):</span><br><span class="line">            res.append([])</span><br><span class="line">        res[height].append(root.val)</span><br><span class="line">        <span class="keyword">return</span> height</span><br><span class="line">    dfs(root)</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<details>
<summary>my implementation</summary>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findLeaves</span>(<span class="params">self, root</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    :type root: TreeNode</span></span><br><span class="line"><span class="string">    :rtype: List[List[int]]</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    d = &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getHeight</span>(<span class="params">node</span>):</span></span><br><span class="line">        <span class="keyword">if</span> node <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        leftH = getHeight(node.left)</span><br><span class="line">        rightH = getHeight(node.right)</span><br><span class="line">        currH = <span class="built_in">max</span>(leftH, rightH)+<span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> currH <span class="keyword">in</span> d:</span><br><span class="line">            d[currH].append(node.val)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            d[currH] = [node.val]</span><br><span class="line">        <span class="keyword">return</span> currH</span><br><span class="line">    </span><br><span class="line">    ans = []</span><br><span class="line">    getHeight(root)</span><br><span class="line">    <span class="keyword">for</span> k, v <span class="keyword">in</span> d.items():</span><br><span class="line">        ans.append(v)</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
</details>
</details>
<h2 id="Backtracking">Backtracking</h2>
<details>
<summary></summary>
> 
<p>Run time: $O()$, space: $O()$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>465. Optimal Account Balancing</summary>
<blockquote>
<p>Store non-zero balance to a list, then use backtracking to loop through all unvisited balances (look forward), and if their balance has different sign, update the candidate’s balance, minimize ans by calling backtracking function recursively plus 1.<br>
<a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=B8pPWgLa2lQ">https://www.youtube.com/watch?v=B8pPWgLa2lQ</a></p>
</blockquote>
<p>Run time: $O(n^2)$, space: $O(n)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">minTransfers</span>(<span class="params">self, transactions: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">    debts = defaultdict(<span class="built_in">int</span>)</span><br><span class="line">    <span class="keyword">for</span> f, t, amt <span class="keyword">in</span> transactions:</span><br><span class="line">        debts[f] -= amt</span><br><span class="line">        debts[t] += amt</span><br><span class="line">    </span><br><span class="line">    debts_list = [debts[<span class="built_in">id</span>] <span class="keyword">for</span> <span class="built_in">id</span> <span class="keyword">in</span> debts <span class="keyword">if</span> debts[<span class="built_in">id</span>] != <span class="number">0</span>]</span><br><span class="line">    </span><br><span class="line">    n = <span class="built_in">len</span>(debts_list)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">backtrack</span>(<span class="params">ind</span>):</span></span><br><span class="line">        <span class="keyword">while</span> ind &lt; n <span class="keyword">and</span> debts_list[ind] == <span class="number">0</span>:</span><br><span class="line">            ind += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> ind == n:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        ans = <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(ind+<span class="number">1</span>, n):</span><br><span class="line">            <span class="keyword">if</span> debts_list[ind] * debts_list[i] &lt; <span class="number">0</span>:</span><br><span class="line">                debts_list[i] += debts_list[ind]</span><br><span class="line">                ans = <span class="built_in">min</span>(ans, backtrack(ind+<span class="number">1</span>)+<span class="number">1</span>)</span><br><span class="line">                debts_list[i] -= debts_list[ind]</span><br><span class="line">        <span class="keyword">return</span> ans</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> backtrack(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>489. Robot Room Cleaner</summary>
<blockquote>
<p>This solution is based on the same idea as maze solving algorithm called right-hand rule. Go forward, cleaning and marking all the cells on the way as visited. At the obstacle turn right, again go forward, etc. Always turn right at the obstacles and then go forward. Consider already visited cells as virtual obstacles.</p>
</blockquote>
<p>Run time: $O(N−M)$, space: $O(N−M)$, where $N$ is a number of cells in the room and $M$ is a number of obstacles.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cleanRoom</span>(<span class="params">self, robot</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    :type robot: Robot</span></span><br><span class="line"><span class="string">    :rtype: None</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">go_back</span>():</span></span><br><span class="line">        robot.turnRight()</span><br><span class="line">        robot.turnRight()</span><br><span class="line">        robot.move()</span><br><span class="line">        robot.turnLeft()</span><br><span class="line">        robot.turnLeft()</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">backtrack</span>(<span class="params">cell = (<span class="params"><span class="number">0</span>, <span class="number">0</span></span>), d = <span class="number">0</span></span>):</span></span><br><span class="line">        visited.add(cell)</span><br><span class="line">        robot.clean()</span><br><span class="line">        <span class="comment"># going clockwise : 0: &#x27;up&#x27;, 1: &#x27;right&#x27;, 2: &#x27;down&#x27;, 3: &#x27;left&#x27;</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">            new_d = (d + i) % <span class="number">4</span></span><br><span class="line">            new_cell = (cell[<span class="number">0</span>] + directions[new_d][<span class="number">0</span>], \</span><br><span class="line">                        cell[<span class="number">1</span>] + directions[new_d][<span class="number">1</span>])</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> new_cell <span class="keyword">not</span> <span class="keyword">in</span> visited <span class="keyword">and</span> robot.move():</span><br><span class="line">                backtrack(new_cell, new_d)</span><br><span class="line">                go_back()</span><br><span class="line">            <span class="comment"># turn the robot following chosen direction : clockwise</span></span><br><span class="line">            robot.turnRight()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># going clockwise : 0: &#x27;up&#x27;, 1: &#x27;right&#x27;, 2: &#x27;down&#x27;, 3: &#x27;left&#x27;</span></span><br><span class="line">    directions = [(-<span class="number">1</span>, <span class="number">0</span>), (<span class="number">0</span>, <span class="number">1</span>), (<span class="number">1</span>, <span class="number">0</span>), (<span class="number">0</span>, -<span class="number">1</span>)]</span><br><span class="line">    visited = <span class="built_in">set</span>()</span><br><span class="line">    backtrack()</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>301. Remove Invalid Parentheses</summary>
<blockquote>
<p>BFS.</p>
</blockquote>
<p>Run time: $O(2^n)$, space: $O(2^n)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">removeInvalidParentheses</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">str</span>]:</span></span><br><span class="line">    <span class="comment"># initialize a set with one element</span></span><br><span class="line">    <span class="comment"># set is used here in order to avoid duplicate element</span></span><br><span class="line">    level = &#123;s&#125;</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        valid = []</span><br><span class="line">        <span class="keyword">for</span> elem <span class="keyword">in</span> level:</span><br><span class="line">            <span class="keyword">if</span> self.isValid(elem):</span><br><span class="line">                valid.append(elem)</span><br><span class="line">        <span class="keyword">if</span> valid:</span><br><span class="line">            <span class="keyword">return</span> valid</span><br><span class="line">        <span class="comment"># initialize an empty set</span></span><br><span class="line">        new_level = <span class="built_in">set</span>()</span><br><span class="line">        <span class="comment"># BFS</span></span><br><span class="line">        <span class="keyword">for</span> elem <span class="keyword">in</span> level:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(elem)):</span><br><span class="line">                new_level.add(elem[:i] + elem[i + <span class="number">1</span>:])</span><br><span class="line">        level = new_level</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isValid</span>(<span class="params">self,s</span>):</span></span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> c <span class="keyword">in</span> s:</span><br><span class="line">        <span class="keyword">if</span> c == <span class="string">&#x27;(&#x27;</span>:</span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> c == <span class="string">&#x27;)&#x27;</span>:</span><br><span class="line">            count -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> count &lt; <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> count == <span class="number">0</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>Backtracking, DFS</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">removeInvalidParentheses</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">str</span>]:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isValid</span>(<span class="params">s</span>):</span></span><br><span class="line">        stack = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)):</span><br><span class="line">            <span class="keyword">if</span>( s[i] == <span class="string">&#x27;(&#x27;</span> ):</span><br><span class="line">                stack.append( (i,<span class="string">&#x27;(&#x27;</span>) )</span><br><span class="line">            <span class="keyword">elif</span>( s[i] == <span class="string">&#x27;)&#x27;</span> ):</span><br><span class="line">                <span class="keyword">if</span>(stack <span class="keyword">and</span> stack[-<span class="number">1</span>][<span class="number">1</span>] == <span class="string">&#x27;(&#x27;</span>):</span><br><span class="line">                    stack.pop()</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    stack.append( (i,<span class="string">&#x27;)&#x27;</span>) )         <span class="comment"># pushing invalid close braces also</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(stack) == <span class="number">0</span>, stack</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params"> s, left, right</span>):</span></span><br><span class="line">        visited.add(s)</span><br><span class="line">        <span class="keyword">if</span> left == <span class="number">0</span> <span class="keyword">and</span> right == <span class="number">0</span> <span class="keyword">and</span> isValid(s)[<span class="number">0</span>]:  res.append(s)</span><br><span class="line">        <span class="keyword">for</span> i, ch <span class="keyword">in</span> <span class="built_in">enumerate</span>(s):</span><br><span class="line">            <span class="keyword">if</span> ch != <span class="string">&#x27;(&#x27;</span> <span class="keyword">and</span> ch != <span class="string">&#x27;)&#x27;</span>: <span class="keyword">continue</span>                                    <span class="comment"># if it is any other char ignore.</span></span><br><span class="line">            <span class="keyword">if</span> (ch == <span class="string">&#x27;(&#x27;</span> <span class="keyword">and</span> left == <span class="number">0</span>) <span class="keyword">or</span> (ch == <span class="string">&#x27;)&#x27;</span> <span class="keyword">and</span> right == <span class="number">0</span>): <span class="keyword">continue</span>    <span class="comment"># if left == 0 then removing &#x27;(&#x27; will only cause imbalance. Hence, skip.</span></span><br><span class="line">            <span class="keyword">if</span> s[:i] + s[i+<span class="number">1</span>:] <span class="keyword">not</span> <span class="keyword">in</span> visited:</span><br><span class="line">                dfs( s[:i] + s[i+<span class="number">1</span>:], left - (ch == <span class="string">&#x27;(&#x27;</span>), right - (ch == <span class="string">&#x27;)&#x27;</span>) )</span><br><span class="line">    </span><br><span class="line">    stack = isValid(s)[<span class="number">1</span>]</span><br><span class="line">    lc = <span class="built_in">sum</span>([<span class="number">1</span> <span class="keyword">for</span> val <span class="keyword">in</span> stack <span class="keyword">if</span> val[<span class="number">1</span>] == <span class="string">&quot;(&quot;</span>]) <span class="comment"># num of left braces</span></span><br><span class="line">    rc = <span class="built_in">len</span>(stack) - lc</span><br><span class="line">    </span><br><span class="line">    res, visited = [], <span class="built_in">set</span>()</span><br><span class="line">    dfs(s, lc, rc)</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>79. Word Search</summary>
<blockquote>
<p>Go through each entry, and in the helper function, check edge cases. If word length is zero, then it means this word has been found. Set the current entry to be #, call functions in four directions recursively, then reverse the change, return the result.</p>
</blockquote>
<p>Run time: $O(n\cdot 3^L)$, space: $O(L)$, where $n$ is the number of cells in the board, $L$ is the length of the word to be matched, 3 is the number of further choices in the next step</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exist</span>(<span class="params">self, board, word</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    :type board: List[List[str]]</span></span><br><span class="line"><span class="string">    :type word: str</span></span><br><span class="line"><span class="string">    :rtype: bool</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># check whether can find word, start at (i,j) position    </span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">board, i, j, word</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(word) == <span class="number">0</span>: <span class="comment"># all the characters are checked</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">if</span> i&lt;<span class="number">0</span> <span class="keyword">or</span> i&gt;=<span class="built_in">len</span>(board) <span class="keyword">or</span> j&lt;<span class="number">0</span> <span class="keyword">or</span> j&gt;=<span class="built_in">len</span>(board[<span class="number">0</span>]) <span class="keyword">or</span> word[<span class="number">0</span>]!=board[i][j]:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        tmp = board[i][j]  <span class="comment"># first character is found, check the remaining part</span></span><br><span class="line">        board[i][j] = <span class="string">&quot;#&quot;</span>  <span class="comment"># avoid visit agian </span></span><br><span class="line">        <span class="comment"># check whether can find &quot;word&quot; along one direction</span></span><br><span class="line">        res = dfs(board, i+<span class="number">1</span>, j, word[<span class="number">1</span>:]) <span class="keyword">or</span> dfs(board, i-<span class="number">1</span>, j, word[<span class="number">1</span>:]) \</span><br><span class="line">        <span class="keyword">or</span> dfs(board, i, j+<span class="number">1</span>, word[<span class="number">1</span>:]) <span class="keyword">or</span> dfs(board, i, j-<span class="number">1</span>, word[<span class="number">1</span>:])</span><br><span class="line">        board[i][j] = tmp</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> board:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(board)):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(board[<span class="number">0</span>])):</span><br><span class="line">            <span class="keyword">if</span> dfs(board, i, j, word):</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>77. Combinations</summary>
<blockquote>
<p>in the helper function, check whether current combination length equals to k, then append to the answer list. In the for loop, pass the array that skips the current element, the path that combines this element.</p>
</blockquote>
<p>Run time: $O(k {n \choose k})$, space: $O({n \choose k})$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">combine</span>(<span class="params">self, n, k</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    :type n: int</span></span><br><span class="line"><span class="string">    :type k: int</span></span><br><span class="line"><span class="string">    :rtype: List[List[int]]</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">nums, k, path, ans</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(path) == k:</span><br><span class="line">            ans.append(path)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            dfs(nums[i+<span class="number">1</span>:], k, path+[nums[i]], ans)</span><br><span class="line">            </span><br><span class="line">    ans = []</span><br><span class="line">    dfs(<span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">1</span>, n+<span class="number">1</span>)), k, [], ans)</span><br><span class="line">    <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>46. Permutations</summary>
> `[:]` makes a deep copy of the list. If you passed back the original list, it would be modified by future swaps. Otherwise the reference to the array is appended rather than the actual list.
<p>Run time: $O(\sum_{k=1}^n P(n, k))$, space: $O(n!)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">permute</span>(<span class="params">self, nums</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    :type nums: List[int]</span></span><br><span class="line"><span class="string">    :rtype: List[List[int]]</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">backtracking</span>(<span class="params">nums, level, ans</span>):</span></span><br><span class="line">        <span class="keyword">if</span> level == <span class="built_in">len</span>(nums)-<span class="number">1</span>:</span><br><span class="line">            ans.append(nums[:])</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(level, <span class="built_in">len</span>(nums)):</span><br><span class="line">            nums[i], nums[level] = nums[level], nums[i]</span><br><span class="line">            backtracking(nums, level+<span class="number">1</span>, ans)</span><br><span class="line">            nums[i], nums[level] = nums[level], nums[i]</span><br><span class="line">            </span><br><span class="line">            </span><br><span class="line">    ans = []</span><br><span class="line">    backtracking(nums, <span class="number">0</span>, ans)</span><br><span class="line">    <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">permute</span>(<span class="params">self, nums</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(nums) == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> [nums]</span><br><span class="line">    result = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">        others = nums[:i] + nums[i+<span class="number">1</span>:]</span><br><span class="line">        other_permutations = self.permute(others)</span><br><span class="line">        <span class="keyword">for</span> permutation <span class="keyword">in</span> other_permutations:</span><br><span class="line">            result.append([nums[i]] + permutation)</span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>282. Expression Add Operators</summary>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/expression-add-operators/discuss/71968/Clean-Python-DFS-with-comments">https://leetcode.com/problems/expression-add-operators/discuss/71968/Clean-Python-DFS-with-comments</a></p>
</blockquote>
<p>Run time: $O(n\cdot 4^n)$, space: $O(n)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">addOperators</span>(<span class="params">self, num, target</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    :type num: str</span></span><br><span class="line"><span class="string">    :type target: int</span></span><br><span class="line"><span class="string">    :rtype: List[str]</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">backtracking</span>(<span class="params">idx=<span class="number">0</span>, path=<span class="string">&#x27;&#x27;</span>, value=<span class="number">0</span>, prev=<span class="literal">None</span></span>):</span></span><br><span class="line">        <span class="keyword">if</span> idx == <span class="built_in">len</span>(num) <span class="keyword">and</span> value == target:</span><br><span class="line">            rtn.append(path)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">    </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(idx+<span class="number">1</span>, <span class="built_in">len</span>(num)+<span class="number">1</span>):</span><br><span class="line">            temp = <span class="built_in">int</span>(num[idx:i])</span><br><span class="line">            <span class="keyword">if</span> i == idx+<span class="number">1</span> <span class="keyword">or</span> (i &gt; idx+<span class="number">1</span> <span class="keyword">and</span> num[idx] != <span class="string">&#x27;0&#x27;</span>):</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> prev:</span><br><span class="line">                    backtracking(i, num[idx:i], temp, temp)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    backtracking(i, path+<span class="string">&#x27;+&#x27;</span>+num[idx:i], value+temp, temp)</span><br><span class="line">                    backtracking(i, path+<span class="string">&#x27;-&#x27;</span>+num[idx:i], value-temp, -temp)</span><br><span class="line">                    backtracking(i, path+<span class="string">&#x27;*&#x27;</span>+num[idx:i], value-prev+prev*temp, prev*temp)</span><br><span class="line">                    </span><br><span class="line">    rtn = []</span><br><span class="line">    backtracking()</span><br><span class="line">    <span class="keyword">return</span> rtn</span><br></pre></td></tr></table></figure>
</details>
<h1>Linked List &amp; Array</h1>
<details>
<summary></summary>
> 
<p>Run time: $O()$, space: $O()$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>54. Spiral Matrix</summary>
<blockquote>
<p>Maintain four variables - top, bottom, left, right, while they are valid, run four for loops and update them. In the end, if the output length is less than actual cells, run a nested for loop for the rest of the bounds.</p>
</blockquote>
<p>Run time: $O(mn)$, space: $O(1)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">spiralOrder</span>(<span class="params">self, matrix: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span></span><br><span class="line">    height = <span class="built_in">len</span>(matrix)</span><br><span class="line">    width = <span class="built_in">len</span>(matrix[<span class="number">0</span>])</span><br><span class="line">    </span><br><span class="line">    top = <span class="number">0</span></span><br><span class="line">    bottom = height - <span class="number">1</span></span><br><span class="line">    left = <span class="number">0</span></span><br><span class="line">    right = width - <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    ans = []</span><br><span class="line">    <span class="keyword">while</span> top &lt; bottom <span class="keyword">and</span> left &lt; right:</span><br><span class="line">        <span class="keyword">for</span> col <span class="keyword">in</span> <span class="built_in">range</span>(left, right):</span><br><span class="line">            ans.append(matrix[top][col])</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> row <span class="keyword">in</span> <span class="built_in">range</span>(top, bottom):</span><br><span class="line">            ans.append(matrix[row][right])</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> col <span class="keyword">in</span> <span class="built_in">range</span>(right, left, -<span class="number">1</span>):</span><br><span class="line">            ans.append(matrix[bottom][col])</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> row <span class="keyword">in</span> <span class="built_in">range</span>(bottom, top, -<span class="number">1</span>):</span><br><span class="line">            ans.append(matrix[row][left])</span><br><span class="line">        </span><br><span class="line">        top += <span class="number">1</span></span><br><span class="line">        bottom -= <span class="number">1</span></span><br><span class="line">        left += <span class="number">1</span></span><br><span class="line">        right -= <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># If a matrix remain inside it is either a 1xn or a mx1</span></span><br><span class="line">    <span class="comment"># a linear scan will return the same order as spiral for these</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(ans) &lt; height*width:</span><br><span class="line">        <span class="keyword">for</span> row <span class="keyword">in</span> <span class="built_in">range</span>(top, bottom+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> col <span class="keyword">in</span> <span class="built_in">range</span>(left, right+<span class="number">1</span>):</span><br><span class="line">                ans.append(matrix[row][col])</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>284. Peeking Iterator</summary>
<blockquote>
<p>Store the next value outside the iterator. When next is called return the stored value and populate with next value from iterator.</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PeekingIterator</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, iterator</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Initialize your data structure here.</span></span><br><span class="line"><span class="string">        :type iterator: Iterator</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self.<span class="built_in">iter</span> = iterator</span><br><span class="line">        self.temp = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">if</span> self.<span class="built_in">iter</span>.hasNext():</span><br><span class="line">            self.temp = self.<span class="built_in">iter</span>.<span class="built_in">next</span>()</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">peek</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Returns the next element in the iteration without advancing the iterator.</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> self.temp</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">next</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        ret = self.temp</span><br><span class="line">        self.temp = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">if</span> self.<span class="built_in">iter</span>.hasNext():</span><br><span class="line">            self.temp = self.<span class="built_in">iter</span>.<span class="built_in">next</span>()</span><br><span class="line">        <span class="keyword">return</span> ret</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hasNext</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> self.temp <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Your PeekingIterator object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"># iter = PeekingIterator(Iterator(nums))</span></span><br><span class="line"><span class="comment"># while iter.hasNext():</span></span><br><span class="line"><span class="comment">#     val = iter.peek()   # Get the next element but not advance the iterator.</span></span><br><span class="line"><span class="comment">#     iter.next()         # Should return the same value as [val].</span></span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>900. RLE Iterator</summary>
<blockquote>
<p>Keep track of the index, and increment 2 at a time once the number has been used up.</p>
</blockquote>
<p>Run time: $O(n)$, space: $O(n)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RLEIterator</span>:</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, A: <span class="type">List</span>[<span class="built_in">int</span>]</span>):</span></span><br><span class="line">        self.A = A</span><br><span class="line">        self.index = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">next</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="keyword">while</span> self.index &lt; <span class="built_in">len</span>(self.A):</span><br><span class="line">            <span class="keyword">if</span> n &lt;= self.A[self.index]:</span><br><span class="line">                self.A[self.index] -= n</span><br><span class="line">                <span class="keyword">return</span> self.A[self.index + <span class="number">1</span>]</span><br><span class="line">            n -= self.A[self.index]</span><br><span class="line">            self.index += <span class="number">2</span></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>23. Merge k Sorted Lists</summary>
<blockquote>
<p>Put &lt;value, node index in array, node&gt; to a heap, each time pop the smallest element, set the next element to be the next element, then push the next element back to the heap.</p>
</blockquote>
<p>Run time: $O(n\log k)$, space: $O(n)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mergeKLists</span>(<span class="params">self, lists: <span class="type">List</span>[<span class="type">Optional</span>[ListNode]]</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span></span><br><span class="line">    curr = head = ListNode(<span class="number">0</span>)</span><br><span class="line">    q = []</span><br><span class="line">    <span class="keyword">for</span> l_id, l <span class="keyword">in</span> <span class="built_in">enumerate</span>(lists):</span><br><span class="line">        <span class="keyword">if</span> l:</span><br><span class="line">            heapq.heappush(q, (l.val, l_id, l))</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">while</span> q:</span><br><span class="line">        _, l_id, temp = heapq.heappop(q)</span><br><span class="line">        curr.<span class="built_in">next</span> = temp</span><br><span class="line">        curr = curr.<span class="built_in">next</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> curr.<span class="built_in">next</span>:</span><br><span class="line">            heapq.heappush(q, (curr.<span class="built_in">next</span>.val, l_id, curr.<span class="built_in">next</span>))</span><br><span class="line">    <span class="keyword">return</span> head.<span class="built_in">next</span> </span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>1877. Minimize Maximum Pair Sum in Array</summary>
<blockquote>
<p>Sort the array, then add from start and end, keep track of the max sum.</p>
</blockquote>
<p>Run time: $O(n\log n)$, space: $O(1)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">minPairSum</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> nums <span class="keyword">or</span> <span class="built_in">len</span>(nums) % <span class="number">2</span> == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">    nums.sort()</span><br><span class="line">    min_sum = <span class="built_in">float</span>(<span class="string">&#x27;-inf&#x27;</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)//<span class="number">2</span>):</span><br><span class="line">        temp = nums[i] + nums[<span class="built_in">len</span>(nums)-<span class="number">1</span>-i]</span><br><span class="line">        min_sum = <span class="built_in">max</span>(min_sum, temp)</span><br><span class="line">    <span class="keyword">return</span> min_sum</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>384. Shuffle an Array</summary>
<blockquote>
<p>The randrange() method returns a randomly selected element from the specified range.<br>
<a target="_blank" rel="noopener" href="https://leetcode.com/problems/shuffle-an-array/discuss/85957/easy-python-solution-based-on-generating-random-index-and-swapping">https://leetcode.com/problems/shuffle-an-array/discuss/85957/easy-python-solution-based-on-generating-random-index-and-swapping</a></p>
</blockquote>
<p>Run time: $O(1)$, space: $O(1)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>):</span></span><br><span class="line">    self.nums = nums</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reset</span>(<span class="params">self</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span></span><br><span class="line">    <span class="keyword">return</span> self.nums</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">shuffle</span>(<span class="params">self</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span></span><br><span class="line">    ans = self.nums[:]                     <span class="comment"># copy list</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(ans)-<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>):     <span class="comment"># start from end</span></span><br><span class="line">        j = random.randrange(<span class="number">0</span>, i+<span class="number">1</span>)    <span class="comment"># generate random index </span></span><br><span class="line">        ans[i], ans[j] = ans[j], ans[i]    <span class="comment"># swap</span></span><br><span class="line">    <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>1509. Minimum Difference Between Largest and Smallest Value in Three Moves</summary>
<blockquote>
<p>Only keep track of the largest and smallest 3 elements.</p>
</blockquote>
<p>Run time: $O(n)$, space: $O(1)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">minDifference</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(nums) &lt; <span class="number">5</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    maxV, minV = [-<span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)] * <span class="number">4</span>, [<span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)] * <span class="number">4</span></span><br><span class="line">    <span class="keyword">for</span> n <span class="keyword">in</span> nums:</span><br><span class="line">        <span class="keyword">if</span> n &gt; maxV[<span class="number">0</span>]:</span><br><span class="line">            maxV[<span class="number">0</span>] = n</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">3</span>):</span><br><span class="line">                <span class="keyword">if</span> maxV[i] &gt; maxV[i + <span class="number">1</span>]:</span><br><span class="line">                    maxV[i], maxV[i + <span class="number">1</span>] = maxV[i + <span class="number">1</span>], maxV[i]     </span><br><span class="line">        <span class="keyword">if</span> n &lt; minV[<span class="number">0</span>]:</span><br><span class="line">            minV[<span class="number">0</span>] = n</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">3</span>):</span><br><span class="line">                <span class="keyword">if</span> minV[i] &lt; minV[i + <span class="number">1</span>]:</span><br><span class="line">                    minV[i], minV[i + <span class="number">1</span>] = minV[i + <span class="number">1</span>], minV[i]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">min</span>(maxV[i] - minV[<span class="number">3</span> - i] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>))  </span><br></pre></td></tr></table></figure>
<blockquote>
<p>sort the array and compute the minimum over the three pair difference.</p>
</blockquote>
<p>Run time: $O(n\log n)$, space: $O(1)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">minDifference</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(nums) &lt;= <span class="number">4</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    nums.sort()</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">min</span>(nums[-<span class="number">1</span>] - nums[<span class="number">3</span>], </span><br><span class="line">               nums[-<span class="number">2</span>] - nums[<span class="number">2</span>], </span><br><span class="line">               nums[-<span class="number">3</span>] - nums[<span class="number">1</span>], </span><br><span class="line">               nums[-<span class="number">4</span>] - nums[<span class="number">0</span>])</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>1004. Max Consecutive Ones III</summary>
<blockquote>
<p>Use a pointer to memorize the starting index of the candidate subarray. If we run out of k, we move the pointer until it’s pointing to zero, and then increment by 1 to skip this zero and include the zero at the end index.</p>
</blockquote>
<p>Run time: $O(n)$, space: $O(1)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">longestOnes</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">    n, ans, l = <span class="built_in">len</span>(nums), <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> r <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        <span class="keyword">if</span> nums[r] == <span class="number">0</span>:                       <span class="comment"># try to pick current 0</span></span><br><span class="line">            <span class="keyword">if</span> k == <span class="number">0</span>:                         <span class="comment"># if window already picked k zeros, pop 1 from left and pick this</span></span><br><span class="line">                <span class="keyword">while</span> nums[l] != <span class="number">0</span> : </span><br><span class="line">                    l += <span class="number">1</span></span><br><span class="line">                l += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>: </span><br><span class="line">                k-= <span class="number">1</span>                       <span class="comment"># otherwise pick it and decrement k</span></span><br><span class="line">        ans = <span class="built_in">max</span>(ans, r - l + <span class="number">1</span>)              <span class="comment"># update ans as max window size till now</span></span><br><span class="line">    <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>977. Squares of a Sorted Array</summary>
<blockquote>
<p>Fill in the output array backwards. Use two pointers, if the abs value of number at right pointer is greater, then set the variable and reduce right pointer.</p>
</blockquote>
<p>Run time: $O(n)$, space: $O(n)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sortedSquares</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span></span><br><span class="line">    n = <span class="built_in">len</span>(nums)</span><br><span class="line">    result = [<span class="number">0</span>] * n</span><br><span class="line">    left = <span class="number">0</span></span><br><span class="line">    right = n - <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n - <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">abs</span>(nums[left]) &lt; <span class="built_in">abs</span>(nums[right]):</span><br><span class="line">            square = nums[right]</span><br><span class="line">            right -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            square = nums[left]</span><br><span class="line">            left += <span class="number">1</span></span><br><span class="line">        result[i] = square * square</span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>896. Monotonic Array</summary>
<blockquote>
<p>Use two boolean and return if they are both false or not.</p>
</blockquote>
<p>Run time: $O(n)$, space: $O(1)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isMonotonic</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">    increasing = decreasing = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums) - <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">if</span> nums[i] &gt; nums[i+<span class="number">1</span>]:</span><br><span class="line">            increasing = <span class="literal">False</span></span><br><span class="line">        <span class="keyword">if</span> nums[i] &lt; nums[i+<span class="number">1</span>]:</span><br><span class="line">            decreasing = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> increasing <span class="keyword">or</span> decreasing</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>138. Copy List with Random Pointer</summary>
<blockquote>
<p>Instead of a separate dictionary to keep the old node --&gt; new node mapping, we can tweak the original linked list and keep every cloned node next to its original node. This interleaving of old and new nodes allows us to solve this problem without any extra space.</p>
</blockquote>
<p>Run time: $O(n)$, space: $O(1)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">copyRandomList</span>(<span class="params">self, head: <span class="string">&#x27;Optional[Node]&#x27;</span></span>) -&gt; &#x27;<span class="type">Optional</span>[Node]&#x27;:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> head:</span><br><span class="line">        <span class="keyword">return</span> head</span><br><span class="line"></span><br><span class="line">    ptr = head</span><br><span class="line">    <span class="keyword">while</span> ptr:</span><br><span class="line">        <span class="comment"># Cloned node</span></span><br><span class="line">        new_node = Node(ptr.val, <span class="literal">None</span>, <span class="literal">None</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Inserting the cloned node just next to the original node.</span></span><br><span class="line">        <span class="comment"># If A-&gt;B-&gt;C is the original linked list,</span></span><br><span class="line">        <span class="comment"># Linked list after weaving cloned nodes would be A-&gt;A&#x27;-&gt;B-&gt;B&#x27;-&gt;C-&gt;C&#x27;</span></span><br><span class="line">        new_node.<span class="built_in">next</span> = ptr.<span class="built_in">next</span></span><br><span class="line">        ptr.<span class="built_in">next</span> = new_node</span><br><span class="line">        ptr = new_node.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">    ptr = head</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Now link the random pointers of the new nodes created.</span></span><br><span class="line">    <span class="comment"># Iterate the newly created list and use the original nodes random pointers,</span></span><br><span class="line">    <span class="comment"># to assign references to random pointers for cloned nodes.</span></span><br><span class="line">    <span class="keyword">while</span> ptr:</span><br><span class="line">        ptr.<span class="built_in">next</span>.random = ptr.random.<span class="built_in">next</span> <span class="keyword">if</span> ptr.random <span class="keyword">else</span> <span class="literal">None</span></span><br><span class="line">        ptr = ptr.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Unweave the linked list to get back the original linked list and the cloned list.</span></span><br><span class="line">    <span class="comment"># i.e. A-&gt;A&#x27;-&gt;B-&gt;B&#x27;-&gt;C-&gt;C&#x27; would be broken to A-&gt;B-&gt;C and A&#x27;-&gt;B&#x27;-&gt;C&#x27;</span></span><br><span class="line">    ptr_old_list = head <span class="comment"># A-&gt;B-&gt;C</span></span><br><span class="line">    ptr_new_list = head.<span class="built_in">next</span> <span class="comment"># A&#x27;-&gt;B&#x27;-&gt;C&#x27;</span></span><br><span class="line">    head_new = head.<span class="built_in">next</span></span><br><span class="line">    <span class="keyword">while</span> ptr_old_list:</span><br><span class="line">        ptr_old_list.<span class="built_in">next</span> = ptr_old_list.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">        ptr_new_list.<span class="built_in">next</span> = ptr_new_list.<span class="built_in">next</span>.<span class="built_in">next</span> <span class="keyword">if</span> ptr_new_list.<span class="built_in">next</span> <span class="keyword">else</span> <span class="literal">None</span></span><br><span class="line">        ptr_old_list = ptr_old_list.<span class="built_in">next</span></span><br><span class="line">        ptr_new_list = ptr_new_list.<span class="built_in">next</span></span><br><span class="line">    <span class="keyword">return</span> head_new</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Using dict.</p>
</blockquote>
<p>Run time: $O(n)$, space: $O(n)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">copyRandomList</span>(<span class="params">self, head: <span class="string">&#x27;Optional[Node]&#x27;</span></span>) -&gt; &#x27;<span class="type">Optional</span>[Node]&#x27;:</span></span><br><span class="line">    cache = &#123;&#125;</span><br><span class="line">    new_ptr = dummy = Node(-<span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> head:</span><br><span class="line">        <span class="keyword">if</span> head <span class="keyword">in</span> cache: </span><br><span class="line">            newnode = cache[head]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            newnode = Node(head.val)</span><br><span class="line">            cache[head] = newnode</span><br><span class="line">        new_ptr.<span class="built_in">next</span> = newnode</span><br><span class="line">        new_ptr = new_ptr.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">if</span> head.random:    </span><br><span class="line">            <span class="keyword">if</span> head.random <span class="keyword">in</span> cache: </span><br><span class="line">                new_random = cache[head.random]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                new_random = Node(head.random.val)</span><br><span class="line">                cache[head.random] = new_random</span><br><span class="line">            new_ptr.random = new_random</span><br><span class="line">        head = head.<span class="built_in">next</span></span><br><span class="line">    <span class="keyword">return</span> dummy.<span class="built_in">next</span></span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>339. Nested List Weight Sum</summary>
<blockquote>
<p>DFS.</p>
</blockquote>
<p>Run time: $O(n)$, space: $O(n)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">depthSum</span>(<span class="params">self, nestedList: <span class="type">List</span>[NestedInteger]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span>(<span class="params">l, dep</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> l:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">for</span> a <span class="keyword">in</span> l:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> a.isInteger():</span><br><span class="line">                helper(a.getList(), dep+<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                self.depth += a.getInteger() * dep</span><br><span class="line">    </span><br><span class="line">    self.depth = <span class="number">0</span></span><br><span class="line">    helper(nestedList, <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> self.depth</span><br></pre></td></tr></table></figure>
<blockquote>
<p>BFS.</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">depthSum</span>(<span class="params">self, nestedList: <span class="type">List</span>[NestedInteger]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">    queue = deque(nestedList)</span><br><span class="line"></span><br><span class="line">    depth = <span class="number">1</span></span><br><span class="line">    total = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="built_in">len</span>(queue) &gt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(queue)):</span><br><span class="line">            nested = queue.pop()</span><br><span class="line">            <span class="keyword">if</span> nested.isInteger():</span><br><span class="line">                total += nested.getInteger() * depth</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                queue.extendleft(nested.getList())</span><br><span class="line">        depth += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> total</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>148. Sort List</summary>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/sort-list/discuss/46711/Python-easy-to-understand-merge-sort-solution">https://leetcode.com/problems/sort-list/discuss/46711/Python-easy-to-understand-merge-sort-solution</a></p>
</blockquote>
<p>Run time: $O(n\log n)$, space: $O(1)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sortList</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span></span><br><span class="line">     <span class="keyword">if</span> <span class="keyword">not</span> head <span class="keyword">or</span> <span class="keyword">not</span> head.<span class="built_in">next</span>:</span><br><span class="line">         <span class="keyword">return</span> head</span><br><span class="line">     fast, slow = head.<span class="built_in">next</span>, head</span><br><span class="line">     <span class="keyword">while</span> fast <span class="keyword">and</span> fast.<span class="built_in">next</span>:</span><br><span class="line">         fast = fast.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">         slow = slow.<span class="built_in">next</span></span><br><span class="line">     start = slow.<span class="built_in">next</span></span><br><span class="line">     slow.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line">     l, r = self.sortList(head), self.sortList(start)</span><br><span class="line">     <span class="keyword">return</span> self.merge(l, r)</span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line"> <span class="function"><span class="keyword">def</span> <span class="title">merge</span>(<span class="params">self, l, r</span>):</span></span><br><span class="line">     <span class="keyword">if</span> <span class="keyword">not</span> l <span class="keyword">or</span> <span class="keyword">not</span> r:</span><br><span class="line">         <span class="keyword">return</span> l <span class="keyword">or</span> r</span><br><span class="line">     <span class="keyword">if</span> l.val &gt; r.val:</span><br><span class="line">         l, r = r, l</span><br><span class="line">     <span class="comment"># get the return node &quot;head&quot;</span></span><br><span class="line">     head = pre = l</span><br><span class="line">     l = l.<span class="built_in">next</span></span><br><span class="line">     <span class="keyword">while</span> l <span class="keyword">and</span> r:</span><br><span class="line">         <span class="keyword">if</span> l.val &lt; r.val:</span><br><span class="line">             pre.<span class="built_in">next</span> = l</span><br><span class="line">             l = l.<span class="built_in">next</span></span><br><span class="line">         <span class="keyword">else</span>:</span><br><span class="line">             pre.<span class="built_in">next</span> = r</span><br><span class="line">             r = r.<span class="built_in">next</span></span><br><span class="line">         pre = pre.<span class="built_in">next</span></span><br><span class="line">     <span class="comment"># l and r at least one is None</span></span><br><span class="line">     pre.<span class="built_in">next</span> = l <span class="keyword">or</span> r</span><br><span class="line">     <span class="keyword">return</span> head</span><br></pre></td></tr></table></figure>
<blockquote>
<p>No recursion.</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sortList</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getsize</span>(<span class="params">head</span>):</span></span><br><span class="line">        c = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> head:</span><br><span class="line">            head = head.<span class="built_in">next</span></span><br><span class="line">            c += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> c</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">split</span>(<span class="params">head, size</span>):</span></span><br><span class="line">        tail = head</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(size-<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> tail:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">            tail = tail.<span class="built_in">next</span></span><br><span class="line">            </span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> tail: <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        next_head, tail.<span class="built_in">next</span> = tail.<span class="built_in">next</span>, <span class="literal">None</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> next_head</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">merge</span>(<span class="params">l1, l2, newtail</span>):</span></span><br><span class="line">        <span class="keyword">while</span> l1 <span class="keyword">and</span> l2:</span><br><span class="line">            <span class="keyword">if</span> l1.val &lt;= l2.val:</span><br><span class="line">                newtail.<span class="built_in">next</span> = l1</span><br><span class="line">                l1 = l1.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                newtail.<span class="built_in">next</span> = l2</span><br><span class="line">                l2 = l2.<span class="built_in">next</span></span><br><span class="line">            newtail = newtail.<span class="built_in">next</span></span><br><span class="line">            </span><br><span class="line">        newtail.<span class="built_in">next</span> = l1 <span class="keyword">or</span> l2</span><br><span class="line">        <span class="keyword">while</span> newtail.<span class="built_in">next</span>:</span><br><span class="line">            newtail = newtail.<span class="built_in">next</span></span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> newtail</span><br><span class="line">    </span><br><span class="line">    length = getsize(head)</span><br><span class="line">    newhead = ListNode(<span class="built_in">next</span>=head)</span><br><span class="line">    size = <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> size &lt; length:</span><br><span class="line">        newtail, cur = newhead, newhead.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            h1 = cur</span><br><span class="line">            h2 = split(h1, size)</span><br><span class="line">            cur = split(h2, size)</span><br><span class="line">            newtail = merge(h1, h2, newtail)</span><br><span class="line">        size *= <span class="number">2</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> newhead.<span class="built_in">next</span></span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>19. Remove Nth Node From End of List</summary>
<blockquote>
<p>One pass. The first pointer advances the list by n+1n+1 steps from the beginning, while the second pointer starts from the beginning of the list. Now, both pointers are exactly separated by nn nodes apart. We maintain this constant gap by advancing both pointers together until the first pointer arrives past the last node. The second pointer will be pointing at the nnth node counting from the last. We relink the next pointer of the node referenced by the second pointer to point to the node’s next next node.</p>
</blockquote>
<p>Run time: $O(n)$, space: $O(1)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">removeNthFromEnd</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode], n: <span class="built_in">int</span></span>) -&gt; <span class="type">Optional</span>[ListNode]:</span></span><br><span class="line">    fast = slow = head</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        fast = fast.<span class="built_in">next</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> fast:</span><br><span class="line">        <span class="keyword">return</span> head.<span class="built_in">next</span></span><br><span class="line">    <span class="keyword">while</span> fast.<span class="built_in">next</span>:</span><br><span class="line">        fast = fast.<span class="built_in">next</span></span><br><span class="line">        slow = slow.<span class="built_in">next</span></span><br><span class="line">    slow.<span class="built_in">next</span> = slow.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">    <span class="keyword">return</span> head</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Two pass. First time calculate the length. Second time reduce the count till 0, and remove that node.</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">removeNthFromEnd</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode], n: <span class="built_in">int</span></span>) -&gt; <span class="type">Optional</span>[ListNode]:</span></span><br><span class="line">    ans = ListNode(<span class="number">0</span>)</span><br><span class="line">    ans.<span class="built_in">next</span> = head</span><br><span class="line">    ptr = head</span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> ptr:</span><br><span class="line">        count += <span class="number">1</span></span><br><span class="line">        ptr = ptr.<span class="built_in">next</span></span><br><span class="line">    </span><br><span class="line">    count -= n</span><br><span class="line">    ptr = ans</span><br><span class="line">    <span class="keyword">while</span> count &gt; <span class="number">0</span>:</span><br><span class="line">        count -= <span class="number">1</span></span><br><span class="line">        ptr = ptr.<span class="built_in">next</span></span><br><span class="line">    ptr.<span class="built_in">next</span> = ptr.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">    <span class="keyword">return</span> ans.<span class="built_in">next</span></span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>83. Remove Duplicates from Sorted List</summary>
<blockquote>
<p>Recursion. Set the next element to be the function call. Return head.next if it is the same as head, otherwise return head.</p>
</blockquote>
<p>Run time: $O(n)$, space: $O(1)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">deleteDuplicates</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span></span><br><span class="line">    <span class="keyword">if</span> head <span class="keyword">and</span> head.<span class="built_in">next</span>:</span><br><span class="line">        head.<span class="built_in">next</span> = self.deleteDuplicates(head.<span class="built_in">next</span>)</span><br><span class="line">        <span class="keyword">if</span> head.<span class="built_in">next</span>.val == head.val:</span><br><span class="line">            <span class="keyword">return</span> head.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">    <span class="keyword">return</span> head</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Iterative. Remember to put moving head in the else statement.</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">deleteDuplicates</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> head <span class="keyword">or</span> <span class="keyword">not</span> head.<span class="built_in">next</span>:</span><br><span class="line">        <span class="keyword">return</span> head</span><br><span class="line">    </span><br><span class="line">    cur = head</span><br><span class="line">    <span class="keyword">while</span> cur <span class="keyword">and</span> cur.<span class="built_in">next</span>:</span><br><span class="line">        <span class="keyword">if</span> cur.val == cur.<span class="built_in">next</span>.val:</span><br><span class="line">            cur.<span class="built_in">next</span> = cur.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            cur = cur.<span class="built_in">next</span></span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> head</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>234. Palindrome Linked List</summary>
<blockquote>
<p>Recursion. If we iterate the nodes in reverse using recursion, and iterate forward at the same time using a variable outside the recursive function, then we can check whether or not we have a palindrome.</p>
</blockquote>
<p>Run time: $O(n)$, space: $O(n)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isPalindrome</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">    self.front_ptr = head</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">recursive_check</span>(<span class="params">node</span>):</span></span><br><span class="line">        <span class="keyword">if</span> node:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> recursive_check(node.<span class="built_in">next</span>):</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">if</span> self.front_ptr.val != node.val:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            self.front_ptr = self.front_ptr.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> recursive_check(head)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Copy into Array List and then Use Two Pointer Technique.</p>
</blockquote>
<p>Run time: $O(n)$, space: $O(n)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isPalindrome</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">    vals = []</span><br><span class="line">    <span class="keyword">while</span> head:</span><br><span class="line">        vals.append(head.val)</span><br><span class="line">        head = head.<span class="built_in">next</span></span><br><span class="line">    <span class="keyword">return</span> vals == vals[::-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>160. Intersection of Two Linked Lists</summary>
<blockquote>
<p>If we say that cc is the shared part, aa is exclusive part of list A and bb is exclusive part of list B, then we can have one pointer that goes over a + c + b and the other that goes over b + c + a. Have a look at the diagram below, and this should be fairly intuitive.</p>
</blockquote>
<p>Run time: $O(m+n)$, space: $O(1)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getIntersectionNode</span>(<span class="params">self, headA: ListNode, headB: ListNode</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span></span><br><span class="line">    p1, p2 = headA, headB</span><br><span class="line">    <span class="keyword">while</span> p1 != p2:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> p1:</span><br><span class="line">            p1 = headB</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            p1 = p1.<span class="built_in">next</span></span><br><span class="line">            </span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> p2:</span><br><span class="line">            p2 = headA</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            p2 = p2.<span class="built_in">next</span></span><br><span class="line">    <span class="keyword">return</span> p1</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Use set to put all nodes in B. Then loop through A once and see if a node is already in the set.</p>
</blockquote>
<p>Run time: $O(m+n)$, space: $O(m)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getIntersectionNode</span>(<span class="params">self, headA: ListNode, headB: ListNode</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span></span><br><span class="line">    s = <span class="built_in">set</span>()</span><br><span class="line">    <span class="keyword">while</span> headB:</span><br><span class="line">        s.add(headB)</span><br><span class="line">        headB = headB.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> headA:</span><br><span class="line">        <span class="keyword">if</span> headA <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">return</span> headA</span><br><span class="line">        headA = headA.<span class="built_in">next</span></span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>Brute force. For each node in A, loop through B and see if two nodes are the same.</p>
</blockquote>
<p>Run time: $O(mn)$, space: $O(1)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getIntersectionNode</span>(<span class="params">self, headA: ListNode, headB: ListNode</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span></span><br><span class="line">    <span class="keyword">while</span> headA:</span><br><span class="line">        p = headB</span><br><span class="line">        <span class="keyword">while</span> p:</span><br><span class="line">            <span class="keyword">if</span> headA == p:</span><br><span class="line">                <span class="keyword">return</span> headA</span><br><span class="line">            p = p.<span class="built_in">next</span></span><br><span class="line">        headA = headA.<span class="built_in">next</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>24. Swap Nodes in Pairs</summary>
<blockquote>
<p>Recursive. In every function call we take out two nodes which would be swapped and the remaining nodes are passed to the next recursive call. The reason we are adopting a recursive approach here is because a sub-list of the original list would still be a linked list and hence, it would adapt to our recursive strategy.</p>
</blockquote>
<p>Run time: $O(n)$, space: $O(n)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">swapPairs</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span></span><br><span class="line">    <span class="keyword">if</span> head <span class="keyword">and</span> head.<span class="built_in">next</span>:</span><br><span class="line">        temp = head.<span class="built_in">next</span></span><br><span class="line">        head.<span class="built_in">next</span> = self.swapPairs(temp.<span class="built_in">next</span>)</span><br><span class="line">        temp.<span class="built_in">next</span> = head</span><br><span class="line">        <span class="keyword">return</span> temp</span><br><span class="line">    <span class="keyword">return</span> head</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Iterative. We break the linked list into pairs by jumping in steps of two. The only difference is, unlike recursion, we swap the nodes on the go. After swapping a pair of nodes, say A and B, we need to link the node B to the node that was right before A. To establish this linkage we save the previous node of node A in prevNode.</p>
</blockquote>
<p>Run time: $O(n)$, space: $O(1)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">swapPairs</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> head <span class="keyword">or</span> <span class="keyword">not</span> head.<span class="built_in">next</span>:</span><br><span class="line">        <span class="keyword">return</span> head</span><br><span class="line">    </span><br><span class="line">    ans = ListNode(<span class="number">0</span>)</span><br><span class="line">    ans.<span class="built_in">next</span> = head</span><br><span class="line">    ptr = ans</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> head <span class="keyword">and</span> head.<span class="built_in">next</span>:</span><br><span class="line">        first = head</span><br><span class="line">        second = head.<span class="built_in">next</span></span><br><span class="line">        </span><br><span class="line">        ptr.<span class="built_in">next</span> = second</span><br><span class="line">        first.<span class="built_in">next</span> = second.<span class="built_in">next</span></span><br><span class="line">        second.<span class="built_in">next</span> = first</span><br><span class="line">        </span><br><span class="line">        ptr = first</span><br><span class="line">        head = first.<span class="built_in">next</span></span><br><span class="line">    <span class="keyword">return</span> ans.<span class="built_in">next</span></span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>21. Merge Two Sorted Lists</summary>
<blockquote>
<p>Iterative.</p>
</blockquote>
<p>Run time: $O(m+n)$, space: $O(m+n)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mergeTwoLists</span>(<span class="params">self, list1: <span class="type">Optional</span>[ListNode], list2: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span></span><br><span class="line">    ans = ListNode(<span class="number">0</span>)</span><br><span class="line">    ptr = ans</span><br><span class="line">    <span class="keyword">while</span> list1 <span class="keyword">and</span> list2:</span><br><span class="line">        <span class="keyword">if</span> list1.val &lt; list2.val:</span><br><span class="line">            ans.<span class="built_in">next</span> = list1</span><br><span class="line">            list1 = list1.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">else</span>: <span class="comment"># list1 &gt; list2</span></span><br><span class="line">            ans.<span class="built_in">next</span> = list2</span><br><span class="line">            list2 = list2.<span class="built_in">next</span></span><br><span class="line">        ans = ans.<span class="built_in">next</span></span><br><span class="line">    ans.<span class="built_in">next</span> = list1 <span class="keyword">or</span> list2</span><br><span class="line">    <span class="keyword">return</span> ptr.<span class="built_in">next</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>Recursion. We can recursively define the result of a merge operation on two lists as the following (avoiding the corner case logic surrounding empty lists):</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mergeTwoLists</span>(<span class="params">self, list1: <span class="type">Optional</span>[ListNode], list2: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> list1 <span class="keyword">or</span> <span class="keyword">not</span> list2:</span><br><span class="line">        <span class="keyword">return</span> list1 <span class="keyword">or</span> list2</span><br><span class="line">    <span class="keyword">if</span> list1.val &lt; list2.val:</span><br><span class="line">        list1.<span class="built_in">next</span> = self.mergeTwoLists(list1.<span class="built_in">next</span>, list2)</span><br><span class="line">        <span class="keyword">return</span> list1</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        list2.<span class="built_in">next</span> = self.mergeTwoLists(list1, list2.<span class="built_in">next</span>)</span><br><span class="line">        <span class="keyword">return</span> list2</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>206. Reverse Linked List</summary>
>  Iterative solution. Use one variable prev and one called curr that points to head. While curr is not None, use another variable to store the next node, set the next node of curr to be prev, set prev to be curr, in the end set curr to be the temp variable.
<p>Run time: $O(n)$, space: $O(n)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reverseList</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span></span><br><span class="line">    prev, curr = <span class="literal">None</span>, head</span><br><span class="line">    <span class="keyword">while</span> curr:</span><br><span class="line">        temp_next = curr.<span class="built_in">next</span></span><br><span class="line">        curr.<span class="built_in">next</span> = prev</span><br><span class="line">        prev = curr</span><br><span class="line">        curr = temp_next</span><br><span class="line">    <span class="keyword">return</span> prev</span><br></pre></td></tr></table></figure>
<blockquote>
<p>The recursive version is slightly trickier and the key is to work backwards. Assume that the rest of the list had already been reversed, now how do I reverse the front part? Let’s assume the list is: n1 → … → nk-1 → nk → nk+1 → … → nm → Ø<br>
Assume from node nk+1 to nm had been reversed and you are at node nk.whilifans.list<br>
n1 → … → nk-1 → nk → nk+1 ← … ← nm<br>
We want nk+1’s next node to point to nk.<br>
So, nk.next.next = nk;<br>
Be very careful that n1’s next must point to Ø. If you forget about this, your linked list has a cycle in it. This bug could be caught if you test your code with a linked list of size 2.</p>
</blockquote>
<p>Run time: $O(n)$, space: $O(n)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reverseList</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> head <span class="keyword">or</span> <span class="keyword">not</span> head.<span class="built_in">next</span>:</span><br><span class="line">        <span class="keyword">return</span> head</span><br><span class="line">    </span><br><span class="line">    temp_next = self.reverseList(head.<span class="built_in">next</span>)</span><br><span class="line">    head.<span class="built_in">next</span>.<span class="built_in">next</span> = head</span><br><span class="line">    head.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line">    <span class="keyword">return</span> temp_next</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>304. Range Sum Query 2D - Immutable</summary>
<blockquote>
<p>Sum(ABCD)=Sum(OD)−Sum(OB)−Sum(OC)+Sum(OA)</p>
</blockquote>
<p>Run time: $O(mn)$, space: $O(mn)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumMatrix</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, matrix: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> matrix: <span class="keyword">return</span> </span><br><span class="line">        m, n = <span class="built_in">len</span>(matrix), <span class="built_in">len</span>(matrix[<span class="number">0</span>])</span><br><span class="line">        dp = self.dp = [[<span class="number">0</span>] * (n + <span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m + <span class="number">1</span>)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                dp[i+<span class="number">1</span>][j+<span class="number">1</span>] = dp[i][j+<span class="number">1</span>] + dp[i+<span class="number">1</span>][j] + matrix[i][j] - dp[i][j]</span><br><span class="line">                       </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sumRegion</span>(<span class="params">self, row1: <span class="built_in">int</span>, col1: <span class="built_in">int</span>, row2: <span class="built_in">int</span>, col2: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        dp = self.dp</span><br><span class="line">        <span class="keyword">return</span> dp[row2+<span class="number">1</span>][col2+<span class="number">1</span>] - dp[row2+<span class="number">1</span>][col1] - dp[row1][col2+<span class="number">1</span>] + dp[row1][col1]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Your NumMatrix object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"># obj = NumMatrix(matrix)</span></span><br><span class="line"><span class="comment"># param_1 = obj.sumRegion(row1,col1,row2,col2)</span></span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>303. Range Sum Query - Immutable</summary>
<blockquote>
<p>Store the cumulative sum. Return (right+1)-left.</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumArray</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>):</span></span><br><span class="line">        self.cum_sum = [<span class="number">0</span>]*(<span class="built_in">len</span>(nums)+<span class="number">1</span>)</span><br><span class="line">        self.cum_sum[<span class="number">0</span>] = nums[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            self.cum_sum[i+<span class="number">1</span>] = nums[i]+self.cum_sum[i]</span><br><span class="line">        <span class="built_in">print</span>(self.cum_sum)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sumRange</span>(<span class="params">self, left: <span class="built_in">int</span>, right: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.cum_sum[right+<span class="number">1</span>] - self.cum_sum[left]</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>560. Subarray Sum Equals K</summary>
> Create a dict to store <cumulative sum, count>. In the loop, find if cumulative sum - k is in the dict, then add the value to the count.
<p>Run time: $O(n)$, space: $O(n)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">subarraySum</span>(<span class="params">self, nums, k</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    :type nums: List[int]</span></span><br><span class="line"><span class="string">    :type k: int</span></span><br><span class="line"><span class="string">    :rtype: int</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    sums = <span class="number">0</span> <span class="comment"># cumulative sum</span></span><br><span class="line">    d = <span class="built_in">dict</span>()</span><br><span class="line">    d[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">        sums += nums[i]</span><br><span class="line">        count += d.get(sums-k,<span class="number">0</span>)</span><br><span class="line">        d[sums] = d.get(sums,<span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span>(count)</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>1570. Dot Product of Two Sparse Vectors</summary>
> Store the index and nonzero values in a dictionary, and check if the keys in another dict is in this dict as well, the compute the product.
<p>Run time: $O(n)$, space: $O(L)$, where $L$ is the number of nonzero values</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SparseVector</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, nums</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self.d = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i, num <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums):</span><br><span class="line">            self.d[i] = num</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    <span class="comment"># Return the dotProduct of two sparse vectors</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dotProduct</span>(<span class="params">self, vec</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type vec: &#x27;SparseVector&#x27;</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i, num <span class="keyword">in</span> self.d.items():</span><br><span class="line">            <span class="keyword">if</span> i <span class="keyword">in</span> vec.d:</span><br><span class="line">                ans += vec.d[i] * num</span><br><span class="line">        <span class="keyword">return</span> ans</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line"><span class="comment"># Your SparseVector object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"># v1 = SparseVector(nums1)</span></span><br><span class="line"><span class="comment"># v2 = SparseVector(nums2)</span></span><br><span class="line"><span class="comment"># ans = v1.dotProduct(v2)</span></span><br></pre></td></tr></table></figure>
</details>
<h1>Stack, Queue</h1>
<details>
<summary></summary>
> 
<p>Run time: $O()$, space: $O()$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>1296. Divide Array in Sets of K Consecutive Numbers</summary>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/divide-array-in-sets-of-k-consecutive-numbers/discuss/470238/JavaC%2B%2BPython-Exactly-Same-as-846.-Hand-of-Straights">https://leetcode.com/problems/divide-array-in-sets-of-k-consecutive-numbers/discuss/470238/JavaC%2B%2BPython-Exactly-Same-as-846.-Hand-of-Straights</a></p>
</blockquote>
<p>Run time: $O(kn\log n)$, space: $O(n)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isPossibleDivide</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">    c = collections.Counter(nums)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">sorted</span>(c):</span><br><span class="line">        <span class="keyword">if</span> c[i] &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(k)[::-<span class="number">1</span>]:</span><br><span class="line">                c[i + j] -= c[i]</span><br><span class="line">                <span class="keyword">if</span> c[i + j] &lt; <span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isPossibleDivide</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">    c = collections.Counter(nums)</span><br><span class="line">    start = collections.deque()</span><br><span class="line">    last_checked, opened = -<span class="number">1</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">sorted</span>(c):</span><br><span class="line">        <span class="keyword">if</span> opened &gt; c[i] <span class="keyword">or</span> opened &gt; <span class="number">0</span> <span class="keyword">and</span> i &gt; last_checked + <span class="number">1</span>: <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        start.append(c[i] - opened)</span><br><span class="line">        last_checked, opened = i, c[i]</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(start) == k: opened -= start.popleft()</span><br><span class="line">    <span class="keyword">return</span> opened == <span class="number">0</span></span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>150. Evaluate Reverse Polish Notation</summary>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/evaluate-reverse-polish-notation/discuss/47444/Python-easy-to-understand-solution">https://leetcode.com/problems/evaluate-reverse-polish-notation/discuss/47444/Python-easy-to-understand-solution</a></p>
</blockquote>
<p>Run time: $O(n)$, space: $O(n)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">evalRPN</span>(<span class="params">self, tokens: <span class="type">List</span>[<span class="built_in">str</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">    stack = []</span><br><span class="line">    <span class="keyword">for</span> t <span class="keyword">in</span> tokens:</span><br><span class="line">        <span class="keyword">if</span> t <span class="keyword">not</span> <span class="keyword">in</span> <span class="string">&quot;+-*/&quot;</span>:</span><br><span class="line">            stack.append(<span class="built_in">int</span>(t))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            r, l = stack.pop(), stack.pop()</span><br><span class="line">            <span class="keyword">if</span> t == <span class="string">&quot;+&quot;</span>:</span><br><span class="line">                stack.append(l+r)</span><br><span class="line">            <span class="keyword">elif</span> t == <span class="string">&quot;-&quot;</span>:</span><br><span class="line">                stack.append(l-r)</span><br><span class="line">            <span class="keyword">elif</span> t == <span class="string">&quot;*&quot;</span>:</span><br><span class="line">                stack.append(l*r)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                stack.append(<span class="built_in">int</span>(<span class="built_in">float</span>(l)/r))</span><br><span class="line">    <span class="keyword">return</span> stack.pop() </span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>1209. Remove All Adjacent Duplicates in String II</summary>
<blockquote>
<p>See 1047 for same idea. Store &lt;char, occurrences&gt; to stack. Increment occurrences if we see it again, and if occurrences equals k, we pop it from stack.<br>
<a target="_blank" rel="noopener" href="https://leetcode.com/problems/remove-all-adjacent-duplicates-in-string-ii/discuss/392933/JavaC%2B%2BPython-Two-Pointers-and-Stack-Solution">https://leetcode.com/problems/remove-all-adjacent-duplicates-in-string-ii/discuss/392933/JavaC%2B%2BPython-Two-Pointers-and-Stack-Solution</a></p>
</blockquote>
<p>Run time: $O(n)$, space: $O(n)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">removeDuplicates</span>(<span class="params">self, s: <span class="built_in">str</span>, k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">str</span>:</span></span><br><span class="line">    stack = [[<span class="string">&#x27;#&#x27;</span>, <span class="number">0</span>]]</span><br><span class="line">    <span class="keyword">for</span> c <span class="keyword">in</span> s:</span><br><span class="line">        <span class="keyword">if</span> stack[-<span class="number">1</span>][<span class="number">0</span>] == c:</span><br><span class="line">            stack[-<span class="number">1</span>][<span class="number">1</span>] += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> stack[-<span class="number">1</span>][<span class="number">1</span>] == k:</span><br><span class="line">                stack.pop()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            stack.append([c, <span class="number">1</span>])</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>.join(c * k <span class="keyword">for</span> c, k <span class="keyword">in</span> stack)</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>239.  Sliding Window Maximum</summary>
<blockquote>
<p>Monotonic decreasing queue.</p>
</blockquote>
<p>Run time: $O(n)$, space: $O(n)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">maxSlidingWindow</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span></span><br><span class="line">    ans = []</span><br><span class="line">    desc_q = collections.deque()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i, num <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums):</span><br><span class="line">        <span class="comment"># pop out-of-bound index</span></span><br><span class="line">        <span class="keyword">if</span> i &gt;= k <span class="keyword">and</span> desc_q[<span class="number">0</span>] == i-k:</span><br><span class="line">            desc_q.popleft()</span><br><span class="line">        <span class="comment"># pop index where elements are smaller than current num</span></span><br><span class="line">        <span class="keyword">while</span> desc_q <span class="keyword">and</span> nums[desc_q[-<span class="number">1</span>]] &lt; num:</span><br><span class="line">            desc_q.pop()</span><br><span class="line">            </span><br><span class="line">        desc_q.append(i)</span><br><span class="line">        <span class="keyword">if</span> i &gt;= k-<span class="number">1</span>:</span><br><span class="line">            ans.append(nums[desc_q[<span class="number">0</span>]])</span><br><span class="line">    <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Use max heap (i.e. a min heap that stores &lt;-num, index&gt;). Each time we need to pop the element if the current top element index exceeds the k bound.</p>
</blockquote>
<p>Run time: $O(n\log n)$, space: $O(n)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">maxSlidingWindow</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span></span><br><span class="line">    ans = []</span><br><span class="line">    pq = []</span><br><span class="line">    <span class="keyword">for</span> i, num <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums):</span><br><span class="line">        <span class="keyword">while</span> pq <span class="keyword">and</span> i &gt;= k <span class="keyword">and</span> pq[<span class="number">0</span>][<span class="number">1</span>] &lt;= i-k:</span><br><span class="line">            heapq.heappop(pq)</span><br><span class="line">        heapq.heappush(pq, (-num, i))</span><br><span class="line">        <span class="keyword">if</span> i &gt;= k-<span class="number">1</span>:</span><br><span class="line">            ans.append(-pq[<span class="number">0</span>][<span class="number">0</span>])</span><br><span class="line">    <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>1499.  Max Value of Equation</summary>
<blockquote>
<p>Monotonic decreasing queue that stores &lt;y-x, x&gt; in descending order. Pop elements that does not satisfy the |x-xj| &lt;= k restriction, i.e., xj &gt;= x-k, then update the max. Then, pop elements that has y-x smaller than or equal to the current y-x, since we are not going to use them.</p>
</blockquote>
<p>Run time: $O(n)$, space: $O(n)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findMaxValueOfEquation</span>(<span class="params">self, points: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]], k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">    q = collections.deque()</span><br><span class="line">    ans = -<span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)</span><br><span class="line">    <span class="keyword">for</span> x, y <span class="keyword">in</span> points:</span><br><span class="line">        <span class="keyword">while</span> q <span class="keyword">and</span> q[<span class="number">0</span>][<span class="number">1</span>] &lt; x - k:</span><br><span class="line">            q.popleft()</span><br><span class="line">        <span class="keyword">if</span> q: ans = <span class="built_in">max</span>(ans, q[<span class="number">0</span>][<span class="number">0</span>] + y + x)</span><br><span class="line">        <span class="keyword">while</span> q <span class="keyword">and</span> q[-<span class="number">1</span>][<span class="number">0</span>] &lt;= y - x:</span><br><span class="line">            q.pop()</span><br><span class="line">        q.append([y - x, x])</span><br><span class="line">    <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Use max heap (in python, create heap and store the negative value) to store y-x for each point. While the x value of current point in the max heap has difference greater than k, we pop it from the heap. Then we get the sum of current x+y, and the y-x from the heap.</p>
</blockquote>
<p>Run time: $O(n\log n)$, space: $O(n)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findMaxValueOfEquation</span>(<span class="params">self, points: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]], k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">    q = [] <span class="comment"># max heap that stores &lt;negative of y-x, x&gt;</span></span><br><span class="line">    ans = -<span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)</span><br><span class="line">    <span class="keyword">for</span> x, y <span class="keyword">in</span> points:</span><br><span class="line">        <span class="keyword">while</span> q <span class="keyword">and</span> x - q[<span class="number">0</span>][<span class="number">1</span>] &gt; k:</span><br><span class="line">            heapq.heappop(q)</span><br><span class="line">        <span class="keyword">if</span> q:</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, -q[<span class="number">0</span>][<span class="number">0</span>] + (x+y))</span><br><span class="line">        heapq.heappush(q, (-(y-x), x))</span><br><span class="line">    <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>394. Decode String</summary>
<blockquote>
<p>Use one variable to keep track of number and string. If we see [, we add string and num to stack and reset them. If we see ], we poll num and string and update string. If we see a digit, we update num. Otherwise, we append char to string.</p>
</blockquote>
<p>Run time: $O(n)$, space: $O(n)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decodeString</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span></span><br><span class="line">    stack = []</span><br><span class="line">    num = <span class="number">0</span></span><br><span class="line">    string = <span class="string">&quot;&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> c <span class="keyword">in</span> s:</span><br><span class="line">        <span class="keyword">if</span> c == <span class="string">&#x27;[&#x27;</span>:</span><br><span class="line">            stack.append(string)</span><br><span class="line">            stack.append(num)</span><br><span class="line">            string = <span class="string">&quot;&quot;</span></span><br><span class="line">            num = <span class="number">0</span></span><br><span class="line">        <span class="keyword">elif</span> c == <span class="string">&#x27;]&#x27;</span>:</span><br><span class="line">            oldNum = stack.pop()</span><br><span class="line">            oldString = stack.pop()</span><br><span class="line">            string = oldString + oldNum * string</span><br><span class="line">        <span class="keyword">elif</span> c.isdigit():</span><br><span class="line">            num = num * <span class="number">10</span> + <span class="built_in">int</span>(c)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            string += c</span><br><span class="line">    <span class="keyword">return</span> string</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>1047. Remove All Adjacent Duplicates In String
</summary>
<blockquote>
<p>Current string character is equal to the last element in stack? Pop that last element out of stack.<br>
Current string character is not equal to the last element in stack? Add the current character into stack.</p>
</blockquote>
<p>Run time: $O(n)$, space: $O(n-d)$, where $d$ is the number of dup char.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">removeDuplicates</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span></span><br><span class="line">    stack = []</span><br><span class="line">    <span class="keyword">for</span> ch <span class="keyword">in</span> s:</span><br><span class="line">        <span class="keyword">if</span> stack <span class="keyword">and</span> ch == stack[-<span class="number">1</span>]:</span><br><span class="line">            stack.pop()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            stack.append(ch)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&quot;</span>.join(stack)</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>716. Max Stack</summary>
<blockquote>
<p>Create a stack and put [value, current index of the max].</p>
</blockquote>
<p>Run time: $O(n)$ for popMax, $O(1)$ for all other calls, space: $O(n)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MaxStack</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.stack = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span>(<span class="params">self, x: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.stack <span class="keyword">and</span> x &gt;= self.stack[self.stack[-<span class="number">1</span>][<span class="number">1</span>]][<span class="number">0</span>]:</span><br><span class="line">            i = <span class="built_in">len</span>(self.stack)  <span class="comment"># index of max</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> self.stack:</span><br><span class="line">                i = self.stack[-<span class="number">1</span>][<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">else</span>: </span><br><span class="line">                i = <span class="number">0</span></span><br><span class="line">        self.stack.append((x, i))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.stack.pop()[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">top</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.stack[-<span class="number">1</span>][<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">peekMax</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.stack[self.stack[-<span class="number">1</span>][<span class="number">1</span>]][<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">popMax</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        index = self.stack[-<span class="number">1</span>][<span class="number">1</span>]  <span class="comment"># index where the max exists</span></span><br><span class="line">        result = self.stack[index][<span class="number">0</span>]  <span class="comment"># max value to return</span></span><br><span class="line">        <span class="keyword">if</span> index &gt; <span class="number">0</span>:</span><br><span class="line">            new_max = self.stack[self.stack[index-<span class="number">1</span>][<span class="number">1</span>]][<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            new_max = -<span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)</span><br><span class="line">        <span class="comment"># Scan the stack starting at &#x27;index&#x27; to recompute the max values and shift all</span></span><br><span class="line">        <span class="comment"># values to the left by one:</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(index, <span class="built_in">len</span>(self.stack)-<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> self.stack[i+<span class="number">1</span>][<span class="number">0</span>] &gt;= new_max:</span><br><span class="line">                new_max = self.stack[i+<span class="number">1</span>][<span class="number">0</span>]</span><br><span class="line">                self.stack[i] = (self.stack[i+<span class="number">1</span>][<span class="number">0</span>], i)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                self.stack[i] = (self.stack[i+<span class="number">1</span>][<span class="number">0</span>], self.stack[i-<span class="number">1</span>][<span class="number">1</span>])</span><br><span class="line">        self.stack.pop()</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>772. Basic Calculator III</summary>
<blockquote>
<p>It is much easier to implement the solution if you build the BNF grammar.<br>
inspired by <a target="_blank" rel="noopener" href="https://leetcode.com/problems/build-binary-expression-tree-from-infix-expression/discuss/864596/Python-Standard-parser-implementation">https://leetcode.com/problems/build-binary-expression-tree-from-infix-expression/discuss/864596/Python-Standard-parser-implementation</a></p>
</blockquote>
<p>Run time: $O(n)$, space: $O(n)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calculate</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">parse_factor</span>(<span class="params">dq</span>):</span></span><br><span class="line">        <span class="keyword">if</span> dq[<span class="number">0</span>].isdigit():</span><br><span class="line">            curr = <span class="number">0</span></span><br><span class="line">            <span class="keyword">while</span> dq <span class="keyword">and</span> dq[<span class="number">0</span>].isdigit():</span><br><span class="line">                curr = curr * <span class="number">10</span> + <span class="built_in">int</span>(dq[<span class="number">0</span>])</span><br><span class="line">                dq.popleft()</span><br><span class="line">            <span class="keyword">return</span> curr</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            dq.popleft()</span><br><span class="line">            tmp = parse_expr(dq)</span><br><span class="line">            dq.popleft()</span><br><span class="line">            <span class="keyword">return</span> tmp</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">parse_term</span>(<span class="params">dq</span>):</span></span><br><span class="line">        lhs = parse_factor(dq)</span><br><span class="line">        <span class="keyword">while</span> dq <span class="keyword">and</span> dq[<span class="number">0</span>] <span class="keyword">in</span> <span class="string">&quot;*/&quot;</span>:</span><br><span class="line">            op = dq.popleft()</span><br><span class="line">            rhs = parse_factor(dq)</span><br><span class="line">            <span class="keyword">if</span> op == <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">                lhs = lhs * rhs </span><br><span class="line">            <span class="keyword">else</span>: </span><br><span class="line">                lhs = <span class="built_in">int</span>(lhs/rhs) <span class="comment"># for this case &quot;(0-3)/4&quot;</span></span><br><span class="line">        <span class="keyword">return</span> lhs</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">parse_expr</span>(<span class="params">dq</span>):</span></span><br><span class="line">        lhs = parse_term(dq)</span><br><span class="line">        <span class="keyword">while</span> dq <span class="keyword">and</span> dq[<span class="number">0</span>] <span class="keyword">in</span> [<span class="string">&#x27;+&#x27;</span>, <span class="string">&#x27;-&#x27;</span>]:</span><br><span class="line">            op = dq.popleft()</span><br><span class="line">            rhs = parse_term(dq)</span><br><span class="line">            lhs = lhs + rhs <span class="keyword">if</span> op == <span class="string">&#x27;+&#x27;</span> <span class="keyword">else</span> lhs - rhs</span><br><span class="line">        <span class="keyword">return</span> lhs</span><br><span class="line">    </span><br><span class="line">    dq = deque(<span class="built_in">list</span>(s))</span><br><span class="line">    <span class="keyword">return</span> parse_expr(dq)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Recursion. <a target="_blank" rel="noopener" href="https://leetcode.com/problems/basic-calculator-iii/discuss/371346/Python-recursive-solution">https://leetcode.com/problems/basic-calculator-iii/discuss/371346/Python-recursive-solution</a></p>
</blockquote>
<p>Run time: $O(n)$, space: $O(n)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calculate</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getSubExpr</span>(<span class="params">s</span>):</span></span><br><span class="line">        left = <span class="number">1</span></span><br><span class="line">        x = []</span><br><span class="line">        <span class="keyword">while</span> left != <span class="number">0</span>:</span><br><span class="line">            x.append(<span class="built_in">next</span>(s))</span><br><span class="line">            <span class="keyword">if</span> x[-<span class="number">1</span>] == <span class="string">&#x27;(&#x27;</span>:</span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> x[-<span class="number">1</span>] == <span class="string">&#x27;)&#x27;</span>:</span><br><span class="line">                left -= <span class="number">1</span></span><br><span class="line">        <span class="comment"># print(x[:-1])</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>.join(x[:-<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">    s = <span class="built_in">iter</span>(re.findall(<span class="string">&#x27;\d+|\S&#x27;</span>, s))</span><br><span class="line">    operand, sign = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">    total = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> token <span class="keyword">in</span> s:</span><br><span class="line">        <span class="comment"># print(token, operand, sign, total)</span></span><br><span class="line">        <span class="keyword">if</span> token <span class="keyword">in</span> <span class="string">&#x27;+-&#x27;</span>:</span><br><span class="line">            total += sign * operand</span><br><span class="line">            sign = [<span class="number">1</span>, -<span class="number">1</span>][token == <span class="string">&#x27;-&#x27;</span>]</span><br><span class="line">        <span class="keyword">elif</span> token <span class="keyword">in</span> <span class="string">&#x27;/*&#x27;</span>:</span><br><span class="line">            n = <span class="built_in">next</span>(s)</span><br><span class="line">            n = self.calculate(getSubExpr(s)) <span class="keyword">if</span> n == <span class="string">&#x27;(&#x27;</span> <span class="keyword">else</span> <span class="built_in">int</span>(n)</span><br><span class="line">            operand = operand*n <span class="keyword">if</span> token == <span class="string">&#x27;*&#x27;</span> <span class="keyword">else</span> operand/n</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            operand = self.calculate(getSubExpr(s)) <span class="keyword">if</span> token == <span class="string">&#x27;(&#x27;</span> <span class="keyword">else</span> <span class="built_in">int</span>(token)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">int</span>(total + sign * operand)</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>503. Next Greater Element II</summary>
<blockquote>
<p>This approach makes use of a stack. This stack stores the indices of the appropriate elements from numsnums array. The top of the stack refers to the index of the Next Greater Element found so far. We store the indices instead of the elements since there could be duplicates in the numsnums array. The description of the method will make the above statement clearer.</p>
</blockquote>
<p>We start traversing the numsnums array from right towards the left. For an element nums[i] encountered, we pop all the elements stack[top]stack[top] from the stack such that num[stack[top]] ≤ nums[i]. We continue the popping till we encounter a stack[top] satisfying nums[stack[top]]&gt;nums[i]. Now, it is obvious that the current stack[top] only can act as the Next Greater Element for nums[i](right now, considering only the elements lying to the right of nums[i]).</p>
<p>If no element remains on the top of the stack, it means no larger element than nums[i]nums[i] exists to its right. Along with this, we also push the index of the element just encountered(nums[i]), i.e. ii over the top of the stack, so that nums[i](or stack[top]) now acts as the Next Greater Element for the elements lying to its left.</p>
<p>We go through two such passes over the complete nums array. This is done so as to complete a circular traversal over the nums array. The first pass could make some wrong entries in the res array since it considers only the elements lying to the right of nums[i], without a circular traversal. But, these entries are corrected in the second pass.</p>
<p>Run time: $O(n)$, space: $O(n)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">nextGreaterElements</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span></span><br><span class="line">    stack, r = [], [-<span class="number">1</span>] * <span class="built_in">len</span>(nums)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">        <span class="keyword">while</span> stack <span class="keyword">and</span> (nums[stack[-<span class="number">1</span>]] &lt; nums[i]):</span><br><span class="line">            r[stack.pop()] = nums[i]</span><br><span class="line">        stack.append(i)</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">        <span class="keyword">while</span> stack <span class="keyword">and</span> (nums[stack[-<span class="number">1</span>]] &lt; nums[i]):</span><br><span class="line">            r[stack.pop()] = nums[i]</span><br><span class="line">        <span class="keyword">if</span> stack == []:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">return</span> r</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>739. Daily Temperatures</summary>
<blockquote>
<p>At each index currDay, check if the current day is the hottest one seen so far. If it is, update hottest and move on. Otherwise, do the following:</p>
</blockquote>
<ul>
<li>Initialize a variable days = 1 because the next warmer day must be at least one day in the future.</li>
<li>While temperatures[currDay + days] &lt;= temperatures[currDay]:</li>
<li>Add answer[currDay + days] to days. This effectively jumps directly to the next warmer day.</li>
<li>Set answer[currDay] = days.</li>
</ul>
<p>Run time: $O(n)$, space: $O(1)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dailyTemperatures</span>(<span class="params">self, temperatures: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span></span><br><span class="line">    n = <span class="built_in">len</span>(temperatures)</span><br><span class="line">    hot = <span class="number">0</span></span><br><span class="line">    ans = [<span class="number">0</span>] * n</span><br><span class="line">    <span class="keyword">for</span> curr_day <span class="keyword">in</span> <span class="built_in">range</span>(n-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>):</span><br><span class="line">        temp = temperatures[curr_day]</span><br><span class="line">        <span class="keyword">if</span> temp &gt;= hot:</span><br><span class="line">            hot = temp</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        </span><br><span class="line">        days = <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> temperatures[curr_day+days] &lt;= temp:</span><br><span class="line">            days += ans[curr_day+days]</span><br><span class="line">        </span><br><span class="line">        ans[curr_day] = days</span><br><span class="line">    <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<blockquote>
<p>If the stack is not empty, that means there are previous days for which we have not yet seen a warmer day.</p>
</blockquote>
<p>Run time: $O(n)$, space: $O(n)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dailyTemperatures</span>(<span class="params">self, temperatures: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span></span><br><span class="line">    n = <span class="built_in">len</span>(temperatures)</span><br><span class="line">    ans = [<span class="number">0</span>] * n</span><br><span class="line">    stack = []</span><br><span class="line">    <span class="keyword">for</span> day, temp <span class="keyword">in</span> <span class="built_in">enumerate</span>(temperatures):</span><br><span class="line">        <span class="keyword">while</span> stack <span class="keyword">and</span> temperatures[stack[-<span class="number">1</span>]] &lt; temp:</span><br><span class="line">            prev_day = stack.pop()</span><br><span class="line">            ans[prev_day] = day - prev_day</span><br><span class="line">        stack.append(day)</span><br><span class="line">    <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>20. Valid Parentheses</summary>
<blockquote>
<p>Pop the last element from the stack only if stack is not empty and the last element matches in the pair. In the end, check if stack is empty or not.</p>
</blockquote>
<p>Run time: $O(n)$, space: $O(n)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isValid</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">    stack = []</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(s) == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> c <span class="keyword">in</span> s:</span><br><span class="line">        <span class="keyword">if</span> stack <span class="keyword">and</span> c==<span class="string">&#x27;]&#x27;</span> <span class="keyword">and</span> stack[-<span class="number">1</span>]==<span class="string">&#x27;[&#x27;</span>:</span><br><span class="line">            stack.pop()</span><br><span class="line">        <span class="keyword">elif</span> stack <span class="keyword">and</span> c==<span class="string">&#x27;&#125;&#x27;</span> <span class="keyword">and</span> stack[-<span class="number">1</span>]==<span class="string">&#x27;&#123;&#x27;</span>:</span><br><span class="line">            stack.pop()</span><br><span class="line">        <span class="keyword">elif</span> stack <span class="keyword">and</span> c==<span class="string">&#x27;)&#x27;</span> <span class="keyword">and</span> stack[-<span class="number">1</span>]==<span class="string">&#x27;(&#x27;</span>:</span><br><span class="line">            stack.pop()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            stack.append(c)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">len</span>(stack)==<span class="number">0</span></span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>155. Min Stack</summary>
> Create a list. Keep track of current element, and the min element so far.
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.stack = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span>(<span class="params">self, val: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.stack:</span><br><span class="line">            self.stack.append((val,val))</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        min_val = self.stack[-<span class="number">1</span>][-<span class="number">1</span>]</span><br><span class="line">        self.stack.append((val,<span class="built_in">min</span>(val, min_val)))</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span>(<span class="params">self</span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">        self.stack.pop()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">top</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.stack[-<span class="number">1</span>][<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getMin</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.stack[-<span class="number">1</span>][<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<blockquote>
<p>two list, one normal list, one containing min element.</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.stack = []</span><br><span class="line">        self.min_stack = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span>(<span class="params">self, val: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">        self.stack.append(val)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.min_stack <span class="keyword">or</span> val &lt;= self.min_stack[-<span class="number">1</span>]:</span><br><span class="line">            self.min_stack.append(val)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span>(<span class="params">self</span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.min_stack[-<span class="number">1</span>] == self.stack[-<span class="number">1</span>]:</span><br><span class="line">            self.min_stack.pop()</span><br><span class="line">        self.stack.pop()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">top</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.stack[-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getMin</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.min_stack[-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>227. Basic Calculator II</summary>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calculate</span>(<span class="params">self, s</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    :type s: str</span></span><br><span class="line"><span class="string">    :rtype: int</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    num, stack, sign = <span class="number">0</span>, [], <span class="string">&quot;+&quot;</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)):</span><br><span class="line">        <span class="keyword">if</span> s[i].isdigit():</span><br><span class="line">            num = num * <span class="number">10</span> + <span class="built_in">int</span>(s[i])</span><br><span class="line">        <span class="keyword">if</span> s[i] <span class="keyword">in</span> <span class="string">&quot;+-*/&quot;</span> <span class="keyword">or</span> i == <span class="built_in">len</span>(s) - <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">if</span> sign == <span class="string">&quot;+&quot;</span>:</span><br><span class="line">                stack.append(num)</span><br><span class="line">            <span class="keyword">elif</span> sign == <span class="string">&quot;-&quot;</span>:</span><br><span class="line">                stack.append(-num)</span><br><span class="line">            <span class="keyword">elif</span> sign == <span class="string">&quot;*&quot;</span>:</span><br><span class="line">                stack.append(stack.pop()*num)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                stack.append(<span class="built_in">int</span>(stack.pop()/num))</span><br><span class="line">            num = <span class="number">0</span></span><br><span class="line">            sign = s[i]</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sum</span>(stack)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Stack. Use helper function <code>update</code> to append the operation result.</p>
</blockquote>
<p>Run time: $O(n)$, space: $O(n)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calculate</span>(<span class="params">self, s</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    :type s: str</span></span><br><span class="line"><span class="string">    :rtype: int</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">calc</span>(<span class="params">it</span>):</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">update</span>(<span class="params">op, v</span>):</span></span><br><span class="line">            <span class="keyword">if</span> op == <span class="string">&quot;+&quot;</span>: stack.append(v)</span><br><span class="line">            <span class="keyword">if</span> op == <span class="string">&quot;-&quot;</span>: stack.append(-v)</span><br><span class="line">            <span class="keyword">if</span> op == <span class="string">&quot;*&quot;</span>: stack.append(stack.pop() * v)</span><br><span class="line">            <span class="keyword">if</span> op == <span class="string">&quot;/&quot;</span>: stack.append(<span class="built_in">int</span>(stack.pop() / v))</span><br><span class="line">    </span><br><span class="line">        num, stack, sign = <span class="number">0</span>, [], <span class="string">&quot;+&quot;</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> it &lt; <span class="built_in">len</span>(s):</span><br><span class="line">            <span class="keyword">if</span> s[it].isdigit():</span><br><span class="line">                num = num * <span class="number">10</span> + <span class="built_in">int</span>(s[it])</span><br><span class="line">            <span class="keyword">elif</span> s[it] <span class="keyword">in</span> <span class="string">&quot;+-*/&quot;</span>:</span><br><span class="line">                update(sign, num)</span><br><span class="line">                num, sign = <span class="number">0</span>, s[it]</span><br><span class="line">            <span class="keyword">elif</span> s[it] == <span class="string">&quot;(&quot;</span>:</span><br><span class="line">                num, j = calc(it + <span class="number">1</span>)</span><br><span class="line">                it = j - <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> s[it] == <span class="string">&quot;)&quot;</span>:</span><br><span class="line">                update(sign, num)</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">sum</span>(stack), it + <span class="number">1</span></span><br><span class="line">            it += <span class="number">1</span></span><br><span class="line">        update(sign, num)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sum</span>(stack)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> calc(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<details>
<summary>my approach</summary>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calculate</span>(<span class="params">self, s</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    :type s: str</span></span><br><span class="line"><span class="string">    :rtype: int</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    stack = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)):</span><br><span class="line">        a = s[i]</span><br><span class="line">        <span class="keyword">if</span> a <span class="keyword">in</span> <span class="string">&quot;+-*/&quot;</span>:</span><br><span class="line">            stack.append(a)</span><br><span class="line">        <span class="keyword">elif</span> a.isnumeric():</span><br><span class="line">            j = i+<span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> j &lt; <span class="built_in">len</span>(s) <span class="keyword">and</span> s[j].isnumeric():</span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">            a = <span class="built_in">int</span>(s[i:j])</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(stack) &gt; <span class="number">1</span> <span class="keyword">and</span> stack[-<span class="number">1</span>] <span class="keyword">in</span> <span class="string">&quot;*/&quot;</span>:</span><br><span class="line">                op = stack.pop()</span><br><span class="line">                num = stack.pop()</span><br><span class="line">                <span class="keyword">if</span> op == <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">                    num *= a</span><br><span class="line">                <span class="keyword">elif</span> op == <span class="string">&#x27;/&#x27;</span>:</span><br><span class="line">                    num /= a</span><br><span class="line">                stack.append(num)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                stack.append(a)</span><br><span class="line">            </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> <span class="built_in">len</span>(stack) &gt; <span class="number">2</span>:</span><br><span class="line">        num2 = stack.pop()</span><br><span class="line">        op = stack.pop()</span><br><span class="line">        num1 = stack.pop()</span><br><span class="line">        <span class="keyword">if</span> op == <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">            num1 += num2</span><br><span class="line">        <span class="keyword">elif</span> op == <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">            num1 -= num2</span><br><span class="line">        stack.append(num1)</span><br><span class="line">    <span class="keyword">return</span> stack.pop()</span><br></pre></td></tr></table></figure>
</details>
</details>
<details>
<summary>71. Simplify Path</summary>
> First split the string by `/` and remove `.` and empty string, then create a stack to append each element, or pop from the nonempty stack if we see `..`.
<p>Run time: $O(n)$, space: $O(n)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">simplifyPath</span>(<span class="params">self, path</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    :type path: str</span></span><br><span class="line"><span class="string">    :rtype: str</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    places = [p <span class="keyword">for</span> p <span class="keyword">in</span> path.split(<span class="string">&quot;/&quot;</span>) <span class="keyword">if</span> p!=<span class="string">&quot;.&quot;</span> <span class="keyword">and</span> p!=<span class="string">&quot;&quot;</span>]</span><br><span class="line">    stack = []</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> p <span class="keyword">in</span> places:</span><br><span class="line">        <span class="keyword">if</span> p == <span class="string">&quot;..&quot;</span>:</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(stack) &gt; <span class="number">0</span>:</span><br><span class="line">                stack.pop()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            stack.append(p)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;/&quot;</span> + <span class="string">&quot;/&quot;</span>.join(stack)</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>735. Asteroid Collision</summary>
> Put every positive asteroid to a stack, if the next one is negative, compare if the absolute value is greater, then pop the top element since it will be collapsed. Keep doing this until stack is empty.
<p>Run time: $O(n)$, space: $O(n)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">asteroidCollision</span>(<span class="params">self, asteroids</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    :type asteroids: List[int]</span></span><br><span class="line"><span class="string">    :rtype: List[int]</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    ans = []</span><br><span class="line">    <span class="keyword">for</span> a <span class="keyword">in</span> asteroids:</span><br><span class="line">        <span class="keyword">while</span> ans <span class="keyword">and</span> a &lt; <span class="number">0</span> &lt; ans[-<span class="number">1</span>]: <span class="comment"># opposite direction</span></span><br><span class="line">            <span class="keyword">if</span> ans[-<span class="number">1</span>] &lt; -a: <span class="comment"># new asteroid is greater than existing one</span></span><br><span class="line">                ans.pop()</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">elif</span> ans[-<span class="number">1</span>] == -a:</span><br><span class="line">                ans.pop()</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            ans.append(a)</span><br><span class="line">    <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>1762. Buildings With an Ocean View</summary>
> Check from right to left and record the max height.
<p>Run time: $O(n)$, space: $O(n)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findBuildings</span>(<span class="params">self, heights: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span></span><br><span class="line">    res = collections.deque([<span class="built_in">len</span>(heights) - <span class="number">1</span>])</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(heights) - <span class="number">2</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">if</span> heights[i] &gt; heights[res[<span class="number">0</span>]]:</span><br><span class="line">            res.appendleft(i)</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<details>
<summary>my implementation</summary>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findBuildings</span>(<span class="params">self, heights</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    :type heights: List[int]</span></span><br><span class="line"><span class="string">    :rtype: List[int]</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(heights) == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> [heights[<span class="number">0</span>]]</span><br><span class="line"></span><br><span class="line">    curr_max = heights[-<span class="number">1</span>]</span><br><span class="line">    ans = [<span class="built_in">len</span>(heights)-<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(heights)-<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">        curr_h = heights[i]</span><br><span class="line">        <span class="keyword">if</span> curr_h &gt; curr_max:</span><br><span class="line">            ans.append(i)</span><br><span class="line">            curr_max = curr_h</span><br><span class="line">    <span class="keyword">return</span> ans[::-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
</details>
</details>
<h1>2 Pointers</h1>
<details>
<summary></summary>
> 
<p>Run time: $O()$, space: $O()$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>986. Interval List Intersections</summary>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/interval-list-intersections/discuss/1594033/Python-two-pointers-approach-explained">https://leetcode.com/problems/interval-list-intersections/discuss/1594033/Python-two-pointers-approach-explained</a></p>
</blockquote>
<p>Run time: $O(m+n)$, space: $O(m+n)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">intervalIntersection</span>(<span class="params">self, firstList: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]], secondList: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span></span><br><span class="line">    i, j, ans = <span class="number">0</span>, <span class="number">0</span>, []</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> i &lt; <span class="built_in">len</span>(firstList) <span class="keyword">and</span> j &lt; <span class="built_in">len</span>(secondList):</span><br><span class="line">        curr = [<span class="built_in">max</span>(firstList[i][<span class="number">0</span>], secondList[j][<span class="number">0</span>]), <span class="built_in">min</span>(firstList[i][<span class="number">1</span>], secondList[j][<span class="number">1</span>])]</span><br><span class="line">        <span class="keyword">if</span> curr[<span class="number">0</span>] &lt;= curr[<span class="number">1</span>]:</span><br><span class="line">            ans.append(curr)</span><br><span class="line">        <span class="keyword">if</span> firstList[i][<span class="number">1</span>] &lt;= secondList[j][<span class="number">1</span>]:</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            j += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>1574. Shortest Subarray to be Removed to Make Array Sorted</summary>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/shortest-subarray-to-be-removed-to-make-array-sorted/discuss/830699/Python-Two-Pointers-Approach-with-Explanation">https://leetcode.com/problems/shortest-subarray-to-be-removed-to-make-array-sorted/discuss/830699/Python-Two-Pointers-Approach-with-Explanation</a></p>
</blockquote>
<p>Run time: $O(n)$, space: $O(1)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findLengthOfShortestSubarray</span>(<span class="params">self, arr: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">    n = <span class="built_in">len</span>(arr)</span><br><span class="line">    s, e = <span class="number">0</span>, n-<span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> s+<span class="number">1</span>&lt;n <span class="keyword">and</span> arr[s]&lt;=arr[s+<span class="number">1</span>]:</span><br><span class="line">        s += <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> s == n-<span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> e-<span class="number">1</span>&gt;=<span class="number">0</span> <span class="keyword">and</span> arr[e-<span class="number">1</span>]&lt;=arr[e]:</span><br><span class="line">        e-=<span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> e==<span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> n-<span class="number">1</span></span><br><span class="line">    result = <span class="built_in">min</span>(n-<span class="number">1</span>-s,e)</span><br><span class="line">    </span><br><span class="line">    i, j = <span class="number">0</span>, e</span><br><span class="line">    <span class="keyword">while</span> i&lt;=s <span class="keyword">and</span> j&lt;n:</span><br><span class="line">        <span class="keyword">if</span> arr[i]&lt;=arr[j]:</span><br><span class="line">            result = <span class="built_in">min</span>(result,j-i-<span class="number">1</span>)  <span class="comment"># j- i -1 will be the length we want to delete</span></span><br><span class="line">            i+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            j+=<span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>777. Swap Adjacent in LR String</summary>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/swap-adjacent-in-lr-string/discuss/217070/Python-using-corresponding-position-">https://leetcode.com/problems/swap-adjacent-in-lr-string/discuss/217070/Python-using-corresponding-position-</a></p>
</blockquote>
<p>Run time: $O(n)$, space: $O(n)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">canTransform</span>(<span class="params">self, start: <span class="built_in">str</span>, end: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(start) != <span class="built_in">len</span>(end): <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    </span><br><span class="line">    A = [(s, idx) <span class="keyword">for</span> idx, s <span class="keyword">in</span> <span class="built_in">enumerate</span>(start) <span class="keyword">if</span> s == <span class="string">&#x27;L&#x27;</span> <span class="keyword">or</span> s == <span class="string">&#x27;R&#x27;</span>]</span><br><span class="line">    B = [(e, idx) <span class="keyword">for</span> idx, e <span class="keyword">in</span> <span class="built_in">enumerate</span>(end) <span class="keyword">if</span> e == <span class="string">&#x27;L&#x27;</span> <span class="keyword">or</span> e == <span class="string">&#x27;R&#x27;</span>]</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(A) != <span class="built_in">len</span>(B): <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (s, i), (e, j) <span class="keyword">in</span> <span class="built_in">zip</span>(A, B):</span><br><span class="line">        <span class="keyword">if</span> s != e: <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">if</span> s == <span class="string">&#x27;L&#x27;</span>:</span><br><span class="line">            <span class="keyword">if</span> i &lt; j:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">if</span> s == <span class="string">&#x27;R&#x27;</span>:</span><br><span class="line">            <span class="keyword">if</span> i &gt; j:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>632. Smallest Range Covering Elements from K Lists</summary>
<blockquote>
<p>Create a heap that stores &lt;first element, index of array, index of upper bound element, default 0&gt; for all arrays. Initialize the right pointer as the max of first elements in all arrays. As long as the priority queue is not empty, we pop the min element, and update the range if the new range is smaller. If the index of upper bound element reaches the end, we just return the current stored bound. Since we have popped one element from pq, we need to put the next element in the same array back, and we also need to update the upper bound.<br>
<a target="_blank" rel="noopener" href="https://leetcode.com/problems/smallest-range-covering-elements-from-k-lists/discuss/104904/Python-Heap-based-solution">https://leetcode.com/problems/smallest-range-covering-elements-from-k-lists/discuss/104904/Python-Heap-based-solution</a></p>
</blockquote>
<p>Run time: $O(n\log n)$, space: $O(k)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">smallestRange</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span></span><br><span class="line">    pq = [(row[<span class="number">0</span>], i, <span class="number">0</span>) <span class="keyword">for</span> i, row <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums)]</span><br><span class="line">    heapq.heapify(pq)</span><br><span class="line">    </span><br><span class="line">    ans = -<span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>), <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)</span><br><span class="line">    right = <span class="built_in">max</span>(row[<span class="number">0</span>] <span class="keyword">for</span> row <span class="keyword">in</span> nums) <span class="comment"># min possible element </span></span><br><span class="line">    <span class="keyword">while</span> pq:</span><br><span class="line">        left, i, j = heapq.heappop(pq)</span><br><span class="line">        <span class="keyword">if</span> right - left &lt; ans[<span class="number">1</span>] - ans[<span class="number">0</span>]: <span class="comment"># smaller bound</span></span><br><span class="line">            ans = left, right</span><br><span class="line">        <span class="keyword">if</span> j == <span class="built_in">len</span>(nums[i])-<span class="number">1</span>: <span class="comment"># reach the end of an array</span></span><br><span class="line">            <span class="keyword">return</span> ans</span><br><span class="line">        v = nums[i][j+<span class="number">1</span>] <span class="comment"># next number in the array</span></span><br><span class="line">        right = <span class="built_in">max</span>(right, v) <span class="comment"># update upper bound</span></span><br><span class="line">        heapq.heappush(pq, (v, i, j+<span class="number">1</span>)) <span class="comment"># put new number to pq</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>1423.  Maximum Points You Can Obtain from Cards</summary>
<blockquote>
<p>Since the sum of k choices are consecutive, we could find the sum of first k elements, then add last element from right, and remove last element from previous sum, keep doing until we get the sum of last k elements. During this process we could get the max sum.</p>
</blockquote>
<p>Run time: $O(n)$, space: $O(1)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">maxScore</span>(<span class="params">self, cardPoints: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">    s = <span class="built_in">sum</span>(cardPoints[:k])</span><br><span class="line">    ans = s</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, k+<span class="number">1</span>):</span><br><span class="line">        s += cardPoints[-i] - cardPoints[k-i]</span><br><span class="line">        ans = <span class="built_in">max</span>(ans, s)</span><br><span class="line">    <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>1610. Maximum Number of Visible Points</summary>
<blockquote>
<p>Helper function that find the angle given location and point. First, include points that are the same as location. Then create a list that contains all angles and sort it, then extend it by adding 360 for each element. Sliding window: as long as the right pointer is valid and the angle difference between left and right is valid, move right pointer. Then update the max points. Next, as long as the left pointer is smaller than the right, and the angle difference between left and right is not valid, move left pointer to the right.</p>
</blockquote>
<p>Run time: $O(n\log n)$, space: $O(n)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">visiblePoints</span>(<span class="params">self, points: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]], angle: <span class="built_in">int</span>, location: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">angle_from_location</span>(<span class="params">point</span>):</span></span><br><span class="line">        dx = point[<span class="number">0</span>] - location[<span class="number">0</span>]</span><br><span class="line">        dy = point[<span class="number">1</span>] - location[<span class="number">1</span>]</span><br><span class="line">        alpha = math.atan2(dy, dx) * (<span class="number">180</span> / math.pi) <span class="comment"># artan</span></span><br><span class="line">        <span class="keyword">if</span> alpha &gt;= <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> alpha</span><br><span class="line">        <span class="keyword">return</span> alpha + <span class="number">360</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># remove pts that are same as location</span></span><br><span class="line">    n = <span class="built_in">len</span>(points)</span><br><span class="line">    pts = [p <span class="keyword">for</span> p <span class="keyword">in</span> points <span class="keyword">if</span> p != location]</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> pts:</span><br><span class="line">        <span class="keyword">return</span> n</span><br><span class="line">    same_loc = n - <span class="built_in">len</span>(pts)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Sort the angles in ascending order, and extend by adding 360</span></span><br><span class="line">    angles = <span class="built_in">sorted</span>((angle_from_location(pt) <span class="keyword">for</span> pt <span class="keyword">in</span> pts))</span><br><span class="line">    angles += [a+<span class="number">360</span> <span class="keyword">for</span> a <span class="keyword">in</span> angles]</span><br><span class="line">    </span><br><span class="line">    max_pts = <span class="number">0</span></span><br><span class="line">    i,j = <span class="number">0</span>,<span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> j &lt; <span class="built_in">len</span>(angles):</span><br><span class="line">        <span class="keyword">while</span> j &lt; <span class="built_in">len</span>(angles) <span class="keyword">and</span> angles[j] - angles[i] &lt;= angle:</span><br><span class="line">            j += <span class="number">1</span></span><br><span class="line">        max_pts = <span class="built_in">max</span>(max_pts, j-i)</span><br><span class="line">        <span class="keyword">while</span> j &lt; <span class="built_in">len</span>(angles) <span class="keyword">and</span> i &lt; j <span class="keyword">and</span> angles[j] - angles[i] &gt; angle:</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> same_loc + max_pts</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>125. Valid Palindrome</summary>
<blockquote>
<p>two pointers.</p>
</blockquote>
<p>Run time: $O(n)$, space: $O(1)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isPalindrome</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">    i, j = <span class="number">0</span>, <span class="built_in">len</span>(s) - <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> i &lt; j:</span><br><span class="line">        <span class="keyword">while</span> i &lt; j <span class="keyword">and</span> <span class="keyword">not</span> s[i].isalnum():</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; j <span class="keyword">and</span> <span class="keyword">not</span> s[j].isalnum():</span><br><span class="line">            j -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> s[i].lower() != s[j].lower():</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">        j -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>Copy updated string to another variable and reverse.</p>
</blockquote>
<p>Run time: $O(n)$, space: $O(n)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isPalindrome</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">    string = <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">for</span> c <span class="keyword">in</span> s:</span><br><span class="line">        <span class="keyword">if</span> c.isalnum():</span><br><span class="line">            string += c.lower()</span><br><span class="line">    <span class="keyword">return</span> string == string[::-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>202. Happy Number</summary>
<blockquote>
<p>Floyd’s Cycle-Finding Algorithm<br>
Regardless of where the tortoise and hare start in the cycle, they are guaranteed to eventually meet. This is because the hare moves one node closer to the tortoise (in their direction of movement) each step.</p>
</blockquote>
<p>Instead of keeping track of just one value in the chain, we keep track of 2, called the slow runner and the fast runner. At each step of the algorithm, the slow runner goes forward by 1 number in the chain, and the fast runner goes forward by 2 numbers (nested calls to the getNext(n) function).</p>
<p>Run time: $O(\log n)$, space: $O(1)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isHappy</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_next</span>(<span class="params">number</span>):</span></span><br><span class="line">        total_sum = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> number &gt; <span class="number">0</span>:</span><br><span class="line">            number, digit = <span class="built_in">divmod</span>(number, <span class="number">10</span>)</span><br><span class="line">            total_sum += digit ** <span class="number">2</span></span><br><span class="line">        <span class="keyword">return</span> total_sum</span><br><span class="line"></span><br><span class="line">    slow_runner = n</span><br><span class="line">    fast_runner = get_next(n)</span><br><span class="line">    <span class="keyword">while</span> fast_runner != <span class="number">1</span> <span class="keyword">and</span> slow_runner != fast_runner:</span><br><span class="line">        slow_runner = get_next(slow_runner)</span><br><span class="line">        fast_runner = get_next(get_next(fast_runner))</span><br><span class="line">    <span class="keyword">return</span> fast_runner == <span class="number">1</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>Helper function that find the next number, keep calling this until the number is in the set or it equals 1.<br>
Run time: $O(\log n)$, space: $O(\log n)$</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isHappy</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    s = <span class="built_in">set</span>()</span><br><span class="line">    <span class="keyword">while</span> n <span class="keyword">not</span> <span class="keyword">in</span> s:</span><br><span class="line">        s.add(n)</span><br><span class="line">        temp_sum = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> n &gt; <span class="number">0</span>:</span><br><span class="line">            temp_sum += (n % <span class="number">10</span>)**<span class="number">2</span></span><br><span class="line">            n //= <span class="number">10</span></span><br><span class="line">        <span class="keyword">if</span> temp_sum == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        n = temp_sum</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>31. Next Permutation</summary>
> First find the point where the descending sub-array starts, and then find the last ascending position, swap them, and swap the elements from the start descending position to the end.
<p>Run time: $O(n)$, space: $O(1)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">nextPermutation</span>(<span class="params">self, nums</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    :type nums: List[int]</span></span><br><span class="line"><span class="string">    :rtype: None Do not return anything, modify nums in-place instead.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    i = <span class="built_in">len</span>(nums)-<span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> nums[i-<span class="number">1</span>] &gt;= nums[i]:</span><br><span class="line">        i -= <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> i == <span class="number">0</span>:</span><br><span class="line">        nums.reverse()</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># find the last ascending position</span></span><br><span class="line">    i, j = i-<span class="number">1</span>, <span class="built_in">len</span>(nums)-<span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> nums[j] &lt;= nums[i]:</span><br><span class="line">        j -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># reverse</span></span><br><span class="line">    nums[i], nums[j] = nums[j], nums[i]</span><br><span class="line">    l = i+<span class="number">1</span></span><br><span class="line">    r = <span class="built_in">len</span>(nums)-<span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> l &lt; r:</span><br><span class="line">        nums[l], nums[r] = nums[r], nums[l]</span><br><span class="line">        l, r = l+<span class="number">1</span>, r-<span class="number">1</span></span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>680. Valid Palindrome II</summary>
> Use 2 pointers to walk through the string, if not match, then check if removing either start or end character might be palindrome. Then update the pointers.
<p>Run time: $O(n)$, space: $O(1)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">validPalindrome</span>(<span class="params">self, s</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    :type s: str</span></span><br><span class="line"><span class="string">    :rtype: bool</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isPalindrome</span>(<span class="params">s</span>):</span></span><br><span class="line">        <span class="keyword">return</span> s == s[::-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">    start, end = <span class="number">0</span>, <span class="built_in">len</span>(s)-<span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> start &lt; end:</span><br><span class="line">        <span class="keyword">if</span> s[start] != s[end]:</span><br><span class="line">            op_1 = s[start+<span class="number">1</span>:end+<span class="number">1</span>] <span class="comment"># remove start</span></span><br><span class="line">            op_2 = s[start:end] <span class="comment"># remove end</span></span><br><span class="line">            <span class="keyword">return</span> isPalindrome(op_1) <span class="keyword">or</span> isPalindrome(op_2)</span><br><span class="line">        start += <span class="number">1</span></span><br><span class="line">        end -= <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>
</details>
<h1>Hash &amp; Heap</h1>
<details>
<summary></summary>
> 
<p>Run time: $O()$, space: $O()$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>336. Palindrome Pairs</summary>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/palindrome-pairs/discuss/79209/Accepted-Python-Solution-With-Explanation">https://leetcode.com/problems/palindrome-pairs/discuss/79209/Accepted-Python-Solution-With-Explanation</a></p>
</blockquote>
<p>Run time: $O(n * w^2)$, space: $O(n)$, being length of the list, w being the average word length</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">palindromePairs</span>(<span class="params">self, words: <span class="type">List</span>[<span class="built_in">str</span>]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_palindrome</span>(<span class="params">check</span>):</span></span><br><span class="line">        <span class="keyword">return</span> check == check[::-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">    words = &#123;word: i <span class="keyword">for</span> i, word <span class="keyword">in</span> <span class="built_in">enumerate</span>(words)&#125;</span><br><span class="line">    valid_pals = []</span><br><span class="line">    <span class="keyword">for</span> word, k <span class="keyword">in</span> words.items():</span><br><span class="line">        n = <span class="built_in">len</span>(word)</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n+<span class="number">1</span>):</span><br><span class="line">            pref = word[:j]</span><br><span class="line">            suf = word[j:]</span><br><span class="line">            <span class="keyword">if</span> is_palindrome(pref):</span><br><span class="line">                back = suf[::-<span class="number">1</span>]</span><br><span class="line">                <span class="keyword">if</span> back != word <span class="keyword">and</span> back <span class="keyword">in</span> words:</span><br><span class="line">                    valid_pals.append([words[back],  k])</span><br><span class="line">            <span class="keyword">if</span> j != n <span class="keyword">and</span> is_palindrome(suf):</span><br><span class="line">                back = pref[::-<span class="number">1</span>]</span><br><span class="line">                <span class="keyword">if</span> back != word <span class="keyword">and</span> back <span class="keyword">in</span> words:</span><br><span class="line">                    valid_pals.append([k, words[back]])</span><br><span class="line">    <span class="keyword">return</span> valid_pals</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>745.  Prefix and Suffix Search</summary>
<blockquote>
<p>store apple=apple in the list, then concatenate all words using space. When finding a word using given prefix and suffix, search for suffix=prefix, and return the index-1 to exclude the equal sign.<br>
<a target="_blank" rel="noopener" href="https://leetcode.com/problems/prefix-and-suffix-search/discuss/483341/Short-Python">https://leetcode.com/problems/prefix-and-suffix-search/discuss/483341/Short-Python</a></p>
</blockquote>
<p>Run time: $O(n)$, space: $O(n)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WordFilter</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, words</span>):</span>        </span><br><span class="line">        self.magic = []</span><br><span class="line">        <span class="keyword">for</span> word <span class="keyword">in</span> <span class="built_in">reversed</span>(words):</span><br><span class="line">            self.magic.append(word+<span class="string">&#x27;=&#x27;</span>+word) </span><br><span class="line">        self.magic = <span class="string">&#x27; &#x27;</span>.join(self.magic)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">f</span>(<span class="params">self, prefix, suffix</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.magic.count(<span class="string">&#x27;=&#x27;</span>, self.magic.find(suffix+<span class="string">&#x27;=&#x27;</span>+prefix))-<span class="number">1</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>Store all possible start and end combinations to the dictionary. Use # to separate the prefix and suffix.</p>
</blockquote>
<p>Run time: $O(n^2)$, space: $O(n^2)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WordFilter</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, words: <span class="type">List</span>[<span class="built_in">str</span>]</span>):</span></span><br><span class="line">        self.dic = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> weight, word <span class="keyword">in</span> <span class="built_in">enumerate</span>(words):</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(word)+<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(word)+<span class="number">1</span>):</span><br><span class="line">                    self.dic[word[:i]+<span class="string">&quot;#&quot;</span>+word[j:]] = weight</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">f</span>(<span class="params">self, prefix: <span class="built_in">str</span>, suffix: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.dic.get(prefix+<span class="string">&#x27;#&#x27;</span>+suffix, -<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Your WordFilter object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"># obj = WordFilter(words)</span></span><br><span class="line"><span class="comment"># param_1 = obj.f(prefix,suffix)</span></span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>659.  Split Array into Consecutive Subsequences</summary>
<blockquote>
<p>Use one dictionary to count each number’s occurrences, and use one dictionary to count the number of valid subsequence ending at certain number. For each number, first decrement its occurrence if any, then check if there exists a valid sequence ending at n-1 already, if so, just decrement that sequence’s occurrence and put the new number in. Otherwise, check if there are two more numbers that could form a new subsequence, if so,  decrement the other two numbers’ occurrences and add the ending number of the dictionary. Other than these two cases, we have to return False.</p>
</blockquote>
<p>Run time: $O(n)$, space: $O(n)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isPossible</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">    left = collections.Counter(nums)</span><br><span class="line">    end = collections.Counter()</span><br><span class="line">    <span class="keyword">for</span> n <span class="keyword">in</span> nums:</span><br><span class="line">        <span class="keyword">if</span> left[n] == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        left[n] -= <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> end[n-<span class="number">1</span>] &gt; <span class="number">0</span>: <span class="comment"># there is already a valid subsequence</span></span><br><span class="line">            end[n-<span class="number">1</span>] -= <span class="number">1</span></span><br><span class="line">            end[n] += <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> left[n+<span class="number">1</span>] <span class="keyword">and</span> left[n+<span class="number">2</span>]: <span class="comment"># it could form a valid subsequence with unvisited elements</span></span><br><span class="line">            left[n+<span class="number">1</span>] -= <span class="number">1</span></span><br><span class="line">            left[n+<span class="number">2</span>] -= <span class="number">1</span></span><br><span class="line">            end[n+<span class="number">2</span>] += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>299. Bulls and Cows</summary>
<blockquote>
<p>Use two dictionary to keep track of unmatched chars. After one loop, check for each key in original string, get the min of two occurrences.</p>
</blockquote>
<p>Run time: $O(n)$, space: $O(n)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getHint</span>(<span class="params">self, secret: <span class="built_in">str</span>, guess: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span></span><br><span class="line">    s,g = defaultdict(<span class="built_in">int</span>), defaultdict(<span class="built_in">int</span>)</span><br><span class="line">    match,occurred = <span class="number">0</span>,<span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(guess)):</span><br><span class="line">        <span class="keyword">if</span> secret[i] == guess[i]:</span><br><span class="line">            match += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            s[secret[i]] += <span class="number">1</span></span><br><span class="line">            g[guess[i]] += <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> s.keys():</span><br><span class="line">        <span class="keyword">if</span> k <span class="keyword">in</span> g:</span><br><span class="line">            occurred += <span class="built_in">min</span>(s[k], g[k])</span><br><span class="line">    <span class="keyword">return</span> <span class="string">f&quot;<span class="subst">&#123;match&#125;</span>A<span class="subst">&#123;occurred&#125;</span>B&quot;</span></span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>2034. Stock Price Fluctuation</summary>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/stock-price-fluctuation/discuss/1513293/Python-Clean-2-Heaps-Commented-Code">https://leetcode.com/problems/stock-price-fluctuation/discuss/1513293/Python-Clean-2-Heaps-Commented-Code</a></p>
</blockquote>
<p>Run time: $O(\log n)$, space: $O(n)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StockPrice</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.timestamps = &#123;&#125;</span><br><span class="line">        self.latestTimestamp = <span class="number">0</span></span><br><span class="line">        self.minHeap = []</span><br><span class="line">        self.maxHeap = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">update</span>(<span class="params">self, timestamp: <span class="built_in">int</span>, price: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">        <span class="comment">#Keep track of current prices</span></span><br><span class="line">        self.timestamps[timestamp] = price</span><br><span class="line">        self.latestTimestamp = <span class="built_in">max</span>(self.latestTimestamp, timestamp)</span><br><span class="line">        </span><br><span class="line">		<span class="comment">#For maximum/minimum</span></span><br><span class="line">        heappush(self.minHeap, (price, timestamp))</span><br><span class="line">        heappush(self.maxHeap, (-price, timestamp))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">current</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.timestamps[self.latestTimestamp]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maximum</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        currPrice, timestamp = heapq.heappop(self.maxHeap)</span><br><span class="line">		</span><br><span class="line">		<span class="comment">#If the price from the heap doesn&#x27;t match the price the timestamp indicates, keep popping from the heap</span></span><br><span class="line">        <span class="keyword">while</span> -currPrice != self.timestamps[timestamp]:</span><br><span class="line">            currPrice, timestamp = heapq.heappop(self.maxHeap)</span><br><span class="line">            </span><br><span class="line">        heapq.heappush(self.maxHeap, (currPrice, timestamp))</span><br><span class="line">        <span class="keyword">return</span> -currPrice</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minimum</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        currPrice, timestamp = heapq.heappop(self.minHeap)</span><br><span class="line">		</span><br><span class="line">		<span class="comment">#If the price from the heap doesn&#x27;t match the price the timestamp indicates, keep popping from the heap</span></span><br><span class="line">        <span class="keyword">while</span> currPrice != self.timestamps[timestamp]:</span><br><span class="line">            currPrice, timestamp = heapq.heappop(self.minHeap)</span><br><span class="line">            </span><br><span class="line">        heapq.heappush(self.minHeap, (currPrice, timestamp))</span><br><span class="line">        <span class="keyword">return</span> currPrice</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sortedcontainers <span class="keyword">import</span> SortedDict</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StockPrice</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.time_to_prices = SortedDict() <span class="comment"># &lt;timestamp, price&gt;</span></span><br><span class="line">        self.rec = SortedDict() <span class="comment"># &lt;price, set of timestamps&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">update</span>(<span class="params">self, timestamp: <span class="built_in">int</span>, price: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">        <span class="keyword">if</span> timestamp <span class="keyword">in</span> self.time_to_prices:</span><br><span class="line">            prev_price = self.time_to_prices[timestamp]</span><br><span class="line">            self.rec[prev_price].remove(timestamp)</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(self.rec[prev_price]) == <span class="number">0</span>:</span><br><span class="line">                self.rec.pop(prev_price)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> price <span class="keyword">in</span> self.rec:</span><br><span class="line">            self.rec[price] = <span class="built_in">set</span>()</span><br><span class="line">            </span><br><span class="line">        self.rec[price].add(timestamp)</span><br><span class="line">        self.time_to_prices[timestamp] = price</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">current</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.time_to_prices.peekitem(-<span class="number">1</span>)[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maximum</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.rec.peekitem(-<span class="number">1</span>)[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minimum</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.rec.peekitem(<span class="number">0</span>)[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Your StockPrice object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"># obj = StockPrice()</span></span><br><span class="line"><span class="comment"># obj.update(timestamp,price)</span></span><br><span class="line"><span class="comment"># param_2 = obj.current()</span></span><br><span class="line"><span class="comment"># param_3 = obj.maximum()</span></span><br><span class="line"><span class="comment"># param_4 = obj.minimum()</span></span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>981. Time Based Key-Value Store</summary>
<blockquote>
<p>Maintain two dictionary that store &lt;key, timestamp&gt; and &lt;key, value&gt;. Get the index of the asked timestamp and then use it to retrieve value.</p>
</blockquote>
<p>Run time: $O(\log n)$, space: $O(n)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TimeMap</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.times = collections.defaultdict(<span class="built_in">list</span>)</span><br><span class="line">        self.values = collections.defaultdict(<span class="built_in">list</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">set</span>(<span class="params">self, key: <span class="built_in">str</span>, value: <span class="built_in">str</span>, timestamp: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">        self.times[key].append(timestamp)</span><br><span class="line">        self.values[key].append(value)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span>(<span class="params">self, key: <span class="built_in">str</span>, timestamp: <span class="built_in">int</span></span>) -&gt; <span class="built_in">str</span>:</span></span><br><span class="line">        i = bisect.bisect(self.times[key], timestamp)</span><br><span class="line">        <span class="keyword">return</span> self.values[key][i - <span class="number">1</span>] <span class="keyword">if</span> i <span class="keyword">else</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Your TimeMap object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"># obj = TimeMap()</span></span><br><span class="line"><span class="comment"># obj.set(key,value,timestamp)</span></span><br><span class="line"><span class="comment"># param_2 = obj.get(key,timestamp)</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TimeMap</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.dic = collections.defaultdict(<span class="built_in">list</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">set</span>(<span class="params">self, key: <span class="built_in">str</span>, value: <span class="built_in">str</span>, timestamp: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">        self.dic[key].append([timestamp, value])</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span>(<span class="params">self, key: <span class="built_in">str</span>, timestamp: <span class="built_in">int</span></span>) -&gt; <span class="built_in">str</span>:</span></span><br><span class="line">        arr = self.dic[key]</span><br><span class="line">        n = <span class="built_in">len</span>(arr)</span><br><span class="line">        </span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        right = n</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            mid = (left + right) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> arr[mid][<span class="number">0</span>] &lt;= timestamp:</span><br><span class="line">                left = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> arr[mid][<span class="number">0</span>] &gt; timestamp:</span><br><span class="line">                right = mid</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span> <span class="keyword">if</span> right == <span class="number">0</span> <span class="keyword">else</span> arr[right - <span class="number">1</span>][<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>2013. Detect Squares</summary>
<blockquote>
<p>First find the diagonal point, and then get the count of the other two points.<br>
<a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=bahebearrDc">https://www.youtube.com/watch?v=bahebearrDc</a></p>
</blockquote>
<p>Run time: $O(n)$, space: $O(n)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DetectSquares</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.pts = defaultdict(<span class="built_in">int</span>)</span><br><span class="line">        self.pts_list = []</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">self, point: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">        self.pts[<span class="built_in">tuple</span>(point)] += <span class="number">1</span></span><br><span class="line">        self.pts_list.append(point)</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">count</span>(<span class="params">self, point: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        x1,y1 = point[<span class="number">0</span>], point[<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">for</span> x2, y2 <span class="keyword">in</span> self.pts_list:</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">abs</span>(x2-x1) != <span class="built_in">abs</span>(y2-y1) <span class="keyword">or</span> x1 == x2 <span class="keyword">or</span> y1 == y2:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            count += self.pts[(x1, y2)] * self.pts[(x2, y1)]</span><br><span class="line">        <span class="keyword">return</span> count</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Your DetectSquares object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"># obj = DetectSquares()</span></span><br><span class="line"><span class="comment"># obj.add(point)</span></span><br><span class="line"><span class="comment"># param_2 = obj.count(point)</span></span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>954. Array of Doubled Pairs</summary>
<blockquote>
<p>Count the frequencies for each element, then sort it by absolute value. If the occurrence of current number is greater than its double, return False, otherwise subtract the occurrence of current number from its double.</p>
</blockquote>
<p>Run time: $O(n\log n)$, space: $O(n)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">canReorderDoubled</span>(<span class="params">self, arr: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">    count = Counter(arr)</span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">sorted</span>(count, key=<span class="built_in">abs</span>):</span><br><span class="line">        <span class="keyword">if</span> count[x] &gt; count[<span class="number">2</span>*x]:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        count[<span class="number">2</span>*x] -= count[x]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>1834. Single-Threaded CPU</summary>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/single-threaded-cpu/discuss/1654840/Fastest-Python-Submission-Code-%2B-Steps">https://leetcode.com/problems/single-threaded-cpu/discuss/1654840/Fastest-Python-Submission-Code-%2B-Steps</a></p>
</blockquote>
<p>Run time: $O(n\log n)$, space: $O(n)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">getOrder</span>(<span class="params">self, tasks: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span></span><br><span class="line">      tasks = <span class="built_in">sorted</span>([t + [i] <span class="keyword">for</span> i, t <span class="keyword">in</span> <span class="built_in">enumerate</span>(tasks)])</span><br><span class="line">      heap, ans = [], []</span><br><span class="line">      last_enq = <span class="number">0</span></span><br><span class="line"><span class="comment">#Process Tasks</span></span><br><span class="line">      <span class="keyword">for</span> time, pro, idx <span class="keyword">in</span> tasks:</span><br><span class="line">          <span class="keyword">while</span> heap <span class="keyword">and</span> last_enq &lt; time:</span><br><span class="line">              p, i, e = heapq.heappop(heap)</span><br><span class="line">              last_enq = <span class="built_in">max</span>(e, last_enq) + p</span><br><span class="line">              ans.append(i)</span><br><span class="line">          heapq.heappush(heap, (pro, idx, time))</span><br><span class="line">      <span class="comment">#Empty heap</span></span><br><span class="line">      <span class="keyword">while</span> heap:</span><br><span class="line">          _, i, _ = heapq.heappop(heap)</span><br><span class="line">          ans.append(i)</span><br><span class="line">      <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>690. Employee Importance</summary>
<blockquote>
<p>Put &lt;id, Employee&gt; in a map, then call helper function to add the importance and call recursively.</p>
</blockquote>
<p>Run time: $O(n)$, space: $O(n)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string"># Definition for Employee.</span></span><br><span class="line"><span class="string">class Employee:</span></span><br><span class="line"><span class="string">    def __init__(self, id: int, importance: int, subordinates: List[int]):</span></span><br><span class="line"><span class="string">        self.id = id</span></span><br><span class="line"><span class="string">        self.importance = importance</span></span><br><span class="line"><span class="string">        self.subordinates = subordinates</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getImportance</span>(<span class="params">self, employees: <span class="type">List</span>[<span class="string">&#x27;Employee&#x27;</span>], <span class="built_in">id</span>: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">emp</span>):</span></span><br><span class="line">            imp = emps[emp].importance            </span><br><span class="line">            <span class="keyword">for</span> s <span class="keyword">in</span> emps[emp].subordinates:</span><br><span class="line">                imp += dfs(s)</span><br><span class="line">            <span class="keyword">return</span> imp</span><br><span class="line">        </span><br><span class="line">        emps= &#123;emp.<span class="built_in">id</span>: emp <span class="keyword">for</span> emp <span class="keyword">in</span> employees&#125;</span><br><span class="line">        <span class="keyword">return</span> dfs(<span class="built_in">id</span>)</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>359. Logger Rate Limiter</summary>
<blockquote>
<p>Use a dictionary to store &lt;message, most recent logged time&gt;.</p>
</blockquote>
<p>Run time: $O(1)$, space: $O(m)$, where $m$ is the number of unique messages.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Logger</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.msg_dict = &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">shouldPrintMessage</span>(<span class="params">self, timestamp: <span class="built_in">int</span>, message: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        <span class="keyword">if</span> message <span class="keyword">not</span> <span class="keyword">in</span> self.msg_dict:</span><br><span class="line">            self.msg_dict[message] = timestamp</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">if</span> timestamp - self.msg_dict[message] &gt;= <span class="number">10</span>:</span><br><span class="line">            self.msg_dict[message] = timestamp</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Your Logger object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"># obj = Logger()</span></span><br><span class="line"><span class="comment"># param_1 = obj.shouldPrintMessage(timestamp,message)</span></span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>1146. Snapshot Array</summary>
<blockquote>
<p>Take individual snap shot when set is called, increment snap id (self.i), when snap is called<br>
This is fast to set &amp; snap but relatively slow when you do an get. Even if it’s binary search, make keys indexable take time.<br>
<a target="_blank" rel="noopener" href="https://leetcode.com/problems/snapshot-array/discuss/850249/Python-3-or-Three-Methods-or-Explanations">https://leetcode.com/problems/snapshot-array/discuss/850249/Python-3-or-Three-Methods-or-Explanations</a></p>
</blockquote>
<p>Run time: $O(1)$ and $O(\log n)$, space: $O(n)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SnapshotArray</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, length: <span class="built_in">int</span></span>):</span></span><br><span class="line">        self.cache = defaultdict(<span class="keyword">lambda</span>: OrderedDict())</span><br><span class="line">        self.s = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">set</span>(<span class="params">self, index: <span class="built_in">int</span>, val: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">        self.cache[index][self.s] = val</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">snap</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        self.s += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> self.s-<span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span>(<span class="params">self, index: <span class="built_in">int</span>, snap_id: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="keyword">if</span> index <span class="keyword">not</span> <span class="keyword">in</span> self.cache:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            snaps = self.cache[index]</span><br><span class="line">            <span class="keyword">if</span> snap_id <span class="keyword">in</span> snaps:</span><br><span class="line">                <span class="keyword">return</span> snaps[snap_id]</span><br><span class="line">            keys = <span class="built_in">list</span>(snaps.keys())</span><br><span class="line">            <span class="keyword">if</span> snap_id &gt; keys[-<span class="number">1</span>]:</span><br><span class="line">                <span class="keyword">return</span> snaps[keys[-<span class="number">1</span>]]</span><br><span class="line"></span><br><span class="line">            ind = bisect.bisect(keys, snap_id)</span><br><span class="line">            <span class="keyword">if</span> ind == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            <span class="keyword">return</span> snaps[keys[ind-<span class="number">1</span>]]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Your SnapshotArray object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"># obj = SnapshotArray(length)</span></span><br><span class="line"><span class="comment"># obj.set(index,val)</span></span><br><span class="line"><span class="comment"># param_2 = obj.snap()</span></span><br><span class="line"><span class="comment"># param_3 = obj.get(index,snap_id)</span></span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>2007. Find Original Array From Doubled Array</summary>
<blockquote>
<p>Put everything to Counter, and loop through each key. Handle the case when key is zero, and all other cases, first find the smallest number if its half is also in the counter, then append the occurrences to the output, and remove this key and reduce the doubled number occurrences.</p>
</blockquote>
<p>Run time: $O(n)$, space: $O(n)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findOriginalArray</span>(<span class="params">self, changed: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span></span><br><span class="line">    counter = collections.Counter(changed)</span><br><span class="line">    res = []</span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> counter.keys():</span><br><span class="line">        <span class="keyword">if</span> k == <span class="number">0</span>:</span><br><span class="line">            <span class="comment"># handle zero as special case</span></span><br><span class="line">            <span class="keyword">if</span> counter[k] % <span class="number">2</span> != <span class="number">0</span>: <span class="comment"># only one zero</span></span><br><span class="line">                <span class="keyword">return</span> []</span><br><span class="line">            res += [<span class="number">0</span>] * (counter[k] // <span class="number">2</span>)</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">elif</span> counter[k] &gt; <span class="number">0</span>:</span><br><span class="line">            x = k</span><br><span class="line">            <span class="comment"># walk down the chain</span></span><br><span class="line">            <span class="keyword">while</span> x % <span class="number">2</span> == <span class="number">0</span> <span class="keyword">and</span> x // <span class="number">2</span> <span class="keyword">in</span> counter:</span><br><span class="line">                x = x // <span class="number">2</span></span><br><span class="line">                </span><br><span class="line">            <span class="comment"># walk up and process all numbers within the chain. mark the counts as 0</span></span><br><span class="line">            <span class="keyword">while</span> x <span class="keyword">in</span> counter:</span><br><span class="line">                <span class="keyword">if</span> counter[x] &gt; <span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">if</span> counter[x+x] &lt; counter[x]:</span><br><span class="line">                        <span class="keyword">return</span> []</span><br><span class="line">                    res += [x] * counter[x]</span><br><span class="line">                    counter[x+x] -= counter[x]</span><br><span class="line">                    counter[x] = <span class="number">0</span></span><br><span class="line">                x += x</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>295. Find Median from Data Stream</summary>
<blockquote>
<p>The idea is to keep two heaps: one for the top half of our data and another is for down half of our data.<br>
If we have even size 2n, then we will keep two heaps with size n<br>
If we have odd size 2n+1, then we will keep size of the small heap n+1 ans the size of large heap n.<br>
When we have new element num, we always put it to small heap, and then normalize our heaps: remove biggest element from the small heap and put it to the large heap. After this operation we can be sure that we have the property that the largest element in small heap is smaller than smaller elements in large heap.<br>
However after this step if we had n, n elements, we will have n, n+1 elements, so we need to put one element from large heap to small heap.<br>
<a target="_blank" rel="noopener" href="https://leetcode.com/problems/find-median-from-data-stream/discuss/1330808/Python-2-heaps-solution-explained">https://leetcode.com/problems/find-median-from-data-stream/discuss/1330808/Python-2-heaps-solution-explained</a></p>
</blockquote>
<p>Run time: $O(\log n)$, space: $O(n)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MedianFinder</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.small, self.large = [], [] </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addNum</span>(<span class="params">self, num: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">        heappush(self.small, -num)           </span><br><span class="line">        heappush(self.large, -heappop(self.small))</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(self.small) &lt; <span class="built_in">len</span>(self.large):</span><br><span class="line">            heappush(self.small, -heappop(self.large))</span><br><span class="line">            </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findMedian</span>(<span class="params">self</span>) -&gt; <span class="built_in">float</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(self.large) != <span class="built_in">len</span>(self.small):</span><br><span class="line">            <span class="keyword">return</span> -self.small[<span class="number">0</span>]                  </span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> (self.large[<span class="number">0</span>] - self.small[<span class="number">0</span>]) / <span class="number">2</span> </span><br><span class="line">        </span><br><span class="line"><span class="comment"># Your MedianFinder object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"># obj = MedianFinder()</span></span><br><span class="line"><span class="comment"># obj.addNum(num)</span></span><br><span class="line"><span class="comment"># param_2 = obj.findMedian()</span></span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>498. Diagonal Traverse</summary>
<blockquote>
<p>Create a dictionary, and use the sum of indices as key, and list of values as values. Reverse the list and append to output array if the key is odd.</p>
</blockquote>
<p>Run time: $O(mn)$, space: $O(mn)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">d = defaultdict(<span class="built_in">list</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(mat)):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(mat[<span class="number">0</span>])):</span><br><span class="line">        d[i+j].append(mat[i][j])</span><br><span class="line"></span><br><span class="line">ans = []</span><br><span class="line"><span class="keyword">for</span> k,v <span class="keyword">in</span> d.items():</span><br><span class="line">    <span class="keyword">if</span> k % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">        ans += v[::-<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        ans += v</span><br><span class="line"><span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">      d=&#123;&#125;</span><br><span class="line"><span class="comment">#loop through matrix</span></span><br><span class="line">      <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(matrix)):</span><br><span class="line">          <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(matrix[i])):</span><br><span class="line">		<span class="comment">#if no entry in dictionary for sum of indices aka the diagonal, create one</span></span><br><span class="line">              <span class="keyword">if</span> i + j <span class="keyword">not</span> <span class="keyword">in</span> d:</span><br><span class="line">                  d[i+j] = [matrix[i][j]]</span><br><span class="line">              <span class="keyword">else</span>:</span><br><span class="line">		<span class="comment">#If you&#x27;ve already passed over this diagonal, keep adding elements to it!</span></span><br><span class="line">                  d[i+j].append(matrix[i][j])</span><br><span class="line"><span class="comment"># we&#x27;re done with the pass, let&#x27;s build our answer array</span></span><br><span class="line">      ans= []</span><br><span class="line"><span class="comment">#look at the diagonal and each diagonal&#x27;s elements</span></span><br><span class="line">      <span class="keyword">for</span> entry <span class="keyword">in</span> d.items():</span><br><span class="line">	<span class="comment">#each entry looks like (diagonal level (sum of indices), [elem1, elem2, elem3, ...])</span></span><br><span class="line">	<span class="comment">#snake time, look at the diagonal level</span></span><br><span class="line">          <span class="keyword">if</span> entry[<span class="number">0</span>] % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">		<span class="comment">#Here we append in reverse order because its an even numbered level/diagonal. </span></span><br><span class="line">              [ans.append(x) <span class="keyword">for</span> x <span class="keyword">in</span> entry[<span class="number">1</span>][::-<span class="number">1</span>]]</span><br><span class="line">          <span class="keyword">else</span>:</span><br><span class="line">              [ans.append(x) <span class="keyword">for</span> x <span class="keyword">in</span> entry[<span class="number">1</span>]]</span><br><span class="line">      <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>523. Continuous Subarray Sum</summary>
<blockquote>
<p>Same as Subarray sum equals K with modification. Basic idea is that, If you get the same remainder again, it means that you’ve encountered some sum which is a multiple of K.<br>
why {0:-1}? In the case the sum of the array a multiple of k, we should store {0:-1} so a modulus of two is noted as already existing.</p>
</blockquote>
<p>Run time: $O(n)$, space: $O(k)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">checkSubarraySum</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">    prefix_sum = <span class="number">0</span></span><br><span class="line">    <span class="comment"># Dictionary of prefix sums and their indices(0 is seen before the array)</span></span><br><span class="line">    prefix_sum_indices = &#123;<span class="number">0</span>: -<span class="number">1</span>&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> index, num <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums):</span><br><span class="line">        <span class="comment"># Compute the remainder when dividing the new sum by k</span></span><br><span class="line">        prefix_sum = (prefix_sum + num) % k</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># Check if this remainder has been encountered before and of length 2</span></span><br><span class="line">        <span class="keyword">if</span> prefix_sum <span class="keyword">in</span> prefix_sum_indices <span class="keyword">and</span> index - prefix_sum_indices[prefix_sum] &gt; <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># Add this index if it is hasn&#x27;t been encountered before</span></span><br><span class="line">        <span class="keyword">if</span> prefix_sum <span class="keyword">not</span> <span class="keyword">in</span> prefix_sum_indices:</span><br><span class="line">            prefix_sum_indices[prefix_sum] = index</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>249. Group Shifted Strings</summary>
<blockquote>
<p>Put the difference between each character as key, and the original string as value in the dictionary.</p>
</blockquote>
<p>Run time: $O(nk)$, space: $O(nk)$, where $n$ is the length of input strings array, $k$ is the max length of the string in the array.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">groupStrings</span>(<span class="params">self, strings: <span class="type">List</span>[<span class="built_in">str</span>]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">str</span>]]:</span></span><br><span class="line">    d = defaultdict(<span class="built_in">list</span>)</span><br><span class="line">    <span class="keyword">for</span> s <span class="keyword">in</span> strings:</span><br><span class="line">        key = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s) - <span class="number">1</span>):</span><br><span class="line">            <span class="comment"># Throw in 26 so that we can normalzie below</span></span><br><span class="line">            difference = <span class="number">26</span> + <span class="built_in">ord</span>(s[i+<span class="number">1</span>]) - <span class="built_in">ord</span>(s[i])</span><br><span class="line">            <span class="comment"># Wrap around</span></span><br><span class="line">            <span class="comment"># z + 1 = a</span></span><br><span class="line">            key.append(<span class="built_in">str</span>(difference % <span class="number">26</span>))</span><br><span class="line">        d[<span class="string">&#x27;,&#x27;</span>.join(key)].append(s)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> d.values()</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>380. Insert Delete GetRandom O(1)</summary>
> Use a dictionary and a list to keep track of the inserted elements. Use dictionary to check whether the element exists, and when we need to remove element, we find the index and put the last element in the original position of the list, and update the dictionary.
Delete: Retrieve an index of element to delete from the hashmap. Move the last element to the place of the element to delete, \mathcal{O}(1)O(1) time. Pop the last element out, \mathcal{O}(1)O(1) time.
<p>Run time: $O(1)$, space: $O(n)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RandomizedSet</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.d = &#123;&#125;</span><br><span class="line">        self.l = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insert</span>(<span class="params">self, val: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        <span class="keyword">if</span> val <span class="keyword">not</span> <span class="keyword">in</span> self.d:</span><br><span class="line">            self.d[val] = <span class="built_in">len</span>(self.l)</span><br><span class="line">            self.l.append(val)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">remove</span>(<span class="params">self, val: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        <span class="keyword">if</span> val <span class="keyword">not</span> <span class="keyword">in</span> self.d:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        last_element = self.l[-<span class="number">1</span>]</span><br><span class="line">        idx = self.d[val]</span><br><span class="line">        </span><br><span class="line">        self.l[idx] = last_element <span class="comment"># rearrange</span></span><br><span class="line">        <span class="keyword">del</span> self.d[val]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getRandom</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="keyword">return</span> random.choice(self.l)</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>242. Valid Anagram</summary>
> Use one or two dictionary to check whether all values are zero in the end, or compare if they are the same.
<p>Run time: $O(n)$, space: $O(n)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isAnagram1</span>(<span class="params">self, s, t</span>):</span></span><br><span class="line">    dic1, dic2 = &#123;&#125;, &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> s:</span><br><span class="line">        dic1[item] = dic1.get(item, <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> t:</span><br><span class="line">        dic2[item] = dic2.get(item, <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> dic1 == dic2</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isAnagram2</span>(<span class="params">self, s, t</span>):</span></span><br><span class="line">    dic1, dic2 = [<span class="number">0</span>]*<span class="number">26</span>, [<span class="number">0</span>]*<span class="number">26</span></span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> s:</span><br><span class="line">        dic1[<span class="built_in">ord</span>(item)-<span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>)] += <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> t:</span><br><span class="line">        dic2[<span class="built_in">ord</span>(item)-<span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>)] += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> dic1 == dic2</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isAnagram3</span>(<span class="params">self, s, t</span>):</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sorted</span>(s) == <span class="built_in">sorted</span>(t)</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>287. Find the Duplicate Number</summary>
<blockquote>
<p>Floyd’s Tortoise and Hare (Cycle Detection)<br>
hare = nums[nums[hare]] is twice as fast as tortoise = nums[tortoise]. Since the hare goes fast, it would be the first to enter the cycle and run around the cycle. At some point, the tortoise enters the cycle as well, and since it’s moving slower the hare catches up to the tortoise at some intersection point. Now phase 1 is over, and the tortoise has lost.</p>
</blockquote>
<p>Run time: $O(n)$, space: $O(1)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findDuplicate</span>(<span class="params">self, nums</span>):</span></span><br><span class="line">    <span class="comment"># Find the intersection point of the two runners.</span></span><br><span class="line">    tortoise = hare = nums[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        tortoise = nums[tortoise]</span><br><span class="line">        hare = nums[nums[hare]]</span><br><span class="line">        <span class="keyword">if</span> tortoise == hare:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Find the &quot;entrance&quot; to the cycle.</span></span><br><span class="line">    tortoise = nums[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">while</span> tortoise != hare:</span><br><span class="line">        tortoise = nums[tortoise]</span><br><span class="line">        hare = nums[hare]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> hare</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Binary search. If the count of the numbers that are smaller than or equal to the mid, update right pointer.</p>
</blockquote>
<p>In the binary search approach, instead of doing a linear scan from 1 to n, we can apply a binary search with a goal of finding the smallest number that satisfies the aforementioned property. We start with a search space of [1,n] that has a midpoint midmid. If midmid satisfies the property, we narrow our search space to the left half [1, mid - 1] and continue searching, otherwise, we narrow our search space to the right half [mid + 1, n].</p>
<p>Run time: $O(n\log n)$, space: $O(1)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findDuplicate</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">    left, right = <span class="number">1</span>, <span class="built_in">len</span>(nums)-<span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> left &lt; right:</span><br><span class="line">        mid = (right + left)//<span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">sum</span>(i &lt;= mid <span class="keyword">for</span> i <span class="keyword">in</span> nums) &gt; mid:</span><br><span class="line">            right = mid</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            left = mid+<span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> right</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Put every element in a set, if it already exists, return it.</p>
</blockquote>
<p>Run time: $O(n)$, space: $O(n)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findDuplicate</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">    seen = <span class="built_in">set</span>()</span><br><span class="line">    <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">        <span class="keyword">if</span> num <span class="keyword">in</span> seen:</span><br><span class="line">            <span class="keyword">return</span> num</span><br><span class="line">        seen.add(num)</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>217. Contains Duplicate</summary>
<blockquote>
<p>Build a set using input array. If every element is distinct, then their length should be equal.</p>
</blockquote>
<p>Run time: $O(n)$, space: $O(n)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">containsDuplicate</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">    s = <span class="built_in">set</span>(nums)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">len</span>(s) != <span class="built_in">len</span>(nums)</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>448. Find All Numbers Disappeared in an Array</summary>
<blockquote>
<p>Negate the number that is in this index. In the end, if the number is still positive, put the corresponding index+1 to the output array.</p>
</blockquote>
<p>Run time: $O(n)$, space: $O(1)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findDisappearedNumbers</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span></span><br><span class="line">    ans = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">        temp = <span class="built_in">abs</span>(nums[i])-<span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> nums[temp] &gt; <span class="number">0</span>:</span><br><span class="line">            nums[temp] *= -<span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">        <span class="keyword">if</span> nums[i] &gt; <span class="number">0</span>:</span><br><span class="line">            ans.append(i+<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Hashset.</p>
</blockquote>
<p>Run time: $O(n)$, space: $O(n)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findDisappearedNumbers</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span></span><br><span class="line">    s = <span class="built_in">set</span>(nums)</span><br><span class="line">    n = <span class="built_in">len</span>(nums)</span><br><span class="line">    ans = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n+<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">if</span> i <span class="keyword">not</span> <span class="keyword">in</span> s:</span><br><span class="line">            ans.append(i)</span><br><span class="line">    <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
</details>
<h2 id="Advanced-Hash-Heap">Advanced Hash/Heap</h2>
<details>
<summary></summary>
> 
<p>Run time: $O()$, space: $O()$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>460. LFU Cache</summary>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/lfu-cache/discuss/1083490/Python-Solution-using-DefaultDict-and-a-Dict%3A-faster%3A77.45-Memory-usageless-88.00">https://leetcode.com/problems/lfu-cache/discuss/1083490/Python-Solution-using-DefaultDict-and-a-Dict%3A-faster%3A77.45-Memory-usageless-88.00</a></p>
</blockquote>
<p>Run time: $O(\log n)$ for put if key not present, $O(1)$ for other calls, space: $O(n)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LFUCache</span>:</span></span><br><span class="line">    <span class="keyword">import</span> collections</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, capacity</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type capacity: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self.capacity = capacity</span><br><span class="line">        <span class="comment"># cache will contain key:[value, frequency]</span></span><br><span class="line">        <span class="comment"># default dict will contain all the keys having the same frequency of occurrence.</span></span><br><span class="line">        <span class="comment"># &#123;frequency:[key1, key2, key3]&#125;</span></span><br><span class="line">        self.cache = &#123;&#125;</span><br><span class="line">        self.freqCache = collections.defaultdict(<span class="built_in">list</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span>(<span class="params">self, key</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type key: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        val = self.cache.get(key, -<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">if</span> val == -<span class="number">1</span>: </span><br><span class="line">            <span class="keyword">return</span> val</span><br><span class="line">        </span><br><span class="line">        value,freq = val</span><br><span class="line">        <span class="comment"># if key is found, increase the frequency in frequency cache and data cache</span></span><br><span class="line">        self.freqCache[freq].remove(key)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.freqCache[freq]: </span><br><span class="line">            <span class="keyword">del</span> self.freqCache[freq]</span><br><span class="line">        self.freqCache[freq+<span class="number">1</span>].append(key)</span><br><span class="line"></span><br><span class="line">        self.cache[key] = [value, freq+<span class="number">1</span>]  </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> value</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">put</span>(<span class="params">self, key, value</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type key: int</span></span><br><span class="line"><span class="string">        :type value: int</span></span><br><span class="line"><span class="string">        :rtype: None</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> self.capacity &lt;=<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        val = self.cache.get(key, -<span class="number">1</span>)</span><br><span class="line">        initfreq=<span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>  val == -<span class="number">1</span>:</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(self.cache) == self.capacity:</span><br><span class="line">                <span class="comment">#print self.freqCache.items()</span></span><br><span class="line">                minFreq, delList = <span class="built_in">min</span>(self.freqCache.items(), key=<span class="keyword">lambda</span> x:x[<span class="number">0</span>])</span><br><span class="line">                <span class="comment">#print delList</span></span><br><span class="line">                delkey = delList[<span class="number">0</span>]</span><br><span class="line">                <span class="keyword">del</span> self.cache[delkey]</span><br><span class="line">                self.freqCache[minFreq].remove(delkey)</span><br><span class="line">                </span><br><span class="line">                <span class="comment">#insert in cache</span></span><br><span class="line">                self.cache.update(&#123;key:[value,initfreq]&#125;)</span><br><span class="line">                self.freqCache[initfreq].append(key)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                self.cache.update(&#123;key:[value,initfreq]&#125;)</span><br><span class="line">                self.freqCache[initfreq].append(key)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            oldval,freq = val</span><br><span class="line">            </span><br><span class="line">            self.freqCache[freq].remove(key)</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> self.freqCache[freq]: <span class="keyword">del</span> self.freqCache[freq]</span><br><span class="line">            self.freqCache[freq+<span class="number">1</span>].append(key)</span><br><span class="line">            </span><br><span class="line">            self.cache[key] = [value,freq+<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Your LFUCache object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"># obj = LFUCache(capacity)</span></span><br><span class="line"><span class="comment"># param_1 = obj.get(key)</span></span><br><span class="line"><span class="comment"># obj.put(key,value)</span></span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>146. LRU Cache</summary>
> Use OrderedDict. pop key: d.pop(key). Remove least used key: d.popitem(last=False).
<p>Run time: $O(1)$, space: $O(n)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, capacity: <span class="built_in">int</span></span>):</span></span><br><span class="line">        self.cap = capacity</span><br><span class="line">        self.d = collections.OrderedDict()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span>(<span class="params">self, key: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="keyword">if</span> key <span class="keyword">not</span> <span class="keyword">in</span> self.d:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        val = self.d.pop(key)</span><br><span class="line">        self.d[key] = val</span><br><span class="line">        <span class="keyword">return</span> val</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">put</span>(<span class="params">self, key: <span class="built_in">int</span>, value: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">        <span class="keyword">if</span> key <span class="keyword">in</span> self.d:</span><br><span class="line">            self.d.pop(key)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> self.cap &gt; <span class="number">0</span>:</span><br><span class="line">                self.cap -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                self.d.popitem(last=<span class="literal">False</span>)</span><br><span class="line">        self.d[key] = value</span><br><span class="line"></span><br><span class="line"><span class="comment"># Your LRUCache object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"># obj = LRUCache(capacity)</span></span><br><span class="line"><span class="comment"># param_1 = obj.get(key)</span></span><br><span class="line"><span class="comment"># obj.put(key,value)</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>Use dictionary + doubly linked list</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, k, v</span>):</span></span><br><span class="line">        self.key = k</span><br><span class="line">        self.value = v</span><br><span class="line">        self.prev = <span class="literal">None</span></span><br><span class="line">        self.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line">        </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, capacity: <span class="built_in">int</span></span>):</span></span><br><span class="line">        self.cap = capacity</span><br><span class="line">        self.dic = <span class="built_in">dict</span>()</span><br><span class="line">        self.prev = self.<span class="built_in">next</span> = self</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span>(<span class="params">self, key: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="keyword">if</span> key <span class="keyword">in</span> self.dic:</span><br><span class="line">            n = self.dic[key]</span><br><span class="line">            self._remove(n)</span><br><span class="line">            self._add(n)</span><br><span class="line">            <span class="keyword">return</span> n.value</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">put</span>(<span class="params">self, key: <span class="built_in">int</span>, value: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">        <span class="keyword">if</span> key <span class="keyword">in</span> self.dic:</span><br><span class="line">            self._remove(self.dic[key])</span><br><span class="line">        n = Node(key, value)</span><br><span class="line">        self._add(n)</span><br><span class="line">        self.dic[key] = n</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(self.dic) &gt; self.cap:</span><br><span class="line">            n = self.<span class="built_in">next</span></span><br><span class="line">            self._remove(n)</span><br><span class="line">            <span class="keyword">del</span> self.dic[n.key]</span><br><span class="line">            </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_remove</span>(<span class="params">self, node</span>):</span></span><br><span class="line">        p = node.prev</span><br><span class="line">        n = node.<span class="built_in">next</span></span><br><span class="line">        p.<span class="built_in">next</span> = n</span><br><span class="line">        n.prev = p</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_add</span>(<span class="params">self, node</span>):</span></span><br><span class="line">        p = self.prev</span><br><span class="line">        p.<span class="built_in">next</span> = node</span><br><span class="line">        self.prev = node</span><br><span class="line">        node.prev = p</span><br><span class="line">        node.<span class="built_in">next</span> = self</span><br></pre></td></tr></table></figure>
</details>
<h1>Union Find</h1>
<details>
<summary></summary>
> 
<p>Run time: $O()$, space: $O()$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>200. Number of Islands</summary>
<blockquote>
<p>DFS.<br>
<a target="_blank" rel="noopener" href="https://leetcode.com/problems/number-of-islands/discuss/583745/Python-3-solutions%3A-DFS-BFS-Union-Find-Concise-and-Clean">https://leetcode.com/problems/number-of-islands/discuss/583745/Python-3-solutions%3A-DFS-BFS-Union-Find-Concise-and-Clean</a></p>
</blockquote>
<p>Run time: $O(mn)$, space: $O(mn)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">numIslands</span>(<span class="params">self, grid: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">str</span>]]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">    m, n = <span class="built_in">len</span>(grid), <span class="built_in">len</span>(grid[<span class="number">0</span>])</span><br><span class="line">    dirs = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, <span class="number">0</span>]</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">r, c</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> (<span class="number">0</span> &lt;= r &lt; m <span class="keyword">and</span> <span class="number">0</span> &lt;= c &lt; n) <span class="keyword">or</span> grid[r][c] == <span class="string">&quot;0&quot;</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        grid[r][c] = <span class="string">&quot;0&quot;</span>  <span class="comment"># Mark as visited</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">            dfs(r + dirs[i], c + dirs[i+<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    ans = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> r <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            ans += dfs(r, c)</span><br><span class="line">    <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/number-of-islands/discuss/56519/Union-Find-in-Python">https://leetcode.com/problems/number-of-islands/discuss/56519/Union-Find-in-Python</a></p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">numIslands</span>(<span class="params">self, grid: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">str</span>]]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find</span>(<span class="params">x: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="keyword">if</span> parent[x] != x:</span><br><span class="line">            parent[x] = find(parent[x])</span><br><span class="line">        <span class="keyword">return</span> parent[x]</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">union</span>(<span class="params">x: <span class="built_in">int</span>, y: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">        xroot = find(x)</span><br><span class="line">        yroot = find(y)</span><br><span class="line">        <span class="keyword">if</span> xroot == yroot: <span class="keyword">return</span> </span><br><span class="line">        <span class="keyword">if</span> rank[xroot] &lt; rank[yroot]:</span><br><span class="line">            xroot, yroot = yroot, xroot</span><br><span class="line">        parent[yroot] = xroot</span><br><span class="line">        rank[xroot] = <span class="built_in">max</span>(rank[xroot], rank[yroot]+<span class="number">1</span>)</span><br><span class="line">        self.count -= <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(grid) == <span class="number">0</span>: </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    m, n = <span class="built_in">len</span>(grid), <span class="built_in">len</span>(grid[<span class="number">0</span>])</span><br><span class="line">    self.count = <span class="built_in">sum</span>(grid[i][j]==<span class="string">&#x27;1&#x27;</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m) <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n))</span><br><span class="line">    parent = [i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m*n)]</span><br><span class="line">    rank = [<span class="number">0</span>] * m * n</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">if</span> grid[i][j] == <span class="string">&#x27;0&#x27;</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            index = i*n + j</span><br><span class="line">            <span class="keyword">if</span> j &lt; n-<span class="number">1</span> <span class="keyword">and</span> grid[i][j+<span class="number">1</span>] == <span class="string">&#x27;1&#x27;</span>:</span><br><span class="line">                union(index, index+<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">if</span> i &lt; m-<span class="number">1</span> <span class="keyword">and</span> grid[i+<span class="number">1</span>][j] == <span class="string">&#x27;1&#x27;</span>:</span><br><span class="line">                union(index, index+n)</span><br><span class="line">    <span class="keyword">return</span> self.count</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numIslands</span>(<span class="params">self, grid: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">str</span>]]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        DIR = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, <span class="number">0</span>]</span><br><span class="line">        m, n = <span class="built_in">len</span>(grid), <span class="built_in">len</span>(grid[<span class="number">0</span>])</span><br><span class="line">        uf = UnionFind(m*n)</span><br><span class="line">        </span><br><span class="line">        component = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> r <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">            <span class="keyword">for</span> c <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                <span class="keyword">if</span> grid[r][c] == <span class="string">&quot;0&quot;</span>: <span class="keyword">continue</span></span><br><span class="line">                component += <span class="number">1</span></span><br><span class="line">                curId = r * n + c</span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">                    nr, nc = r + DIR[i], c + DIR[i+<span class="number">1</span>]</span><br><span class="line">                    <span class="keyword">if</span> <span class="keyword">not</span> (<span class="number">0</span> &lt;= nr &lt; m <span class="keyword">and</span> <span class="number">0</span> &lt;= nc &lt; n) <span class="keyword">or</span> grid[nr][nc] == <span class="string">&quot;0&quot;</span>: <span class="keyword">continue</span></span><br><span class="line">                    neiId = nr * n + nc</span><br><span class="line">                    <span class="keyword">if</span> uf.union(curId, neiId):</span><br><span class="line">                        component -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> component</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnionFind</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, n</span>):</span></span><br><span class="line">        self.parent = [i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">        self.size = [<span class="number">1</span>] * n</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find</span>(<span class="params">self, u</span>):</span></span><br><span class="line">        <span class="keyword">if</span> u != self.parent[u]:</span><br><span class="line">            self.parent[u] = self.find(self.parent[u])  <span class="comment"># Path compression</span></span><br><span class="line">        <span class="keyword">return</span> self.parent[u]</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">union</span>(<span class="params">self, u, v</span>):</span></span><br><span class="line">        pu, pv = self.find(u), self.find(v)</span><br><span class="line">        <span class="keyword">if</span> pu == pv: <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">if</span> self.size[pu] &lt; self.size[pv]:  <span class="comment"># Merge pu to pv</span></span><br><span class="line">            self.size[pv] += self.size[pu]</span><br><span class="line">            self.parent[pu] = pv</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.size[pu] += self.size[pv]</span><br><span class="line">            self.parent[pv] = pu</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>BFS.</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">numIslands</span>(<span class="params">self, grid: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">str</span>]]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">    m, n = <span class="built_in">len</span>(grid), <span class="built_in">len</span>(grid[<span class="number">0</span>])</span><br><span class="line">    DIR = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, <span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">bfs</span>(<span class="params">r, c</span>):</span></span><br><span class="line">        <span class="keyword">if</span> grid[r][c] == <span class="string">&quot;0&quot;</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        q = deque([(r, c)])</span><br><span class="line">        <span class="keyword">while</span> q:</span><br><span class="line">            r, c = q.popleft()</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">                nr, nc = r + DIR[i], c + DIR[i+<span class="number">1</span>]</span><br><span class="line">                <span class="keyword">if</span> nr &lt; <span class="number">0</span> <span class="keyword">or</span> nr == m <span class="keyword">or</span> nc &lt; <span class="number">0</span> <span class="keyword">or</span> nc == n <span class="keyword">or</span> grid[nr][nc] == <span class="string">&quot;0&quot;</span>: <span class="keyword">continue</span></span><br><span class="line">                grid[nr][nc] = <span class="string">&quot;0&quot;</span>  <span class="comment"># Mark as visited</span></span><br><span class="line">                q.append([nr, nc])</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    ans = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> r <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            ans += bfs(r, c)</span><br><span class="line">    <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>721.  Accounts Merge</summary>
<blockquote>
<p>Use one map that stores email to id, one map for id to email, one map for email to name.<br>
First for each user, gets their name, then loop through each email, and add &lt;email, name&gt; to the last dict. If this email is not in the email-to-id dict, add &lt;email, id&gt; to it, and put &lt;id, email&gt; to the id-to-email dict. Remember to increment the id for the next user. Then, union the first email with every email including itself.<br>
Next, create a dictionary that stores &lt;id, set of emails&gt;. For each id, find its root, create an entry for its root and add the emails retrieved using current id from id-to-email dictionary.<br>
For the final output, look at all &lt;id, email set&gt; pair, get the name from the email-to-name map using the id-to-email map. Then, get the name, and concatenate with the sorted list of emails.</p>
</blockquote>
<p>Run time: $O(SlogS)$, space: $O(S)$, where <code>S</code> is sum of all emails of accounts.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">accountsMerge</span>(<span class="params">self, accounts: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">str</span>]]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">str</span>]]:</span></span><br><span class="line">        uf = UnionFind(<span class="number">10000</span>)</span><br><span class="line">        </span><br><span class="line">        map_email_id = &#123;&#125;</span><br><span class="line">        map_id_email = &#123;&#125;</span><br><span class="line">        map_email_name = &#123;&#125;</span><br><span class="line">        <span class="built_in">id</span> = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> acc <span class="keyword">in</span> accounts:</span><br><span class="line">            name = acc[<span class="number">0</span>]</span><br><span class="line">            <span class="keyword">for</span> email <span class="keyword">in</span> acc[<span class="number">1</span>:]:</span><br><span class="line">                map_email_name[email] = name</span><br><span class="line">                <span class="keyword">if</span> email <span class="keyword">not</span> <span class="keyword">in</span> map_email_id:</span><br><span class="line">                    map_email_id[email] = <span class="built_in">id</span></span><br><span class="line">                    map_id_email[<span class="built_in">id</span>] = email</span><br><span class="line">                    <span class="built_in">id</span> += <span class="number">1</span></span><br><span class="line">                uf.union(map_email_id[acc[<span class="number">1</span>]], map_email_id[email]) <span class="comment"># union 1st email and ith emails -&gt; union emails in same account together</span></span><br><span class="line">        </span><br><span class="line">        merged_emails = defaultdict(<span class="built_in">set</span>)</span><br><span class="line">        <span class="keyword">for</span> _<span class="built_in">id</span> <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">id</span>):</span><br><span class="line">            merged_emails[uf.find(_<span class="built_in">id</span>)].add(map_id_email[_<span class="built_in">id</span>])</span><br><span class="line">            </span><br><span class="line">        ans = []</span><br><span class="line">        <span class="keyword">for</span> (_<span class="built_in">id</span>, emails) <span class="keyword">in</span> merged_emails.items():</span><br><span class="line">            name = map_email_name[map_id_email[_<span class="built_in">id</span>]]</span><br><span class="line">            ans.append([name] + <span class="built_in">list</span>(<span class="built_in">sorted</span>(emails)))</span><br><span class="line">        <span class="keyword">return</span> ans</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnionFind</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, n</span>):</span></span><br><span class="line">        self.parent = [i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">        self.size = [<span class="number">1</span>] * n</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        <span class="keyword">if</span> x != self.parent[x]:</span><br><span class="line">            self.parent[x] = self.find(self.parent[x]) <span class="comment"># Path compression</span></span><br><span class="line">        <span class="keyword">return</span> self.parent[x]</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">union</span>(<span class="params">self, u, v</span>):</span></span><br><span class="line">        pu, pv = self.find(u), self.find(v)</span><br><span class="line">        <span class="keyword">if</span> pu == pv: <span class="keyword">return</span> <span class="literal">False</span>  <span class="comment"># Return False if u and v are already union</span></span><br><span class="line">        <span class="keyword">if</span> self.size[pu] &gt; self.size[pv]: <span class="comment"># Union by larger size</span></span><br><span class="line">            self.size[pu] += self.size[pv]</span><br><span class="line">            self.parent[pv] = pu</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.size[pv] += self.size[pu]</span><br><span class="line">            self.parent[pu] = pv</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>803.  Bricks Falling When Hit</summary>
<blockquote>
<p>First initialize the rank and parent to store (-1,-1). The num_child dictionary stores the (x,y) position and the number of children connected to it. The set hits stores each hit to have easier access. First we initialize all 1 positions as nodes, if it is on the first row (connected to the ceiling), then union it with (-1,-1). Otherwise, connect it to its four neighbors if any.<br>
Once this step is complete, we go through each hit in reversed order, if the hit position is empty, append 0 and continue. If the area is 1, we first get the children of (-1,-1), i.e., the number of bricks connected to ceiling. Then we initialize the node in the hit position. If the row is 0, we connect the node with (-1,-1), and connect its four neighbors. Now, we get the number of children of position (-1,-1), and the curr-prev-1 would be the number of falling bricks, as if the hit brick is added, we may be able to connect more bricks to the ceiling, and they would fall when this brick is hit.<br>
<a target="_blank" rel="noopener" href="https://leetcode.com/problems/bricks-falling-when-hit/discuss/1695192/Python-UF-Template">https://leetcode.com/problems/bricks-falling-when-hit/discuss/1695192/Python-UF-Template</a></p>
</blockquote>
<p>Run time: $O(mn)$, space: $O(mn)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hitBricks</span>(<span class="params">self, grid: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]], hits: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> grid:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">union</span>(<span class="params">node1, node2</span>):</span></span><br><span class="line">            root1 = find(node1)</span><br><span class="line">            root2 = find(node2)</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> root1 != root2:</span><br><span class="line">                <span class="keyword">if</span> rank[root1] &gt; rank[root2]:</span><br><span class="line">                    parent[root2] = root1</span><br><span class="line">                    num_child[root1] += num_child[root2]</span><br><span class="line">                <span class="keyword">elif</span> rank[root2] &gt; rank[root1]:</span><br><span class="line">                    parent[root1] = root2</span><br><span class="line">                    num_child[root2] += num_child[root1]</span><br><span class="line">                <span class="keyword">else</span>: <span class="comment"># rank[root1] == rank[root2]</span></span><br><span class="line">                    parent[root2] = root1</span><br><span class="line">                    num_child[root1] += num_child[root2]</span><br><span class="line">                    rank[root1] += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">find</span>(<span class="params">node</span>):</span></span><br><span class="line">            <span class="keyword">if</span> parent[node] != node:</span><br><span class="line">                parent[node] = find(parent[node])</span><br><span class="line">            <span class="keyword">return</span> parent[node]</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">init_node</span>(<span class="params">node</span>):</span></span><br><span class="line">            parent[node] = node</span><br><span class="line">            num_child[node] = <span class="number">1</span></span><br><span class="line">            rank[node] = <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">connect_neighbors</span>(<span class="params">node</span>):</span></span><br><span class="line">            <span class="keyword">for</span> dx, dy <span class="keyword">in</span> [(<span class="number">1</span>,<span class="number">0</span>), (-<span class="number">1</span>,<span class="number">0</span>), (<span class="number">0</span>,<span class="number">1</span>), (<span class="number">0</span>,-<span class="number">1</span>)]:</span><br><span class="line">                x,y = node[<span class="number">0</span>]+dx, node[<span class="number">1</span>]+dy</span><br><span class="line">                <span class="keyword">if</span> (x,y) <span class="keyword">in</span> parent:</span><br><span class="line">                    union(node, (x,y))</span><br><span class="line">        </span><br><span class="line">        m,n = <span class="built_in">len</span>(grid), <span class="built_in">len</span>(grid[<span class="number">0</span>])</span><br><span class="line">        <span class="comment"># add virtual parent (-1, -1) for all of first row points</span></span><br><span class="line">        rank = &#123;(-<span class="number">1</span>, -<span class="number">1</span>): m * n&#125;</span><br><span class="line">        parent = &#123;(-<span class="number">1</span>, -<span class="number">1</span>): (-<span class="number">1</span>, -<span class="number">1</span>)&#125;</span><br><span class="line">        num_child = collections.defaultdict(<span class="built_in">int</span>)</span><br><span class="line">        hits_cache = &#123;(x,y) <span class="keyword">for</span> [x,y] <span class="keyword">in</span> hits&#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> row <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">            <span class="keyword">for</span> col <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                <span class="keyword">if</span> (row, col) <span class="keyword">in</span> hits_cache:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                <span class="keyword">if</span> grid[row][col] == <span class="number">1</span>:</span><br><span class="line">                    init_node((row, col))</span><br><span class="line">                    <span class="keyword">if</span> row == <span class="number">0</span>:</span><br><span class="line">                        union((-<span class="number">1</span>,-<span class="number">1</span>), (row, col))</span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        connect_neighbors((row, col))</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> row, col <span class="keyword">in</span> hits[::-<span class="number">1</span>]:</span><br><span class="line">            <span class="keyword">if</span> grid[row][col] != <span class="number">1</span>:</span><br><span class="line">                res.append(<span class="number">0</span>)</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            pre = num_child[(-<span class="number">1</span>,-<span class="number">1</span>)]</span><br><span class="line">            init_node((row, col))</span><br><span class="line">            <span class="keyword">if</span> row == <span class="number">0</span>:</span><br><span class="line">                union((-<span class="number">1</span>,-<span class="number">1</span>), (row, col))</span><br><span class="line">                </span><br><span class="line">            connect_neighbors((row, col))</span><br><span class="line">            cur = num_child[(-<span class="number">1</span>,-<span class="number">1</span>)]</span><br><span class="line">            res.append(<span class="built_in">max</span>(<span class="number">0</span>, cur-pre-<span class="number">1</span>))</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res[::-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>827. Making A Large Island</summary>
<blockquote>
<p>Union Find. First initialize the dictionary for parents and size. Then For each 1 island, explore its down and right neighbors that are 1 and try to union them. For each cell, explore its all four neighbors and if it is 0, find its parent and add to a set. In the end, get the max size for all parents. If there is no zero in the matrix, return max size.</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/making-a-large-island/discuss/1150779/Python-Union-Find-Solution">https://leetcode.com/problems/making-a-large-island/discuss/1150779/Python-Union-Find-Solution</a></p>
<p>Run time: $O(n^2)$, space: $O(n^2)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">largestIsland</span>(<span class="params">self, grid: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">    N = <span class="built_in">len</span>(grid)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># union find and size of components</span></span><br><span class="line">    uf = &#123;</span><br><span class="line">        (r, c): (r, c)</span><br><span class="line">        <span class="keyword">for</span> r <span class="keyword">in</span> <span class="built_in">range</span>(N)</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> <span class="built_in">range</span>(N)</span><br><span class="line">        <span class="keyword">if</span> grid[r][c]</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    size = &#123;</span><br><span class="line">        (r, c): <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> r <span class="keyword">in</span> <span class="built_in">range</span>(N)</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> <span class="built_in">range</span>(N)</span><br><span class="line">        <span class="keyword">if</span> grid[r][c]</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find</span>(<span class="params">x</span>):</span></span><br><span class="line">        <span class="keyword">if</span> x != uf[x]:</span><br><span class="line">            uf[x] = find(uf[x])</span><br><span class="line">        <span class="keyword">return</span> uf[x]</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">union</span>(<span class="params">x, y</span>):</span></span><br><span class="line">        rootx = find(x)</span><br><span class="line">        rooty = find(y)</span><br><span class="line">        <span class="keyword">if</span> rootx != rooty:</span><br><span class="line">            uf[rootx] = rooty</span><br><span class="line">            size[rooty] += size[rootx]</span><br><span class="line">        </span><br><span class="line">    <span class="comment"># union adjacant 1s</span></span><br><span class="line">    <span class="keyword">for</span> r <span class="keyword">in</span> <span class="built_in">range</span>(N):</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> <span class="built_in">range</span>(N):</span><br><span class="line">            <span class="keyword">if</span> grid[r][c]:</span><br><span class="line">                <span class="keyword">for</span> nr, nc <span class="keyword">in</span> [[r+<span class="number">1</span>, c], [r, c+<span class="number">1</span>]]:</span><br><span class="line">                    <span class="keyword">if</span> <span class="number">0</span> &lt;= nr &lt; N <span class="keyword">and</span> <span class="number">0</span> &lt;= nc &lt; N <span class="keyword">and</span> grid[nr][nc]:</span><br><span class="line">                        union((r,c), (nr,nc))</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># iterate all 0s to find the max area</span></span><br><span class="line">    max_area = <span class="number">0</span></span><br><span class="line">    has_zero = <span class="literal">False</span></span><br><span class="line">    <span class="keyword">for</span> r <span class="keyword">in</span> <span class="built_in">range</span>(N):</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> <span class="built_in">range</span>(N):</span><br><span class="line">            <span class="keyword">if</span> grid[r][c] == <span class="number">0</span>:</span><br><span class="line">                has_zero = <span class="literal">True</span></span><br><span class="line">                adj_islands = <span class="built_in">set</span>()</span><br><span class="line">                <span class="keyword">for</span> nr, nc <span class="keyword">in</span> [[r+<span class="number">1</span>, c], [r, c+<span class="number">1</span>], [r-<span class="number">1</span>, c], [r, c-<span class="number">1</span>]]:</span><br><span class="line">                    <span class="keyword">if</span> <span class="number">0</span> &lt;= nr &lt; N <span class="keyword">and</span> <span class="number">0</span> &lt;= nc &lt; N <span class="keyword">and</span> grid[nr][nc]:</span><br><span class="line">                        adj_islands.add(find((nr, nc)))</span><br><span class="line">                area = <span class="number">1</span> + <span class="built_in">sum</span>(size[adj_island] <span class="keyword">for</span> adj_island <span class="keyword">in</span> adj_islands)</span><br><span class="line">                max_area = <span class="built_in">max</span>(max_area, area)</span><br><span class="line">                </span><br><span class="line">    <span class="keyword">return</span> max_area <span class="keyword">if</span> has_zero <span class="keyword">else</span> N * N</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">largestIsland</span>(<span class="params">self, grid: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">    DIR = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, <span class="number">0</span>]</span><br><span class="line">    m, n, nextColor = <span class="built_in">len</span>(grid), <span class="built_in">len</span>(grid[<span class="number">0</span>]), <span class="number">2</span></span><br><span class="line">    componentSize = defaultdict(<span class="built_in">int</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">paint</span>(<span class="params">r, c, color</span>):</span></span><br><span class="line">        <span class="keyword">if</span> r &lt; <span class="number">0</span> <span class="keyword">or</span> r == m <span class="keyword">or</span> c &lt; <span class="number">0</span> <span class="keyword">or</span> c == n <span class="keyword">or</span> grid[r][c] != <span class="number">1</span>: <span class="keyword">return</span></span><br><span class="line">        grid[r][c] = color</span><br><span class="line">        componentSize[color] += <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">            paint(r + DIR[i], c + DIR[i + <span class="number">1</span>], color)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> r <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">if</span> grid[r][c] != <span class="number">1</span>: <span class="keyword">continue</span>  <span class="comment"># Only paint when it&#x27;s an island cell</span></span><br><span class="line">            paint(r, c, nextColor)</span><br><span class="line">            nextColor += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    ans = <span class="built_in">max</span>(componentSize.values() <span class="keyword">or</span> [<span class="number">0</span>])</span><br><span class="line">    <span class="keyword">for</span> r <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">if</span> grid[r][c] != <span class="number">0</span>: <span class="keyword">continue</span></span><br><span class="line">            neiColors = <span class="built_in">set</span>()</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">                nr, nc = r + DIR[i], c + DIR[i + <span class="number">1</span>]</span><br><span class="line">                <span class="keyword">if</span> nr &lt; <span class="number">0</span> <span class="keyword">or</span> nr == m <span class="keyword">or</span> nc &lt; <span class="number">0</span> <span class="keyword">or</span> nc == n <span class="keyword">or</span> grid[nr][nc] == <span class="number">0</span>: <span class="keyword">continue</span></span><br><span class="line">                neiColors.add(grid[nr][nc])</span><br><span class="line">            sizeFormed = <span class="number">1</span>  <span class="comment"># Start with 1, which is matrix[r][c] when turning from 0 into 1</span></span><br><span class="line">            <span class="keyword">for</span> color <span class="keyword">in</span> neiColors:</span><br><span class="line">                sizeFormed += componentSize[color]</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, sizeFormed)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
</details>
<h1>DP</h1>
<details>
<summary></summary>
> 
<p>Run time: $O()$, space: $O()$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>10. Regular Expression Matching</summary>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/regular-expression-matching/discuss/5723/My-DP-approach-in-Python-with-comments-and-unittest">https://leetcode.com/problems/regular-expression-matching/discuss/5723/My-DP-approach-in-Python-with-comments-and-unittest</a></p>
</blockquote>
<p>Run time: $O(mn)$, space: $O(mn)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isMatch</span>(<span class="params">self, s: <span class="built_in">str</span>, p: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">    <span class="comment"># The DP table and the string s and p use the same indexes i and j, but</span></span><br><span class="line">    <span class="comment"># table[i][j] means the match status between p[:i] and s[:j], i.e.</span></span><br><span class="line">    <span class="comment"># table[0][0] means the match status of two empty strings, and</span></span><br><span class="line">    <span class="comment"># table[1][1] means the match status of p[0] and s[0]. Therefore, when</span></span><br><span class="line">    <span class="comment"># refering to the i-th and the j-th characters of p and s for updating</span></span><br><span class="line">    <span class="comment"># table[i][j], we use p[i - 1] and s[j - 1].</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Initialize the table with False. The first row is satisfied.</span></span><br><span class="line">    table = [[<span class="literal">False</span>] * (<span class="built_in">len</span>(s) + <span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(p) + <span class="number">1</span>)]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Update the corner case of matching two empty strings.</span></span><br><span class="line">    table[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Update the corner case of when s is an empty string but p is not.</span></span><br><span class="line">    <span class="comment"># Since each &#x27;*&#x27; can eliminate the charter before it, the table is</span></span><br><span class="line">    <span class="comment"># vertically updated by the one before previous. [test_symbol_0]</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, <span class="built_in">len</span>(p) + <span class="number">1</span>):</span><br><span class="line">        table[i][<span class="number">0</span>] = table[i - <span class="number">2</span>][<span class="number">0</span>] <span class="keyword">and</span> p[i - <span class="number">1</span>] == <span class="string">&#x27;*&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(p) + <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(s) + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> p[i - <span class="number">1</span>] != <span class="string">&quot;*&quot;</span>:</span><br><span class="line">                <span class="comment"># Update the table by referring the diagonal element.</span></span><br><span class="line">                table[i][j] = table[i - <span class="number">1</span>][j - <span class="number">1</span>] <span class="keyword">and</span> \</span><br><span class="line">                              (p[i - <span class="number">1</span>] == s[j - <span class="number">1</span>] <span class="keyword">or</span> p[i - <span class="number">1</span>] == <span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># Eliminations (referring to the vertical element)</span></span><br><span class="line">                <span class="comment"># Either refer to the one before previous or the previous.</span></span><br><span class="line">                <span class="comment"># I.e. * eliminate the previous or count the previous.</span></span><br><span class="line">                <span class="comment"># [test_symbol_1]</span></span><br><span class="line">                table[i][j] = table[i - <span class="number">2</span>][j] <span class="keyword">or</span> table[i - <span class="number">1</span>][j]</span><br><span class="line"></span><br><span class="line">                <span class="comment"># Propagations (referring to the horizontal element)</span></span><br><span class="line">                <span class="comment"># If p&#x27;s previous one is equal to the current s, with</span></span><br><span class="line">                <span class="comment"># helps of *, the status can be propagated from the left.</span></span><br><span class="line">                <span class="comment"># [test_symbol_2]</span></span><br><span class="line">                <span class="keyword">if</span> p[i - <span class="number">2</span>] == s[j - <span class="number">1</span>] <span class="keyword">or</span> p[i - <span class="number">2</span>] == <span class="string">&#x27;.&#x27;</span>:</span><br><span class="line">                    table[i][j] |= table[i][j - <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> table[-<span class="number">1</span>][-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>322. Coin Change</summary>
<blockquote>
<p>Assume dp[i] is the fewest number of coins making up amount i, then for every coin in coins, dp[i] = min(dp[i - coin] + 1).</p>
</blockquote>
<p>Run time: $O(mn)$, space: $O(m)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">coinChange</span>(<span class="params">self, coins: <span class="type">List</span>[<span class="built_in">int</span>], amount: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">    dp = [<span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)] * (amount+<span class="number">1</span>)</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">    coins.sort()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,amount+<span class="number">1</span>):</span><br><span class="line">        temp = [<span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)]</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> coins:</span><br><span class="line">            <span class="keyword">if</span> i - c &lt; <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            temp.append(dp[i-c])</span><br><span class="line">        dp[i] = <span class="built_in">min</span>(temp)+<span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[amount] <span class="keyword">if</span> dp[amount] != <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>) <span class="keyword">else</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>403. Frog Jump</summary>
<blockquote>
<p>Use a dictionary dic which maps the position of a stone in stones to the set of stepsizes that can jump onto the stone. We initialize dic = {0:{0}}, meaning that we start with the stone at position 0. Next, we iterate i over range(len(stones)), and check if stones[i] is in dic, if it is, it means that there are previous jumps that land on this stone, and we can continue jumping ahead, in which case we iterate over all val in dic[stones[i]], and for each val, we can continue jumping ahead with three stepsizes (val-1, val, and val+1). Therefore, we add val-1 to dic[stones[i]+val-1], val to dic[stones[i]+val], and val+1 to dic[stones[i]+val+1]. Finally, we check if stones[-1] is in dic, if it is, we return True; Else we return False.</p>
</blockquote>
<p>Run time: $O(n^2)$, space: $O(n^2)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">canCross</span>(<span class="params">self, stones: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">    dic = collections.defaultdict(<span class="built_in">set</span>) <span class="comment"># &lt;steps, possible next steps&gt;</span></span><br><span class="line">    dic[<span class="number">0</span>].add(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(stones)):</span><br><span class="line">        <span class="keyword">if</span> stones[i] <span class="keyword">in</span> dic:</span><br><span class="line">            <span class="keyword">for</span> val <span class="keyword">in</span> dic[stones[i]]:</span><br><span class="line">                <span class="keyword">if</span> val &gt; <span class="number">0</span>:</span><br><span class="line">                    dic[stones[i]+val].add(val)</span><br><span class="line">                <span class="keyword">if</span> val &gt; <span class="number">1</span>:</span><br><span class="line">                    dic[stones[i]+val-<span class="number">1</span>].add(val-<span class="number">1</span>)</span><br><span class="line">                dic[stones[i]+val+<span class="number">1</span>].add(val+<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> stones[-<span class="number">1</span>] <span class="keyword">in</span> dic</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>1406. Stone Game III</summary>
<blockquote>
<p>dp[i] means, if we ignore before A[i],<br>
what’s the highest score that Alex can win over the Bob？<br>
There are three option for Alice to choose.<br>
Take A[i], win take - dp[i+1]<br>
Take A[i] + A[i+1], win take - dp[i+2]<br>
Take A[i] + A[i+1] + A[i+2], win take - dp[i+3]<br>
dp[i] equals the best outcome of these three solutions.<br>
<a target="_blank" rel="noopener" href="https://leetcode.com/problems/stone-game-iii/discuss/564260/JavaC%2B%2BPython-DP-O(1)-Space">https://leetcode.com/problems/stone-game-iii/discuss/564260/JavaC%2B%2BPython-DP-O(1)-Space</a></p>
</blockquote>
<p>Run time: $O(n)$, space: $O(1)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">stoneGameIII</span>(<span class="params">self, stoneValue: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">str</span>:</span></span><br><span class="line">    dp = [<span class="number">0</span>] * <span class="number">4</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(stoneValue)-<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">        dp[i % <span class="number">4</span>] = -<span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)</span><br><span class="line">        take = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">            <span class="keyword">if</span> i+k &lt; <span class="built_in">len</span>(stoneValue):</span><br><span class="line">                take += stoneValue[i+k]</span><br><span class="line">                dp[i % <span class="number">4</span>] = <span class="built_in">max</span>(dp[i % <span class="number">4</span>], take - dp[(i+k+<span class="number">1</span>) % <span class="number">4</span>])</span><br><span class="line">    <span class="keyword">if</span> dp[<span class="number">0</span>] &gt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Alice&quot;</span></span><br><span class="line">    <span class="keyword">if</span> dp[<span class="number">0</span>] &lt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Bob&quot;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Tie&quot;</span></span><br></pre></td></tr></table></figure>
<p>Run time: $O(n)$, space: $O(n)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">stoneGameIII</span>(<span class="params">self, stoneValue: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">str</span>:</span></span><br><span class="line">    n = <span class="built_in">len</span>(stoneValue)</span><br><span class="line">    dp = [<span class="number">0</span>] * (n+<span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n-<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">        k = <span class="number">0</span></span><br><span class="line">        take = <span class="number">0</span></span><br><span class="line">        dp[i] = -<span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)</span><br><span class="line">        <span class="keyword">while</span> k &lt; <span class="number">3</span> <span class="keyword">and</span> i + k &lt; n:</span><br><span class="line">            take += stoneValue[i+k]</span><br><span class="line">            dp[i] = <span class="built_in">max</span>(dp[i], take - dp[i+k+<span class="number">1</span>])</span><br><span class="line">            k += <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> dp[<span class="number">0</span>] &gt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Alice&quot;</span></span><br><span class="line">    <span class="keyword">if</span> dp[<span class="number">0</span>] &lt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Bob&quot;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Tie&quot;</span></span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>562. Longest Line of Consecutive One in Matrix</summary>
<blockquote>
<p>Use a 3D matrix to keep track of the max length in four directions.<br>
<a target="_blank" rel="noopener" href="https://leetcode.com/problems/longest-line-of-consecutive-one-in-matrix/discuss/195405/Python3-DP-Solution">https://leetcode.com/problems/longest-line-of-consecutive-one-in-matrix/discuss/195405/Python3-DP-Solution</a></p>
</blockquote>
<p>Run time: $O(mn)$, space: $O(mn)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">longestLine</span>(<span class="params">self, mat: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> mat <span class="keyword">or</span> <span class="keyword">not</span> mat[<span class="number">0</span>]:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    m,n = <span class="built_in">len</span>(mat), <span class="built_in">len</span>(mat[<span class="number">0</span>])</span><br><span class="line">    dp = [[[<span class="number">0</span>]*<span class="number">4</span> <span class="keyword">for</span> __ <span class="keyword">in</span> <span class="built_in">range</span>(n)] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m)]</span><br><span class="line">    max_len = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> row <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">        <span class="keyword">for</span> col <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">if</span> mat[row][col] == <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">if</span> col-<span class="number">1</span> &gt;= <span class="number">0</span>:</span><br><span class="line">                    dp[row][col][<span class="number">0</span>] = dp[row][col-<span class="number">1</span>][<span class="number">0</span>]+<span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[row][col][<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> row-<span class="number">1</span> &gt;= <span class="number">0</span>:</span><br><span class="line">                    dp[row][col][<span class="number">1</span>] = dp[row-<span class="number">1</span>][col][<span class="number">1</span>]+<span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[row][col][<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> row-<span class="number">1</span> &gt;= <span class="number">0</span> <span class="keyword">and</span> col-<span class="number">1</span> &gt;= <span class="number">0</span>:</span><br><span class="line">                    dp[row][col][<span class="number">2</span>] = dp[row-<span class="number">1</span>][col-<span class="number">1</span>][<span class="number">2</span>]+<span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[row][col][<span class="number">2</span>] = <span class="number">1</span></span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> row-<span class="number">1</span> &gt;= <span class="number">0</span> <span class="keyword">and</span> col+<span class="number">1</span> &lt; n:</span><br><span class="line">                    dp[row][col][<span class="number">3</span>] = dp[row-<span class="number">1</span>][col+<span class="number">1</span>][<span class="number">3</span>]+<span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[row][col][<span class="number">3</span>] = <span class="number">1</span></span><br><span class="line">            max_len = <span class="built_in">max</span>(max_len, dp[row][col][<span class="number">0</span>],</span><br><span class="line">                                 dp[row][col][<span class="number">1</span>],</span><br><span class="line">                                 dp[row][col][<span class="number">2</span>],</span><br><span class="line">                                 dp[row][col][<span class="number">3</span>])</span><br><span class="line">    <span class="keyword">return</span> max_len</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>1691. Maximum Height by Stacking Cuboids</summary>
<blockquote>
<p>Sort items by its three side lengths, then sort all items in descending order. Then keep one array of longest side for each box. For each box, we look at all possible larger boxes and see if its all three sides are smaller, then update the max height to be the longest side plus the max height at index of the larger box. In the end return the max of max height array.</p>
</blockquote>
<p>Run time: $O(n^2)$, space: $O(n)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">maxHeight</span>(<span class="params">self, cuboids: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">    Info = []</span><br><span class="line">    <span class="keyword">for</span> cube <span class="keyword">in</span> cuboids:</span><br><span class="line">        Info.append(<span class="built_in">sorted</span>(cube))</span><br><span class="line"></span><br><span class="line">    Info.sort(reverse = <span class="literal">True</span>)</span><br><span class="line">    max_height = [Info[i][<span class="number">2</span>] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(Info))]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># add boxes from bottom to top (i sits on top of j)</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(Info)):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i):</span><br><span class="line">            <span class="keyword">if</span> Info[i][<span class="number">0</span>] &lt;= Info[j][<span class="number">0</span>] <span class="keyword">and</span> \</span><br><span class="line">               Info[i][<span class="number">1</span>] &lt;= Info[j][<span class="number">1</span>] <span class="keyword">and</span> \</span><br><span class="line">               Info[i][<span class="number">2</span>] &lt;= Info[j][<span class="number">2</span>]:</span><br><span class="line">                max_height[i] = <span class="built_in">max</span>(max_height[i], </span><br><span class="line">                                    max_height[j] + Info[i][<span class="number">2</span>]) <span class="comment"># assume height is the last dimension</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>(max_height)</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>1987. Number of Unique Good Subsequences</summary>
<blockquote>
<p>We count the number of subsequence that ends with 0 and ends with 1. If we see a 0, we add the sum of the array. If we see a 1, we add the sum of the array and a 1, since itself and form a valid substring later.<br>
<a target="_blank" rel="noopener" href="https://leetcode.com/problems/number-of-unique-good-subsequences/discuss/1431819/JavaC%2B%2BPython-DP-4-lines-O(N)-Time-O(1)-Space">https://leetcode.com/problems/number-of-unique-good-subsequences/discuss/1431819/JavaC%2B%2BPython-DP-4-lines-O(N)-Time-O(1)-Space</a></p>
</blockquote>
<p>Run time: $O(n)$, space: $O(1)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">numberOfUniqueGoodSubsequences</span>(<span class="params">self, binary: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">    mod = <span class="number">10</span>**<span class="number">9</span> + <span class="number">7</span></span><br><span class="line">    dp = [<span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> c <span class="keyword">in</span> binary:</span><br><span class="line">        dp[<span class="built_in">int</span>(c)] = (<span class="built_in">sum</span>(dp) + <span class="built_in">int</span>(c)) % mod</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">if</span> <span class="string">&#x27;0&#x27;</span> <span class="keyword">in</span> binary:</span><br><span class="line">        <span class="keyword">return</span> (<span class="built_in">sum</span>(dp)+<span class="number">1</span>) % mod</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sum</span>(dp) % mod</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>940. Distinct Subsequences II</summary>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/02501f516437">https://www.jianshu.com/p/02501f516437</a></p>
</blockquote>
<p>Run time: $O(n)$, space: $O(1)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">distinctSubseqII</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">    dp = [<span class="number">0</span>] * <span class="number">26</span></span><br><span class="line">    mod = <span class="number">10</span>**<span class="number">9</span>+<span class="number">7</span></span><br><span class="line">    <span class="keyword">for</span> ss <span class="keyword">in</span> s:</span><br><span class="line">        dp[<span class="built_in">ord</span>(ss)-<span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>)] = <span class="built_in">sum</span>(dp) + <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sum</span>(dp) % mod</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>727. Minimum Window Subsequence</summary>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://anshika-bhargava0202.medium.com/leetcode-727-minimum-window-subsequence-21c40baff689">https://anshika-bhargava0202.medium.com/leetcode-727-minimum-window-subsequence-21c40baff689</a></p>
</blockquote>
<p>Run time: $O(mn)$, space: $O(mn)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">minWindow</span>(<span class="params">self, S: <span class="built_in">str</span>, T: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span></span><br><span class="line">	m,n = <span class="built_in">len</span>(S), <span class="built_in">len</span>(T)</span><br><span class="line">	dp = [[<span class="number">0</span>]*(n+<span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m+<span class="number">1</span>)]</span><br><span class="line">	<span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n+<span class="number">1</span>):</span><br><span class="line">		dp[<span class="number">0</span>][j] = sys.maxsize // <span class="number">2</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, m+<span class="number">1</span>):</span><br><span class="line">		<span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n+<span class="number">1</span>):</span><br><span class="line">			<span class="keyword">if</span> S[i] == T[j]:</span><br><span class="line">				dp[i][j] = dp[i-<span class="number">1</span>][j-<span class="number">1</span>] + <span class="number">1</span></span><br><span class="line">			<span class="keyword">else</span>:</span><br><span class="line">				dp[i][j] = dp[i-<span class="number">1</span>][j] + <span class="number">1</span></span><br><span class="line">	</span><br><span class="line">	min_len = sys.maxsize // <span class="number">2</span></span><br><span class="line">	end_pos = -<span class="number">1</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, m+<span class="number">1</span>):</span><br><span class="line">		<span class="keyword">if</span> dp[i][n] &lt; min_len:</span><br><span class="line">			min_len = dp[i][n]</span><br><span class="line">			end_pos = i-<span class="number">1</span></span><br><span class="line">	<span class="keyword">if</span> min_len == sys.maxsize // <span class="number">2</span>:</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;&quot;</span></span><br><span class="line">	<span class="keyword">return</span> S[end_pos-min_len+<span class="number">1</span>: end_pos+<span class="number">1</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>42. Trapping Rain Water</summary>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=StH5vntauyQ">https://www.youtube.com/watch?v=StH5vntauyQ</a></p>
</blockquote>
<p>Run time: $O(n)$, space: $O(1)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">trap</span>(<span class="params">self, height: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> height:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    n = <span class="built_in">len</span>(height)</span><br><span class="line">    l, r = <span class="number">0</span>, n-<span class="number">1</span></span><br><span class="line">    max_l = height[l]</span><br><span class="line">    max_r = height[r]</span><br><span class="line">    ans = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> l &lt; r:</span><br><span class="line">        <span class="keyword">if</span> max_l &lt; max_r:</span><br><span class="line">            ans += max_l - height[l]</span><br><span class="line">            l += <span class="number">1</span></span><br><span class="line">            max_l = <span class="built_in">max</span>(max_l, height[l])</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            ans += max_r - height[r]</span><br><span class="line">            r -= <span class="number">1</span></span><br><span class="line">            max_r = <span class="built_in">max</span>(max_r, height[r])</span><br><span class="line">    <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<p>Run time: $O(n)$, space: $O(n)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">trap</span>(<span class="params">self, height: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">    waterLevel = []</span><br><span class="line">    left = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> h <span class="keyword">in</span> height:</span><br><span class="line">        left = <span class="built_in">max</span>(left, h) </span><br><span class="line">        waterLevel += [left] <span class="comment"># over-fill it to left max height</span></span><br><span class="line">    right = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i, h <span class="keyword">in</span> <span class="built_in">reversed</span>(<span class="built_in">list</span>(<span class="built_in">enumerate</span>(height))):</span><br><span class="line">        right = <span class="built_in">max</span>(right, h)</span><br><span class="line">        waterLevel[i] = <span class="built_in">min</span>(waterLevel[i], right) - h <span class="comment"># drain to the right height</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sum</span>(waterLevel)</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>664. Strange Printer</summary>
<blockquote>
<p>Let dp(i, j) be the number of turns needed to print S[i:j+1].Then, when trying to complete the printing of interval [i, k] (with S[i] == S[k]), the job will take the same number of turns as painting [i, k-1]. This is because it is always at least as good to print [i, k] first in one turn rather than separately.<br>
Also, we would need to complete [k+1, j]. So in total, our candidate answer is dp(i, k-1) + dp(k+1, j). Of course, when k == i, our candidate is 1 + dp(i+1, j): we paint S[i] in one turn, then paint the rest in dp(i+1, j) turns.<br>
<a target="_blank" rel="noopener" href="https://leetcode.com/problems/strange-printer/discuss/106795/Python-Straightforward-DP-with-Explanation">https://leetcode.com/problems/strange-printer/discuss/106795/Python-Straightforward-DP-with-Explanation</a></p>
</blockquote>
<p>Run time: $O(n^3)$, space: $O(n^2)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">strangePrinter</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">    memo = &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dp</span>(<span class="params">i, j</span>):</span></span><br><span class="line">        <span class="keyword">if</span> i &gt; j: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> (i, j) <span class="keyword">not</span> <span class="keyword">in</span> memo:</span><br><span class="line">            ans = dp(i+<span class="number">1</span>, j) + <span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(i+<span class="number">1</span>, j+<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> s[k] == s[i]:</span><br><span class="line">                    ans = <span class="built_in">min</span>(ans, dp(i, k-<span class="number">1</span>) + dp(k+<span class="number">1</span>, j))</span><br><span class="line">            memo[i, j] = ans</span><br><span class="line">        <span class="keyword">return</span> memo[i, j]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp(<span class="number">0</span>, <span class="built_in">len</span>(s) - <span class="number">1</span>)</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>1218. Longest Arithmetic Subsequence of Given Difference</summary>
<blockquote>
<p>Use a dictionary to store &lt;last number, length of subsequence&gt;, return 0 if not found, then add 1.</p>
</blockquote>
<p>Run time: $O(n)$, space: $O(n)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">longestSubsequence</span>(<span class="params">self, arr: <span class="type">List</span>[<span class="built_in">int</span>], difference: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">    res = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> a <span class="keyword">in</span> arr:</span><br><span class="line">        res[a] = res.get(a-difference, <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>(res.values())</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>552. Student Attendance Record II</summary>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/student-attendance-record-ii/discuss/101634/Python-DP-with-explanation">https://leetcode.com/problems/student-attendance-record-ii/discuss/101634/Python-DP-with-explanation</a></p>
</blockquote>
<p>Run time: $O(n)$, space: $O(n)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">checkRecord</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    i=0, possible =1</span></span><br><span class="line"><span class="string">    i=1, possible =2 (P,L)</span></span><br><span class="line"><span class="string">    i=2, possible =4 (PP,PL,LP,LL)</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> n==<span class="number">1</span>:<span class="keyword">return</span> <span class="number">3</span></span><br><span class="line">    <span class="keyword">if</span> n==<span class="number">0</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    mod=<span class="number">1000000007</span></span><br><span class="line">    dp=[<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n+<span class="number">1</span>)]</span><br><span class="line">    dp[<span class="number">0</span>],dp[<span class="number">1</span>],dp[<span class="number">2</span>]=<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>,n+<span class="number">1</span>):</span><br><span class="line">        dp[i]=(dp[i-<span class="number">1</span>]+dp[i-<span class="number">2</span>]+dp[i-<span class="number">3</span>] )% mod</span><br><span class="line">    res=dp[n] </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n+<span class="number">1</span>):</span><br><span class="line">        res+=dp[i-<span class="number">1</span>]*dp[n -i]%mod</span><br><span class="line">    res=res%mod</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>1277. Count Square Submatrices with All Ones</summary>
<blockquote>
<p>Get the min of the three neighbors, then add value in the current cell.</p>
</blockquote>
<p>Run time: $O(mn)$, space: $O(1)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">countSquares</span>(<span class="params">self, matrix: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> matrix <span class="keyword">or</span> <span class="built_in">len</span>(matrix) == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    m,n = <span class="built_in">len</span>(matrix), <span class="built_in">len</span>(matrix[<span class="number">0</span>])</span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">if</span> matrix[i][j] == <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">if</span> i == <span class="number">0</span> <span class="keyword">or</span> j == <span class="number">0</span>:</span><br><span class="line">                    count += <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    temp = <span class="built_in">min</span>(matrix[i-<span class="number">1</span>][j-<span class="number">1</span>], </span><br><span class="line">                                       matrix[i-<span class="number">1</span>][j], </span><br><span class="line">                                       matrix[i][j-<span class="number">1</span>]) + matrix[i][j]</span><br><span class="line">                    count += temp</span><br><span class="line">                    matrix[i][j] = temp</span><br><span class="line">    <span class="keyword">return</span> count</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>1937. Maximum Number of Points with Cost</summary>
<blockquote>
<p>We traverse current_points left to right and store the maximum possible score that the next row can get, taking into account only the elements with indexes [0, col], then do this reversely.</p>
</blockquote>
<p>Run time: $O(mn)$, space: $O(m)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">maxPoints</span>(<span class="params">self, points: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">    current_points = points[<span class="number">0</span>][:]</span><br><span class="line">    <span class="keyword">for</span> row <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(points)):</span><br><span class="line">        max_col_points = -<span class="built_in">float</span>(<span class="string">&quot;inf&quot;</span>)</span><br><span class="line">        <span class="keyword">for</span> col <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(current_points)):</span><br><span class="line">            max_col_points = <span class="built_in">max</span>(max_col_points - <span class="number">1</span>, current_points[col])</span><br><span class="line">            current_points[col] = max_col_points</span><br><span class="line">            </span><br><span class="line">        max_col_points = -<span class="built_in">float</span>(<span class="string">&quot;inf&quot;</span>)</span><br><span class="line">        <span class="keyword">for</span> col <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(current_points)-<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">            max_col_points = <span class="built_in">max</span>(max_col_points - <span class="number">1</span>, current_points[col])</span><br><span class="line">            current_points[col] = max_col_points</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">for</span> col <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(current_points)):</span><br><span class="line">            current_points[col] = points[row][col] + current_points[col]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>(current_points)</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>140. Word Break II</summary>
<blockquote>
<p>For any word (denoted as \text{w}w) in the dictionary, if it matches with a prefix of the input string, we then can divide the string into two parts: the word and the postfix, i.e. s = \text{w} + \text{postfix}s=w+postfix.</p>
</blockquote>
<p>Run time: $ \mathcal{O}(N^2 + 2 ^ N + W)$, space: $ \mathcal{O}(2^N \cdot N + N^2 + W)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">wordBreak</span>(<span class="params">self, s: <span class="built_in">str</span>, wordDict: <span class="type">List</span>[<span class="built_in">str</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">str</span>]:</span></span><br><span class="line">    memo = &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">s</span>):</span></span><br><span class="line">        <span class="keyword">if</span> s <span class="keyword">in</span> memo:</span><br><span class="line">            <span class="keyword">return</span> memo[s]</span><br><span class="line">        </span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> wordDict:</span><br><span class="line">            <span class="keyword">if</span> s.startswith(x):</span><br><span class="line">                <span class="keyword">if</span> s == x:</span><br><span class="line">                    res += [x]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">for</span> y <span class="keyword">in</span> dfs(s[<span class="built_in">len</span>(x):]):</span><br><span class="line">                        res += [x + <span class="string">&#x27; &#x27;</span> + y]</span><br><span class="line">        memo[s] = res</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">                    </span><br><span class="line">    <span class="keyword">return</span> dfs(s) </span><br></pre></td></tr></table></figure>
<blockquote>
<p>Recursion</p>
</blockquote>
<p>Run time: $ \mathcal{O}(N^2 + 2 ^ N + W)$, space: $ \mathcal{O}(2^N \cdot N + N^2 + W)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">helper</span>(<span class="params">s, string, ans</span>):</span></span><br><span class="line">    <span class="keyword">if</span> s == <span class="string">&quot;&quot;</span>:</span><br><span class="line">        ans.append(string.strip())</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)+<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">if</span> s[:i] <span class="keyword">in</span> wordDict:</span><br><span class="line">            temp = string + <span class="string">&quot; &quot;</span>+ s[:i]</span><br><span class="line">            helper(s[i:], temp, ans)</span><br><span class="line"></span><br><span class="line">ans = []</span><br><span class="line">helper(s, <span class="string">&quot;&quot;</span>, ans)</span><br><span class="line"><span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>53. Maximum Subarray</summary>
> One variable to keep track of current subarray, one variable to track max subarray.
<p>Run time: $O(n)$, space: $O(1)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">maxSubArray</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">    current_subarray = max_subarray = nums[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> num <span class="keyword">in</span> nums[<span class="number">1</span>:]:</span><br><span class="line">        current_subarray = <span class="built_in">max</span>(num, current_subarray + num)</span><br><span class="line">        max_subarray = <span class="built_in">max</span>(max_subarray, current_subarray)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> max_subarray</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>121. Best Time to Buy and Sell Stock</summary>
> Keep track of lowest price, and update max profit.
<p>Run time: $O(n)$, space: $O(1)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span>(<span class="params">self, prices: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">    buy = <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)</span><br><span class="line">    profit = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> p <span class="keyword">in</span> prices:</span><br><span class="line">        buy = <span class="built_in">min</span>(buy, p)</span><br><span class="line">        profit = <span class="built_in">max</span>(profit, p-buy)</span><br><span class="line">    <span class="keyword">return</span> profit</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>10. Regular Expression Matching</summary>
<blockquote>
<p>dp[i][j] represents whether the string s ending at index i could be expressed by string p ending at index j.</p>
</blockquote>
<p>Run time: $O(mn)$, space: $O(mn)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isMatch</span>(<span class="params">self, s: <span class="built_in">str</span>, p: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">    m,n = <span class="built_in">len</span>(s), <span class="built_in">len</span>(p)</span><br><span class="line">    dp = [[<span class="literal">False</span>]*(n+<span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m+<span class="number">1</span>)]</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">True</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n+<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">if</span> p[i-<span class="number">1</span>] == <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">            dp[<span class="number">0</span>][i] = dp[<span class="number">0</span>][i-<span class="number">2</span>] <span class="comment"># same as the char before *</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, m+<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> p[j-<span class="number">1</span>] == <span class="string">&#x27;.&#x27;</span>: <span class="comment"># skip current one</span></span><br><span class="line">                dp[i][j] = dp[i-<span class="number">1</span>][j-<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">elif</span> p[j-<span class="number">1</span>] != <span class="string">&#x27;*&#x27;</span>: <span class="comment"># normal char must match</span></span><br><span class="line">                dp[i][j] = dp[i-<span class="number">1</span>][j-<span class="number">1</span>] <span class="keyword">and</span> p[j-<span class="number">1</span>] == s[i-<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">elif</span> p[j-<span class="number">2</span>] != <span class="string">&#x27;.&#x27;</span> <span class="keyword">and</span> p[j-<span class="number">2</span>] != s[i-<span class="number">1</span>]: <span class="comment"># ended at *</span></span><br><span class="line">                dp[i][j] = dp[i][j-<span class="number">2</span>]</span><br><span class="line">            <span class="keyword">else</span>: <span class="comment"># all other cases</span></span><br><span class="line">                dp[i][j] = dp[i-<span class="number">1</span>][j] <span class="keyword">or</span> dp[i][j-<span class="number">1</span>] <span class="keyword">or</span> dp[i][j-<span class="number">2</span>]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> dp[-<span class="number">1</span>][-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>416. Partition Equal Subset Sum</summary>
<blockquote>
<p>We could further optimize Approach 3. We must understand that for any array element ii, we need results of the previous iteration (i-1) only. Hence, we could achieve the same using a one-dimensional array as well.</p>
</blockquote>
<p>Run time: $O(mn)$, space: $O(m)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">canPartition</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">    sum_ = <span class="built_in">sum</span>(nums)</span><br><span class="line">    <span class="keyword">if</span> sum_ % <span class="number">2</span> != <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    </span><br><span class="line">    half = sum_ // <span class="number">2</span></span><br><span class="line">    n = <span class="built_in">len</span>(nums)</span><br><span class="line">    </span><br><span class="line">    dp = [<span class="literal">False</span>]*(sum_+<span class="number">1</span>)</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="literal">True</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n+<span class="number">1</span>):</span><br><span class="line">        curr = nums[i-<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(sum_, curr-<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">            dp[j] = dp[j] <span class="keyword">or</span> dp[j-curr]</span><br><span class="line">    <span class="keyword">return</span> dp[sum_]</span><br></pre></td></tr></table></figure>
<blockquote>
<p>We maintain a 2D array ,dp[n][subSetSum] For an array element ii and sum jj in array nums,</p>
</blockquote>
<p>dp[i][j]=true if the sum jj can be formed by array elements in subset nums[0]…nums[i],otherwise dp[i][j]=false</p>
<p>Run time: $O(mn)$, space: $O(mn)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">canPartition</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">    sum_ = <span class="built_in">sum</span>(nums)</span><br><span class="line">    <span class="keyword">if</span> sum_ % <span class="number">2</span> != <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    </span><br><span class="line">    half = sum_ // <span class="number">2</span></span><br><span class="line">    n = <span class="built_in">len</span>(nums)</span><br><span class="line">    </span><br><span class="line">    dp = [[<span class="literal">False</span>]*(sum_+<span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n+<span class="number">1</span>)]</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">True</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n+<span class="number">1</span>):</span><br><span class="line">        curr = nums[i-<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(sum_ + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> j &lt; curr:</span><br><span class="line">                dp[i][j] = dp[i-<span class="number">1</span>][j]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                dp[i][j] = dp[i-<span class="number">1</span>][j] <span class="keyword">or</span> dp[i-<span class="number">1</span>][j-curr]</span><br><span class="line">    <span class="keyword">return</span> dp[n][sum_]</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>300. Longest Increasing Subsequence</summary>
<blockquote>
<p>Use finary search <code>bisect_left</code></p>
</blockquote>
<p>Run time: $O(n\log n)$, space: $O(n)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lengthOfLIS</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">    tails = [<span class="number">0</span>] * <span class="built_in">len</span>(nums)</span><br><span class="line">    size = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> nums:</span><br><span class="line">        lo, hi = <span class="number">0</span>, size</span><br><span class="line">        <span class="keyword">while</span> lo != hi:</span><br><span class="line">            mid = (lo + hi) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> tails[mid] &lt; x:</span><br><span class="line">                lo = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                hi = mid</span><br><span class="line">        tails[lo] = x</span><br><span class="line">        size = <span class="built_in">max</span>(lo + <span class="number">1</span>, size)</span><br><span class="line">    <span class="keyword">return</span> size</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Double for loop and update max if the inner value is smaller than current value.</p>
</blockquote>
<p>Run time: $O(n^2)$, space: $O(n)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lengthOfLIS</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">    n = <span class="built_in">len</span>(nums)</span><br><span class="line">    dp = [<span class="number">1</span>] * (n+<span class="number">1</span>)</span><br><span class="line">    max_len = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i):</span><br><span class="line">            <span class="keyword">if</span> nums[j] &lt; nums[i]:</span><br><span class="line">                dp[i] = <span class="built_in">max</span>(dp[j]+<span class="number">1</span>, dp[i])</span><br><span class="line">        max_len = <span class="built_in">max</span>(dp[i], max_len)</span><br><span class="line">    <span class="keyword">return</span> max_len</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>139. Word Break</summary>
<blockquote>
<p>First put list into a set for easier access. Initialize an array of size n+1 and set the first entry to be True. Loop from 1 to n, and loop from 0 to i-1, check if dp[j] is True and the substring between j and i is valid. If so, set this entry of the dp array to be true.</p>
</blockquote>
<p>Run time: $O(n^3)$, space: $O(n)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">wordBreak</span>(<span class="params">self, s: <span class="built_in">str</span>, wordDict: <span class="type">List</span>[<span class="built_in">str</span>]</span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">    word_set = <span class="built_in">set</span>(wordDict)</span><br><span class="line">    n = <span class="built_in">len</span>(s)</span><br><span class="line">    dp = [<span class="literal">False</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n+<span class="number">1</span>)]</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n+<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i):</span><br><span class="line">            <span class="keyword">if</span> dp[j] <span class="keyword">and</span> s[j:i] <span class="keyword">in</span> word_set:</span><br><span class="line">                dp[i] = <span class="literal">True</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">return</span> dp[<span class="built_in">len</span>(s)]</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>279. Perfect Squares</summary>
> To calculate the value of numSquares(n), first we need to calculate all the values before n.
<p>Run time: $O(n\sqrt{n})$ or $O(\frac{\sqrt{n}^{h+1}-1}{\sqrt{n}-1})=O(n^{\frac{h}{2}})$, space: $O(n)$ or $O((\sqrt{n})^h)$, where h is the height of the N-ary tree.</p>
<blockquote>
<p>Again, first of all, we prepare a list of square numbers (named square_nums) that are less than the given number n.<br>
We then create a queue variable which would keep all the remainders to enumerate at each level.<br>
In the main loop, we iterate over the queue variable. At each iteration, we check if the remainder is one of the square numbers. If the remainder is not a square number, we subtract it with one of the square numbers to obtain a new remainder and then add the new remainder to the next_queue for the iteration of the next level. We break out of the loop once we encounter a remainder that is of a square number, which also means that we find the solution.</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numSquares</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        queue = deque([(n, <span class="number">0</span>)])</span><br><span class="line">        visited = &#123;n&#125;</span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            curr, step = queue.popleft()</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">int</span>(curr ** <span class="number">0.5</span>) == curr ** <span class="number">0.5</span>:</span><br><span class="line">                <span class="keyword">return</span> step + <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">int</span>(curr ** <span class="number">0.5</span>) + <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> curr - (i ** <span class="number">2</span>) <span class="keyword">not</span> <span class="keyword">in</span> visited:</span><br><span class="line">                    queue.append((curr - (i ** <span class="number">2</span>), step + <span class="number">1</span>))</span><br><span class="line">                    visited.add(curr - (i ** <span class="number">2</span>))</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">numSquares</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">    dp = [i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n+<span class="number">1</span>)]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>, n+<span class="number">1</span>):</span><br><span class="line">        j = <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> j**<span class="number">2</span> &lt;= i:</span><br><span class="line">            dp[i] = <span class="built_in">min</span>(dp[i], dp[i-j**<span class="number">2</span>]+<span class="number">1</span>)</span><br><span class="line">            j += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> dp[-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>221. Maximal Square</summary>
<blockquote>
<p>Find squares whose bottom right corner is formed by the current cell. If we can modify the input, the space complexity can be further reduced to $O(1)$.</p>
</blockquote>
<p>Run time: $O(mn)$, space: $O(mn)$ or $O(n)$ or $O(1)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">maximalSquare</span>(<span class="params">self, matrix: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">str</span>]]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">    m, n, ans = <span class="built_in">len</span>(matrix), <span class="built_in">len</span>(matrix[<span class="number">0</span>]), <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i, j <span class="keyword">in</span> product(<span class="built_in">range</span>(m-<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>), <span class="built_in">range</span>(n-<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>)):</span><br><span class="line">        <span class="keyword">if</span> i == m-<span class="number">1</span> <span class="keyword">or</span> j == n-<span class="number">1</span>:</span><br><span class="line">            matrix[i][j] = <span class="built_in">int</span>(matrix[i][j])</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, matrix[i][j])</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> matrix[i][j] == <span class="string">&#x27;1&#x27;</span>:</span><br><span class="line">                matrix[i][j] = <span class="number">1</span> + <span class="built_in">min</span>(matrix[i+<span class="number">1</span>][j], matrix[i][j+<span class="number">1</span>], matrix[i+<span class="number">1</span>][j+<span class="number">1</span>])</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                matrix[i][j] = <span class="number">0</span></span><br><span class="line">            ans = <span class="built_in">max</span>(ans, matrix[i][j])</span><br><span class="line">    <span class="keyword">return</span> ans * ans</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">maximalSquare</span>(<span class="params">self, matrix: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">str</span>]]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">    m, n, ans = <span class="built_in">len</span>(matrix), <span class="built_in">len</span>(matrix[<span class="number">0</span>]), <span class="number">0</span></span><br><span class="line">    dp = [[<span class="number">0</span>]*(n+<span class="number">1</span>) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m+<span class="number">1</span>)]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i, j <span class="keyword">in</span> product(<span class="built_in">range</span>(m-<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>), <span class="built_in">range</span>(n-<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>)):</span><br><span class="line">        <span class="keyword">if</span> matrix[i][j] == <span class="string">&#x27;1&#x27;</span>:</span><br><span class="line">            dp[i][j] = <span class="number">1</span> + <span class="built_in">min</span>(dp[i+<span class="number">1</span>][j], dp[i][j+<span class="number">1</span>], dp[i+<span class="number">1</span>][j+<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            dp[i][j] = <span class="number">0</span></span><br><span class="line">        ans = <span class="built_in">max</span>(ans, dp[i][j])</span><br><span class="line">    <span class="keyword">return</span> ans * ans</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>542. 01 Matrix</summary>
<blockquote>
<p>Two for loops, one goes from top left to bottom right, one goes from bottom right to top left. In this way we could find the minimum distance over all four directions.</p>
</blockquote>
<p>Run time: $O(n^2)$, space: $O(1)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">updateMatrix</span>(<span class="params">self, mat: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span></span><br><span class="line">    m, n = <span class="built_in">len</span>(mat), <span class="built_in">len</span>(mat[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> r <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">if</span> mat[r][c] &gt; <span class="number">0</span>:</span><br><span class="line">                top = mat[r - <span class="number">1</span>][c] <span class="keyword">if</span> r &gt; <span class="number">0</span> <span class="keyword">else</span> math.inf</span><br><span class="line">                left = mat[r][c - <span class="number">1</span>] <span class="keyword">if</span> c &gt; <span class="number">0</span> <span class="keyword">else</span> math.inf</span><br><span class="line">                mat[r][c] = <span class="built_in">min</span>(top, left) + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> r <span class="keyword">in</span> <span class="built_in">range</span>(m - <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> <span class="built_in">range</span>(n - <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> mat[r][c] &gt; <span class="number">0</span>:</span><br><span class="line">                bottom = mat[r + <span class="number">1</span>][c] <span class="keyword">if</span> r &lt; m - <span class="number">1</span> <span class="keyword">else</span> math.inf</span><br><span class="line">                right = mat[r][c + <span class="number">1</span>] <span class="keyword">if</span> c &lt; n - <span class="number">1</span> <span class="keyword">else</span> math.inf</span><br><span class="line">                mat[r][c] = <span class="built_in">min</span>(mat[r][c], bottom + <span class="number">1</span>, right + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> mat</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>64. Minimum Path Sum</summary>
<blockquote>
<p>Instead of using a 2D matrix for dp, we can do the same work using a dp array of the row size, since for making the current entry all we need is the dp entry for the bottom and the right element. Thus, we start by initializing only the last element of the array as the last element of the given matrix. The last entry is the bottom rightmost element of the given matrix.</p>
</blockquote>
<p>Run time: $O(n^2)$, space: $O(n^2)$ or $O(n)$ or $O(1)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">minPathSum</span>(<span class="params">self, grid: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">    m,n = <span class="built_in">len</span>(grid), <span class="built_in">len</span>(grid[<span class="number">0</span>])</span><br><span class="line">    dp = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m-<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n-<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> i == m-<span class="number">1</span> <span class="keyword">and</span> j != n-<span class="number">1</span>:</span><br><span class="line">                dp[j] = grid[i][j] + dp[j+<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">elif</span> j == n-<span class="number">1</span> <span class="keyword">and</span> i != m-<span class="number">1</span>:</span><br><span class="line">                dp[j] = grid[i][j] + dp[j]</span><br><span class="line">            <span class="keyword">elif</span> i != m-<span class="number">1</span> <span class="keyword">and</span> j != n-<span class="number">1</span>:</span><br><span class="line">                dp[j] = grid[i][j] + <span class="built_in">min</span>(dp[j], dp[j+<span class="number">1</span>])</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                dp[j] = grid[i][j]</span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">0</span>]</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">minPathSum</span>(<span class="params">self, grid: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">    m = <span class="built_in">len</span>(grid)</span><br><span class="line">    n = <span class="built_in">len</span>(grid[<span class="number">0</span>])</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n):</span><br><span class="line">        grid[<span class="number">0</span>][i] += grid[<span class="number">0</span>][i-<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, m):</span><br><span class="line">        grid[i][<span class="number">0</span>] += grid[i-<span class="number">1</span>][<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, m):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n):</span><br><span class="line">            grid[i][j] += <span class="built_in">min</span>(grid[i-<span class="number">1</span>][j], grid[i][j-<span class="number">1</span>])</span><br><span class="line">    <span class="keyword">return</span> grid[-<span class="number">1</span>][-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>413. Arithmetic Slices</summary>
<blockquote>
<p>we only require the element dp[i−1] to determine the value to be entered at dp[i]. Thus, instead of making use of a 1-D array to store the required data, we can simply keep a track of just the last element.</p>
</blockquote>
<p>Run time: $O(n)$, space: $O(n)$ or $O(1)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">numberOfArithmeticSlices</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">    dp = <span class="number">0</span></span><br><span class="line">    total = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, <span class="built_in">len</span>(nums)):</span><br><span class="line">        <span class="keyword">if</span> nums[i] - nums[i-<span class="number">1</span>] == nums[i-<span class="number">1</span>] - nums[i-<span class="number">2</span>]:</span><br><span class="line">            dp += <span class="number">1</span></span><br><span class="line">            total += dp</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            dp = <span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> total</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">numberOfArithmeticSlices</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(nums) &lt; <span class="number">3</span>: </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    dp = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums))]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, <span class="built_in">len</span>(nums)):</span><br><span class="line">        <span class="keyword">if</span> nums[i] - nums[i-<span class="number">1</span>] == nums[i-<span class="number">1</span>] - nums[i-<span class="number">2</span>]:</span><br><span class="line">            dp[i] = dp[i-<span class="number">1</span>]+<span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sum</span>(dp)</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>198. House Robber</summary>
> Either steal this house and the n-2 ones, or not steal this one. We could just use two variables and keep shifting them.
<p>Run time: $O(n)$, space: $O(n)$ or $O(1)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rob</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            </span><br><span class="line">    rob_prev_two = <span class="number">0</span></span><br><span class="line">    rob_prev_one = nums[<span class="number">0</span>]</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># DP table calculations.</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(nums)):</span><br><span class="line">        current = <span class="built_in">max</span>(rob_prev_one, rob_prev_two + nums[i])</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># Update the variables</span></span><br><span class="line">        rob_prev_two = rob_prev_one</span><br><span class="line">        rob_prev_one = current</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> rob_prev_one</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rob</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(nums) == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> nums[<span class="number">0</span>]</span><br><span class="line">    </span><br><span class="line">    ans = [nums[<span class="number">0</span>], <span class="built_in">max</span>(nums[<span class="number">0</span>], nums[<span class="number">1</span>])]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, <span class="built_in">len</span>(nums)):</span><br><span class="line">        ans.append(<span class="built_in">max</span>(nums[i] + ans[i-<span class="number">2</span>], ans[i-<span class="number">1</span>]))</span><br><span class="line">    <span class="keyword">return</span> ans[-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>70. Climbing Stairs</summary>
> Since the `i`th stairs can be reached either from the `i-1`th stair or `i-2`th stair, so the number of ways is the sum of ways at `i-1`th stair and `i-2`th stair.
<p>Run time: $O(n)$, space: $O(n)$ or $O(1)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">climbStairs</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">    a, b = <span class="number">1</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        a, b = b, a + b</span><br><span class="line">    <span class="keyword">return</span> a</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">climbStairs</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">    <span class="keyword">if</span> n &lt;= <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">    ans = [<span class="number">1</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n+<span class="number">1</span>)]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, n+<span class="number">1</span>):</span><br><span class="line">        ans[i] = ans[i-<span class="number">1</span>] + ans[i-<span class="number">2</span>]</span><br><span class="line">    <span class="keyword">return</span> ans[n]</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>1048. Longest String Chain</summary>
<blockquote>
<p>Store the word and the length of longest chain in a dictionary. For each word in the sorted list by length, first initialize the length to be 1, then loop through each char and form substring by removing it. If this substring is in the dictionary, update the key of this word, and update the final result.</p>
</blockquote>
<p>Run time: $O(n\log n)+O(NSS)$, where word length $S\leq 16$, space: $O(NS)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">longestStrChain</span>(<span class="params">self, words: <span class="type">List</span>[<span class="built_in">str</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">    dp = &#123;&#125;</span><br><span class="line">    result = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> word <span class="keyword">in</span> <span class="built_in">sorted</span>(words, key=<span class="built_in">len</span>):</span><br><span class="line">        dp[word] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(word)):</span><br><span class="line">            prev = word[:i] + word[i + <span class="number">1</span>:]</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> prev <span class="keyword">in</span> dp:</span><br><span class="line">                dp[word] = <span class="built_in">max</span>(dp[prev] + <span class="number">1</span>, dp[word])</span><br><span class="line">                result = <span class="built_in">max</span>(result, dp[word])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
</details>
<h1>DP coord + connected</h1>
<h2 id="DP-sliding-array-memory-search">DP sliding array + memory search</h2>
<h2 id="DP-interval-backpack">DP interval + backpack</h2>
<h1>Tree</h1>
<details>
<summary>[Recursively delete leave nodes in a multi-tree](https://leetcode.com/discuss/interview-question/1693416/google-onsite-recursively-delete-leave-nodes-in-a-multi-tree)</summary>
<blockquote>
<p>Did you consider Topological sort kind of solution? i.e. Kahn’s algo?<br>
I think, from a first glance, that you could construct another adj list that shows the parents per node, not the children (that is O(n)).<br>
such list will be something like this:<br>
1:[]<br>
2:[1]<br>
5:[1]<br>
3:[1]<br>
7:[2]<br>
4:[2]<br>
8:[4]<br>
9:[5]</p>
</blockquote>
<p>You also save a dict with the number of children each node has. Something like this<br>
1:3<br>
2:2<br>
3:0<br>
4:1<br>
5:1<br>
7:0<br>
8:0<br>
9:0</p>
<p>You construct a queue with all nodes that don’t have parents (i.e. leaves). Those with length zero<br>
Per node you pop from Q, you write its value to answer, but you also make sure to reduce 1 from it from the parents num of children. So if we just handled node 9, that is a leaf, we know that its parent is 5. So we go to 5 and see it has 1 children. We reduce 1, to 0, If the num of children is now zero, we add 5 to the queue…</p>
<p>That way we peal the onion layer by layer, and it’s O(N) for building the special structures, and O(N) in building the answer.</p>
<p>Run time: $O(n)$, space: $O(n)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">remove_leaves</span>(<span class="params">self, root</span>):</span></span><br><span class="line">    nodes_with_the_same_depth = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">node</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        current_height = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> child <span class="keyword">in</span> node.children:</span><br><span class="line">            current_height = <span class="built_in">max</span>(current_height, dfs(child) + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(nodes_with_the_same_depth) == current_height - <span class="number">1</span>:</span><br><span class="line">            nodes_with_the_same_depth.append([])</span><br><span class="line">        nodes_with_the_same_depth[current_height-<span class="number">1</span>].append(node.val)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> current_height</span><br><span class="line"></span><br><span class="line">    dfs(root)</span><br><span class="line">    ans = []</span><br><span class="line">    <span class="keyword">for</span> nodes <span class="keyword">in</span> nodes_with_the_same_depth:</span><br><span class="line">        ans.extend(nodes)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
</details>
<h2 id="Binary-Tree-Divide-Conquer">Binary Tree / Divide &amp; Conquer</h2>
<details>
<summary></summary>
> 
<p>Run time: $O()$, space: $O()$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>[Print BST leaves in alternate order](https://leetcode.com/discuss/interview-question/615526/Google-or-Phone-or-Print-BST-leaves-in-alternate-order)</summary>
> 
<p>Run time: $O(n)$, space: $O(\log n)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">insert_left</span>(<span class="params">node, stack</span>):</span></span><br><span class="line">      <span class="keyword">while</span> node:</span><br><span class="line">            stack.append(node)</span><br><span class="line">            node = node.left</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">insert_right</span>(<span class="params">node, stack</span>):</span></span><br><span class="line">      <span class="keyword">while</span> node:</span><br><span class="line">             stack.append(node)</span><br><span class="line">             node = node.right</span><br><span class="line"></span><br><span class="line">stack_left = stack()</span><br><span class="line">stack_right = stack()</span><br><span class="line">insert_left(root, stack_left)</span><br><span class="line">insert_right(root, stack_right)</span><br><span class="line"></span><br><span class="line">reverse = <span class="literal">False</span></span><br><span class="line"><span class="comment"># not sure about this condition</span></span><br><span class="line"><span class="keyword">while</span> stack_left <span class="keyword">and</span> stack_right:</span><br><span class="line">       <span class="keyword">if</span> reverse:</span><br><span class="line">             node =stack_right.pop()</span><br><span class="line">             insert_right(node.left)</span><br><span class="line">      <span class="keyword">else</span>:</span><br><span class="line">            node =stack_left.pop()</span><br><span class="line">            insert_left(node.right)</span><br><span class="line">       <span class="keyword">if</span> is_leaf(node):</span><br><span class="line">            reverse = <span class="keyword">not</span> reverse</span><br><span class="line">            <span class="built_in">print</span>(node.val)</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>104. Maximum Depth of Binary Tree</summary>
<blockquote></blockquote>
<p>Run time: $O(n)$, space: $O(1)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">maxDepth</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    left = self.maxDepth(root.left)</span><br><span class="line">    right = self.maxDepth(root.right)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>(left, right)+<span class="number">1</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxDepth</span>(<span class="params">self, root</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        queue = [root]</span><br><span class="line">        depth = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            depth += <span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(queue)):</span><br><span class="line">                cur_root = queue.pop(<span class="number">0</span>)</span><br><span class="line">                <span class="keyword">if</span> cur_root.left:</span><br><span class="line">                    queue.append(cur_root.left)</span><br><span class="line">                <span class="keyword">if</span> cur_root.right:</span><br><span class="line">                    queue.append(cur_root.right)</span><br><span class="line">        <span class="keyword">return</span> depth</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>652. Find Duplicate Subtrees</summary>
<blockquote>
<p>Use a map to keep track of the &lt;current node val+left val+right val, &lt;occurrence, current node&gt;&gt;. Then we loop through the values, if occurrence is greater than 1, then we append node to the output array.<br>
<a target="_blank" rel="noopener" href="https://leetcode.com/problems/find-duplicate-subtrees/discuss/106020/Python-easy-understand-solution">https://leetcode.com/problems/find-duplicate-subtrees/discuss/106020/Python-easy-understand-solution</a></p>
</blockquote>
<p>Run time: $O(n)$, space: $O(n)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findDuplicateSubtrees</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="type">Optional</span>[TreeNode]]:</span></span><br><span class="line">    <span class="comment"># Concept - We can use a hashmap to store the all the trees and their roots</span></span><br><span class="line">    <span class="comment"># Also advantage of using hashmap is you can easily find for the repeated</span></span><br><span class="line">    <span class="comment"># or duplicate trees</span></span><br><span class="line">    hashmap = &#123;&#125;</span><br><span class="line">    res = []</span><br><span class="line">    self.solve(root, hashmap)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Once the hashmap is built, we can just travserse through the values </span></span><br><span class="line">    <span class="comment"># and find out the values that are greater than 1 are repeated</span></span><br><span class="line">    <span class="keyword">for</span> val, node <span class="keyword">in</span> hashmap.values():</span><br><span class="line">        <span class="keyword">if</span> val &gt; <span class="number">1</span>:</span><br><span class="line">            res.append(node)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">solve</span>(<span class="params">self, root, hashmap</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;X&#x27;</span></span><br><span class="line">    </span><br><span class="line">    a = self.solve(root.left, hashmap)</span><br><span class="line">    b = self.solve(root.right, hashmap)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Pre-order tree representation for storing the tree</span></span><br><span class="line">    temp = <span class="built_in">str</span>(root.val) + <span class="string">&#x27; &#x27;</span> + a + <span class="string">&#x27; &#x27;</span> + b</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Check if it is already in hashmap</span></span><br><span class="line">    <span class="keyword">if</span> temp <span class="keyword">not</span> <span class="keyword">in</span> hashmap:</span><br><span class="line">        hashmap[temp] = [<span class="number">1</span>, root]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        hashmap[temp][<span class="number">0</span>] += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> temp</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>572. Subtree of Another Tree</summary>
<blockquote>
<p>DFS. Recursion.</p>
</blockquote>
<p>Run time: $O(n)$, space: $O(1)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isSubtree</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode], subRoot: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">s, t</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> s <span class="keyword">and</span> <span class="keyword">not</span> t: <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> s <span class="keyword">or</span> <span class="keyword">not</span> t: <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> s.val == t.val <span class="keyword">and</span> dfs(s.left, t.left) <span class="keyword">and</span> dfs(s.right, t.right)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root: </span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">if</span> root.val == subRoot.val <span class="keyword">and</span> dfs(root, subRoot): </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">return</span> self.isSubtree(root.left, subRoot) <span class="keyword">or</span> \</span><br><span class="line">           self.isSubtree(root.right, subRoot)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Use queue.</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isSubtree</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode], subRoot: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">n, t</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> n <span class="keyword">and</span> <span class="keyword">not</span> t: <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> n <span class="keyword">or</span> <span class="keyword">not</span> t: <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> n.val == t.val <span class="keyword">and</span> \</span><br><span class="line">               dfs(n.left, t.left) <span class="keyword">and</span> \</span><br><span class="line">               dfs(n.right, t.right)</span><br><span class="line"></span><br><span class="line">    queue = [root]</span><br><span class="line">    <span class="keyword">while</span> queue:</span><br><span class="line">        n = queue.pop(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">if</span> n.val == subRoot.val <span class="keyword">and</span> dfs(n, subRoot): </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">if</span> n.left: </span><br><span class="line">            queue.append(n.left)</span><br><span class="line">        <span class="keyword">if</span> n.right: </span><br><span class="line">            queue.append(n.right)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>111. Minimum Depth of Binary Tree</summary>
<blockquote>
<p>Recursion, DFS.</p>
</blockquote>
<p>Run time: $O(n)$, space: $O(n)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">minDepth</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root.left:</span><br><span class="line">        <span class="keyword">return</span> self.minDepth(root.right) +<span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root.right:</span><br><span class="line">        <span class="keyword">return</span> self.minDepth(root.left) +<span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">min</span>(self.minDepth(root.right) +<span class="number">1</span>, self.minDepth(root.left) +<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Iterative, BFS. The first leaf node is the min depth.</p>
</blockquote>
<p>Run time: $O(n)$, space: $O(n)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">minDepth</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">    visit_queue = deque([(root, <span class="number">1</span>)])</span><br><span class="line">    <span class="keyword">while</span> <span class="built_in">len</span>(visit_queue) != <span class="number">0</span>:</span><br><span class="line">        <span class="comment"># BFS Traversal</span></span><br><span class="line">        next_visit, cur_depth =visit_queue.popleft()</span><br><span class="line">        <span class="keyword">if</span> next_visit <span class="keyword">is</span> <span class="literal">None</span>: <span class="comment"># empty node or empty tree</span></span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">if</span> next_visit.left <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">and</span> next_visit.right <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="comment"># reach a leaf node</span></span><br><span class="line">            <span class="comment"># get the minimal depth of binary tree, early return</span></span><br><span class="line">            <span class="keyword">return</span> cur_depth</span><br><span class="line">        <span class="comment">#append left and right child into visit_queue, increase current depth by 1</span></span><br><span class="line">        visit_queue.append( (next_visit.left, cur_depth+<span class="number">1</span>) )</span><br><span class="line">        visit_queue.append( (next_visit.right, cur_depth + <span class="number">1</span>) )</span><br><span class="line"></span><br><span class="line">    <span class="comment"># depth 0 for empty-tree</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>173. Binary Search Tree Iterator</summary>
<blockquote>
<p>Push all left nodes to the stack. Once a node is popped from the stack, push its right node back to the stack, and return its value.</p>
</blockquote>
<p>Run time: $O(1)$, space: $O(\log n)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BSTIterator</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>):</span></span><br><span class="line">        self.stack = []</span><br><span class="line">        self.pushAll(root)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">next</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        tmpNode = self.stack.pop()</span><br><span class="line">        self.pushAll(tmpNode.right)</span><br><span class="line">        <span class="keyword">return</span> tmpNode.val</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hasNext</span>(<span class="params">self</span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.stack</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pushAll</span>(<span class="params">self, node</span>):</span></span><br><span class="line">        <span class="keyword">while</span> node:</span><br><span class="line">            self.stack.append(node)</span><br><span class="line">            node = node.left</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Flatten the BST and use a pointer for index.</p>
</blockquote>
<p>Run time: $O(1)$, space: $O(n)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BSTIterator</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>):</span></span><br><span class="line">        self.arr = []</span><br><span class="line">        self.ind = -<span class="number">1</span></span><br><span class="line">        self._inorder(root)</span><br><span class="line">            </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_inorder</span>(<span class="params">self, root</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        self._inorder(root.left)</span><br><span class="line">        self.arr.append(root.val)</span><br><span class="line">        self._inorder(root.right)</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">next</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.hasNext():</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        self.ind += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> self.arr[self.ind]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hasNext</span>(<span class="params">self</span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.ind+<span class="number">1</span> &lt; <span class="built_in">len</span>(self.arr)</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>199. Binary Tree Right Side View</summary>
<blockquote>
<p>DFS, Recursion.</p>
</blockquote>
<p>Run time: $O(n)$, space: $O(n)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rightSideView</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span></span><br><span class="line">    self.ans = []</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span>(<span class="params">node, level</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">if</span> level &gt;= <span class="built_in">len</span>(self.ans):</span><br><span class="line">            self.ans.append(node.val)</span><br><span class="line"></span><br><span class="line">        helper(node.right, level+<span class="number">1</span>)</span><br><span class="line">        helper(node.left, level+<span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line">    helper(root, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> self.ans</span><br></pre></td></tr></table></figure>
<blockquote>
<p>BFS, iterative.</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rightSideView</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span></span><br><span class="line">    view = []</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line">    </span><br><span class="line">    q = collections.deque()</span><br><span class="line">    q.append((root, <span class="number">0</span>))</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> q:</span><br><span class="line">        curr, level = q.popleft()</span><br><span class="line">        <span class="keyword">if</span> level == <span class="number">0</span> <span class="keyword">or</span> <span class="keyword">not</span> q <span class="keyword">or</span> q[<span class="number">0</span>][<span class="number">1</span>] &gt; level:</span><br><span class="line">            view.append(curr.val)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> curr.left:</span><br><span class="line">            q.append((curr.left, level + <span class="number">1</span>))</span><br><span class="line">        <span class="keyword">if</span> curr.right:</span><br><span class="line">            q.append((curr.right, level + <span class="number">1</span>))</span><br><span class="line">    <span class="keyword">return</span> view</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>987. Vertical Order Traversal of a Binary Tree</summary>
<blockquote>
<p>Use defaultdict instead of normal dict to get rid of key not exist case. Put &lt;level, value&gt; as value into the dictionary, use placement as key. In the end sort placement, and sort the level.</p>
</blockquote>
<p>Run time: $O(n\log n)$, space: $O()$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">verticalTraversal</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span>(<span class="params">placement, level, node, dic</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        dic[placement].append((level, node.val))</span><br><span class="line">        helper(placement-<span class="number">1</span>, level+<span class="number">1</span>, node.left, dic)</span><br><span class="line">        helper(placement+<span class="number">1</span>, level+<span class="number">1</span>, node.right, dic)</span><br><span class="line">        </span><br><span class="line">    dic = defaultdict(<span class="built_in">list</span>)</span><br><span class="line">    helper(<span class="number">0</span>,<span class="number">0</span>,root,dic)</span><br><span class="line">    res = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">sorted</span>(dic.keys()):</span><br><span class="line">        temp = []</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">sorted</span>(dic[i]):</span><br><span class="line">            temp.append(j[<span class="number">1</span>])</span><br><span class="line">        res.append(temp)</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>938. Range Sum of BST</summary>
<blockquote>
<p>Recursion. Need to check if strictly less than or greater than the range, then call helper function recursively.</p>
</blockquote>
<p>Run time: $O(n)$, space: $O(n)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rangeSumBST</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode], low: <span class="built_in">int</span>, high: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">    self.rangeSum = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span>(<span class="params">node, lo, hi</span>):</span></span><br><span class="line">        <span class="keyword">if</span> node:</span><br><span class="line">            <span class="keyword">if</span> lo &lt;= node.val &lt;= hi:</span><br><span class="line">                self.rangeSum += node.val</span><br><span class="line">            <span class="keyword">if</span> lo &lt; node.val:</span><br><span class="line">                    helper(node.left, lo, hi)</span><br><span class="line">            <span class="keyword">if</span> node.val &lt; hi:</span><br><span class="line">                helper(node.right, lo, hi)</span><br><span class="line">            </span><br><span class="line">    helper(root, low, high)</span><br><span class="line">    <span class="keyword">return</span> self.rangeSum</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Iterative</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rangeSumBST</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode], low: <span class="built_in">int</span>, high: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">    ans = <span class="number">0</span></span><br><span class="line">    stack = [root]</span><br><span class="line">    <span class="keyword">while</span> stack:</span><br><span class="line">        node = stack.pop()</span><br><span class="line">        <span class="keyword">if</span> node:</span><br><span class="line">            <span class="keyword">if</span> L &lt;= node.val &lt;= R:</span><br><span class="line">                ans += node.val</span><br><span class="line">            <span class="keyword">if</span> L &lt; node.val:</span><br><span class="line">                stack.append(node.left)</span><br><span class="line">            <span class="keyword">if</span> node.val &lt; R:</span><br><span class="line">                stack.append(node.right)</span><br><span class="line">    <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>426. Convert Binary Search Tree to Sorted Doubly Linked List</summary>
<blockquote>
<p>Recursion</p>
</blockquote>
<p>Run time: $O(n)$, space: $O(n)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">treeToDoublyList</span>(<span class="params">self, root: <span class="string">&#x27;Optional[Node]&#x27;</span></span>) -&gt; &#x27;<span class="type">Optional</span>[Node]&#x27;:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span>(<span class="params">node</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Performs standard inorder traversal:</span></span><br><span class="line"><span class="string">        left -&gt; node -&gt; right</span></span><br><span class="line"><span class="string">        and links all nodes into DLL</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> node:</span><br><span class="line">            <span class="comment"># left</span></span><br><span class="line">            helper(node.left)</span><br><span class="line">            <span class="comment"># node </span></span><br><span class="line">            <span class="keyword">if</span> self.last:</span><br><span class="line">                <span class="comment"># link the previous node (last)</span></span><br><span class="line">                <span class="comment"># with the current one (node)</span></span><br><span class="line">                self.last.right = node</span><br><span class="line">                node.left = self.last</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># keep the smallest node</span></span><br><span class="line">                <span class="comment"># to close DLL later on</span></span><br><span class="line">                self.first = node        </span><br><span class="line">            self.last = node</span><br><span class="line">            <span class="comment"># right</span></span><br><span class="line">            helper(node.right)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># the smallest (first) and the largest (last) nodes</span></span><br><span class="line">    self.first, self.last = <span class="literal">None</span>, <span class="literal">None</span></span><br><span class="line">    helper(root)</span><br><span class="line">    <span class="comment"># close DLL</span></span><br><span class="line">    self.last.right = self.first</span><br><span class="line">    self.first.left = self.last</span><br><span class="line">    <span class="keyword">return</span> self.first</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>1110. Delete Nodes And Return Forest</summary>
<blockquote>
<p>DFS.</p>
</blockquote>
<p>Run time: $O(n)$, space: $O(n)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">delNodes</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode], to_delete: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[TreeNode]:</span></span><br><span class="line">      ans = []</span><br><span class="line">      to_delete = <span class="built_in">set</span>(to_delete)</span><br><span class="line">      </span><br><span class="line">      <span class="function"><span class="keyword">def</span> <span class="title">helper</span>(<span class="params">node</span>):</span></span><br><span class="line">          <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">              <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">          node.left = helper(node.left)</span><br><span class="line">          node.right = helper(node.right)</span><br><span class="line">	</span><br><span class="line">	<span class="comment"># add children of a node that is to be deleted</span></span><br><span class="line">          <span class="keyword">if</span> node.val <span class="keyword">in</span> to_delete:</span><br><span class="line">              <span class="keyword">if</span> node.left: </span><br><span class="line">                  ans.append(node.left)</span><br><span class="line">              <span class="keyword">if</span> node.right:</span><br><span class="line">                  ans.append(node.right)</span><br><span class="line">              <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">          <span class="keyword">return</span> node</span><br><span class="line">              </span><br><span class="line">      helper(root)</span><br><span class="line"><span class="comment"># if root is not to be deleted then add it</span></span><br><span class="line">      <span class="keyword">if</span> root.val <span class="keyword">not</span> <span class="keyword">in</span> to_delete:</span><br><span class="line">          ans.append(root)</span><br><span class="line">      <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<blockquote>
<p>BFS.</p>
</blockquote>
<p>Run time: $O(n)$, space: $O(n)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delNodes</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode], to_delete: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[TreeNode]:</span></span><br><span class="line">    output = []</span><br><span class="line">    to_delete_set = <span class="built_in">set</span>(to_delete)</span><br><span class="line">    tree_queue = [root]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> tree_queue:</span><br><span class="line">        curr_tree = tree_queue.pop(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> curr_tree:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">if</span> curr_tree.val <span class="keyword">in</span> to_delete_set:</span><br><span class="line">            tree_queue.append(curr_tree.left)</span><br><span class="line">            tree_queue.append(curr_tree.right)</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        </span><br><span class="line">        node_queue = [curr_tree]</span><br><span class="line">        <span class="keyword">while</span> node_queue:</span><br><span class="line">            curr_node = node_queue.pop(<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> curr_node:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> curr_node.left <span class="keyword">and</span> curr_node.left.val <span class="keyword">in</span> to_delete_set:</span><br><span class="line">                tree_queue.append(curr_node.left.left)</span><br><span class="line">                tree_queue.append(curr_node.left.right)</span><br><span class="line">                curr_node.left = <span class="literal">None</span></span><br><span class="line">            <span class="keyword">if</span> curr_node.right <span class="keyword">and</span> curr_node.right.val <span class="keyword">in</span> to_delete_set:</span><br><span class="line">                tree_queue.append(curr_node.right.left)</span><br><span class="line">                tree_queue.append(curr_node.right.right)</span><br><span class="line">                curr_node.right = <span class="literal">None</span></span><br><span class="line">                </span><br><span class="line">            node_queue.append(curr_node.left)</span><br><span class="line">            node_queue.append(curr_node.right)</span><br><span class="line">            </span><br><span class="line">        output.append(curr_tree)</span><br><span class="line">    <span class="keyword">return</span> output</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>235. Lowest Common Ancestor of a Binary Search Tree</summary>
<blockquote>
<p>Recursion. Since the input tree is a binary search tree, we can utilize the property and determine the LCA. If both p and q values are smaller or greater than the current node val, we know that the LCA could be further reduced.</p>
</blockquote>
<p>Run time: $O(n)$, space: $O(n)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lowestCommonAncestor</span>(<span class="params">self, root: <span class="string">&#x27;TreeNode&#x27;</span>, p: <span class="string">&#x27;TreeNode&#x27;</span>, q: <span class="string">&#x27;TreeNode&#x27;</span></span>) -&gt; &#x27;TreeNode&#x27;:</span></span><br><span class="line">    <span class="keyword">if</span> root.val &lt; p.val <span class="keyword">and</span> root.val &lt; q.val:</span><br><span class="line">        <span class="keyword">return</span> self.lowestCommonAncestor(root.right, p, q)</span><br><span class="line">    <span class="keyword">elif</span> root.val &gt; p.val <span class="keyword">and</span> root.val &gt; q.val:</span><br><span class="line">        <span class="keyword">return</span> self.lowestCommonAncestor(root.left, p, q)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Iterative.</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lowestCommonAncestor</span>(<span class="params">self, root: <span class="string">&#x27;TreeNode&#x27;</span>, p: <span class="string">&#x27;TreeNode&#x27;</span>, q: <span class="string">&#x27;TreeNode&#x27;</span></span>) -&gt; &#x27;TreeNode&#x27;:</span></span><br><span class="line">    node = root</span><br><span class="line">    <span class="keyword">while</span> node:</span><br><span class="line">        <span class="keyword">if</span> node.val &lt; p.val <span class="keyword">and</span> node.val &lt; q.val:</span><br><span class="line">            node = node.right</span><br><span class="line">        <span class="keyword">elif</span> node.val &gt; p.val <span class="keyword">and</span> node.val &gt; q.val:</span><br><span class="line">            node = node.left</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> node</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>637. Average of Levels in Binary Tree</summary>
> DFS. Create a list of list where the index is the height. If the current node height is greater than or equal to the output array length, then append an empty array. Then access the array at index height and append the value. Use list comprehension to get the average for each list.
<p>Run time: $O(n)$, space: $O(n)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">averageOfLevels</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="built_in">float</span>]:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getH</span>(<span class="params">node, height</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">if</span> height &gt;= <span class="built_in">len</span>(self.ans):</span><br><span class="line">            self.ans.append([])</span><br><span class="line">        self.ans[height].append(node.val)</span><br><span class="line">        getH(node.left, height+<span class="number">1</span>)</span><br><span class="line">        getH(node.right, height+<span class="number">1</span>)</span><br><span class="line">        </span><br><span class="line">    self.ans = []</span><br><span class="line">    getH(root, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> [<span class="built_in">sum</span>(s)/<span class="built_in">len</span>(s) <span class="keyword">for</span> s <span class="keyword">in</span> self.ans]</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>450. Delete Node in a BST</summary>
> There are three possible situations here :
- Node is a leaf, and one could delete it straightforward : node = null.
- Node is not a leaf and has a right child. Then the node could be replaced by its successor which is somewhere lower in the right subtree. Then one could proceed down recursively to delete the successor.
- Node is not a leaf, has no right child and has a left child. That means that its successor is somewhere upper in the tree but we don't want to go back. Let's use the predecessor here which is somewhere lower in the left subtree. The node could be replaced by its predecessor and then one could proceed down recursively to delete the predecessor.
<p>Run time: $O(\log n)$, space: $O(h)$, where $h$ is the tree height, when $h=\log n$, it is a balanced tree.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">deleteNode</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode], key: <span class="built_in">int</span></span>) -&gt; <span class="type">Optional</span>[TreeNode]:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">successor</span>(<span class="params">root</span>):</span></span><br><span class="line">        root = root.right</span><br><span class="line">        <span class="keyword">while</span> root.left:</span><br><span class="line">            root = root.left</span><br><span class="line">        <span class="keyword">return</span> root.val</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">predecessor</span>(<span class="params">root</span>):</span></span><br><span class="line">        root = root.left</span><br><span class="line">        <span class="keyword">while</span> root.right:</span><br><span class="line">            root = root.right</span><br><span class="line">        <span class="keyword">return</span> root.val</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">        <span class="keyword">return</span> root</span><br><span class="line">    <span class="keyword">if</span> root.val &gt; key:</span><br><span class="line">        root.left = self.deleteNode(root.left, key)</span><br><span class="line">    <span class="keyword">elif</span> root.val &lt; key:</span><br><span class="line">        root.right = self.deleteNode(root.right, key)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root.left <span class="keyword">and</span> <span class="keyword">not</span> root.right:</span><br><span class="line">            root = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">elif</span> root.right:</span><br><span class="line">            root.val = successor(root)</span><br><span class="line">            root.right = self.deleteNode(root.right, root.val)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            root.val = predecessor(root)</span><br><span class="line">            root.left = self.deleteNode(root.left, root.val)</span><br><span class="line">            </span><br><span class="line">    <span class="keyword">return</span> root</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>328. Odd Even Linked List</summary>
<blockquote>
<p>Put the odd nodes in a linked list and the even nodes in another. Then link the evenList to the tail of the oddList.</p>
</blockquote>
<p>Run time: $O(n)$, space: $O(1)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">oddEvenList</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span></span><br><span class="line">    d1 = odd = ListNode(<span class="number">0</span>)</span><br><span class="line">    d2 = even = ListNode(<span class="number">0</span>)</span><br><span class="line">    i = <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> head:</span><br><span class="line">        <span class="keyword">if</span> i%<span class="number">2</span>:</span><br><span class="line">            odd.<span class="built_in">next</span>, odd = head,head</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            even.<span class="built_in">next</span>, even = head,head</span><br><span class="line">        head = head.<span class="built_in">next</span></span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">    odd.<span class="built_in">next</span>, even.<span class="built_in">next</span> = d2.<span class="built_in">next</span>,<span class="literal">None</span></span><br><span class="line">    <span class="keyword">return</span> d1.<span class="built_in">next</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">oddEvenList</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> head:</span><br><span class="line">        <span class="keyword">return</span> head</span><br><span class="line">    odd = head</span><br><span class="line">    even = head.<span class="built_in">next</span></span><br><span class="line">    evenHead = even</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> even <span class="keyword">and</span> even.<span class="built_in">next</span>:</span><br><span class="line">        odd.<span class="built_in">next</span> = even.<span class="built_in">next</span></span><br><span class="line">        odd = odd.<span class="built_in">next</span></span><br><span class="line">        even.<span class="built_in">next</span> = odd.<span class="built_in">next</span></span><br><span class="line">        even = even.<span class="built_in">next</span></span><br><span class="line">    odd.<span class="built_in">next</span> = evenHead</span><br><span class="line">    <span class="keyword">return</span> head</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>101. Symmetric Tree</summary>
<blockquote>
<p>Iterative. Maintain a queue and pop two elements at a time and compare, then append their child nodes pairs to the queue.</p>
</blockquote>
<p>Run time: $O(n)$, space: $O(n)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isSymmetric</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">    q = [root, root]</span><br><span class="line">    <span class="keyword">while</span> q:</span><br><span class="line">        n1 = q.pop()</span><br><span class="line">        n2 = q.pop()</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> n1 <span class="keyword">and</span> <span class="keyword">not</span> n2:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">elif</span> <span class="keyword">not</span> n1 <span class="keyword">or</span> <span class="keyword">not</span> n2:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">elif</span> n1.val != n2.val:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        q.append(n1.left)</span><br><span class="line">        q.append(n2.right)</span><br><span class="line">        q.append(n1.right)</span><br><span class="line">        q.append(n2.left)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>Recursion. Use a helper function to check whether the current two nodes have the same value, and check left==right and right==left.</p>
</blockquote>
<p>Run time: $O(n)$, space: $O(n)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isSymmetric</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span>(<span class="params">n1, n2</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> n1 <span class="keyword">and</span> <span class="keyword">not</span> n2:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">elif</span> <span class="keyword">not</span> n1 <span class="keyword">or</span> <span class="keyword">not</span> n2:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> n1.val == n2.val <span class="keyword">and</span> \</span><br><span class="line">               helper(n1.right, n2.left) <span class="keyword">and</span> \</span><br><span class="line">               helper(n1.left, n2.right)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> helper(root, root)</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>437. Path Sum III</summary>
<blockquote>
<p>Use a variable to track the current prefix sum and a hashmap “prefix sum -&gt; how many times was it seen so far”. Parse the input structure and count the requested subarrays/submatrices/tree paths along the way with the help of that hashmap. How to count?<br>
The logic is simple: the current prefix sum is curr_sum, and some elements before the prefix sum was curr_sum - target. All the elements in between sum up to curr_sum - (curr_sum - target) = target.</p>
</blockquote>
<p>Run time: $O(n)$, space: $O(n)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pathSum</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode], targetSum: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">preorder</span>(<span class="params">node: TreeNode, curr_sum</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        curr_sum += node.val</span><br><span class="line">        <span class="keyword">if</span> curr_sum == k:</span><br><span class="line">            self.count += <span class="number">1</span></span><br><span class="line">        self.count += h[curr_sum-k]</span><br><span class="line">        h[curr_sum] += <span class="number">1</span></span><br><span class="line">        preorder(node.left, curr_sum)</span><br><span class="line">        preorder(node.right, curr_sum)</span><br><span class="line">        </span><br><span class="line">    self.count = <span class="number">0</span></span><br><span class="line">    k = targetSum</span><br><span class="line">    h = defaultdict(<span class="built_in">int</span>)</span><br><span class="line">    preorder(root, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> self.count</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pathSum</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode], targetSum: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">    <span class="keyword">return</span> self.helper(root, targetSum, [targetSum])</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">helper</span>(<span class="params">self, node, origin, targets</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> node: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    hit = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> t <span class="keyword">in</span> targets:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> t-node.val: hit += <span class="number">1</span>                          <span class="comment"># count if sum == target</span></span><br><span class="line">    targets = [t-node.val <span class="keyword">for</span> t <span class="keyword">in</span> targets]+[origin]         <span class="comment"># update the targets</span></span><br><span class="line">    <span class="keyword">return</span> hit+self.helper(node.left, origin, targets)+self.helper(node.right, origin, targets)</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>543. Diameter of Binary Tree</summary>
<blockquote>
<p>we know that the longest path in the tree would consist of a node, its longest left branch, and its longest right branch. So, our algorithm to solve this problem will find the node where the sum of its longest left and right branches is maximized. This would hint at us to apply Depth-first search (DFS) to count each node’s branch lengths, because it would allow us to dive deep into the leaves first, and then start counting the edges upwards.</p>
</blockquote>
<p>Run time: $O(n)$, space: $O(n)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">diameterOfBinaryTree</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">    self.diameter = <span class="number">0</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longest</span>(<span class="params">node</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        left = longest(node.left)</span><br><span class="line">        right = longest(node.right)</span><br><span class="line">        </span><br><span class="line">        self.diameter = <span class="built_in">max</span>(self.diameter, left+right)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(left, right)+<span class="number">1</span></span><br><span class="line">   </span><br><span class="line">    longest(root)</span><br><span class="line">    <span class="keyword">return</span> self.diameter</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>110. Balanced Binary Tree</summary>
<blockquote>
<p>Bottom up. If node is None, return 0. Then check for its left and right child, if any of them returns -1, then it means the subtree is not balanced. Or if the difference is greater than 1, the subtree is also not balanced. In the end return 1 + max of left and right child.</p>
</blockquote>
<p>Run time: $O()$, space: $O()$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isBalanced</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">check</span>(<span class="params">root</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        left  = check(root.left)</span><br><span class="line">        right = check(root.right)</span><br><span class="line">        <span class="keyword">if</span> left == -<span class="number">1</span> <span class="keyword">or</span> right == -<span class="number">1</span> <span class="keyword">or</span> <span class="built_in">abs</span>(left - right) &gt; <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + <span class="built_in">max</span>(left, right)</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> check(root) != -<span class="number">1</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>if recursive calls before conditional check, then its bottom up. If recursive call after conditional check, its top down.</p>
</blockquote>
<p>Run time: $O(n\log n)$, space: $O(n)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isBalanced</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">height</span>(<span class="params">node</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(height(node.left), height(node.right))+<span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">abs</span>(height(root.left) - height(root.right)) &lt; <span class="number">2</span> \</span><br><span class="line">        <span class="keyword">and</span> self.isBalanced(root.left) \</span><br><span class="line">        <span class="keyword">and</span> self.isBalanced(root.right)</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>236. Lowest Common Ancestor of a Binary Tree</summary>
> Recursive solution, DFS
<p>Run time: $O(n)$, space: $O(h)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lowestCommonAncestor</span>(<span class="params">self, root, p, q</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    :type root: TreeNode</span></span><br><span class="line"><span class="string">    :type p: TreeNode</span></span><br><span class="line"><span class="string">    :type q: TreeNode</span></span><br><span class="line"><span class="string">    :rtype: TreeNode</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    <span class="keyword">if</span> p == root <span class="keyword">or</span> q == root:</span><br><span class="line">        <span class="keyword">return</span> root</span><br><span class="line">    left = self.lowestCommonAncestor(root.left, p, q)</span><br><span class="line">    right = self.lowestCommonAncestor(root.right, p, q)</span><br><span class="line">    <span class="keyword">if</span> left <span class="keyword">and</span> right:</span><br><span class="line">        <span class="keyword">return</span> root</span><br><span class="line">    <span class="keyword">elif</span> <span class="keyword">not</span> left:</span><br><span class="line">        <span class="keyword">return</span> right</span><br><span class="line">    <span class="keyword">elif</span> <span class="keyword">not</span> right:</span><br><span class="line">        <span class="keyword">return</span> left</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Iterative, BFS. Use a stack to keep track of each viewed node, and a parent dict to track a node’s parent. If <code>p</code> and <code>q</code> are not in the parent dict, keep popping from the stack, add to parent dict, and append to stack. Then we create a set called <code>ancestors</code>, keep finding p’s parent. Then find q’s parent until q is in the ancestors, then return q.</p>
</blockquote>
<p>Run time: $O(n)$, space: $O(h)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lowestCommonAncestor</span>(<span class="params">self, root, p, q</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    :type root: TreeNode</span></span><br><span class="line"><span class="string">    :type p: TreeNode</span></span><br><span class="line"><span class="string">    :type q: TreeNode</span></span><br><span class="line"><span class="string">    :rtype: TreeNode</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    stack = [root]</span><br><span class="line">    parent_dict = &#123;root: <span class="literal">None</span>&#125;</span><br><span class="line">    <span class="keyword">while</span> p <span class="keyword">not</span> <span class="keyword">in</span> parent_dict <span class="keyword">or</span> q <span class="keyword">not</span> <span class="keyword">in</span> parent_dict:</span><br><span class="line">        node = stack.pop()</span><br><span class="line">        <span class="keyword">if</span> node.left:</span><br><span class="line">            parent_dict[node.left] = node</span><br><span class="line">            stack.append(node.left)</span><br><span class="line">        <span class="keyword">if</span> node.right:</span><br><span class="line">            parent_dict[node.right] = node</span><br><span class="line">            stack.append(node.right)</span><br><span class="line">    </span><br><span class="line">    ancestors = <span class="built_in">set</span>()</span><br><span class="line">    <span class="keyword">while</span> p:</span><br><span class="line">        ancestors.add(p)</span><br><span class="line">        p = parent_dict[p]</span><br><span class="line">    <span class="keyword">while</span> q <span class="keyword">not</span> <span class="keyword">in</span> ancestors:</span><br><span class="line">        ancestors.add(q)</span><br><span class="line">        q = parent_dict[q]</span><br><span class="line">    <span class="keyword">return</span> q</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>1650. Lowest Common Ancestor of a Binary Tree III</summary>
> Use two pointers to keep track of the parents, until they point to the same node. When either of the pointers points to the root, i.e., parent is None, then set it to the other original node.
<p>Run time: $O(n)$, space: $O(1)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lowestCommonAncestor</span>(<span class="params">self, p, q</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    :type node: Node</span></span><br><span class="line"><span class="string">    :rtype: Node</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    p1, p2 = p, q</span><br><span class="line">    <span class="keyword">while</span> p1 != p2:</span><br><span class="line">        p1 =  p1.parent <span class="keyword">if</span> p1.parent <span class="keyword">else</span> q</span><br><span class="line">        p2 = p2.parent <span class="keyword">if</span> p2.parent <span class="keyword">else</span> p</span><br><span class="line">    <span class="keyword">return</span> p1</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>314. Binary Tree Vertical Order Traversal</summary>
> BFS, obtain the range of the column indices, walk through the column range [min_column, max_column] and retrieve the results accordingly.
<p>Run time: $O(n)$, space: $O(n)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">verticalOrder</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span></span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line"></span><br><span class="line">        columnTable = defaultdict(<span class="built_in">list</span>)</span><br><span class="line">        min_column = max_column = <span class="number">0</span></span><br><span class="line">        queue = deque([(root, <span class="number">0</span>)])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            node, column = queue.popleft()</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> node <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                columnTable[column].append(node.val)</span><br><span class="line">                min_column = <span class="built_in">min</span>(min_column, column)</span><br><span class="line">                max_column = <span class="built_in">max</span>(max_column, column)</span><br><span class="line"></span><br><span class="line">                queue.append((node.left, column - <span class="number">1</span>))</span><br><span class="line">                queue.append((node.right, column + <span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> [columnTable[x] <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(min_column, max_column + <span class="number">1</span>)]</span><br></pre></td></tr></table></figure>
<blockquote>
<p>BFS, store the current node in the answer, and if left/right child is not None, enqueue.</p>
</blockquote>
<p>Run time: $O(n \log n)$, space: $O(n)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">verticalOrder</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line">    </span><br><span class="line">    result = collections.defaultdict(<span class="built_in">list</span>)</span><br><span class="line">    queue = [(root, <span class="number">0</span>)]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> node, distance <span class="keyword">in</span> queue:</span><br><span class="line">        result[distance].append(node.val)</span><br><span class="line">        <span class="keyword">if</span> node.left:</span><br><span class="line">            queue.append((node.left, distance-<span class="number">1</span>))</span><br><span class="line">        <span class="keyword">if</span> node.right:</span><br><span class="line">            queue.append((node.right, distance+<span class="number">1</span>))</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> [order <span class="keyword">for</span> distance, order <span class="keyword">in</span> <span class="built_in">sorted</span>(result.items())]</span><br></pre></td></tr></table></figure>
<details>
<summary>my implementation</summary>
Run time: $O(n)$, space: $O(n)$
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">verticalOrder</span>(<span class="params">self, root</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: List[List[int]]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">helper</span>(<span class="params">node, level</span>):</span></span><br><span class="line">            <span class="keyword">if</span> node <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> node.left <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">if</span> level-<span class="number">1</span> <span class="keyword">not</span> <span class="keyword">in</span> d:</span><br><span class="line">                    d[level-<span class="number">1</span>] = []</span><br><span class="line">                d[level-<span class="number">1</span>].append(node.left.val)</span><br><span class="line">            <span class="keyword">if</span> node.right <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">if</span> level+<span class="number">1</span> <span class="keyword">not</span> <span class="keyword">in</span> d:</span><br><span class="line">                    d[level+<span class="number">1</span>] = []</span><br><span class="line">                d[level+<span class="number">1</span>].append(node.right.val)</span><br><span class="line">            helper(node.left, level-<span class="number">1</span>)</span><br><span class="line">            helper(node.right, level+<span class="number">1</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        d = &#123;&#125;</span><br><span class="line">        d[<span class="number">0</span>] = [root.val]</span><br><span class="line">        helper(root, <span class="number">0</span>)</span><br><span class="line">        </span><br><span class="line">        ans = []</span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">sorted</span>(d):</span><br><span class="line">            ans.append(d[k])</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
</details>
</details>
<h2 id="Trie">Trie</h2>
<details>
<summary></summary>
> 
<p>Run time: $O()$, space: $O()$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>208. Implement Trie (Prefix Tree)</summary>
<blockquote>
<p>Maintain a dictionary and keep adding empty entries if the character does not exist, and update the pointer to the key.</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Trie</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.trie = &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insert</span>(<span class="params">self, word: <span class="built_in">str</span></span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">        curr_d = self.trie</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> word:</span><br><span class="line">            <span class="keyword">if</span> c <span class="keyword">not</span> <span class="keyword">in</span> curr_d:</span><br><span class="line">                curr_d[c] = &#123;&#125;</span><br><span class="line">            curr_d = curr_d[c]</span><br><span class="line">        curr_d[<span class="string">&#x27;-&#x27;</span>] = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search</span>(<span class="params">self, word: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        curr_d = self.trie</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> word:</span><br><span class="line">            <span class="keyword">if</span> c <span class="keyword">not</span> <span class="keyword">in</span> curr_d:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            curr_d = curr_d[c]</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;-&#x27;</span> <span class="keyword">in</span> curr_d</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">startsWith</span>(<span class="params">self, prefix: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        curr_d = self.trie</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> prefix:</span><br><span class="line">            <span class="keyword">if</span> c <span class="keyword">not</span> <span class="keyword">in</span> curr_d:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            curr_d = curr_d[c]</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>
</details>
<h2 id="Segment-Tree">Segment Tree</h2>
<h1>String</h1>
<details>
<summary></summary>
> 
<p>Run time: $O()$, space: $O()$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>248. Strobogrammatic Number III</summary>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/strobogrammatic-number-iii/discuss/201185/python-DFS-solution">https://leetcode.com/problems/strobogrammatic-number-iii/discuss/201185/python-DFS-solution</a></p>
</blockquote>
<p>Run time: $O(n)$, space: $O(n)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">strobogrammaticInRange</span>(<span class="params">self, low: <span class="built_in">str</span>, high: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">    self.res = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> length <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(low), <span class="built_in">len</span>(high) + <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> d <span class="keyword">in</span> [<span class="string">&#x27;&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;8&#x27;</span>, <span class="string">&#x27;0&#x27;</span>]:</span><br><span class="line">            self.dfs(low, high, length, d)</span><br><span class="line">    <span class="keyword">return</span> self.res</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">self, low, high, length, path</span>):</span></span><br><span class="line">    leng = <span class="built_in">len</span>(path)</span><br><span class="line">    <span class="keyword">if</span> leng &gt; length: <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">if</span> leng == length:</span><br><span class="line">        <span class="keyword">if</span> leng != <span class="number">1</span> <span class="keyword">and</span> path[<span class="number">0</span>] == <span class="string">&#x27;0&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">elif</span> <span class="built_in">int</span>(low) &lt;= <span class="built_in">int</span>(path) &lt;= <span class="built_in">int</span>(high):</span><br><span class="line">            self.res += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">for</span> d <span class="keyword">in</span> [<span class="string">&#x27;00&#x27;</span>, <span class="string">&#x27;69&#x27;</span>, <span class="string">&#x27;96&#x27;</span>, <span class="string">&#x27;88&#x27;</span>, <span class="string">&#x27;11&#x27;</span>]:</span><br><span class="line">        self.dfs(low, high, length, d[<span class="number">0</span>] + path + d[<span class="number">1</span>])</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>8. String to Integer (atoi)</summary>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/string-to-integer-atoi/discuss/4673/60ms-python-solution-OJ-says-this-beats-100-python-submissions">https://leetcode.com/problems/string-to-integer-atoi/discuss/4673/60ms-python-solution-OJ-says-this-beats-100-python-submissions</a></p>
</blockquote>
<p>Run time: $O(n)$, space: $O(n)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">myAtoi</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">    MIN_NUM = -<span class="number">2</span> ** <span class="number">31</span></span><br><span class="line">    MAX_NUM = <span class="number">2</span> ** <span class="number">31</span> - <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># trim the leading white space first</span></span><br><span class="line">    s = s.strip()</span><br><span class="line">    sign = <span class="number">1</span></span><br><span class="line">    index = <span class="number">0</span></span><br><span class="line">    num = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> s:</span><br><span class="line">        <span class="keyword">return</span> num</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> s[<span class="number">0</span>] == <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">        sign = -<span class="number">1</span></span><br><span class="line">        index += <span class="number">1</span></span><br><span class="line">    <span class="keyword">elif</span> s[<span class="number">0</span>] == <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">        index += <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> index &lt; <span class="built_in">len</span>(s) <span class="keyword">and</span> s[index].isdigit():</span><br><span class="line">        curr_digit = <span class="built_in">ord</span>(s[index]) - <span class="built_in">ord</span>(<span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> num &gt; MAX_NUM // <span class="number">10</span> <span class="keyword">or</span> (num == MAX_NUM // <span class="number">10</span> <span class="keyword">and</span> curr_digit &gt; <span class="number">7</span>): <span class="comment"># here we do the check before adding current digit</span></span><br><span class="line">            <span class="keyword">if</span> sign == <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> MAX_NUM  </span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> MIN_NUM</span><br><span class="line">        num = num * <span class="number">10</span> + curr_digit</span><br><span class="line">        index += <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    num = sign * num</span><br><span class="line">    <span class="keyword">return</span> num</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>388.  Longest Absolute File Path</summary>
<blockquote>
<p>Split the input by new line using <code>input.splitlines()</code>, then use <code>lstrip('\t')</code> to remove the new tabs on its left. This would be the directory or file name. If the name contains a dot, then it is a file, and we could update the max length using the current depth plus the length of name. The number of tabs represents the depth of a file. If it is not a file, we put the depth+1 as the key, get the current depth level, add name length and add 1 as the backslash in the file path.</p>
</blockquote>
<p>Run time: $O(n)$, space: $O(n)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lengthLongestPath</span>(<span class="params">self, <span class="built_in">input</span>: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">    maxlen = <span class="number">0</span></span><br><span class="line">    pathlen = &#123;<span class="number">0</span>:<span class="number">0</span>&#125;</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> <span class="built_in">input</span>.splitlines():</span><br><span class="line">        name = line.lstrip(<span class="string">&#x27;\t&#x27;</span>)</span><br><span class="line">        depth = <span class="built_in">len</span>(line)-<span class="built_in">len</span>(name)</span><br><span class="line">        <span class="keyword">if</span> <span class="string">&#x27;.&#x27;</span> <span class="keyword">in</span> name:</span><br><span class="line">            maxlen = <span class="built_in">max</span>(maxlen, pathlen[depth] + <span class="built_in">len</span>(name))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            pathlen[depth+<span class="number">1</span>] = pathlen[depth] + <span class="built_in">len</span>(name) + <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> maxlen</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>418. Sentence Screen Fitting</summary>
<blockquote>
<p>Pre-calculation. Not like DP.<br>
<a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=kFBbZolQYdI">https://www.youtube.com/watch?v=kFBbZolQYdI</a></p>
</blockquote>
<p>Run time: $O(n)$, space: $O(n)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">wordsTyping</span>(<span class="params">self, sentence: <span class="type">List</span>[<span class="built_in">str</span>], rows: <span class="built_in">int</span>, cols: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">n = <span class="built_in">len</span>(sentence)</span><br><span class="line">next_index = [<span class="number">0</span>]*n</span><br><span class="line">times = [<span class="number">0</span>]*n</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">	cur_i = i</span><br><span class="line">	loop = <span class="number">0</span></span><br><span class="line">	cur_len = <span class="number">0</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span> cur_len + <span class="built_in">len</span>(sentence[cur_i]) &lt; cols:</span><br><span class="line">		cur_len += <span class="built_in">len</span>(sentence[cur_i])</span><br><span class="line">		cur_i += <span class="number">1</span></span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span> cur_i == n:</span><br><span class="line">			loop += <span class="number">1</span></span><br><span class="line">			cur_i = <span class="number">0</span></span><br><span class="line">	next_index[i] = cur_i</span><br><span class="line">	times[i] = loop</span><br><span class="line">ans = <span class="number">0</span></span><br><span class="line">word_index = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(rows):</span><br><span class="line">	ans += times[word_index]</span><br><span class="line">	word_index = next_index[word_index]</span><br><span class="line"><span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/sentence-screen-fitting/discuss/1638021/python-solution">https://leetcode.com/problems/sentence-screen-fitting/discuss/1638021/python-solution</a></p>
</blockquote>
<p>Run time: $O(rows)$, space: $O(1)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">wordsTyping</span>(<span class="params">self, sentence: <span class="type">List</span>[<span class="built_in">str</span>], rows: <span class="built_in">int</span>, cols: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">    s = <span class="string">&#x27; &#x27;</span>.join(sentence) + <span class="string">&#x27; &#x27;</span></span><br><span class="line">    l = <span class="built_in">len</span>(s)</span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(rows):</span><br><span class="line">        count += cols</span><br><span class="line">        ind = count % l</span><br><span class="line">        <span class="keyword">if</span> s[ind] == <span class="string">&#x27; &#x27;</span>:</span><br><span class="line">            count += <span class="number">1</span> <span class="comment"># move to next new position</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">while</span> count &gt;= <span class="number">0</span> <span class="keyword">and</span> s[count % l] != <span class="string">&#x27; &#x27;</span>:</span><br><span class="line">                count -= <span class="number">1</span></span><br><span class="line">            count += <span class="number">1</span> <span class="comment"># move to next new position</span></span><br><span class="line">    <span class="keyword">return</span> count // l</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>1525. Number of Good Ways to Split a String</summary>
<blockquote>
<p>Sliding Window. Use one empty dictionary, and one full dictionary containing occurrences. For each char, add it to empty dictionary, and remove it from right dictionary, if the length are the same, increment the final answer.<br>
<a target="_blank" rel="noopener" href="https://leetcode.com/problems/number-of-good-ways-to-split-a-string/discuss/755264/Python-O(N)-Sliding-Window">https://leetcode.com/problems/number-of-good-ways-to-split-a-string/discuss/755264/Python-O(N)-Sliding-Window</a></p>
</blockquote>
<p>Run time: $O(n)$, space: $O(n)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">numSplits</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">    left_count = collections.Counter()</span><br><span class="line">    right_count = collections.Counter(s)</span><br><span class="line">    res = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> c <span class="keyword">in</span> s:</span><br><span class="line">        left_count[c] += <span class="number">1</span></span><br><span class="line">        right_count[c] -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> right_count[c] == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">del</span> right_count[c]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(left_count) == <span class="built_in">len</span>(right_count):</span><br><span class="line">            res += <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>833. Find And Replace in String</summary>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/find-and-replace-in-string/discuss/315827/Python-SIMPLE-Forward-O(N)-Solution-(32ms-97)">https://leetcode.com/problems/find-and-replace-in-string/discuss/315827/Python-SIMPLE-Forward-O(N)-Solution-(32ms-97)</a></p>
</blockquote>
<p>Run time: $O(m)$, space: $O(n)$, Let N = len(S) and M = len(indexes)</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findReplaceString</span>(<span class="params">self, s: <span class="built_in">str</span>, indices: <span class="type">List</span>[<span class="built_in">int</span>], sources: <span class="type">List</span>[<span class="built_in">str</span>], targets: <span class="type">List</span>[<span class="built_in">str</span>]</span>) -&gt; <span class="built_in">str</span>:</span></span><br><span class="line">    <span class="comment"># lookup = &#123;i: (src, tgt) for i, src, tgt in zip(indexes, sources, targets)&#125;</span></span><br><span class="line">    lookup = <span class="built_in">dict</span>(<span class="built_in">zip</span>(indices, <span class="built_in">zip</span>(sources, targets)))</span><br><span class="line">    i, result = <span class="number">0</span>, <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">while</span> i &lt; <span class="built_in">len</span>(s):</span><br><span class="line">        <span class="keyword">if</span> i <span class="keyword">in</span> lookup <span class="keyword">and</span> s[i:].startswith(lookup[i][<span class="number">0</span>]):</span><br><span class="line">            result += lookup[i][<span class="number">1</span>]</span><br><span class="line">            i += <span class="built_in">len</span>(lookup[i][<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            result += s[i]</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>843. Guess the Word</summary>
<blockquote>
<p>Calculate the occurrences for each character at position i (6 in total). Then sort the list by the sum of the occurrences. For each guess, pop the last word and make a guess, then discard any word that does have the same number of matched characters returned from master.</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/guess-the-word/discuss/1318789/Careful-explanation-of-two-ideas-that-allow-you-to-solve-this-problem-in-a-few-lines">https://leetcode.com/problems/guess-the-word/discuss/1318789/Careful-explanation-of-two-ideas-that-allow-you-to-solve-this-problem-in-a-few-lines</a></p>
<p>Run time: $O()$, space: $O()$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findSecretWord</span>(<span class="params">self, wordlist: <span class="type">List</span>[<span class="built_in">str</span>], master: <span class="string">&#x27;Master&#x27;</span></span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">    weights = [Counter(word[i] <span class="keyword">for</span> word <span class="keyword">in</span> wordlist) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">6</span>)]</span><br><span class="line">    wordlist.sort(key=<span class="keyword">lambda</span> word: <span class="built_in">sum</span>(weights[i][c] <span class="keyword">for</span> i, c <span class="keyword">in</span> <span class="built_in">enumerate</span>(word)))</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> wordlist:</span><br><span class="line">        word = wordlist.pop()</span><br><span class="line">        matches = master.guess(word)</span><br><span class="line">        wordlist = [candidate <span class="keyword">for</span> candidate <span class="keyword">in</span> wordlist</span><br><span class="line">                   <span class="keyword">if</span> matches == <span class="built_in">sum</span>(c1 == c2 <span class="keyword">for</span> c1, c2 <span class="keyword">in</span> <span class="built_in">zip</span>(word, candidate))]</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>791. Custom Sort String</summary>
> 
<p>Run time: $O(\max(m,n))$, space: $O(n)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">customSortString</span>(<span class="params">self, order: <span class="built_in">str</span>, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span></span><br><span class="line">      freq = Counter(s) <span class="comment">#O(n) + O(1)</span></span><br><span class="line"><span class="comment"># equivalent:</span></span><br><span class="line"><span class="comment"># freq = &#123;&#125;</span></span><br><span class="line">      <span class="comment"># for ch in s: #O(n) where n is len(s)</span></span><br><span class="line">      <span class="comment">#     freq[ch] = freq.get(ch, 0) + 1</span></span><br><span class="line"></span><br><span class="line">      chars = []</span><br><span class="line">      <span class="keyword">for</span> ch <span class="keyword">in</span> order: <span class="comment">#O(m) where m is the len(order)</span></span><br><span class="line">          chars.append(ch*freq.pop(ch, <span class="number">0</span>)) <span class="comment">#O(1)</span></span><br><span class="line">      </span><br><span class="line">      <span class="keyword">for</span> key <span class="keyword">in</span> freq.keys(): <span class="comment">#O(k) where k is the size of keys present in s but not in order</span></span><br><span class="line">          chars.append(key*freq[key]) <span class="comment">#O(1)</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;&quot;</span>.join(chars)</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>766. Toeplitz Matrix</summary>
<blockquote></blockquote>
<p>Run time: $O(mn)$, space: $O(1)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isToeplitzMatrix</span>(<span class="params">self, matrix: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(matrix)-<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(matrix[<span class="number">0</span>])-<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> matrix[i][j] != matrix[i + <span class="number">1</span>][j + <span class="number">1</span>]:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">def</span> <span class="title">isToeplitzMatrix</span>(<span class="params">self, matrix: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">     <span class="keyword">if</span> <span class="keyword">not</span> matrix <span class="keyword">or</span> <span class="keyword">not</span> matrix[<span class="number">0</span>]:</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">False</span>                </span><br><span class="line">     </span><br><span class="line">     <span class="comment"># Create a deque tracking the expected values for the next row</span></span><br><span class="line">     expected = deque(matrix[<span class="number">0</span>])</span><br><span class="line">     </span><br><span class="line">     <span class="comment"># Iterate through all the remaining rows, verifying they align with the</span></span><br><span class="line">     <span class="comment">#   expected row.</span></span><br><span class="line">     <span class="keyword">for</span> row_i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(matrix)):</span><br><span class="line">         row = matrix[row_i]</span><br><span class="line">         expected.pop()</span><br><span class="line">         expected.appendleft(row[<span class="number">0</span>])</span><br><span class="line">         </span><br><span class="line"><span class="comment"># Only check from index 1 and down as we&#x27;ve just added index 0 to expected</span></span><br><span class="line">         <span class="keyword">for</span> col_i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(row)):</span><br><span class="line">             <span class="keyword">if</span> row[col_i] != expected[col_i]:</span><br><span class="line">                 <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">     </span><br><span class="line">     <span class="comment"># If we&#x27;ve reached here, all diagonals aligned</span></span><br><span class="line">     <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>953. Verifying an Alien Dictionary</summary>
<blockquote>
<p>Two cases: 1. prev and curr in correct order but prev length is longer, 2. prev and curr not in order.</p>
</blockquote>
<p>Run time: $O(n)$, space: $O(1)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">def</span> <span class="title">isAlienSorted</span>(<span class="params">self, words: <span class="type">List</span>[<span class="built_in">str</span>], order: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">     d = &#123;&#125;</span><br><span class="line">     <span class="keyword">for</span> i, c <span class="keyword">in</span> <span class="built_in">enumerate</span>(order):</span><br><span class="line">         d[c] = i</span><br><span class="line"></span><br><span class="line">     <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(words)):</span><br><span class="line">         <span class="comment">#flag = 1 here means inner loop is break out due to pre less than cur</span></span><br><span class="line"><span class="comment">#flag = 0 here means inner loop done iteration but two strings length are not equal</span></span><br><span class="line">         pre, cur, flag = words[i-<span class="number">1</span>], words[i], <span class="number">0</span></span><br><span class="line">         <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">min</span>(<span class="built_in">len</span>(pre),<span class="built_in">len</span>(cur))):</span><br><span class="line">             <span class="keyword">if</span> d[pre[j]] &lt; d[cur[j]]:</span><br><span class="line">                 flag = <span class="number">1</span></span><br><span class="line">                 <span class="keyword">break</span></span><br><span class="line">             <span class="keyword">elif</span> d[pre[j]] &gt; d[cur[j]]:</span><br><span class="line">                 <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">         <span class="keyword">if</span> <span class="keyword">not</span> flag <span class="keyword">and</span> <span class="built_in">len</span>(pre) &gt; <span class="built_in">len</span>(cur): </span><br><span class="line">             <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">     <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>65. Valid Number</summary>
> 
<p>Run time: $O(n)$, space: $O(1)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isNumber</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">    seen_digit = seen_exponent = seen_dot =  <span class="literal">False</span></span><br><span class="line">    <span class="keyword">for</span> i, c <span class="keyword">in</span> <span class="built_in">enumerate</span>(s):</span><br><span class="line">        <span class="keyword">if</span> c.isdigit():</span><br><span class="line">            seen_digit = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">elif</span> c <span class="keyword">in</span> <span class="string">&quot;+-&quot;</span>:</span><br><span class="line">            <span class="keyword">if</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> s[i - <span class="number">1</span>] != <span class="string">&quot;e&quot;</span> <span class="keyword">and</span> s[i - <span class="number">1</span>] != <span class="string">&quot;E&quot;</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">elif</span> c <span class="keyword">in</span> <span class="string">&quot;Ee&quot;</span>:</span><br><span class="line">            <span class="keyword">if</span> seen_exponent <span class="keyword">or</span> <span class="keyword">not</span> seen_digit:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            seen_exponent = <span class="literal">True</span></span><br><span class="line">            seen_digit = <span class="literal">False</span></span><br><span class="line">        <span class="keyword">elif</span> c == <span class="string">&quot;.&quot;</span>:</span><br><span class="line">            <span class="keyword">if</span> seen_dot <span class="keyword">or</span> seen_exponent:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            seen_dot = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> seen_digit</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Deterministic Finite Automaton (DFA). Initialize the DFA as an array of hash tables. Each hash table’s keys will be a character group, and the values will be the state it should transition to. We can use the indexes of the array to handle state transitions. Set the currentState = 0.<br>
Iterate through the input. For each character, first determine what group it belongs to. Then, check if that group exists in the current state’s hash table. If it does, transition to the next state. Otherwise, return false.<br>
At the end, check if we are currently in a valid end state: 1, 4, or 7.</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isNumber</span>(<span class="params">self, s</span>):</span></span><br><span class="line">        <span class="comment"># This is the DFA we have designed above</span></span><br><span class="line">        dfa = [</span><br><span class="line">            &#123;<span class="string">&quot;digit&quot;</span>: <span class="number">1</span>, <span class="string">&quot;sign&quot;</span>: <span class="number">2</span>, <span class="string">&quot;dot&quot;</span>: <span class="number">3</span>&#125;,</span><br><span class="line">            &#123;<span class="string">&quot;digit&quot;</span>: <span class="number">1</span>, <span class="string">&quot;dot&quot;</span>: <span class="number">4</span>, <span class="string">&quot;exponent&quot;</span>: <span class="number">5</span>&#125;,</span><br><span class="line">            &#123;<span class="string">&quot;digit&quot;</span>: <span class="number">1</span>, <span class="string">&quot;dot&quot;</span>: <span class="number">3</span>&#125;,</span><br><span class="line">            &#123;<span class="string">&quot;digit&quot;</span>: <span class="number">4</span>&#125;,</span><br><span class="line">            &#123;<span class="string">&quot;digit&quot;</span>: <span class="number">4</span>, <span class="string">&quot;exponent&quot;</span>: <span class="number">5</span>&#125;,</span><br><span class="line">            &#123;<span class="string">&quot;sign&quot;</span>: <span class="number">6</span>, <span class="string">&quot;digit&quot;</span>: <span class="number">7</span>&#125;,</span><br><span class="line">            &#123;<span class="string">&quot;digit&quot;</span>: <span class="number">7</span>&#125;,</span><br><span class="line">            &#123;<span class="string">&quot;digit&quot;</span>: <span class="number">7</span>&#125;</span><br><span class="line">        ]</span><br><span class="line">        </span><br><span class="line">        current_state = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> c.isdigit():</span><br><span class="line">                group = <span class="string">&quot;digit&quot;</span></span><br><span class="line">            <span class="keyword">elif</span> c <span class="keyword">in</span> [<span class="string">&quot;+&quot;</span>, <span class="string">&quot;-&quot;</span>]:</span><br><span class="line">                group = <span class="string">&quot;sign&quot;</span></span><br><span class="line">            <span class="keyword">elif</span> c <span class="keyword">in</span> [<span class="string">&quot;e&quot;</span>, <span class="string">&quot;E&quot;</span>]:</span><br><span class="line">                group = <span class="string">&quot;exponent&quot;</span></span><br><span class="line">            <span class="keyword">elif</span> c == <span class="string">&quot;.&quot;</span>:</span><br><span class="line">                group = <span class="string">&quot;dot&quot;</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> group <span class="keyword">not</span> <span class="keyword">in</span> dfa[current_state]:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            </span><br><span class="line">            current_state = dfa[current_state][group]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> current_state <span class="keyword">in</span> [<span class="number">1</span>, <span class="number">4</span>, <span class="number">7</span>]</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>5. Longest Palindromic Substring</summary>
<blockquote>
<p>Helper function that gets the start and end indices. Then use max function and set key=lambda x: x[1] - x[0]).</p>
</blockquote>
<p>Run time: $O(n)$, space: $O(1)$ or $O(n)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">longestPalindrome</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">f</span>(<span class="params">i, j</span>):</span></span><br><span class="line">        <span class="keyword">while</span> i &gt;= <span class="number">0</span> <span class="keyword">and</span> j &lt; <span class="built_in">len</span>(s) <span class="keyword">and</span> s[i] == s[j]:</span><br><span class="line">            i -= <span class="number">1</span></span><br><span class="line">            j += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> i, j</span><br><span class="line">    </span><br><span class="line">    i = j = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)):</span><br><span class="line">        i, j = <span class="built_in">max</span>((i, j), f(k, k), f(k, k+<span class="number">1</span>), key=<span class="keyword">lambda</span> x: x[<span class="number">1</span>] - x[<span class="number">0</span>])</span><br><span class="line">    <span class="keyword">return</span> s[i+<span class="number">1</span>:j] </span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">longestPalindrome</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span>(<span class="params">s, start, end</span>):</span></span><br><span class="line">        <span class="keyword">while</span> start &gt;= <span class="number">0</span> <span class="keyword">and</span> end &lt; <span class="built_in">len</span>(s) <span class="keyword">and</span> s[start] == s[end]:</span><br><span class="line">            start -= <span class="number">1</span></span><br><span class="line">            end += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> s[start+<span class="number">1</span>:end]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> s:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span></span><br><span class="line">    longest = <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)):</span><br><span class="line">        curr_substr1 = helper(s, i, i)</span><br><span class="line">        curr_substr2 = helper(s, i, i+<span class="number">1</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(curr_substr1) &gt; <span class="built_in">len</span>(longest):</span><br><span class="line">            longest = curr_substr1</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(curr_substr2) &gt; <span class="built_in">len</span>(longest):</span><br><span class="line">            longest = curr_substr2</span><br><span class="line">    <span class="keyword">return</span> longest</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>3. Longest Substring Without Repeating Characters</summary>
<blockquote>
<p>Sliding window. We use a dictionary to store the character as the key, the last appear index has been seen so far as value. seen[charactor] = index<br>
Move the pointer when you met a repeated character in your window.</p>
</blockquote>
<p>Run time: $O(n)$, space: $O(m)$, where $n$ is the length of the input string, $m$ is the number of unique characters of the input.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lengthOfLongestSubstring</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">    used = &#123;&#125;</span><br><span class="line">    max_length = start = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i, c <span class="keyword">in</span> <span class="built_in">enumerate</span>(s):</span><br><span class="line">        <span class="keyword">if</span> c <span class="keyword">in</span> used <span class="keyword">and</span> start &lt;= used[c]:</span><br><span class="line">            start = used[c] + <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            max_length = <span class="built_in">max</span>(max_length, i - start + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        used[c] = i</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> max_length</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Brute force.</p>
</blockquote>
<p>Run time: $O(n^2)$, space: $O(min(m,n))$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lengthOfLongestSubstring</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> s:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    count = <span class="number">1</span></span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> i &lt; <span class="built_in">len</span>(s):</span><br><span class="line">        seen = <span class="built_in">set</span>()</span><br><span class="line">        seen.add(s[i])</span><br><span class="line">        j = i+<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> j &lt; <span class="built_in">len</span>(s) <span class="keyword">and</span> s[j] <span class="keyword">not</span> <span class="keyword">in</span> seen:</span><br><span class="line">            seen.add(s[j])</span><br><span class="line">            j += <span class="number">1</span></span><br><span class="line">        count = <span class="built_in">max</span>(count, j-i)</span><br><span class="line">        i = j</span><br><span class="line">    <span class="keyword">return</span> count</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>647. Palindromic Substrings</summary>
> There are 2N-1 possible centers for the palindrome: we could have a center at S[0], between S[0] and S[1], at S[1], between S[1] and S[2], at S[2], etc.
<p>Run time: $O(n)$, space: $O(1)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">countSubstrings</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> s:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    n = <span class="built_in">len</span>(s)</span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>*n-<span class="number">1</span>):</span><br><span class="line">        left = i//<span class="number">2</span></span><br><span class="line">        right = (i+<span class="number">1</span>)//<span class="number">2</span></span><br><span class="line">        <span class="keyword">while</span> left &gt;= <span class="number">0</span> <span class="keyword">and</span> right &lt; n <span class="keyword">and</span> s[left] == s[right]:</span><br><span class="line">            left -= <span class="number">1</span></span><br><span class="line">            right += <span class="number">1</span></span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> count</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Intuitive solution.</p>
</blockquote>
<p>Run time: $O(n^2)$, space: $O(1)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">countSubstrings</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span>(<span class="params">s, i</span>):</span></span><br><span class="line">        <span class="keyword">if</span> i &lt; <span class="number">0</span> <span class="keyword">or</span> i &gt;= <span class="built_in">len</span>(s):</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        count = <span class="number">1</span></span><br><span class="line">        left,right = i-<span class="number">1</span>,i+<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> left &gt;=<span class="number">0</span> <span class="keyword">and</span> right &lt; <span class="built_in">len</span>(s):</span><br><span class="line">            <span class="keyword">if</span> s[left] == s[right]:</span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">            left, right = left-<span class="number">1</span>, right+<span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> i+<span class="number">1</span> &lt; <span class="built_in">len</span>(s) <span class="keyword">and</span> s[i] == s[i+<span class="number">1</span>]:</span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line">            left,right = i-<span class="number">1</span>,i+<span class="number">2</span></span><br><span class="line">            <span class="keyword">while</span> left &gt;=<span class="number">0</span> <span class="keyword">and</span> right &lt; <span class="built_in">len</span>(s):</span><br><span class="line">                <span class="keyword">if</span> s[left] == s[right]:</span><br><span class="line">                    count += <span class="number">1</span></span><br><span class="line">                left, right = left-<span class="number">1</span>, right+<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> count</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> s:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    ans = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)):</span><br><span class="line">        ans += helper(s, i)</span><br><span class="line">    <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>415. Add Strings</summary>
> use `chr()` to convert integer to character. `ord()` converts a charactor to integer.
<p>Run time: $O(max(two strings))$, space: $O(max(two strings))$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">addStrings</span>(<span class="params">self, num1, num2</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    :type num1: str</span></span><br><span class="line"><span class="string">    :type num2: str</span></span><br><span class="line"><span class="string">    :rtype: str</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    ans = []</span><br><span class="line">    i1, i2 = <span class="built_in">len</span>(num1)-<span class="number">1</span>, <span class="built_in">len</span>(num2)-<span class="number">1</span></span><br><span class="line">    carry = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> i1 &gt;= <span class="number">0</span> <span class="keyword">or</span> i2 &gt;= <span class="number">0</span> <span class="keyword">or</span> carry &gt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">if</span> i1 &gt;= <span class="number">0</span>:</span><br><span class="line">            carry += <span class="built_in">ord</span>(num1[i1]) - <span class="built_in">ord</span>(<span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">            i1 -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> i2 &gt;= <span class="number">0</span>:</span><br><span class="line">            carry += <span class="built_in">ord</span>(num2[i2]) - <span class="built_in">ord</span>(<span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">            i2 -= <span class="number">1</span></span><br><span class="line">        ans.append(<span class="built_in">chr</span>(carry % <span class="number">10</span> + <span class="built_in">ord</span>(<span class="string">&#x27;0&#x27;</span>)))</span><br><span class="line">        carry //= <span class="number">10</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&quot;</span>.join(ans)[::-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<details>
<summary>My approach</summary>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">addStrings</span>(<span class="params">self, num1, num2</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    :type num1: str</span></span><br><span class="line"><span class="string">    :type num2: str</span></span><br><span class="line"><span class="string">    :rtype: str</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    ans = <span class="number">0</span></span><br><span class="line">    digit = <span class="number">0</span></span><br><span class="line">    i, j = <span class="built_in">len</span>(num1)-<span class="number">1</span>, <span class="built_in">len</span>(num2)-<span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> i &gt;= <span class="number">0</span> <span class="keyword">and</span> j &gt;= <span class="number">0</span>:</span><br><span class="line">        d1 = <span class="built_in">int</span>(num1[i])</span><br><span class="line">        d2 = <span class="built_in">int</span>(num2[j])</span><br><span class="line">        temp_sum = d1+d2</span><br><span class="line">        temp = <span class="number">10</span>**digit * (temp_sum % <span class="number">10</span>) + <span class="number">10</span>**(digit+<span class="number">1</span>) *(temp_sum//<span class="number">10</span>)</span><br><span class="line">        ans += temp</span><br><span class="line">        digit += <span class="number">1</span></span><br><span class="line">        i, j = i-<span class="number">1</span>, j-<span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> i &lt; <span class="number">0</span> <span class="keyword">and</span> j &lt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">str</span>(ans)</span><br><span class="line">    <span class="keyword">elif</span> i &lt; <span class="number">0</span>:</span><br><span class="line">        ans += (<span class="number">10</span>**digit) * <span class="built_in">int</span>(num2[:j+<span class="number">1</span>])</span><br><span class="line">    <span class="keyword">elif</span> j &lt; <span class="number">0</span>:</span><br><span class="line">        ans += (<span class="number">10</span>**digit) * <span class="built_in">int</span>(num1[:i+<span class="number">1</span>])</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">str</span>(ans)</span><br></pre></td></tr></table></figure>
</details>
</details>
<details>
<summary>68. Text Justification</summary>
> Use one list for final output, one list for current line, one variable to keep track of current character count. Since the current length also represents the minimum space added between words, if the length of current line, plus current character count, plus current word length exceeds `maxWidth`, then we should not add this word, and need to add more space to make the words on the current line distributed evenly. 
Therefore, we loop from 0 to `maxWidth-char_count`, which is the number of space to be added on this line, then we take modulo. For example, if there are three words on this line, and we need to add 5 space. We first get 0%(3-1), which is 0. Then we calculate 1%(3-1), which is 1. Then we calculate 2%(3-1), which is 0. Then we calculate 3%(3-1), which is 1. Then we calculate 4%(3-1), which is 0. 
<p>Run time: $O(n)$, space: $O(n)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fullJustify</span>(<span class="params">self, words, maxWidth</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    :type words: List[str]</span></span><br><span class="line"><span class="string">    :type maxWidth: int</span></span><br><span class="line"><span class="string">    :rtype: List[str]</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    ans = []</span><br><span class="line">    cur = []</span><br><span class="line">    char_count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> w <span class="keyword">in</span> words:</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(cur) + char_count + <span class="built_in">len</span>(w) &gt; maxWidth:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(maxWidth - char_count):</span><br><span class="line">                cur[i % (<span class="built_in">len</span>(cur)-<span class="number">1</span> <span class="keyword">or</span> <span class="number">1</span>)] += <span class="string">&#x27; &#x27;</span></span><br><span class="line">            ans.append(<span class="string">&#x27;&#x27;</span>.join(cur))</span><br><span class="line">            cur = []</span><br><span class="line">            char_count = <span class="number">0</span></span><br><span class="line">        cur += [w]</span><br><span class="line">        char_count += <span class="built_in">len</span>(w)</span><br><span class="line">    <span class="comment"># form last line by join with space and left justify to maxWidth using ljust (python method)</span></span><br><span class="line">    <span class="comment"># that means pad additional spaces to the right to make string length equal to maxWidth</span></span><br><span class="line">    <span class="keyword">return</span> ans + [<span class="string">&#x27; &#x27;</span>.join(cur).ljust(maxWidth)]</span><br></pre></td></tr></table></figure>
<details>
<summary>68. Text Justification</summary>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/text-justification/discuss/24891/Concise-python-solution-10-lines">https://leetcode.com/problems/text-justification/discuss/24891/Concise-python-solution-10-lines</a>.</p>
</blockquote>
<p>Run time: $O(n)$, space: $O(n)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fullJustify</span>(<span class="params">self, words: <span class="type">List</span>[<span class="built_in">str</span>], maxWidth: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">str</span>]:</span></span><br><span class="line">    result, current_list, num_of_letters = [],[], <span class="number">0</span></span><br><span class="line">    <span class="comment"># result -&gt; stores final result output</span></span><br><span class="line">    <span class="comment"># current_list -&gt; stores list of words which are traversed but not yet added to result</span></span><br><span class="line">    <span class="comment"># num_of_letters -&gt; stores number of chars corresponding to words in current_list</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> word <span class="keyword">in</span> words:</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># total no. of chars in current_list + total no. of chars in current word</span></span><br><span class="line">        <span class="comment"># + total no. of words ~= min. number of spaces between words</span></span><br><span class="line">        <span class="keyword">if</span> num_of_letters + <span class="built_in">len</span>(word) + <span class="built_in">len</span>(current_list) &gt; maxWidth:</span><br><span class="line">            <span class="comment"># size will be used for module &quot;magic&quot; for round robin</span></span><br><span class="line">            <span class="comment"># we use max. 1 because atleast one word would be there and to avoid modulo by 0</span></span><br><span class="line">            size = <span class="built_in">max</span>(<span class="number">1</span>, <span class="built_in">len</span>(current_list)-<span class="number">1</span>)</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(maxWidth-num_of_letters):</span><br><span class="line">                <span class="comment"># add space to each word in round robin fashion</span></span><br><span class="line">                index = i%size</span><br><span class="line">                current_list[index] += <span class="string">&#x27; &#x27;</span> </span><br><span class="line">            </span><br><span class="line">            <span class="comment"># add current line of words to the output</span></span><br><span class="line">            result.append(<span class="string">&quot;&quot;</span>.join(current_list))</span><br><span class="line">            current_list, num_of_letters = [], <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># add current word to the list and add length to char count</span></span><br><span class="line">        current_list.append(word)</span><br><span class="line">        num_of_letters += <span class="built_in">len</span>(word)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># form last line by join with space and left justify to maxWidth using ljust (python method)</span></span><br><span class="line">    <span class="comment"># that means pad additional spaces to the right to make string length equal to maxWidth</span></span><br><span class="line">    result.append(<span class="string">&quot; &quot;</span>.join(current_list).ljust(maxWidth))</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
</details>
</details>
<details>
<summary>408. Valid Word Abbreviation</summary>
> Use two pointers, one for index in the word, one for the abbr.
<p>Run time: $O(n)$, space: $O(1)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">validWordAbbreviation</span>(<span class="params">self, word, abbr</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    :type word: str</span></span><br><span class="line"><span class="string">    :type abbr: str</span></span><br><span class="line"><span class="string">    :rtype: bool</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    i = j = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> i &lt; <span class="built_in">len</span>(word) <span class="keyword">and</span> j &lt; <span class="built_in">len</span>(abbr):</span><br><span class="line">        <span class="keyword">if</span> word[i] == abbr[j]:</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">            j += <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> abbr[j] == <span class="string">&quot;0&quot;</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">elif</span> abbr[j].isdigit():</span><br><span class="line">            k = j+<span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> k &lt; <span class="built_in">len</span>(abbr) <span class="keyword">and</span> abbr[k].isdigit():</span><br><span class="line">                k += <span class="number">1</span></span><br><span class="line">            i += <span class="built_in">int</span>(abbr[j:k])</span><br><span class="line">            j = k</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> i == <span class="built_in">len</span>(word) <span class="keyword">and</span> j == <span class="built_in">len</span>(abbr)</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>921. Minimum Add to Make Parentheses Valid</summary>
> Maintain a count of current ungrouped parentheses, and a count of parentheses needed to be inserted. If we see a (, increment the count, otherwise decrement the count if it is greater than 0, or increment the final count.
<p>Run time: $O(n)$, space: $O(1)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">minAddToMakeValid</span>(<span class="params">self, s</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    :type s: str</span></span><br><span class="line"><span class="string">    :rtype: int</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    ans = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> c <span class="keyword">in</span> s:</span><br><span class="line">        <span class="keyword">if</span> c == <span class="string">&#x27;(&#x27;</span>:</span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> count == <span class="number">0</span>:</span><br><span class="line">            ans += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            count -= <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> ans + count</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>1249. Minimum Remove to Make Valid Parentheses</summary>
> Use stack to store "(" only, and when encounter ")" and stack is empty, record this index. If stack is not empy, then pop one "(". In the end union the stack and the list and skip these indices when building the final string.
<p>Run time: $O(n)$, space: $O(n)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">minRemoveToMakeValid</span>(<span class="params">self, s</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    :type s: str</span></span><br><span class="line"><span class="string">    :rtype: str</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">remove_invalid</span>(<span class="params">s, good, bad</span>):</span></span><br><span class="line">        sb = []</span><br><span class="line">        bal = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> c == good:</span><br><span class="line">                bal += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> c == bad:</span><br><span class="line">                <span class="keyword">if</span> bal == <span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                bal -= <span class="number">1</span></span><br><span class="line">            sb.append(c)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>.join(sb)</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    s = remove_invalid(s, <span class="string">&quot;(&quot;</span>, <span class="string">&quot;)&quot;</span>)    </span><br><span class="line">    s = remove_invalid(s[::-<span class="number">1</span>], <span class="string">&quot;)&quot;</span>, <span class="string">&quot;(&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> s[::-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">minRemoveToMakeValid</span>(<span class="params">self, s</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    :type s: str</span></span><br><span class="line"><span class="string">    :rtype: str</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    ind_remove = <span class="built_in">set</span>()</span><br><span class="line">    stack = []</span><br><span class="line">    <span class="keyword">for</span> i, c <span class="keyword">in</span> <span class="built_in">enumerate</span>(s):</span><br><span class="line">        <span class="keyword">if</span> c <span class="keyword">not</span> <span class="keyword">in</span> <span class="string">&quot;()&quot;</span>:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">if</span> c == <span class="string">&quot;(&quot;</span>: <span class="comment"># add ( to stack</span></span><br><span class="line">            stack.append(i)</span><br><span class="line">        <span class="keyword">elif</span> <span class="keyword">not</span> stack: <span class="comment"># ) and stack empty, need to remove</span></span><br><span class="line">            ind_remove.add(i)</span><br><span class="line">        <span class="keyword">else</span>: <span class="comment"># ) and stack not empty, pop one</span></span><br><span class="line">            stack.pop()</span><br><span class="line">        </span><br><span class="line">    ind_remove = ind_remove.union(<span class="built_in">set</span>(stack))</span><br><span class="line">    sb = []</span><br><span class="line">    <span class="keyword">for</span> i, c <span class="keyword">in</span> <span class="built_in">enumerate</span>(s):</span><br><span class="line">        <span class="keyword">if</span> i <span class="keyword">not</span> <span class="keyword">in</span> ind_remove:</span><br><span class="line">            sb.append(c)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&quot;</span>.join(sb)</span><br></pre></td></tr></table></figure>
</details>
<h1>Recursion / Math</h1>
<details>
<summary></summary>
> 
<p>Run time: $O()$, space: $O()$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>2128. Remove All Ones With Row and Column Flips</summary>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/remove-all-ones-with-row-and-column-flips/discuss/1671908/Python-3-or-Math-or-Explanation">https://leetcode.com/problems/remove-all-ones-with-row-and-column-flips/discuss/1671908/Python-3-or-Math-or-Explanation</a></p>
</blockquote>
<p>Run time: $O(n)$, space: $O(n)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">removeOnes</span>(<span class="params">self, grid: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">    r1, r1_invert = grid[<span class="number">0</span>], [<span class="number">1</span>-val <span class="keyword">for</span> val <span class="keyword">in</span> grid[<span class="number">0</span>]]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(grid)):</span><br><span class="line">        <span class="keyword">if</span> grid[i] != r1 <span class="keyword">and</span> grid[i] != r1_invert:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>593. Valid Square</summary>
<blockquote>
<p>The idea is to calculate all the distance between each two points, and sort them. In this way, we get 4 edges and 2 diagonals of the square in order. If the 4 edges equal to each other, that means it should be equilateral parallelogram. Finally, we check whether the 2 diagonals equal to each other so as to check if it’s a square.</p>
</blockquote>
<p>Run time: $O(n)$, space: $O(n)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">validSquare</span>(<span class="params">self, p1: <span class="type">List</span>[<span class="built_in">int</span>], p2: <span class="type">List</span>[<span class="built_in">int</span>], p3: <span class="type">List</span>[<span class="built_in">int</span>], p4: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dist</span>(<span class="params">x,y</span>):</span></span><br><span class="line">        <span class="keyword">return</span> math.sqrt(((x[<span class="number">0</span>] - y[<span class="number">0</span>]) ** <span class="number">2</span>) + ((x[<span class="number">1</span>] - y[<span class="number">1</span>]) ** <span class="number">2</span>))</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> p1==p2==p3==p4:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    </span><br><span class="line">    lst = [</span><br><span class="line">        dist(p1, p2),</span><br><span class="line">        dist(p1, p3),</span><br><span class="line">        dist(p1, p4),</span><br><span class="line">        dist(p2, p3),</span><br><span class="line">        dist(p3, p4),</span><br><span class="line">        dist(p2, p4)]</span><br><span class="line">    </span><br><span class="line">    lst.sort()</span><br><span class="line">    <span class="keyword">return</span> lst[<span class="number">0</span>] == lst[<span class="number">1</span>] == lst[<span class="number">2</span>] == lst[<span class="number">3</span>] <span class="keyword">and</span> lst[<span class="number">4</span>] == lst[<span class="number">5</span>]</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>273. Integer to English Words</summary>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/integer-to-english-words/discuss/70632/Recursive-Python">https://leetcode.com/problems/integer-to-english-words/discuss/70632/Recursive-Python</a></p>
</blockquote>
<p>Run time: $O(n)$, space: $O(n)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">numberToWords</span>(<span class="params">self, num: <span class="built_in">int</span></span>) -&gt; <span class="built_in">str</span>:</span></span><br><span class="line">    to19 = <span class="string">&#x27;One Two Three Four Five Six Seven Eight Nine Ten Eleven Twelve &#x27;</span> \</span><br><span class="line">       <span class="string">&#x27;Thirteen Fourteen Fifteen Sixteen Seventeen Eighteen Nineteen&#x27;</span>.split()</span><br><span class="line">    tens = <span class="string">&#x27;Twenty Thirty Forty Fifty Sixty Seventy Eighty Ninety&#x27;</span>.split()</span><br><span class="line">    thousand = <span class="string">&#x27;Thousand Million Billion&#x27;</span>.split()</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">word</span>(<span class="params">num, idx=<span class="number">0</span></span>):</span></span><br><span class="line">        <span class="keyword">if</span> num == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        <span class="keyword">if</span> num &lt; <span class="number">20</span>:</span><br><span class="line">            <span class="keyword">return</span> [to19[num-<span class="number">1</span>]]</span><br><span class="line">        <span class="keyword">if</span> num &lt; <span class="number">100</span>:</span><br><span class="line">            <span class="keyword">return</span> [tens[num//<span class="number">10</span>-<span class="number">2</span>]] + word(num%<span class="number">10</span>)</span><br><span class="line">        <span class="keyword">if</span> num &lt; <span class="number">1000</span>:</span><br><span class="line">            <span class="keyword">return</span> [to19[num//<span class="number">100</span>-<span class="number">1</span>]] + [<span class="string">&#x27;Hundred&#x27;</span>] + word(num%<span class="number">100</span>)</span><br><span class="line"></span><br><span class="line">        p, r = num//<span class="number">1000</span>, num%<span class="number">1000</span></span><br><span class="line">        <span class="keyword">if</span> p % <span class="number">1000</span> !=<span class="number">0</span>:</span><br><span class="line">            space = [thousand[idx]]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            space = []</span><br><span class="line">        <span class="keyword">return</span>  word(p, idx+<span class="number">1</span>) + space + word(r)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27; &#x27;</span>.join(word(num)) <span class="keyword">or</span> <span class="string">&#x27;Zero&#x27;</span></span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>670. Maximum Swap</summary>
<blockquote>
<p>Iterate the list of digits backwards and keep tracking of the max digit, as well as the digit that is smaller than the max.<br>
<a target="_blank" rel="noopener" href="https://leetcode.com/problems/maximum-swap/discuss/1593049/Python-simple-1-pass-solution">https://leetcode.com/problems/maximum-swap/discuss/1593049/Python-simple-1-pass-solution</a></p>
</blockquote>
<p>Run time: $O(n)$, space: $O(1)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">maximumSwap</span>(<span class="params">self, num: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">    digits = <span class="built_in">list</span>(<span class="built_in">str</span>(num))</span><br><span class="line">    min_ind, max_ind, max_i = -<span class="number">1</span>, -<span class="number">1</span>, <span class="built_in">len</span>(digits)-<span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(max_i-<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">if</span> digits[i] &gt; digits[max_i]:</span><br><span class="line">            max_i = i</span><br><span class="line">        <span class="keyword">elif</span> digits[i] &lt; digits[max_i]:</span><br><span class="line">            min_ind, max_ind = i, max_i</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> min_ind &gt; -<span class="number">1</span>:</span><br><span class="line">        digits[min_ind], digits[max_ind] = digits[max_ind], digits[min_ind]</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">int</span>(<span class="string">&#x27;&#x27;</span>.join(digits))</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>48. Rotate Image</summary>
> rotate the image by 90 degrees (clockwise) is equivalent to transpose + reflection.
<p>Run time: $O(mn)$, space: $O(1)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rotate</span>(<span class="params">self, matrix: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Do not return anything, modify matrix in-place instead.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">transpose</span>(<span class="params">ma</span>):</span></span><br><span class="line">        n = <span class="built_in">len</span>(ma)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i+<span class="number">1</span>, n):</span><br><span class="line">                ma[j][i], ma[i][j] = ma[i][j], ma[j][i]</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reflect</span>(<span class="params">ma</span>):</span></span><br><span class="line">        n = <span class="built_in">len</span>(ma)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n//<span class="number">2</span>):</span><br><span class="line">                ma[i][j], ma[i][-j-<span class="number">1</span>] = ma[i][-j-<span class="number">1</span>], ma[i][j]</span><br><span class="line"></span><br><span class="line">    transpose(matrix)</span><br><span class="line">    reflect(matrix)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Directly rotate. ~ means invert, ~j = -j-1</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rotate</span>(<span class="params">self, matrix: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Do not return anything, modify matrix in-place instead.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    n = <span class="built_in">len</span>(matrix)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n//<span class="number">2</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n - n//<span class="number">2</span>):</span><br><span class="line">            matrix[i][j], matrix[~j][i], matrix[~i][~j], matrix[j][~i] = \</span><br><span class="line">                     matrix[~j][i], matrix[~i][~j], matrix[j][~i], matrix[i][j]</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>268. Missing Number</summary>
<blockquote>
<p>Gauss’ Formula. Compute expected sum and actual sum, the difference is the missing number.</p>
</blockquote>
<p>Run time: $O(n)$, space: $O(1)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">missingNumber</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">    n = <span class="built_in">len</span>(nums)</span><br><span class="line">    expected = n*(n+<span class="number">1</span>) // <span class="number">2</span></span><br><span class="line">    actual = <span class="built_in">sum</span>(nums)</span><br><span class="line">    <span class="keyword">return</span> expected-actual</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Bit Manipulation.<br>
Intuition<br>
We can harness the fact that XOR is its own inverse to find the missing element in linear time.</p>
</blockquote>
<p>Algorithm<br>
Because we know that nums contains nn numbers and that it is missing exactly one number on the range [0…n-1][0…n−1], we know that nn definitely replaces the missing number in nums. Therefore, if we initialize an integer to nn and XOR it with every index and value, we will be left with the missing number. Consider the following example (the values have been sorted for intuitive convenience, but need not be):</p>
<p>Run time: $O(n)$, space: $O(1)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">missingNumber</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">    missing = <span class="built_in">len</span>(nums)</span><br><span class="line">    <span class="keyword">for</span> i, num <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums):</span><br><span class="line">        missing ^= i ^ num</span><br><span class="line">    <span class="keyword">return</span> missing</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Initialize a set using the input array. Loop through the length of array + 1, if not in set, return this number.</p>
</blockquote>
<p>Run time: $O(n)$, space: $O(n)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">missingNumber</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">    num_set = <span class="built_in">set</span>(nums)</span><br><span class="line">    n = <span class="built_in">len</span>(nums) + <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> number <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        <span class="keyword">if</span> number <span class="keyword">not</span> <span class="keyword">in</span> num_set:</span><br><span class="line">            <span class="keyword">return</span> number</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>238. Product of Array Except Self</summary>
> The output array does not count toward the space complexity. Use original output array to find the cumulative sum from left, then use one variable to keep track of the cumulative sum from right, and multiply it to the output array.
<p>Run time: $O(n)$, space: $O(1)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">productExceptSelf</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span></span><br><span class="line">    n = <span class="built_in">len</span>(nums)</span><br><span class="line">    ans = [<span class="number">1</span>] * n</span><br><span class="line">    right = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n): <span class="comment"># cumulative sum from left</span></span><br><span class="line">        ans[i] = ans[i-<span class="number">1</span>]*nums[i-<span class="number">1</span>]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n-<span class="number">2</span>,-<span class="number">1</span>,-<span class="number">1</span>): <span class="comment"># cumulative sum from right</span></span><br><span class="line">        right *= nums[i+<span class="number">1</span>]</span><br><span class="line">        ans[i] *= right</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">productExceptSelf</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span></span><br><span class="line">    n = <span class="built_in">len</span>(nums)</span><br><span class="line">    left, right = <span class="number">1</span>, <span class="number">1</span></span><br><span class="line">    ans = [<span class="number">1</span>]*n</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n):</span><br><span class="line">        left *= nums[i-<span class="number">1</span>]</span><br><span class="line">        ans[i] = left</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n-<span class="number">2</span>,-<span class="number">1</span>,-<span class="number">1</span>):</span><br><span class="line">        right *= nums[i+<span class="number">1</span>]</span><br><span class="line">        ans[i] *= right</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<blockquote>
<p>One array to track the cumulative sum from left, one array to track the cumulative sum from right. In the end, multiply them together on the same index.</p>
</blockquote>
<p>Run time: $O(n)$, space: $O(n)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">productExceptSelf</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span></span><br><span class="line">    n = <span class="built_in">len</span>(nums)</span><br><span class="line">    left, right = [<span class="number">1</span>]*n, [<span class="number">1</span>]*n</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n):</span><br><span class="line">        left[i] = nums[i-<span class="number">1</span>] * left[i-<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n-<span class="number">2</span>,-<span class="number">1</span>,-<span class="number">1</span>):</span><br><span class="line">        right[i] = nums[i+<span class="number">1</span>] * right[i+<span class="number">1</span>]</span><br><span class="line">    <span class="built_in">print</span>(left, right)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        left[i] *= right[i]</span><br><span class="line">    <span class="keyword">return</span> left</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>67. Add Binary</summary>
<blockquote>
<p>XOR: ^, AND: &amp;, left-shifted: &lt;&lt;</p>
</blockquote>
<p>Run time: $O(m+n)$, space: $O(max(m,n))$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">addBinary</span>(<span class="params">self, a: <span class="built_in">str</span>, b: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span></span><br><span class="line">    x, y = <span class="built_in">int</span>(a,<span class="number">2</span>), <span class="built_in">int</span>(b,<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">while</span> y:</span><br><span class="line">        ans = x ^ y</span><br><span class="line">        carry = (x &amp; y) &lt;&lt; <span class="number">1</span></span><br><span class="line">        x, y = ans, carry</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">bin</span>(x)[<span class="number">2</span>:]</span><br></pre></td></tr></table></figure>
<blockquote>
<p>two pointers, and one carry</p>
</blockquote>
<p>Run time: $O(max(m,n))$, space: $O(max(m,n))$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">addBinary</span>(<span class="params">self, a: <span class="built_in">str</span>, b: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span></span><br><span class="line">    ans = <span class="string">&quot;&quot;</span></span><br><span class="line">    i,j = <span class="built_in">len</span>(a)-<span class="number">1</span>, <span class="built_in">len</span>(b)-<span class="number">1</span></span><br><span class="line">    carry = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> i&gt;= <span class="number">0</span> <span class="keyword">or</span> j&gt;=<span class="number">0</span> <span class="keyword">or</span> carry&gt;<span class="number">0</span>:</span><br><span class="line">        <span class="keyword">if</span> i&gt;=<span class="number">0</span>:</span><br><span class="line">            carry += <span class="built_in">int</span>(a[i])</span><br><span class="line">        <span class="keyword">if</span> j&gt;=<span class="number">0</span>:</span><br><span class="line">            carry += <span class="built_in">int</span>(b[j])</span><br><span class="line">        <span class="keyword">if</span> carry == <span class="number">3</span>:</span><br><span class="line">            ans += <span class="string">&quot;1&quot;</span></span><br><span class="line">            carry = <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> carry == <span class="number">2</span>:</span><br><span class="line">            ans += <span class="string">&quot;0&quot;</span></span><br><span class="line">            carry = <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> carry == <span class="number">1</span>:</span><br><span class="line">            ans += <span class="string">&quot;1&quot;</span></span><br><span class="line">            carry = <span class="number">0</span></span><br><span class="line">        i,j = i-<span class="number">1</span>,j-<span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> ans[::-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
</details>
</details>
<details>
<summary>69. Sqrt(x)</summary>
<blockquote>
<p>Newton method. $x_{n+1} = x_n - \frac{f(x_n)}{f’(x_n)}$, where $f(x) = x^2-a = 0$.</p>
</blockquote>
<p>Run time: $O(\log n)$, space: $O(1)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mySqrt</span>(<span class="params">self, x</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    :type x: int</span></span><br><span class="line"><span class="string">    :rtype: int</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    a = x</span><br><span class="line">    <span class="keyword">while</span> a**<span class="number">2</span> &gt; x:</span><br><span class="line">        a = (a + x/a)//<span class="number">2</span></span><br><span class="line">    <span class="keyword">return</span> a</span><br></pre></td></tr></table></figure>
<blockquote>
<p>binary search.</p>
</blockquote>
<p>Run time: $O(\log n)$, space: $O(1)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mySqrt</span>(<span class="params">self, x</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    :type x: int</span></span><br><span class="line"><span class="string">    :rtype: int</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> x == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    lo, hi = <span class="number">1</span>, x</span><br><span class="line">    <span class="keyword">while</span> lo &lt;= hi:</span><br><span class="line">        mid = lo + (hi-lo)//<span class="number">2</span></span><br><span class="line">        sqrt = x // mid</span><br><span class="line">        <span class="keyword">if</span> sqrt == mid:</span><br><span class="line">            <span class="keyword">return</span> mid</span><br><span class="line">        <span class="keyword">elif</span> sqrt &lt; mid:</span><br><span class="line">            hi = mid-<span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            lo = mid +<span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> hi</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>50. Pow(x, n)</summary>
<blockquote>
<p>First check if power is 0, and check if power is negative. If so, flip the sign of the power and return the reciprocal. Then calculate the half of the power, and if the original power is odd, multiply by one more <code>x</code>.</p>
</blockquote>
<p>Run time: $O(\log n)$, space: $O(1)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">myPow</span>(<span class="params">self, x, n</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    :type x: float</span></span><br><span class="line"><span class="string">    :type n: int</span></span><br><span class="line"><span class="string">    :rtype: float</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span>: <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> n &lt; <span class="number">0</span>: <span class="keyword">return</span> <span class="number">1.0</span> / self.myPow(x, -n)</span><br><span class="line">    half = self.myPow(x, n // <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">if</span> n % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> half * half</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> half * half * x</span><br></pre></td></tr></table></figure>
</details>
  </div>
</article>



        
          <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/about/">About</a></li>
         
          <li><a href="/archives/">Posts</a></li>
         
          <li><a href="/projects/">Projects</a></li>
         
          <li><a href="/life/">Life</a></li>
        
      </ul>
    </div>

    <div id="toc-footer" style="display: none">
      <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">1.</span> <span class="toc-text">Binary Search, Sorting</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Sorting"><span class="toc-number">1.1.</span> <span class="toc-text">Sorting</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Topological-Sort"><span class="toc-number">1.1.1.</span> <span class="toc-text">Topological Sort</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Other"><span class="toc-number">1.1.2.</span> <span class="toc-text">Other</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Sweep-Line-Deque-Advanced-BS"><span class="toc-number">1.2.</span> <span class="toc-text">Sweep Line, Deque, Advanced BS</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">2.</span> <span class="toc-text">BFS</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">3.</span> <span class="toc-text">DFS</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Backtracking"><span class="toc-number">3.1.</span> <span class="toc-text">Backtracking</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">4.</span> <span class="toc-text">Linked List &amp; Array</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">5.</span> <span class="toc-text">Stack, Queue</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">6.</span> <span class="toc-text">2 Pointers</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">7.</span> <span class="toc-text">Hash &amp; Heap</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Advanced-Hash-Heap"><span class="toc-number">7.1.</span> <span class="toc-text">Advanced Hash&#x2F;Heap</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">8.</span> <span class="toc-text">Union Find</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">9.</span> <span class="toc-text">DP</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">10.</span> <span class="toc-text">DP coord + connected</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#DP-sliding-array-memory-search"><span class="toc-number">10.1.</span> <span class="toc-text">DP sliding array + memory search</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DP-interval-backpack"><span class="toc-number">10.2.</span> <span class="toc-text">DP interval + backpack</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">11.</span> <span class="toc-text">Tree</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Binary-Tree-Divide-Conquer"><span class="toc-number">11.1.</span> <span class="toc-text">Binary Tree &#x2F; Divide &amp; Conquer</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Trie"><span class="toc-number">11.2.</span> <span class="toc-text">Trie</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Segment-Tree"><span class="toc-number">11.3.</span> <span class="toc-text">Segment Tree</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">12.</span> <span class="toc-text">String</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">13.</span> <span class="toc-text">Recursion &#x2F; Math</span></a></li></ol>
    </div>

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=http://yu24l.github.io/lc-summary-python/"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=http://yu24l.github.io/lc-summary-python/&text=(Python) LeetCode Summary"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=http://yu24l.github.io/lc-summary-python/&title=(Python) LeetCode Summary"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=http://yu24l.github.io/lc-summary-python/&is_video=false&description=(Python) LeetCode Summary"><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=(Python) LeetCode Summary&body=Check out this article: http://yu24l.github.io/lc-summary-python/"><i class="fas fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=http://yu24l.github.io/lc-summary-python/&title=(Python) LeetCode Summary"><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=http://yu24l.github.io/lc-summary-python/&title=(Python) LeetCode Summary"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=http://yu24l.github.io/lc-summary-python/&title=(Python) LeetCode Summary"><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=http://yu24l.github.io/lc-summary-python/&title=(Python) LeetCode Summary"><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=http://yu24l.github.io/lc-summary-python/&name=(Python) LeetCode Summary&description="><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=http://yu24l.github.io/lc-summary-python/&t=(Python) LeetCode Summary"><i class="fab fa-hacker-news fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fas fa-bars fa-lg" aria-hidden="true"></i> Menu</a>
        <a id="toc" class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fas fa-list fa-lg" aria-hidden="true"></i> TOC</a>
        <a id="share" class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fas fa-share-alt fa-lg" aria-hidden="true"></i> Share</a>
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up fa-lg" aria-hidden="true"></i> Top</a>
    </div>

  </div>
</div>

        
        <footer id="footer">
	<div class="footer-left">
		<link rel="stylesheet" 
		href="https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.css">
		<script src="https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.js"></script>
		<script src="https://cdn.jsdelivr.net/npm/meting@1.2.0/dist/Meting.min.js"></script>
	</div>
	<div class="footer-right">
		Copyright &copy;
		
		
		2019-2022
		Lu Yu
	  <!-- <nav>
		<ul>
		   
			<li><a href="/">Home</a></li>
		   
			<li><a href="/about/">About</a></li>
		   
			<li><a href="/archives/">Posts</a></li>
		   
			<li><a href="/projects/">Projects</a></li>
		   
			<li><a href="/life/">Life</a></li>
		  
		</ul>
	  </nav> -->
	</div>
  </footer>
    </div>
    <!-- styles -->

<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">


<link rel="stylesheet" href="/lib/justified-gallery/css/justifiedGallery.min.css">


    <!-- jquery -->

<script src="/lib/jquery/jquery.min.js"></script>


<script src="/lib/justified-gallery/js/jquery.justifiedGallery.min.js"></script>

<!-- clipboard -->

  
<script src="/lib/clipboard/clipboard.min.js"></script>

  <script type="text/javascript">
  $(function() {
    // copy-btn HTML
    var btn = "<span class=\"btn-copy tooltipped tooltipped-sw\" aria-label=\"Copy to clipboard!\">";
    btn += '<i class="far fa-clone"></i>';
    btn += '</span>'; 
    // mount it!
    $(".highlight table").before(btn);
    var clip = new ClipboardJS('.btn-copy', {
      text: function(trigger) {
        return Array.from(trigger.nextElementSibling.querySelectorAll('.code')).reduce((str,it)=>str+it.innerText+'\n','')
      }
    });
    clip.on('success', function(e) {
      e.trigger.setAttribute('aria-label', "Copied!");
      e.clearSelection();
    })
  })
  </script>


<script src="/js/main.js"></script>

<!-- search -->

<!-- Google Analytics -->

<!-- Baidu Analytics -->

<!-- Umami Analytics -->

<!-- Disqus Comments -->



<!-- <div class="aplayer" 
    data-id="60198"
    data-server="netease"
    data-type="playlist"
    data-fixed="true"	>
</div> -->

<!-- <script src="dist/Meting.min.js"></script> -->
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
</body>
    <!--如果将本体放在body里面，导致页面加载出现问题，请尝试放到body体后面-->
    <!-- <div class="aplayer" 
    data-id="3778678" 
    data-server="netease" 
    data-type="playlist" 
    data-fixed="true"	
    data-order="random"
    data-volume="0.65"
    data-autoplay="false"   
    date-preload="auto"
    data-theme="#cc543a">
    </div> -->
</html>

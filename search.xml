<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Java Basics Summary</title>
    <url>/java-basics/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Here I will write down some key concepts about Java when I read Head First Java.<br>
Notes written by others: <a href="https://archerimagine.wordpress.com/notes-of-book/head-first-java/">link</a></p>
<p>9.16</p>
<h3 id="1-Dive-in-a-Quick-Dip">1 Dive in a Quick Dip</h3>
<p>How java works:<br>
Source --&gt; Compiler --&gt; Output --&gt; Virtual Machine</p>
<p>A Java program/application only has one main method</p>
<h3 id="2-Classes-and-Objects">2 Classes and Objects</h3>
<p><strong>Inheritance:</strong> “Square inherits from Shape.” The Shape class is called the superclass of the other four classes. The other four classes are the subclasses of Shape, inheriting the methods of the superclass.</p>
<p><strong>Overriding:</strong> a subclass refines one of its inherited methods when it needs to change/extend the behavior of that method.</p>
<p><strong>Instance variables:</strong> things an object knows about itself; represent state(data), can have unique values for each object of that type.</p>
<p><strong>Method:</strong> things an object can do.</p>
<p><strong>Class:</strong> a blueprint for an object. Tell VM how to make an object of that particular type.</p>
<p>Dot operator (.): access to state/instance var and behavior/methods.</p>
<p><strong>main:</strong> test real class; launch/start Java app</p>
<p><strong>(Garbage Collection) Heap:</strong> where the created object is stored. Java allocates memory space on the heap according to how much that particular created object needs.</p>
<h3 id="3-Primitives-and-References">3 Primitives and References</h3>
<p><strong>primitives:</strong> hold fundamental values – int (32 bits), boolean, float (32 bits), char(16 bits), double (64 bits), byte (8 bits), short (16 bits), long (64 bits)</p>
<p><strong>object references:</strong> hold references to objects</p>
<p>Variables must have a type and name.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">float f &#x3D; 32.5f; &#x2F;&#x2F; Java think anything with a floating point is a double, so add &#39;f&#39;</span><br></pre></td></tr></table></figure>
<p>Name: start with a letter/_/$ not number; no use of reserved words</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Dog myDog &#x3D; new Dog(); &#x2F;&#x2F; declare a reference variable, create an object, link them</span><br></pre></td></tr></table></figure>
<p>Arrays are always objects, whether they are declared to hold primitives/object references.</p>
<h3 id="4-Methods-Use-Instance-Variables">4 Methods Use Instance Variables</h3>
<p>A method uses parameters. A caller passes arguments.</p>
<p>Java is pass-by-value, which means it pass-by-copy.</p>
<ol>
<li>int is one of the 8 basic variables, and int[] is reference variable.</li>
<li>In a Java method, method arguments(MA) are passed by by value.</li>
<li>if basic variables are in MA, the value is copied, and the initial variable remain unchanged.</li>
<li>if reference variable is in MA, the address is copied (and passed as value), and the initial variable will be changed.</li>
</ol>
<h3 id="7-Inheritance-and-Polymorphism">7 Inheritance and Polymorphism</h3>
<p>Polymorphism example: <code>Animal myDog = new Dog();</code><br>
The reference variable type is declared as Animal, but the object is. created as <code>new Dog()</code>.<br>
With polymorphism, the reference type can be a superclass of the actual object type.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">Animal[] animals = <span class="keyword">new</span> Animal[<span class="number">5</span>];</span><br><span class="line">animals[<span class="number">0</span>] = <span class="keyword">new</span> Dog();</span><br><span class="line">animals[<span class="number">1</span>] = <span class="keyword">new</span> Cat();</span><br></pre></td></tr></table></figure>
<p>Make a class <code>private</code>: if you need security<br>
Make a method/class <code>final</code>: protect a specific method from being overridden; want to guarantee that none of the methods in that class will ever be overridden.</p>
<p><strong>Overriding rules:</strong></p>
<ol>
<li>arguments must be the same, and return types must be compatible</li>
<li>the method can’t be less accessible</li>
</ol>
<p><strong>Overloading rules:</strong></p>
<ol>
<li>return types can be different</li>
<li>cannot change only the return type (also change the argument list)</li>
<li>can vary the access levels in any direction</li>
</ol>
<h3 id="8-Interfaces-and-Abstract-Classes">8 Interfaces and Abstract Classes</h3>
<p><strong>Abstract class:</strong></p>
<ol>
<li>has no body</li>
<li>if declare an abstract method, must also mark the class abstract</li>
<li>good for: polymorphism, inheritable method implementations</li>
<li>concrete class must implement all abstract methods (like overriding)</li>
</ol>
<p>Every class in Java extends class Object.<br>
<strong>Interface:</strong> all methods are abstract</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Pet</span></span>&#123;...&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Canine</span> <span class="keyword">implements</span> <span class="title">Pet</span></span>&#123;...&#125;</span><br></pre></td></tr></table></figure>
<p>Encapsulation</p>
<p>Mark instance variables private, mark getters and setter public.</p>
<p>The signed left shift operator “&lt;&lt;” shifts a bit pattern to the left<br>
The signed right shift operator “&gt;&gt;” shifts a bit pattern to the right.<br>
The unsigned right shift operator “&gt;&gt;&gt;” shifts a zero into the leftmost position</p>
<h2 id="String"><a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html">String</a></h2>
<p><strong>Commonly used methods:</strong> charAt, indexOf, length, split, toCharArray, trim, replaceAll, compareTo, equals, startsWith, endsWith, toLowerCase, toUpperCase, valueOf</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String[] pets = &#123;<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// they are the same</span></span><br><span class="line">String str = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"><span class="keyword">char</span> data[] = &#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>&#125;;</span><br><span class="line">String str = <span class="keyword">new</span> String(data);</span><br><span class="line"></span><br><span class="line"><span class="comment">// more examples</span></span><br><span class="line">System.out.println(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">String cde = <span class="string">&quot;cde&quot;</span>;</span><br><span class="line">System.out.println(<span class="string">&quot;abc&quot;</span> + cde);</span><br><span class="line">String c = <span class="string">&quot;abc&quot;</span>.substring(<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line">String d = cde.substring(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"> </span><br><span class="line"> <span class="string">&quot;cares&quot;</span>.concat(<span class="string">&quot;s&quot;</span>); <span class="comment">// returns &quot;caress&quot;</span></span><br><span class="line"> <span class="string">&quot;to&quot;</span>.concat(<span class="string">&quot;get&quot;</span>).concat(<span class="string">&quot;her&quot;</span>) <span class="comment">// returns &quot;together&quot;</span></span><br></pre></td></tr></table></figure>
<h2 id="Maps"><a href="https://docs.oracle.com/javase/8/docs/api/java/util/Map.html">Maps</a></h2>
<p><strong>Common methods:</strong> Map.Entry&lt;K,V&gt;, containsKey, getOrDefault, isEmpty, keySet, putIfAbsent, remove, replace, size, entrySet</p>
<h3 id="HashMap-TreeMap-LinkedHashMap-Hashtable">HashMap, TreeMap, LinkedHashMap, Hashtable</h3>
<p>HashMap is implemented as a hash table, and there is no ordering on keys or values. HashMap doesn’t allow two identical elements (same key+value, but same key different values is fine!).<br>
TreeMap is implemented based on red-black tree structure, and it is ordered by the key. A TreeMap is sorted by keys.<br>
LinkedHashMap preserves the insertion order. LinkedHashMap is a subclass of HashMap. That means it inherits the features of HashMap. In addition, the linked list preserves the insertion-order.<br>
Hashtable is synchronized, in contrast to HashMap.<br>
From Java Doc:  The HashMap class is roughly equivalent to Hashtable, except that it is unsynchronized and permits nulls.</p>
<h2 id="Set"><a href="https://docs.oracle.com/javase/9/docs/api/java/util/Set.html">Set</a></h2>
<p><strong>Common methods:</strong> add, contains, isEmpty, remove, toArray, size</p>
<h3 id="TreeSet">TreeSet</h3>
<p><strong>Common methods:</strong> first, last</p>
<h2 id="Priority-Queue-with-custom-comparator"><a href="https://docs.oracle.com/javase/8/docs/api/java/util/PriorityQueue.html">Priority Queue</a> with custom comparator</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// not necessary to specify the capacity</span></span><br><span class="line">PriorityQueue&lt;Node&gt; pq = <span class="keyword">new</span> PriorityQueue&lt;Node&gt;(initCapacity, <span class="keyword">new</span> Comparator&lt;Node&gt;() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Node n1, Node n2)</span> </span>&#123; <span class="comment">// type should be consistent</span></span><br><span class="line">        <span class="comment">// compare n1 and n2</span></span><br><span class="line">        <span class="keyword">return</span> str1.compareTo(str2);</span><br><span class="line">        <span class="comment">// return s1-s2;</span></span><br><span class="line">        <span class="comment">// return s1[0]-s2[0];</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Using lambda expression</span></span><br><span class="line">PriorityQueue&lt;String&gt; pq = <span class="keyword">new</span> PriorityQueue&lt;String&gt;(<span class="number">5</span>,(a,b) -&gt; a.length() - b.length());</span><br><span class="line"></span><br><span class="line"><span class="comment">// max heap    </span></span><br><span class="line">PriorityQueue&lt;Integer&gt; pqInt = <span class="keyword">new</span> PriorityQueue&lt;&gt;(<span class="number">10</span>, Collections.reverseOrder());                    </span><br></pre></td></tr></table></figure>
<h2 id="Scanner"><a href="https://docs.oracle.com/javase/8/docs/api/index.html">Scanner</a></h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"><span class="keyword">while</span>(sc.hasNextLine())&#123;</span><br><span class="line">	String s = sc.nextLine();</span><br><span class="line">	<span class="comment">// int i = sc.nextInt();</span></span><br><span class="line">	<span class="comment">// do more things</span></span><br><span class="line">&#125; </span><br><span class="line">sc.close();</span><br></pre></td></tr></table></figure>
<h2 id="StringBuilder"><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/StringBuilder.html">StringBuilder</a></h2>
<p><strong>Commonly used methods:</strong> append, charAt, delete, deleteCharAt, length, reverse, toString, setLength, substring, setCharAt, insert</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">StringBuilder str = <span class="keyword">new</span> StringBuilder(<span class="string">&quot;AAAABBBCCCC&quot;</span>); </span><br><span class="line">System.out.println(<span class="string">&quot;String = &quot;</span>+ str.toString());  <span class="comment">// print string </span></span><br><span class="line">StringBuilder reverseStr = str.reverse(); <span class="comment">// reverse the string </span></span><br></pre></td></tr></table></figure>
<h2 id="Arrays"><a href="https://docs.oracle.com/javase/8/docs/api/java/util/Arrays.html">Arrays</a></h2>
<p><strong>Commonly used methods:</strong> asList, binarySearch, sort, equals, fill, toString</p>
]]></content>
  </entry>
  <entry>
    <title>Python Basics</title>
    <url>/python-basics/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1>String</h1>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s = s[::<span class="number">1</span>] <span class="comment"># reverse string, O(1)</span></span><br></pre></td></tr></table></figure>
<h1>Stack</h1>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s = []</span><br><span class="line">s.append(<span class="number">1</span>)</span><br><span class="line">s.pop()</span><br></pre></td></tr></table></figure>
<h1>Dictionary</h1>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">d = <span class="built_in">dict</span>()</span><br><span class="line">d[key] = d.get(key, <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">d = collections.OrderedDict()</span><br><span class="line">d[key] = val</span><br><span class="line">val = d.pop(key)</span><br><span class="line"></span><br><span class="line"><span class="comment"># pop least used key</span></span><br><span class="line">d.popitem(last=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure>
<h1>Queue</h1>
<p><a href="https://note.nkmk.me/en/python-collections-deque/">https://note.nkmk.me/en/python-collections-deque/</a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">q = deque()</span><br><span class="line">q.append(<span class="string">&quot;a&quot;</span>)</span><br><span class="line">where q:</span><br><span class="line">	curr = q.popleft()</span><br><span class="line"></span><br><span class="line">q.extendleft([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]) <span class="comment"># give [4,3,2,1]</span></span><br></pre></td></tr></table></figure>
<h1>Sort</h1>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">points = <span class="built_in">sorted</span>(points, key=<span class="keyword">lambda</span> x: x[<span class="number">0</span>]**<span class="number">2</span> + x[<span class="number">1</span>]**<span class="number">2</span>)</span><br><span class="line">intervals.sort(key=<span class="keyword">lambda</span> x: x[<span class="number">0</span>])</span><br></pre></td></tr></table></figure>
<h1><a href="https://docs.python.org/3/library/heapq.html">Heap</a></h1>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">heapsort</span>(<span class="params">iterable</span>):</span></span><br><span class="line">	h = []</span><br><span class="line">	<span class="keyword">for</span> value <span class="keyword">in</span> iterable:</span><br><span class="line">		heappush(h, value)</span><br><span class="line">	<span class="keyword">return</span> [heappop(h) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(h))]</span><br><span class="line"></span><br><span class="line">count = Counter(nums)</span><br><span class="line">heapq.nlargest(k, count.keys(), key=count.get)</span><br></pre></td></tr></table></figure>
<h2 id="Quicksort-O-n-log-n">Quicksort, $O(n\log n)$</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quicksort_recursive</span>(<span class="params">a</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(a) == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    p = <span class="built_in">len</span>(a) // <span class="number">2</span></span><br><span class="line">    l = [i <span class="keyword">for</span> i <span class="keyword">in</span> a <span class="keyword">if</span> i &lt; a[p]]</span><br><span class="line">    m = [i <span class="keyword">for</span> i <span class="keyword">in</span> a <span class="keyword">if</span> i == a[p]]</span><br><span class="line">    r = [i <span class="keyword">for</span> i <span class="keyword">in</span> a <span class="keyword">if</span> i &gt; a[p]]</span><br><span class="line">    <span class="keyword">return</span> quicksort_recursive(l) + m + quicksort_recursive(r)</span><br></pre></td></tr></table></figure>
<h2 id="Mergesort-O-n-log-n">Mergesort, $O(n\log n)$</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># MergeSort in Python</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mergeSort</span>(<span class="params">array</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(array) &gt; <span class="number">1</span>:</span><br><span class="line"></span><br><span class="line">        <span class="comment">#  r is the point where the array is divided into two subarrays</span></span><br><span class="line">        r = <span class="built_in">len</span>(array)//<span class="number">2</span></span><br><span class="line">        L = array[:r]</span><br><span class="line">        M = array[r:]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Sort the two halves</span></span><br><span class="line">        mergeSort(L)</span><br><span class="line">        mergeSort(M)</span><br><span class="line"></span><br><span class="line">        i = j = k = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># Until we reach either end of either L or M, pick larger among</span></span><br><span class="line">        <span class="comment"># elements L and M and place them in the correct position at A[p..r]</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; <span class="built_in">len</span>(L) <span class="keyword">and</span> j &lt; <span class="built_in">len</span>(M):</span><br><span class="line">            <span class="keyword">if</span> L[i] &lt; M[j]:</span><br><span class="line">                array[k] = L[i]</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                array[k] = M[j]</span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">            k += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># When we run out of elements in either L or M,</span></span><br><span class="line">        <span class="comment"># pick up the remaining elements and put in A[p..r]</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; <span class="built_in">len</span>(L):</span><br><span class="line">            array[k] = L[i]</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">            k += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> j &lt; <span class="built_in">len</span>(M):</span><br><span class="line">            array[k] = M[j]</span><br><span class="line">            j += <span class="number">1</span></span><br><span class="line">            k += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Print the array</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">printList</span>(<span class="params">array</span>):</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(array)):</span><br><span class="line">        <span class="built_in">print</span>(array[i], end=<span class="string">&quot; &quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Driver program</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    array = [<span class="number">6</span>, <span class="number">5</span>, <span class="number">12</span>, <span class="number">10</span>, <span class="number">9</span>, <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">    mergeSort(array)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Sorted array is: &quot;</span>)</span><br><span class="line">    printList(array)</span><br></pre></td></tr></table></figure>
<h2 id="Insertion-sort-O-n-2">Insertion sort, $O(n^2)$</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Insertion sort in Python</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">insertionSort</span>(<span class="params">array</span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> step <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(array)):</span><br><span class="line">        key = array[step]</span><br><span class="line">        j = step - <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># Compare key with each element on the left of it until an element smaller than it is found</span></span><br><span class="line">        <span class="comment"># For descending order, change key&lt;array[j] to key&gt;array[j].        </span></span><br><span class="line">        <span class="keyword">while</span> j &gt;= <span class="number">0</span> <span class="keyword">and</span> key &lt; array[j]:</span><br><span class="line">            array[j + <span class="number">1</span>] = array[j]</span><br><span class="line">            j = j - <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># Place key at after the element just smaller than it.</span></span><br><span class="line">        array[j + <span class="number">1</span>] = key</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">data = [<span class="number">9</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">3</span>]</span><br><span class="line">insertionSort(data)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Sorted Array in Ascending Order:&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(data)</span><br></pre></td></tr></table></figure>
<h2 id="Bubble-sort-O-n-2">Bubble sort, $O(n^2)$</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Bubble sort in Python</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bubbleSort</span>(<span class="params">array</span>):</span></span><br><span class="line">    </span><br><span class="line">  <span class="comment"># loop to access each array element</span></span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(array)):</span><br><span class="line"></span><br><span class="line">    <span class="comment"># loop to compare array elements</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(array) - i - <span class="number">1</span>):</span><br><span class="line"></span><br><span class="line">      <span class="comment"># compare two adjacent elements</span></span><br><span class="line">      <span class="comment"># change &gt; to &lt; to sort in descending order</span></span><br><span class="line">      <span class="keyword">if</span> array[j] &gt; array[j + <span class="number">1</span>]:</span><br><span class="line"></span><br><span class="line">        <span class="comment"># swapping elements if elements</span></span><br><span class="line">        <span class="comment"># are not in the intended order</span></span><br><span class="line">        temp = array[j]</span><br><span class="line">        array[j] = array[j+<span class="number">1</span>]</span><br><span class="line">        array[j+<span class="number">1</span>] = temp</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">data = [-<span class="number">2</span>, <span class="number">45</span>, <span class="number">0</span>, <span class="number">11</span>, -<span class="number">9</span>]</span><br><span class="line"></span><br><span class="line">bubbleSort(data)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Sorted Array in Ascending Order:&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(data)</span><br></pre></td></tr></table></figure>
<h2 id="Selection-sort-O-n-2">Selection sort, $O(n^2)$</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Selection sort in Python</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">selectionSort</span>(<span class="params">array, size</span>):</span></span><br><span class="line">   </span><br><span class="line">    <span class="keyword">for</span> step <span class="keyword">in</span> <span class="built_in">range</span>(size):</span><br><span class="line">        min_idx = step</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(step + <span class="number">1</span>, size):</span><br><span class="line">         </span><br><span class="line">            <span class="comment"># to sort in descending order, change &gt; to &lt; in this line</span></span><br><span class="line">            <span class="comment"># select the minimum element in each loop</span></span><br><span class="line">            <span class="keyword">if</span> array[i] &lt; array[min_idx]:</span><br><span class="line">                min_idx = i</span><br><span class="line">         </span><br><span class="line">        <span class="comment"># put min at the correct position</span></span><br><span class="line">        (array[step], array[min_idx]) = (array[min_idx], array[step])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">data = [-<span class="number">2</span>, <span class="number">45</span>, <span class="number">0</span>, <span class="number">11</span>, -<span class="number">9</span>]</span><br><span class="line">size = <span class="built_in">len</span>(data)</span><br><span class="line">selectionSort(data, size)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Sorted Array in Ascending Order:&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(data)</span><br></pre></td></tr></table></figure>
<h1>Array</h1>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">arr.reverse() <span class="comment"># in-place reverse</span></span><br><span class="line">deep_copy = arr[:]</span><br></pre></td></tr></table></figure>
<h1>Counter</h1>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">count = Counter(nums).items()</span><br><span class="line">        <span class="keyword">for</span> k, v <span class="keyword">in</span> count:</span><br><span class="line">            <span class="keyword">if</span> v &gt; max_count:</span><br><span class="line">                max_count = v</span><br><span class="line">                maj = k</span><br><span class="line">        <span class="keyword">return</span> maj</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>(Python) LeetCode Summary</title>
    <url>/lc-summary-python/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Template:</p>
<details>
<summary></summary>
> 
<p>Run time: $O()$, space: $O()$</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
</details>
<h1>Binary Search, Sorting</h1>
<details>
<summary></summary>
> 
<p>Run time: $O()$, space: $O()$</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>162. Find Peak Element</summary>
<blockquote>
<p>Check if nums[m] &lt; nums[m+1]. If so, it means the possible answer might not be on the left side, so set lo=mid+1.</p>
</blockquote>
<p>Run time: $O(\log n)$, space: $O(1)$</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findPeakElement</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">    lo, hi = <span class="number">0</span>, <span class="built_in">len</span>(nums)-<span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> lo &lt; hi:</span><br><span class="line">        m = lo + (hi-lo)//<span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> nums[m] &lt; nums[m+<span class="number">1</span>]: <span class="comment"># here m is low mid so here is nerver a case m+1 = h while l&lt;h</span></span><br><span class="line">            lo = m+<span class="number">1</span> <span class="comment"># possible answer right side without the mid            </span></span><br><span class="line">        <span class="keyword">if</span> nums[m] &gt; nums[m+<span class="number">1</span>]:</span><br><span class="line">            hi = m <span class="comment"># possible answer left side the mid</span></span><br><span class="line">    <span class="keyword">return</span> lo</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findPeakElement</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span>(<span class="params">nums, lo, hi</span>):</span></span><br><span class="line">        <span class="keyword">if</span> lo == hi:</span><br><span class="line">            <span class="keyword">return</span> lo</span><br><span class="line">        mid = lo + (hi-lo) //<span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> nums[mid] &gt; nums[mid+<span class="number">1</span>]:</span><br><span class="line">            <span class="keyword">return</span> helper(nums, lo, mid)</span><br><span class="line">        <span class="keyword">return</span> helper(nums, mid+<span class="number">1</span>, hi)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> helper(nums, <span class="number">0</span>, <span class="built_in">len</span>(nums)-<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<p>Run time: $O(n)$, space: $O(1)$</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findPeakElement</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)-<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">if</span> nums[i] &gt; nums[i+<span class="number">1</span>]:</span><br><span class="line">            <span class="keyword">return</span> i</span><br><span class="line">    <span class="keyword">return</span> nums[<span class="built_in">len</span>(nums)-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>240. Search a 2D Matrix II</summary>
> Search from bottom left corner. Move up if target is smaller, move right if target is greater.
<p>Run time: $O(m+n)$, space: $O(1)$</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">searchMatrix</span>(<span class="params">self, matrix: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]], target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">len</span>(matrix) <span class="keyword">or</span> <span class="keyword">not</span> <span class="built_in">len</span>(matrix[<span class="number">0</span>]):</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    </span><br><span class="line">    h, w = <span class="built_in">len</span>(matrix), <span class="built_in">len</span>(matrix[<span class="number">0</span>])</span><br><span class="line">    i, j = h-<span class="number">1</span>, <span class="number">0</span> <span class="comment"># bottom left corner</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">if</span> i &lt; <span class="number">0</span> <span class="keyword">or</span> j &gt;= w:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        </span><br><span class="line">        current = matrix[i][j]</span><br><span class="line">        <span class="keyword">if</span> target &lt; current: <span class="comment"># target is smaller, then go up</span></span><br><span class="line">            i -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> target &gt; current: <span class="comment"># target is larger, then go right</span></span><br><span class="line">            j += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">else</span>:<span class="comment"># hit target</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>Recursion.</p>
</blockquote>
<p>Run time: $O(mn)$, space: $O(mn)$</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">searchMatrix</span>(<span class="params">self, matrix: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]], target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span>(<span class="params">matrix, target, i, j, s</span>):</span></span><br><span class="line">        <span class="keyword">if</span> i &gt;= m <span class="keyword">or</span> j &gt;= n <span class="keyword">or</span> i &lt; <span class="number">0</span> <span class="keyword">or</span> j &lt; <span class="number">0</span> <span class="keyword">or</span> (i,j) <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        s.add((i,j))</span><br><span class="line">        <span class="keyword">if</span> matrix[i][j] == target:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">elif</span> matrix[i][j] &lt; target:</span><br><span class="line">            <span class="keyword">return</span> helper(matrix, target, i+<span class="number">1</span>, j, s) <span class="keyword">or</span> \</span><br><span class="line">                   helper(matrix, target, i, j+<span class="number">1</span>, s)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> helper(matrix, target, i-<span class="number">1</span>, j, s) <span class="keyword">or</span> \</span><br><span class="line">                   helper(matrix, target, i, j-<span class="number">1</span>, s)</span><br><span class="line">            </span><br><span class="line">    <span class="keyword">if</span> target &gt; matrix[-<span class="number">1</span>][-<span class="number">1</span>]:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    m,n = <span class="built_in">len</span>(matrix), <span class="built_in">len</span>(matrix[<span class="number">0</span>])</span><br><span class="line">    <span class="keyword">return</span> helper(matrix, target, <span class="number">0</span>,<span class="number">0</span>, <span class="built_in">set</span>())</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>81. Search in Rotated Sorted Array II</summary>
> Three cases: if `nums[mid] == target`, return True. If `nums[mid]` is equal to `nums[lo]`, we could not determine which part of the array is rotated, therefore we increment `lo` by 1. If `nums[mid]`is smaller than or equal to `nums[hi]`, then we know the right part may be monotone increasing. We check if the target falls into this interval and update the index. The last case is whether the target falls into the intervals of `lo` and `mid`.
<p>Run time: $O(\log n)$, space: $O(1)$</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">search</span>(<span class="params">self, nums, target</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    :type nums: List[int]</span></span><br><span class="line"><span class="string">    :type target: int</span></span><br><span class="line"><span class="string">    :rtype: bool</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    </span><br><span class="line">    lo = <span class="number">0</span></span><br><span class="line">    hi = <span class="built_in">len</span>(nums)-<span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> lo &lt;= hi:</span><br><span class="line">        mid = lo + (hi-lo)//<span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> nums[mid] == target:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">if</span> nums[lo] == nums[mid]:</span><br><span class="line">            lo += <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> nums[mid] &lt;= nums[hi]:</span><br><span class="line">            <span class="keyword">if</span> nums[mid] &lt; target &lt;= nums[hi]:</span><br><span class="line">                lo = mid+<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                hi = mid-<span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> nums[lo] &lt;= target &lt; nums[mid]:</span><br><span class="line">                hi = mid-<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                lo = mid+<span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>34. Find First and Last Position of Element in Sorted Array</summary>
> If the while condition has equal sign, then every case needs to increment or decrement by 1.
<p>Run time: $O(\log n)$, space: $O(1)$</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">searchRange</span>(<span class="params">self, nums, target</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    :type nums: List[int]</span></span><br><span class="line"><span class="string">    :type target: int</span></span><br><span class="line"><span class="string">    :rtype: List[int]</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lower_bound</span>():</span></span><br><span class="line">        lo = <span class="number">0</span></span><br><span class="line">        hi = <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">while</span> lo &lt;= hi:</span><br><span class="line">            mid = lo + (hi-lo)//<span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid] &gt;= target:</span><br><span class="line">                hi = mid-<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                lo = mid+<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> lo</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">upper_bound</span>():</span></span><br><span class="line">        lo = <span class="number">0</span></span><br><span class="line">        hi = <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">while</span> lo &lt;= hi:</span><br><span class="line">            mid = lo + (hi-lo)//<span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid] &lt;= target:</span><br><span class="line">                lo = mid+<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                hi = mid-<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> hi</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">        <span class="keyword">return</span> [-<span class="number">1</span>,-<span class="number">1</span>]</span><br><span class="line">    first = lower_bound()</span><br><span class="line">    last = upper_bound()</span><br><span class="line">    <span class="keyword">if</span> first &gt;= last:</span><br><span class="line">        <span class="keyword">return</span> [-<span class="number">1</span>,-<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">return</span> [first, last]</span><br></pre></td></tr></table></figure>
</details>
<h2 id="Sorting">Sorting</h2>
<details>
<summary></summary>
> 
<p>Run time: $O()$, space: $O()$</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
</details>
<h3 id="Topological-Sort">Topological Sort</h3>
<details>
<summary>210. Course Schedule II</summary>
<blockquote>
<p><a href="https://leetcode.com/problems/course-schedule-ii/discuss/762346/Python-BFS-beats-98-with-Detailed-Explanation-and-Comments">https://leetcode.com/problems/course-schedule-ii/discuss/762346/Python-BFS-beats-98-with-Detailed-Explanation-and-Comments</a>!</p>
</blockquote>
<p>Run time: $O(v+e)$, space: $O(v+e)$</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">findOrder</span>(<span class="params">self, numCourses: <span class="built_in">int</span>, prerequisites: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span></span><br><span class="line">      <span class="comment"># Create a prerequisite dict. (containing courses (nodes) that need to be taken (visited)</span></span><br><span class="line"><span class="comment"># before we can visit the key.</span></span><br><span class="line">      preq = &#123;i:<span class="built_in">set</span>() <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(numCourses)&#125;</span><br><span class="line"><span class="comment"># Create a graph for adjacency and traversing.</span></span><br><span class="line">      graph = collections.defaultdict(<span class="built_in">set</span>)</span><br><span class="line">      <span class="keyword">for</span> i,j <span class="keyword">in</span> prerequisites:</span><br><span class="line">    <span class="comment"># Preqs store requirments as their given.</span></span><br><span class="line">          preq[i].add(j)</span><br><span class="line">	<span class="comment"># Graph stores nodes and neighbors.</span></span><br><span class="line">          graph[j].add(i)</span><br><span class="line">      </span><br><span class="line">      q = collections.deque([])</span><br><span class="line"><span class="comment"># We need to find a starting location, aka courses that have no prereqs.</span></span><br><span class="line">      <span class="keyword">for</span> k, v <span class="keyword">in</span> preq.items():</span><br><span class="line">          <span class="keyword">if</span> <span class="built_in">len</span>(v) == <span class="number">0</span>:</span><br><span class="line">              q.append(k)</span><br><span class="line"><span class="comment"># Keep track of which courses have been taken.</span></span><br><span class="line">      taken = []</span><br><span class="line">      <span class="keyword">while</span> q:</span><br><span class="line">          course = q.popleft()</span><br><span class="line">          taken.append(course)</span><br><span class="line">	<span class="comment"># If we have visited the numCourses we&#x27;re done.</span></span><br><span class="line">          <span class="keyword">if</span> <span class="built_in">len</span>(taken) == numCourses:</span><br><span class="line">              <span class="keyword">return</span> taken</span><br><span class="line">	<span class="comment"># For neighboring courses.</span></span><br><span class="line">          <span class="keyword">for</span> cor <span class="keyword">in</span> graph[course]:</span><br><span class="line">	    <span class="comment"># If the course we&#x27;ve just taken was a prereq for the next course, remove it from its prereqs.</span></span><br><span class="line">              preq[cor].remove(course)</span><br><span class="line">		<span class="comment"># If we&#x27;ve taken all of the preqs for the new course, we&#x27;ll visit it.</span></span><br><span class="line">              <span class="keyword">if</span> <span class="keyword">not</span> preq[cor]:</span><br><span class="line">                  q.append(cor)</span><br><span class="line"><span class="comment"># If we didn&#x27;t hit numCourses in our search we know we can&#x27;t take all of the courses.</span></span><br><span class="line">      <span class="keyword">return</span> []</span><br></pre></td></tr></table></figure>
<blockquote>
<p><a href="https://leetcode.com/problems/course-schedule-ii/discuss/266867/Python-Topological-Sort-BFS-and-DFS-(reserve-order)">https://leetcode.com/problems/course-schedule-ii/discuss/266867/Python-Topological-Sort-BFS-and-DFS-(reserve-order)</a></p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findOrder</span>(<span class="params">self, numCourses: <span class="built_in">int</span>, prerequisites: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span></span><br><span class="line">    n = numCourses</span><br><span class="line">    G = [<span class="built_in">set</span>() <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">    <span class="keyword">for</span> d, s <span class="keyword">in</span> prerequisites:</span><br><span class="line">        G[s].add(d)</span><br><span class="line">    vis, orders = [<span class="number">0</span>] * n, []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs_circle</span>(<span class="params">x</span>):</span></span><br><span class="line">        vis[x] = -<span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> y <span class="keyword">in</span> G[x]:</span><br><span class="line">            <span class="keyword">if</span> vis[y] &lt; <span class="number">0</span> <span class="keyword">or</span> (<span class="keyword">not</span> vis[y] <span class="keyword">and</span> dfs_circle(y)):</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        vis[x] = <span class="number">1</span></span><br><span class="line">        orders.append(x)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(numCourses):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> vis[x] <span class="keyword">and</span> dfs_circle(x):</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">    <span class="keyword">return</span> orders[::-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
</details>
<h3 id="Other">Other</h3>
<details>
<summary></summary>
> 
<p>Run time: $O()$, space: $O()$</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>56. Merge Intervals</summary>
<blockquote>
<p>Question: How do you add intervals and merge them for a large stream of intervals? (Facebook Follow-up Question)</p>
</blockquote>
<p>Run time: $O(n\log n)$, space: $O(n)$</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge</span>(<span class="params">self, intervals: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span></span><br><span class="line">    heapify(intervals)</span><br><span class="line">    merged = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(intervals)):</span><br><span class="line">        root = heappop(intervals)</span><br><span class="line">        <span class="keyword">if</span> merged <span class="keyword">and</span> merged[-<span class="number">1</span>][<span class="number">1</span>]&gt;=root[<span class="number">0</span>]:</span><br><span class="line">            merged[-<span class="number">1</span>][<span class="number">1</span>] = <span class="built_in">max</span>(merged[-<span class="number">1</span>][<span class="number">1</span>], root[<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            merged.append(root)</span><br><span class="line">    <span class="keyword">return</span> merged</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge</span>(<span class="params">self, intervals: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span></span><br><span class="line">    intervals.sort(key=<span class="keyword">lambda</span> x: x[<span class="number">0</span>])</span><br><span class="line">    merged = []</span><br><span class="line">    <span class="keyword">for</span> interval <span class="keyword">in</span> intervals:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> merged <span class="keyword">or</span> merged[-<span class="number">1</span>][<span class="number">1</span>] &lt; interval[<span class="number">0</span>]:</span><br><span class="line">            merged.append(interval)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            merged[-<span class="number">1</span>][<span class="number">1</span>] = <span class="built_in">max</span>(merged[-<span class="number">1</span>][<span class="number">1</span>], interval[<span class="number">1</span>])</span><br><span class="line">    <span class="keyword">return</span> merged</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>169. Majority Element</summary>
<blockquote>
<p>Boyer-Moore Voting Algorithm<br>
If we had some way of counting instances of the majority element as +1+1 and instances of any other element as -1−1, summing them would make it obvious that the majority element is indeed the majority element.</p>
</blockquote>
<p>Run time: $O(n)$, space: $O(1)$</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">majorityElement</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    candidate = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">        <span class="keyword">if</span> count == <span class="number">0</span>:</span><br><span class="line">            candidate = num</span><br><span class="line">        <span class="keyword">if</span> num == candidate:</span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            count -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> candidate</span><br></pre></td></tr></table></figure>
<blockquote>
<p>In-place sort, and the one in the middle would be the mode.</p>
</blockquote>
<p>Run time: $O(n\log n)$, space: $O(1)$</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">majorityElement</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">    nums.sort()</span><br><span class="line">    <span class="keyword">return</span> nums[<span class="built_in">len</span>(nums)//<span class="number">2</span>]</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Put into a dictionary, and find the one with max value.</p>
</blockquote>
<p>Run time: $O(n)$, space: $O(n)$</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">majorityElement</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">    count = Counter(nums).items()</span><br><span class="line">    max_count, maj = <span class="number">0</span>, -<span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> k, v <span class="keyword">in</span> count:</span><br><span class="line">        <span class="keyword">if</span> v &gt; max_count:</span><br><span class="line">            max_count = v</span><br><span class="line">            maj = k</span><br><span class="line">    <span class="keyword">return</span> maj</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>347. Top K Frequent Elements</summary>
<blockquote>
<p>bucket sort. Create a list of list of length <code>len(nums)+1</code>, where index serves as frequency. Use a dictionary or Counter to get the frequencies of each number, and loop through each key value pair, and put the key to the corresponding buckets. Loop through the buckets reversely, if it is not empty, append the number.</p>
</blockquote>
<p>Run time: $O(n)$, space: $O(n)$</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">buckets = [[] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums) + <span class="number">1</span>)]</span><br><span class="line">number_count = collections.defaultdict(<span class="built_in">int</span>)</span><br><span class="line"><span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">    number_count[num] += <span class="number">1</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">for</span> num, freq <span class="keyword">in</span> number_count.items():</span><br><span class="line">    buckets[freq].append(num)</span><br><span class="line"></span><br><span class="line"><span class="comment"># buckets is a double array</span></span><br><span class="line">flat_list = []</span><br><span class="line"><span class="comment"># traverse from right to left so number with higher frequency come first</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(buckets) - <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">    bucket = buckets[i]</span><br><span class="line">    <span class="keyword">if</span> bucket:</span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> bucket:</span><br><span class="line">            flat_list.append(num)</span><br><span class="line"><span class="keyword">return</span> flat_list[:k]</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Use <code>Counter</code> to calculate the count for each number, which returns a dict. Then put the keys into a heap, sort by values, <code>key=count.get</code>, use <code>heapq.nlargest</code>.</p>
</blockquote>
<p>Run time: $O(n\log k)$, space: $O(n+k)$</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">topKFrequent</span>(<span class="params">self, nums, k</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    :type nums: List[int]</span></span><br><span class="line"><span class="string">    :type k: int</span></span><br><span class="line"><span class="string">    :rtype: List[int]</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> k == <span class="built_in">len</span>(nums):</span><br><span class="line">        <span class="keyword">return</span> nums</span><br><span class="line">    count = Counter(nums)</span><br><span class="line">    <span class="keyword">return</span> heapq.nlargest(k, count.keys(), key=count.get)</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>215. Kth Largest Element in an Array</summary>
<blockquote>
<p>Quick Select.</p>
</blockquote>
<p>Run time: $O(n)$, space: $O(n)$</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findKthLargest</span>(<span class="params">self, nums, k</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> nums: <span class="keyword">return</span></span><br><span class="line">    pivot = random.choice(nums)</span><br><span class="line">    left =  [x <span class="keyword">for</span> x <span class="keyword">in</span> nums <span class="keyword">if</span> x &gt; pivot]</span><br><span class="line">    mid  =  [x <span class="keyword">for</span> x <span class="keyword">in</span> nums <span class="keyword">if</span> x == pivot]</span><br><span class="line">    right = [x <span class="keyword">for</span> x <span class="keyword">in</span> nums <span class="keyword">if</span> x &lt; pivot]</span><br><span class="line">    </span><br><span class="line">    L, M = <span class="built_in">len</span>(left), <span class="built_in">len</span>(mid)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> k &lt;= L:</span><br><span class="line">        <span class="keyword">return</span> self.findKthLargest(left, k)</span><br><span class="line">    <span class="keyword">elif</span> k &gt; L + M:</span><br><span class="line">        <span class="keyword">return</span> self.findKthLargest(right, k - L - M)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> mid[<span class="number">0</span>]</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Use <code>heapq.nlargest(k, nums)</code> and get the last element in the return array.</p>
</blockquote>
<p>Run time: $O(n\log k)$, space: $O(k)$</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findKthLargest</span>(<span class="params">self, nums, k</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    :type nums: List[int]</span></span><br><span class="line"><span class="string">    :type k: int</span></span><br><span class="line"><span class="string">    :rtype: int</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># heap = []</span></span><br><span class="line">    <span class="comment"># for n in nums:</span></span><br><span class="line">    <span class="comment">#     if len(heap) == k:</span></span><br><span class="line">    <span class="comment">#         if heap[0] &lt; n:</span></span><br><span class="line">    <span class="comment">#             heappop(heap)</span></span><br><span class="line">    <span class="comment">#             heappush(heap, n)</span></span><br><span class="line">    <span class="comment">#     else:</span></span><br><span class="line">    <span class="comment">#         heappush(heap, n)</span></span><br><span class="line">    <span class="comment"># return heap[-k]</span></span><br><span class="line">    <span class="keyword">return</span> heapq.nlargest(k, nums)[-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>528. Random Pick with Weight</summary>
<blockquote>
<p>Use binary search to find the target index</p>
</blockquote>
<p>Run time: $O(n)$, $O(\log n)$, space: $O(n)$, $O(1)$</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, w</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type w: List[int]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self.prefix_sums = []</span><br><span class="line">        total = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> weight <span class="keyword">in</span> w:</span><br><span class="line">            total += weight</span><br><span class="line">            self.prefix_sums.append(total)</span><br><span class="line">        self.total_sum = total</span><br><span class="line">            </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pickIndex</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        rand = random.random() * self.total_sum</span><br><span class="line">        lo, hi = <span class="number">0</span>, <span class="built_in">len</span>(self.prefix_sums)</span><br><span class="line">        <span class="keyword">while</span> lo &lt; hi:</span><br><span class="line">            mid = lo + (hi-lo)//<span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> rand &gt; self.prefix_sums[mid]:</span><br><span class="line">                lo = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                hi = mid</span><br><span class="line">        <span class="keyword">return</span> lo</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>Keep track of cumulative sum and put it in an array, also get the total sum. Generate a number from 0 to 1, and scale with the total sum. If it is smaller than current cumulative sum, return the index.</p>
</blockquote>
<p>Run time: $O(n)$, $O(n)$, space: $O(n)$, $O(1)$</p>
<details>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, w</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type w: List[int]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        d = <span class="built_in">sum</span>(w)</span><br><span class="line">        <span class="built_in">print</span>(d)</span><br><span class="line">        self.weighted = [<span class="built_in">float</span>(a)/d <span class="keyword">for</span> a <span class="keyword">in</span> w]</span><br><span class="line">            </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pickIndex</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        rand = random.random()</span><br><span class="line">        <span class="keyword">for</span> i, w <span class="keyword">in</span> <span class="built_in">enumerate</span>(self.weighted):</span><br><span class="line">            <span class="keyword">if</span> rand &lt; w:</span><br><span class="line">                <span class="keyword">return</span> i</span><br></pre></td></tr></table></figure>
</details>
</details>
<details>
<summary>973. K Closest Points to Origin</summary>
<blockquote>
<p>QuickSelect</p>
</blockquote>
<p>Run time: $O(n)$, space: $O(1)$</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">kClosest</span>(<span class="params">self, points, k</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.quick_select(points, k)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">quick_select</span>(<span class="params">self, points, k</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;Perform the QuickSelect algorithm on the list&quot;&quot;&quot;</span></span><br><span class="line">        left, right = <span class="number">0</span>, <span class="built_in">len</span>(points) - <span class="number">1</span></span><br><span class="line">        pivot_index = <span class="built_in">len</span>(points)</span><br><span class="line">        <span class="keyword">while</span> pivot_index != k:</span><br><span class="line">            <span class="comment"># Repeatedly partition the list</span></span><br><span class="line">            <span class="comment"># while narrowing in on the kth element</span></span><br><span class="line">            pivot_index = self.partition(points, left, right)</span><br><span class="line">            <span class="keyword">if</span> pivot_index &lt; k:</span><br><span class="line">                left = pivot_index</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                right = pivot_index - <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># Return the first k elements of the partially sorted list</span></span><br><span class="line">        <span class="keyword">return</span> points[:k]</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">partition</span>(<span class="params">self, points, left, right</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;Partition the list around the pivot value&quot;&quot;&quot;</span></span><br><span class="line">        pivot = self.choose_pivot(points, left, right)</span><br><span class="line">        pivot_dist = self.squared_distance(pivot)</span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            <span class="comment"># Iterate through the range and swap elements to make sure</span></span><br><span class="line">            <span class="comment"># that all points closer than the pivot are to the left</span></span><br><span class="line">            <span class="keyword">if</span> self.squared_distance(points[left]) &gt;= pivot_dist:</span><br><span class="line">                points[left], points[right] = points[right], points[left]</span><br><span class="line">                right -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># Ensure the left pointer is just past the end of</span></span><br><span class="line">        <span class="comment"># the left range then return it as the new pivotIndex</span></span><br><span class="line">        <span class="keyword">if</span> self.squared_distance(points[left]) &lt; pivot_dist:</span><br><span class="line">            left += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> left</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">choose_pivot</span>(<span class="params">self, points, left, right</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;Choose a pivot element of the list&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> points[left + (right - left) // <span class="number">2</span>]</span><br><span class="line">        </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">squared_distance</span>(<span class="params">self, point</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;Calculate and return the squared Euclidean distance.&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> point[<span class="number">0</span>] ** <span class="number">2</span> + point[<span class="number">1</span>] ** <span class="number">2</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>Binary Search: set the <code>lo</code> and <code>hi</code> to be the min (0) and max euclidean distance in the list of points. Then perform binary search to loop through all points in this range and classify them into two lists: distance smaller than mid, and distance greater than mid. If the length of closer list is equal to or less than <code>k</code>, then all of them would be included in the final result and we will skip them in the next search and update the <code>k</code>.<br>
Run time: $O(n)$, space: $O(n)$</p>
</blockquote>
<details>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">kClosest</span>(<span class="params">self, points, k</span>):</span></span><br><span class="line">    <span class="comment"># Precompute the Euclidean distance for each point</span></span><br><span class="line">    distances = [self.euclidean_distance(point) <span class="keyword">for</span> point <span class="keyword">in</span> points]</span><br><span class="line">    <span class="comment"># Create a reference list of point indices</span></span><br><span class="line">    remaining = [i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(points))]</span><br><span class="line">    <span class="comment"># Define the initial binary search range</span></span><br><span class="line">    low, high = <span class="number">0</span>, <span class="built_in">max</span>(distances)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Perform a binary search of the distances</span></span><br><span class="line">    <span class="comment"># to find the k closest points</span></span><br><span class="line">    closest = []</span><br><span class="line">    <span class="keyword">while</span> k:</span><br><span class="line">        mid = low + (high - low) / <span class="number">2</span></span><br><span class="line">        closer, farther = self.split_distances(remaining, distances, mid)</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(closer) &gt; k:</span><br><span class="line">            <span class="comment"># If more than k points are in the closer distances</span></span><br><span class="line">            <span class="comment"># then discard the farther points and continue</span></span><br><span class="line">            remaining = closer</span><br><span class="line">            high = mid</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># Add the closer points to the answer array and keep</span></span><br><span class="line">            <span class="comment"># searching the farther distances for the remaining points</span></span><br><span class="line">            k -= <span class="built_in">len</span>(closer)</span><br><span class="line">            closest.extend(closer)</span><br><span class="line">            remaining = farther</span><br><span class="line">            low = mid</span><br><span class="line">            </span><br><span class="line">    <span class="comment"># Return the k closest points using the reference indices</span></span><br><span class="line">    <span class="keyword">return</span> [points[i] <span class="keyword">for</span> i <span class="keyword">in</span> closest]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">split_distances</span>(<span class="params">self, remaining, distances, mid</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;Split the distances around the midpoint</span></span><br><span class="line"><span class="string">    and return them in separate lists.&quot;&quot;&quot;</span></span><br><span class="line">    closer, farther = [], []</span><br><span class="line">    <span class="keyword">for</span> index <span class="keyword">in</span> remaining:</span><br><span class="line">        <span class="keyword">if</span> distances[index] &lt;= mid:</span><br><span class="line">            closer.append(index)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            farther.append(index)</span><br><span class="line">    <span class="keyword">return</span> [closer, farther]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">euclidean_distance</span>(<span class="params">self, point</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;Calculate and return the Euclidean distance.&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> sqrt(point[<span class="number">0</span>] ** <span class="number">2</span> + point[<span class="number">1</span>] ** <span class="number">2</span>)</span><br></pre></td></tr></table></figure>
</details>
<blockquote>
<p>Maintain a max heap with size $k$ that stores the negative value of the squares of coordinates. Once heap size exceeds $k$, pop the element.</p>
</blockquote>
<p>Run time: $O(n\log k)$, space: $O(k)$</p>
<details>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">kClosest</span>(<span class="params">self, points, k</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    :type points: List[List[int]]</span></span><br><span class="line"><span class="string">    :type k: int</span></span><br><span class="line"><span class="string">    :rtype: List[List[int]]</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    heap = []</span><br><span class="line">    <span class="keyword">for</span> point <span class="keyword">in</span> points:</span><br><span class="line">        dist = point[<span class="number">0</span>] * point[<span class="number">0</span>] + point[<span class="number">1</span>] * point[<span class="number">1</span>]</span><br><span class="line">        heapq.heappush(heap, (-dist, point))</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(heap) &gt; k:</span><br><span class="line">            heapq.heappop(heap)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> [<span class="built_in">tuple</span>[<span class="number">1</span>] <span class="keyword">for</span> <span class="built_in">tuple</span> <span class="keyword">in</span> heap]</span><br></pre></td></tr></table></figure>
</details>
</details>
<h2 id="Sweep-Line-Deque-Advanced-BS">Sweep Line, Deque, Advanced BS</h2>
<details>
<summary></summary>
> 
<p>Run time: $O()$, space: $O()$</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
</details>
<h1>BFS</h1>
<details>
<summary></summary>
> 
<p>Run time: $O()$, space: $O()$</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>126. Word Ladder II</summary>
> bi-directional search
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findLadders</span>(<span class="params">self, beginWord: <span class="built_in">str</span>, endWord: <span class="built_in">str</span>, wordList: <span class="type">List</span>[<span class="built_in">str</span>]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">str</span>]]:</span></span><br><span class="line">    <span class="keyword">if</span> endWord <span class="keyword">not</span> <span class="keyword">in</span> wordList:</span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line"></span><br><span class="line">    wordList = <span class="built_in">set</span>(wordList)</span><br><span class="line">    n = <span class="built_in">len</span>(beginWord)</span><br><span class="line"></span><br><span class="line">    found, swapped = <span class="literal">False</span>, <span class="literal">False</span></span><br><span class="line">    start_q, end_q= &#123;beginWord&#125;, &#123;endWord&#125;</span><br><span class="line">    paths, res = collections.defaultdict(<span class="built_in">set</span>), []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> start_q <span class="keyword">and</span> <span class="keyword">not</span> found:</span><br><span class="line">        next_q = <span class="built_in">set</span>()</span><br><span class="line">        wordList -= <span class="built_in">set</span>(start_q)</span><br><span class="line">        <span class="keyword">for</span> word <span class="keyword">in</span> start_q:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                first, second = word[:i], word[i+<span class="number">1</span>:]</span><br><span class="line">                <span class="keyword">for</span> c <span class="keyword">in</span> <span class="string">&#x27;abcdefghijklmnopqrstuvwxyz&#x27;</span>:</span><br><span class="line">                    new_word = first+c+second</span><br><span class="line">                    <span class="keyword">if</span> new_word <span class="keyword">in</span> wordList:</span><br><span class="line">                        <span class="keyword">if</span> new_word <span class="keyword">in</span> end_q:</span><br><span class="line">                            found = <span class="literal">True</span></span><br><span class="line">                        <span class="keyword">else</span>:</span><br><span class="line">                            next_q.add(new_word)</span><br><span class="line"></span><br><span class="line">                        paths[new_word].add(word) <span class="keyword">if</span> swapped <span class="keyword">else</span> paths[word].add(new_word)</span><br><span class="line"></span><br><span class="line">        start_q = next_q</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(start_q) &gt; <span class="built_in">len</span>(end_q):</span><br><span class="line">            start_q, end_q = end_q, start_q</span><br><span class="line">            swapped = <span class="keyword">not</span> swapped</span><br><span class="line">    </span><br><span class="line">    res = []</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">bfs</span>(<span class="params">word, cur_path</span>):</span></span><br><span class="line">        <span class="keyword">if</span> word == endWord:</span><br><span class="line">            cur_path.append(word)</span><br><span class="line">            res.append(cur_path[::])</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">for</span> parent <span class="keyword">in</span> paths[word]:</span><br><span class="line">                bfs(parent, cur_path+[word])</span><br><span class="line">    bfs(beginWord, [])</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Create a set that contains wordList, and a dictionary <code>layer</code> that contains &lt;endWord, all possible sequences&gt; pairs. While layer is not empty, we loop through all keys, and see if the endWord is in it. Then, we loop through each character in the word, trying to replace it with every alphabet. If this new word is valid, we create an entry in the new dictionary, and the values are formed by the values of the old word. Outside of this for loop, we remove the keys in the new dictionary so that they will not be reused, and we assign the new dictionary to the old one.</p>
</blockquote>
<p>Run time: $O(nk^2)$, space: $O(nk)$</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findLadders</span>(<span class="params">self, beginWord: <span class="built_in">str</span>, endWord: <span class="built_in">str</span>, wordList: <span class="type">List</span>[<span class="built_in">str</span>]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">str</span>]]:</span></span><br><span class="line">    <span class="keyword">if</span> endWord <span class="keyword">not</span> <span class="keyword">in</span> wordList:</span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line">    </span><br><span class="line">    wordSet = <span class="built_in">set</span>(wordList)</span><br><span class="line">    layer = &#123;&#125;</span><br><span class="line">    layer[beginWord] = [[beginWord]]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> layer:</span><br><span class="line">        new_l = collections.defaultdict(<span class="built_in">list</span>)</span><br><span class="line">        <span class="keyword">for</span> word <span class="keyword">in</span> layer:</span><br><span class="line">            <span class="keyword">if</span> word == endWord:</span><br><span class="line">                <span class="keyword">return</span> layer[word]</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(word)):</span><br><span class="line">                <span class="keyword">for</span> c <span class="keyword">in</span> <span class="string">&#x27;abcdefghijklmnopqrstuvwxyz&#x27;</span>:</span><br><span class="line">                    new_word = word[:i] + c + word[i+<span class="number">1</span>:]</span><br><span class="line">                    <span class="keyword">if</span> new_word <span class="keyword">in</span> wordSet:</span><br><span class="line">                        <span class="comment"># add new word to all sequences and form new layer element</span></span><br><span class="line">                        new_l[new_word] += [j + [new_word] <span class="keyword">for</span> j <span class="keyword">in</span> layer[word]]</span><br><span class="line">        wordSet -= <span class="built_in">set</span>(new_l.keys())</span><br><span class="line">        layer = new_l</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> []</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>934. Shortest Bridge</summary>
<blockquote>
<p>First use DFS find one island, change all cells to 2 in order to differentiate from the other island, and also add the position to the stack. Get the size of the stack, while it is not empty, pop one position from the stack and explore in four directions, if it is not valid or still the same island (==2), continue. If it is 1, then it means we found the island, return the number of steps. Otherwise, we set this empty land to be 2, and append the position to the level. When we run out of current possible movements, we increment the steps by 1, and assign level to the stack.</p>
</blockquote>
<p>Run time: $O(mn)$, space: $O(mn)$</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">shortestBridge</span>(<span class="params">self, grid</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    :type grid: List[List[int]]</span></span><br><span class="line"><span class="string">    :rtype: int</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">grid, i, j, stack</span>):</span></span><br><span class="line">        <span class="keyword">if</span> i &lt; <span class="number">0</span> <span class="keyword">or</span> i &gt;= m <span class="keyword">or</span> j &lt; <span class="number">0</span> <span class="keyword">or</span> j &gt;= n <span class="keyword">or</span> grid[i][j] != <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        grid[i][j] = <span class="number">2</span></span><br><span class="line">        stack.append((i, j))</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">            dfs(grid, i+dirs[k], j+dirs[k+<span class="number">1</span>], stack)</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> grid:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    </span><br><span class="line">    dirs = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, <span class="number">0</span>]</span><br><span class="line">    stack = []</span><br><span class="line">    m,n = <span class="built_in">len</span>(grid), <span class="built_in">len</span>(grid[<span class="number">0</span>])</span><br><span class="line">    found = <span class="literal">False</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">if</span> grid[i][j] == <span class="number">1</span>:</span><br><span class="line">                dfs(grid,i, j, stack)</span><br><span class="line">                found = <span class="literal">True</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span> found:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    </span><br><span class="line">    steps = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> stack:</span><br><span class="line">        size = <span class="built_in">len</span>(stack)</span><br><span class="line">        level = []</span><br><span class="line">        <span class="keyword">while</span> (size):</span><br><span class="line">            x,y = stack.pop()</span><br><span class="line">            size -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">                x1 = x + dirs[i]</span><br><span class="line">                y1 = y + dirs[i+<span class="number">1</span>]</span><br><span class="line">                <span class="keyword">if</span> x1 &lt; <span class="number">0</span> <span class="keyword">or</span> x1 &gt;= m <span class="keyword">or</span> y1 &lt; <span class="number">0</span> <span class="keyword">or</span> y1 &gt;= n <span class="keyword">or</span> grid[x1][y1] == <span class="number">2</span>:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                <span class="keyword">if</span> grid[x1][y1] == <span class="number">1</span>: <span class="comment"># found</span></span><br><span class="line">                    <span class="keyword">return</span> steps</span><br><span class="line">                grid[x1][y1] = <span class="number">2</span></span><br><span class="line">                level.append((x1, y1))</span><br><span class="line">        steps += <span class="number">1</span></span><br><span class="line">        stack = level</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>317. Shortest Distance from All Buildings</summary>
<blockquote>
<p><a href="https://leetcode.com/problems/shortest-distance-from-all-buildings/discuss/963506/Python-BFS-code-with-comments">https://leetcode.com/problems/shortest-distance-from-all-buildings/discuss/963506/Python-BFS-code-with-comments</a></p>
</blockquote>
<p>Run time: $O(N^2M^2)$, space: $O(NM)$, where $N$, $M$ are the number of rows and columns in grid.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">shortestDistance</span>(<span class="params">self, grid: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> grid:</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">    <span class="comment"># create a list of buildings and a set of empty lands for easy search later</span></span><br><span class="line">    build, land = [], <span class="built_in">set</span>()</span><br><span class="line">    <span class="keyword">for</span> x,y <span class="keyword">in</span> itertools.product(<span class="built_in">range</span>(<span class="built_in">len</span>(grid)), <span class="built_in">range</span>(<span class="built_in">len</span>(grid[<span class="number">0</span>]))):</span><br><span class="line">        <span class="keyword">if</span> grid[x][y] == <span class="number">0</span>:</span><br><span class="line">            land.add((x,y))</span><br><span class="line">        <span class="keyword">elif</span> grid[x][y] == <span class="number">1</span>:</span><br><span class="line">            build.append((x,y))</span><br><span class="line">    <span class="comment"># if there is no empty land available, we can&#x27;t proceed further</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> land:</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># create a dictionary where each land&#x27;s position tuple is a key and its value</span></span><br><span class="line">    <span class="comment"># is a list of length equal to the number of buildings we found above. </span></span><br><span class="line">    <span class="comment"># This list is populated with Inf, to start with, that will be updated by the</span></span><br><span class="line">    <span class="comment"># shortest distance between the land and building pair, found by BFS routine below.</span></span><br><span class="line">    d = &#123;x: [<span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)]*<span class="built_in">len</span>(build) <span class="keyword">for</span> x <span class="keyword">in</span> land&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># BFS for a given building&#x27;s location</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">BFS</span>(<span class="params">loc</span>):</span></span><br><span class="line">        x, y = build[loc]</span><br><span class="line">        <span class="comment"># (x,y) is building&#x27;s location on the grid and 0 is the starting distance</span></span><br><span class="line">        q = collections.deque([(x,y,<span class="number">0</span>)]) </span><br><span class="line">        <span class="keyword">while</span> q:</span><br><span class="line">            x, y, dist = q.popleft()</span><br><span class="line">            <span class="keyword">for</span> i, j <span class="keyword">in</span> [(x-<span class="number">1</span>, y), (x+<span class="number">1</span>, y), (x, y-<span class="number">1</span>), (x, y+<span class="number">1</span>)]:</span><br><span class="line">                <span class="comment"># we are interested in only traversing lands whose recorded distance from</span></span><br><span class="line">                <span class="comment"># current building is more than dist+1. We update their distance and include</span></span><br><span class="line">                <span class="comment"># these lands in our queue for the next layer, if that&#x27;s the case</span></span><br><span class="line">                <span class="keyword">if</span> (i,j) <span class="keyword">in</span> land <span class="keyword">and</span> d[(i,j)][loc] &gt; dist + <span class="number">1</span>:</span><br><span class="line">                    d[(i,j)][loc] = dist + <span class="number">1</span></span><br><span class="line">                    q.append((i,j,dist+<span class="number">1</span>))</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># run BFS routine for all buildings</span></span><br><span class="line">    <span class="keyword">for</span> loc <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(build)):</span><br><span class="line">        BFS(loc)</span><br><span class="line">        </span><br><span class="line">    <span class="comment"># compute the shortest distance to all buildings for each empty land</span></span><br><span class="line">    min_dist = <span class="built_in">min</span>(<span class="built_in">sum</span>(d[x]) <span class="keyword">for</span> x <span class="keyword">in</span> land)</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span> <span class="keyword">if</span> min_dist == <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>) <span class="keyword">else</span> min_dist</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>1293. Shortest Path in a Grid with Obstacles Elimination</summary>
<blockquote>
<p>Use BFS like a sonar to explore all possible next steps, and once target is in the explored area, meaning we find a solution. Use a queue to store candidates and a set to store visited positions. Keep track of total steps taken, current position, and quota. If quota is still valid and position is not visited, add it to visited set and the queue.</p>
</blockquote>
<p>Run time: $O(nk)$, where n is the number of cells in the grid, k is the quota, space: $O(nk)$</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">shortestPath</span>(<span class="params">self, grid, k</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    :type grid: List[List[int]]</span></span><br><span class="line"><span class="string">    :type k: int</span></span><br><span class="line"><span class="string">    :rtype: int</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    r, c = <span class="built_in">len</span>(grid), <span class="built_in">len</span>(grid[<span class="number">0</span>])</span><br><span class="line">    target = (r-<span class="number">1</span>, c-<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">if</span> k &gt;= r+c-<span class="number">2</span>: <span class="comment"># if quota is greater than min # steps</span></span><br><span class="line">        <span class="keyword">return</span> r+c-<span class="number">2</span></span><br><span class="line">    </span><br><span class="line">    state = (<span class="number">0</span>, <span class="number">0</span>, k) <span class="comment"># position, and quota</span></span><br><span class="line">    queue = deque([(<span class="number">0</span>, state)]) <span class="comment"># steps taken, position, and quota</span></span><br><span class="line">    visited = <span class="built_in">set</span>([state])</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> queue:</span><br><span class="line">        steps, (row, col, k) = queue.popleft()</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (row, col) == target: <span class="comment"># reach the end</span></span><br><span class="line">            <span class="keyword">return</span> steps</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># explore next steps</span></span><br><span class="line">        <span class="keyword">for</span> new_r, new_c <span class="keyword">in</span> [(row, col+<span class="number">1</span>), (row+<span class="number">1</span>, col), (row, col-<span class="number">1</span>), (row-<span class="number">1</span>, col)]:</span><br><span class="line">            <span class="keyword">if</span> <span class="number">0</span> &lt;= new_r &lt; r <span class="keyword">and</span> <span class="number">0</span> &lt;= new_c &lt; c:</span><br><span class="line">                new_k = k - grid[new_r][new_c] <span class="comment"># unchange if no block here</span></span><br><span class="line">                new_state = (new_r, new_c, new_k)</span><br><span class="line">                <span class="keyword">if</span> new_k &gt;= <span class="number">0</span> <span class="keyword">and</span> new_state <span class="keyword">not</span> <span class="keyword">in</span> visited:</span><br><span class="line">                    visited.add(new_state)</span><br><span class="line">                    queue.append((steps+<span class="number">1</span>, new_state))</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure>
</details>
<h1>DFS</h1>
<details>
<summary></summary>
> 
<p>Run time: $O()$, space: $O()$</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>785. Is Graph Bipartite?</summary>
<blockquote>
<p>We’ll keep an array (or hashmap) to lookup the color of each node: color[node]. The colors could be 0, 1, or uncolored (-1 or null).<br>
We should be careful to consider disconnected components of the graph, by searching each node. For each uncolored node, we’ll start the coloring process by doing a depth-first-search on that node. Every neighbor gets colored the opposite color from the current node. If we find a neighbor colored the same color as the current node, then our coloring was impossible.</p>
</blockquote>
<p>Run time: $O(n+e)$, space: $O(n)$</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isBipartite</span>(<span class="params">self, graph: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">    color = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> node <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(graph)):</span><br><span class="line">        <span class="keyword">if</span> node <span class="keyword">not</span> <span class="keyword">in</span> color:</span><br><span class="line">            stack = [node]</span><br><span class="line">            color[node] = <span class="number">0</span></span><br><span class="line">            <span class="keyword">while</span> stack:</span><br><span class="line">                node = stack.pop()</span><br><span class="line">                <span class="keyword">for</span> neighbor <span class="keyword">in</span> graph[node]:</span><br><span class="line">                    <span class="keyword">if</span> neighbor <span class="keyword">not</span> <span class="keyword">in</span> color:</span><br><span class="line">                        stack.append(neighbor)</span><br><span class="line">                        color[neighbor] = color[node] ^ <span class="number">1</span></span><br><span class="line">                    <span class="keyword">elif</span> color[neighbor] == color[node]:</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>417. Pacific Atlantic Water Flow</summary>
> Use two matrices of the same size to determine whether one position is reachable from the top left and bottom right corner. If the cell from both matrices are true, then it is reachable to both corners. In the helper function, if this position is already marked true, then return. Otherwise, marked it as true, and explore the four neighbors.
<p>Run time: $O(mn)$, space: $O(mn)$</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pacificAtlantic</span>(<span class="params">self, heights</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    :type heights: List[List[int]]</span></span><br><span class="line"><span class="string">    :rtype: List[List[int]]</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    dirs = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, <span class="number">0</span>]</span><br><span class="line">    m, n = <span class="built_in">len</span>(heights), <span class="built_in">len</span>(heights[<span class="number">0</span>])</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">heights, reach, x, y</span>):</span></span><br><span class="line">        <span class="keyword">if</span> reach[x][y]:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        reach[x][y] = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">            next_x, next_y = x+dirs[i], y+dirs[i+<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">if</span> <span class="number">0</span> &lt;= next_x &lt; m <span class="keyword">and</span> <span class="number">0</span> &lt;= next_y &lt; n <span class="keyword">and</span> heights[x][y] &lt;= heights[next_x][next_y]:</span><br><span class="line">                dfs(heights, reach, next_x, next_y)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> heights <span class="keyword">or</span> <span class="built_in">len</span>(heights[<span class="number">0</span>]) == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line">    </span><br><span class="line">    reachable_p = [[<span class="literal">False</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m)] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">    reachable_a = [[<span class="literal">False</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m)] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">    ans = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">        dfs(heights, reachable_p, i, <span class="number">0</span>)</span><br><span class="line">        dfs(heights, reachable_a, i, n-<span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(heights[<span class="number">0</span>])):</span><br><span class="line">        dfs(heights, reachable_p, <span class="number">0</span>, i)</span><br><span class="line">        dfs(heights, reachable_a, m-<span class="number">1</span>, i)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">if</span> reachable_p[i][j] <span class="keyword">and</span> reachable_a[i][j]:</span><br><span class="line">                ans.append([i,j])</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>547. Number of Provinces</summary>
<blockquote>
<p>In order to find the number of connected components in an undirected graph, one of the simplest methods is to make use of Depth First Search starting from every node. We make use of visitedvisited array of size N(M is of size NxN).</p>
</blockquote>
<p>Run time: $O(n^2)$, space: $O(n)$</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findCircleNum</span>(<span class="params">self, isConnected</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    :type isConnected: List[List[int]]</span></span><br><span class="line"><span class="string">    :rtype: int</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">isConnected, i, visited</span>):</span></span><br><span class="line">        visited.add(i)</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(isConnected)):</span><br><span class="line">            <span class="keyword">if</span> isConnected[i][j] == <span class="number">1</span> <span class="keyword">and</span> j <span class="keyword">not</span> <span class="keyword">in</span> visited:</span><br><span class="line">                dfs(isConnected, j, visited)</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> isConnected:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    visited = <span class="built_in">set</span>()</span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(isConnected)):</span><br><span class="line">        <span class="keyword">if</span> i <span class="keyword">not</span> <span class="keyword">in</span> visited:</span><br><span class="line">            dfs(isConnected, i, visited)</span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> count</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>695. Max Area of Island</summary>
> in the helper function, change the grid value from 1 to 0, then call the function again for the four directions plus 1.
<p>Run time: $O(n^2)$, space: $O(1)$</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">maxAreaOfIsland</span>(<span class="params">self, grid</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    :type grid: List[List[int]]</span></span><br><span class="line"><span class="string">    :rtype: int</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">grid, i, j</span>):</span></span><br><span class="line">        <span class="keyword">if</span> i &lt; <span class="number">0</span> <span class="keyword">or</span> i &gt;= <span class="built_in">len</span>(grid) <span class="keyword">or</span> j &lt; <span class="number">0</span> <span class="keyword">or</span> j &gt;= <span class="built_in">len</span>(grid[<span class="number">0</span>]) <span class="keyword">or</span> grid[i][j] == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        grid[i][j] = <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>+dfs(grid,i+<span class="number">1</span>,j)+dfs(grid,i-<span class="number">1</span>,j)+dfs(grid,i,j+<span class="number">1</span>)+dfs(grid,i,j-<span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> grid <span class="keyword">or</span> <span class="built_in">len</span>(grid) == <span class="number">0</span> <span class="keyword">or</span> <span class="built_in">len</span>(grid[<span class="number">0</span>]) == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    max_area = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(grid)):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(grid[<span class="number">0</span>])):</span><br><span class="line">            max_area = <span class="built_in">max</span>(max_area, dfs(grid, i, j))</span><br><span class="line">    <span class="keyword">return</span> max_area</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>827. Making A Large Island</summary>
> 
<p>Run time: $O()$, space: $O()$</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">largestIsland</span>(<span class="params">self, grid: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">    DIR = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, <span class="number">0</span>]</span><br><span class="line">    m, n, nextColor = <span class="built_in">len</span>(grid), <span class="built_in">len</span>(grid[<span class="number">0</span>]), <span class="number">2</span></span><br><span class="line">    componentSize = defaultdict(<span class="built_in">int</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">paint</span>(<span class="params">r, c, color</span>):</span></span><br><span class="line">        <span class="keyword">if</span> r &lt; <span class="number">0</span> <span class="keyword">or</span> r == m <span class="keyword">or</span> c &lt; <span class="number">0</span> <span class="keyword">or</span> c == n <span class="keyword">or</span> grid[r][c] != <span class="number">1</span>: <span class="keyword">return</span></span><br><span class="line">        grid[r][c] = color</span><br><span class="line">        componentSize[color] += <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">            paint(r + DIR[i], c + DIR[i + <span class="number">1</span>], color)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> r <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">if</span> grid[r][c] != <span class="number">1</span>: <span class="keyword">continue</span>  <span class="comment"># Only paint when it&#x27;s an island cell</span></span><br><span class="line">            paint(r, c, nextColor)</span><br><span class="line">            nextColor += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    ans = <span class="built_in">max</span>(componentSize.values() <span class="keyword">or</span> [<span class="number">0</span>])</span><br><span class="line">    <span class="keyword">for</span> r <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">if</span> grid[r][c] != <span class="number">0</span>: <span class="keyword">continue</span></span><br><span class="line">            neiColors = <span class="built_in">set</span>()</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">                nr, nc = r + DIR[i], c + DIR[i + <span class="number">1</span>]</span><br><span class="line">                <span class="keyword">if</span> nr &lt; <span class="number">0</span> <span class="keyword">or</span> nr == m <span class="keyword">or</span> nc &lt; <span class="number">0</span> <span class="keyword">or</span> nc == n <span class="keyword">or</span> grid[nr][nc] == <span class="number">0</span>: <span class="keyword">continue</span></span><br><span class="line">                neiColors.add(grid[nr][nc])</span><br><span class="line">            sizeFormed = <span class="number">1</span>  <span class="comment"># Start with 1, which is matrix[r][c] when turning from 0 into 1</span></span><br><span class="line">            <span class="keyword">for</span> color <span class="keyword">in</span> neiColors:</span><br><span class="line">                sizeFormed += componentSize[color]</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, sizeFormed)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>366. Find Leaves of Binary Tree</summary>
> Create helper function that gets the height of a node. In the function, use post-order traversal to get the height of the left and right child, then set the max of them + 1 as the height of given node. Put <height, node.val> in a dictionary.
<p>Run time: $O(n)$, space: $O(n)$</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findLeaves</span>(<span class="params">self, root: <span class="string">&#x27;TreeNode&#x27;</span></span>) -&gt; &#x27;<span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]&#x27;:</span></span><br><span class="line">    res = []</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">root</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        height = <span class="built_in">max</span>(dfs(root.left), dfs(root.right)) + <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> height &gt;= <span class="built_in">len</span>(res):</span><br><span class="line">            res.append([])</span><br><span class="line">        res[height].append(root.val)</span><br><span class="line">        <span class="keyword">return</span> height</span><br><span class="line">    dfs(root)</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<details>
<summary>my implementation</summary>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findLeaves</span>(<span class="params">self, root</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    :type root: TreeNode</span></span><br><span class="line"><span class="string">    :rtype: List[List[int]]</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    d = &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getHeight</span>(<span class="params">node</span>):</span></span><br><span class="line">        <span class="keyword">if</span> node <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        leftH = getHeight(node.left)</span><br><span class="line">        rightH = getHeight(node.right)</span><br><span class="line">        currH = <span class="built_in">max</span>(leftH, rightH)+<span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> currH <span class="keyword">in</span> d:</span><br><span class="line">            d[currH].append(node.val)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            d[currH] = [node.val]</span><br><span class="line">        <span class="keyword">return</span> currH</span><br><span class="line">    </span><br><span class="line">    ans = []</span><br><span class="line">    getHeight(root)</span><br><span class="line">    <span class="keyword">for</span> k, v <span class="keyword">in</span> d.items():</span><br><span class="line">        ans.append(v)</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
</details>
</details>
<h2 id="Backtracking">Backtracking</h2>
<details>
<summary></summary>
> 
<p>Run time: $O()$, space: $O()$</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>301. Remove Invalid Parentheses</summary>
<blockquote>
<p>BFS.</p>
</blockquote>
<p>Run time: $O(2^n)$, space: $O(2^n)$</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">removeInvalidParentheses</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">str</span>]:</span></span><br><span class="line">    <span class="comment"># initialize a set with one element</span></span><br><span class="line">    <span class="comment"># set is used here in order to avoid duplicate element</span></span><br><span class="line">    level = &#123;s&#125;</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        valid = []</span><br><span class="line">        <span class="keyword">for</span> elem <span class="keyword">in</span> level:</span><br><span class="line">            <span class="keyword">if</span> self.isValid(elem):</span><br><span class="line">                valid.append(elem)</span><br><span class="line">        <span class="keyword">if</span> valid:</span><br><span class="line">            <span class="keyword">return</span> valid</span><br><span class="line">        <span class="comment"># initialize an empty set</span></span><br><span class="line">        new_level = <span class="built_in">set</span>()</span><br><span class="line">        <span class="comment"># BFS</span></span><br><span class="line">        <span class="keyword">for</span> elem <span class="keyword">in</span> level:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(elem)):</span><br><span class="line">                new_level.add(elem[:i] + elem[i + <span class="number">1</span>:])</span><br><span class="line">        level = new_level</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isValid</span>(<span class="params">self,s</span>):</span></span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> c <span class="keyword">in</span> s:</span><br><span class="line">        <span class="keyword">if</span> c == <span class="string">&#x27;(&#x27;</span>:</span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> c == <span class="string">&#x27;)&#x27;</span>:</span><br><span class="line">            count -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> count &lt; <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> count == <span class="number">0</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>Backtracking, DFS</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">removeInvalidParentheses</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">str</span>]:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isValid</span>(<span class="params">s</span>):</span></span><br><span class="line">        stack = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)):</span><br><span class="line">            <span class="keyword">if</span>( s[i] == <span class="string">&#x27;(&#x27;</span> ):</span><br><span class="line">                stack.append( (i,<span class="string">&#x27;(&#x27;</span>) )</span><br><span class="line">            <span class="keyword">elif</span>( s[i] == <span class="string">&#x27;)&#x27;</span> ):</span><br><span class="line">                <span class="keyword">if</span>(stack <span class="keyword">and</span> stack[-<span class="number">1</span>][<span class="number">1</span>] == <span class="string">&#x27;(&#x27;</span>):</span><br><span class="line">                    stack.pop()</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    stack.append( (i,<span class="string">&#x27;)&#x27;</span>) )         <span class="comment"># pushing invalid close braces also</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(stack) == <span class="number">0</span>, stack</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params"> s, left, right</span>):</span></span><br><span class="line">        visited.add(s)</span><br><span class="line">        <span class="keyword">if</span> left == <span class="number">0</span> <span class="keyword">and</span> right == <span class="number">0</span> <span class="keyword">and</span> isValid(s)[<span class="number">0</span>]:  res.append(s)</span><br><span class="line">        <span class="keyword">for</span> i, ch <span class="keyword">in</span> <span class="built_in">enumerate</span>(s):</span><br><span class="line">            <span class="keyword">if</span> ch != <span class="string">&#x27;(&#x27;</span> <span class="keyword">and</span> ch != <span class="string">&#x27;)&#x27;</span>: <span class="keyword">continue</span>                                    <span class="comment"># if it is any other char ignore.</span></span><br><span class="line">            <span class="keyword">if</span> (ch == <span class="string">&#x27;(&#x27;</span> <span class="keyword">and</span> left == <span class="number">0</span>) <span class="keyword">or</span> (ch == <span class="string">&#x27;)&#x27;</span> <span class="keyword">and</span> right == <span class="number">0</span>): <span class="keyword">continue</span>    <span class="comment"># if left == 0 then removing &#x27;(&#x27; will only cause imbalance. Hence, skip.</span></span><br><span class="line">            <span class="keyword">if</span> s[:i] + s[i+<span class="number">1</span>:] <span class="keyword">not</span> <span class="keyword">in</span> visited:</span><br><span class="line">                dfs( s[:i] + s[i+<span class="number">1</span>:], left - (ch == <span class="string">&#x27;(&#x27;</span>), right - (ch == <span class="string">&#x27;)&#x27;</span>) )</span><br><span class="line">    </span><br><span class="line">    stack = isValid(s)[<span class="number">1</span>]</span><br><span class="line">    lc = <span class="built_in">sum</span>([<span class="number">1</span> <span class="keyword">for</span> val <span class="keyword">in</span> stack <span class="keyword">if</span> val[<span class="number">1</span>] == <span class="string">&quot;(&quot;</span>]) <span class="comment"># num of left braces</span></span><br><span class="line">    rc = <span class="built_in">len</span>(stack) - lc</span><br><span class="line">    </span><br><span class="line">    res, visited = [], <span class="built_in">set</span>()</span><br><span class="line">    dfs(s, lc, rc)</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>79. Word Search</summary>
<blockquote>
<p>Go through each entry, and in the helper function, check edge cases. If word length is zero, then it means this word has been found. Set the current entry to be #, call functions in four directions recursively, then reverse the change, return the result.</p>
</blockquote>
<p>Run time: $O(n\cdot 3^L)$, space: $O(L)$, where $n$ is the number of cells in the board, $L$ is the length of the word to be matched, 3 is the number of further choices in the next step</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exist</span>(<span class="params">self, board, word</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    :type board: List[List[str]]</span></span><br><span class="line"><span class="string">    :type word: str</span></span><br><span class="line"><span class="string">    :rtype: bool</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># check whether can find word, start at (i,j) position    </span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">board, i, j, word</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(word) == <span class="number">0</span>: <span class="comment"># all the characters are checked</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">if</span> i&lt;<span class="number">0</span> <span class="keyword">or</span> i&gt;=<span class="built_in">len</span>(board) <span class="keyword">or</span> j&lt;<span class="number">0</span> <span class="keyword">or</span> j&gt;=<span class="built_in">len</span>(board[<span class="number">0</span>]) <span class="keyword">or</span> word[<span class="number">0</span>]!=board[i][j]:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        tmp = board[i][j]  <span class="comment"># first character is found, check the remaining part</span></span><br><span class="line">        board[i][j] = <span class="string">&quot;#&quot;</span>  <span class="comment"># avoid visit agian </span></span><br><span class="line">        <span class="comment"># check whether can find &quot;word&quot; along one direction</span></span><br><span class="line">        res = dfs(board, i+<span class="number">1</span>, j, word[<span class="number">1</span>:]) <span class="keyword">or</span> dfs(board, i-<span class="number">1</span>, j, word[<span class="number">1</span>:]) \</span><br><span class="line">        <span class="keyword">or</span> dfs(board, i, j+<span class="number">1</span>, word[<span class="number">1</span>:]) <span class="keyword">or</span> dfs(board, i, j-<span class="number">1</span>, word[<span class="number">1</span>:])</span><br><span class="line">        board[i][j] = tmp</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> board:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(board)):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(board[<span class="number">0</span>])):</span><br><span class="line">            <span class="keyword">if</span> dfs(board, i, j, word):</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>77. Combinations</summary>
<blockquote>
<p>in the helper function, check whether current combination length equals to k, then append to the answer list. In the for loop, pass the array that skips the current element, the path that combines this element.</p>
</blockquote>
<p>Run time: $O(k {n \choose k})$, space: $O({n \choose k})$</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">combine</span>(<span class="params">self, n, k</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    :type n: int</span></span><br><span class="line"><span class="string">    :type k: int</span></span><br><span class="line"><span class="string">    :rtype: List[List[int]]</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">nums, k, path, ans</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(path) == k:</span><br><span class="line">            ans.append(path)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            dfs(nums[i+<span class="number">1</span>:], k, path+[nums[i]], ans)</span><br><span class="line">            </span><br><span class="line">    ans = []</span><br><span class="line">    dfs(<span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">1</span>, n+<span class="number">1</span>)), k, [], ans)</span><br><span class="line">    <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>46. Permutations</summary>
> `[:]` makes a deep copy of the list. If you passed back the original list, it would be modified by future swaps. Otherwise the reference to the array is appended rather than the actual list.
<p>Run time: $O(\sum_{k=1}^n P(n, k))$, space: $O(n!)$</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">permute</span>(<span class="params">self, nums</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    :type nums: List[int]</span></span><br><span class="line"><span class="string">    :rtype: List[List[int]]</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">backtracking</span>(<span class="params">nums, level, ans</span>):</span></span><br><span class="line">        <span class="keyword">if</span> level == <span class="built_in">len</span>(nums)-<span class="number">1</span>:</span><br><span class="line">            ans.append(nums[:])</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(level, <span class="built_in">len</span>(nums)):</span><br><span class="line">            nums[i], nums[level] = nums[level], nums[i]</span><br><span class="line">            backtracking(nums, level+<span class="number">1</span>, ans)</span><br><span class="line">            nums[i], nums[level] = nums[level], nums[i]</span><br><span class="line">            </span><br><span class="line">            </span><br><span class="line">    ans = []</span><br><span class="line">    backtracking(nums, <span class="number">0</span>, ans)</span><br><span class="line">    <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">permute</span>(<span class="params">self, nums</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(nums) == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> [nums]</span><br><span class="line">    result = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">        others = nums[:i] + nums[i+<span class="number">1</span>:]</span><br><span class="line">        other_permutations = self.permute(others)</span><br><span class="line">        <span class="keyword">for</span> permutation <span class="keyword">in</span> other_permutations:</span><br><span class="line">            result.append([nums[i]] + permutation)</span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>282. Expression Add Operators</summary>
<blockquote>
<p><a href="https://leetcode.com/problems/expression-add-operators/discuss/71968/Clean-Python-DFS-with-comments">https://leetcode.com/problems/expression-add-operators/discuss/71968/Clean-Python-DFS-with-comments</a></p>
</blockquote>
<p>Run time: $O(n\cdot 4^n)$, space: $O(n)$</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">addOperators</span>(<span class="params">self, num, target</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    :type num: str</span></span><br><span class="line"><span class="string">    :type target: int</span></span><br><span class="line"><span class="string">    :rtype: List[str]</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">backtracking</span>(<span class="params">idx=<span class="number">0</span>, path=<span class="string">&#x27;&#x27;</span>, value=<span class="number">0</span>, prev=<span class="literal">None</span></span>):</span></span><br><span class="line">        <span class="keyword">if</span> idx == <span class="built_in">len</span>(num) <span class="keyword">and</span> value == target:</span><br><span class="line">            rtn.append(path)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">    </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(idx+<span class="number">1</span>, <span class="built_in">len</span>(num)+<span class="number">1</span>):</span><br><span class="line">            temp = <span class="built_in">int</span>(num[idx:i])</span><br><span class="line">            <span class="keyword">if</span> i == idx+<span class="number">1</span> <span class="keyword">or</span> (i &gt; idx+<span class="number">1</span> <span class="keyword">and</span> num[idx] != <span class="string">&#x27;0&#x27;</span>):</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> prev:</span><br><span class="line">                    backtracking(i, num[idx:i], temp, temp)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    backtracking(i, path+<span class="string">&#x27;+&#x27;</span>+num[idx:i], value+temp, temp)</span><br><span class="line">                    backtracking(i, path+<span class="string">&#x27;-&#x27;</span>+num[idx:i], value-temp, -temp)</span><br><span class="line">                    backtracking(i, path+<span class="string">&#x27;*&#x27;</span>+num[idx:i], value-prev+prev*temp, prev*temp)</span><br><span class="line">                    </span><br><span class="line">    rtn = []</span><br><span class="line">    backtracking()</span><br><span class="line">    <span class="keyword">return</span> rtn</span><br></pre></td></tr></table></figure>
</details>
<h1>Linked List &amp; Array</h1>
<details>
<summary></summary>
> 
<p>Run time: $O()$, space: $O()$</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>138. Copy List with Random Pointer</summary>
<blockquote>
<p>Instead of a separate dictionary to keep the old node --&gt; new node mapping, we can tweak the original linked list and keep every cloned node next to its original node. This interleaving of old and new nodes allows us to solve this problem without any extra space.</p>
</blockquote>
<p>Run time: $O(n)$, space: $O(1)$</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">copyRandomList</span>(<span class="params">self, head: <span class="string">&#x27;Optional[Node]&#x27;</span></span>) -&gt; &#x27;<span class="type">Optional</span>[Node]&#x27;:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> head:</span><br><span class="line">        <span class="keyword">return</span> head</span><br><span class="line"></span><br><span class="line">    ptr = head</span><br><span class="line">    <span class="keyword">while</span> ptr:</span><br><span class="line">        <span class="comment"># Cloned node</span></span><br><span class="line">        new_node = Node(ptr.val, <span class="literal">None</span>, <span class="literal">None</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Inserting the cloned node just next to the original node.</span></span><br><span class="line">        <span class="comment"># If A-&gt;B-&gt;C is the original linked list,</span></span><br><span class="line">        <span class="comment"># Linked list after weaving cloned nodes would be A-&gt;A&#x27;-&gt;B-&gt;B&#x27;-&gt;C-&gt;C&#x27;</span></span><br><span class="line">        new_node.<span class="built_in">next</span> = ptr.<span class="built_in">next</span></span><br><span class="line">        ptr.<span class="built_in">next</span> = new_node</span><br><span class="line">        ptr = new_node.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">    ptr = head</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Now link the random pointers of the new nodes created.</span></span><br><span class="line">    <span class="comment"># Iterate the newly created list and use the original nodes random pointers,</span></span><br><span class="line">    <span class="comment"># to assign references to random pointers for cloned nodes.</span></span><br><span class="line">    <span class="keyword">while</span> ptr:</span><br><span class="line">        ptr.<span class="built_in">next</span>.random = ptr.random.<span class="built_in">next</span> <span class="keyword">if</span> ptr.random <span class="keyword">else</span> <span class="literal">None</span></span><br><span class="line">        ptr = ptr.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Unweave the linked list to get back the original linked list and the cloned list.</span></span><br><span class="line">    <span class="comment"># i.e. A-&gt;A&#x27;-&gt;B-&gt;B&#x27;-&gt;C-&gt;C&#x27; would be broken to A-&gt;B-&gt;C and A&#x27;-&gt;B&#x27;-&gt;C&#x27;</span></span><br><span class="line">    ptr_old_list = head <span class="comment"># A-&gt;B-&gt;C</span></span><br><span class="line">    ptr_new_list = head.<span class="built_in">next</span> <span class="comment"># A&#x27;-&gt;B&#x27;-&gt;C&#x27;</span></span><br><span class="line">    head_new = head.<span class="built_in">next</span></span><br><span class="line">    <span class="keyword">while</span> ptr_old_list:</span><br><span class="line">        ptr_old_list.<span class="built_in">next</span> = ptr_old_list.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">        ptr_new_list.<span class="built_in">next</span> = ptr_new_list.<span class="built_in">next</span>.<span class="built_in">next</span> <span class="keyword">if</span> ptr_new_list.<span class="built_in">next</span> <span class="keyword">else</span> <span class="literal">None</span></span><br><span class="line">        ptr_old_list = ptr_old_list.<span class="built_in">next</span></span><br><span class="line">        ptr_new_list = ptr_new_list.<span class="built_in">next</span></span><br><span class="line">    <span class="keyword">return</span> head_new</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Using dict.</p>
</blockquote>
<p>Run time: $O(n)$, space: $O(n)$</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">copyRandomList</span>(<span class="params">self, head: <span class="string">&#x27;Optional[Node]&#x27;</span></span>) -&gt; &#x27;<span class="type">Optional</span>[Node]&#x27;:</span></span><br><span class="line">    cache = &#123;&#125;</span><br><span class="line">    new_ptr = dummy = Node(-<span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> head:</span><br><span class="line">        <span class="keyword">if</span> head <span class="keyword">in</span> cache: </span><br><span class="line">            newnode = cache[head]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            newnode = Node(head.val)</span><br><span class="line">            cache[head] = newnode</span><br><span class="line">        new_ptr.<span class="built_in">next</span> = newnode</span><br><span class="line">        new_ptr = new_ptr.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">if</span> head.random:    </span><br><span class="line">            <span class="keyword">if</span> head.random <span class="keyword">in</span> cache: </span><br><span class="line">                new_random = cache[head.random]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                new_random = Node(head.random.val)</span><br><span class="line">                cache[head.random] = new_random</span><br><span class="line">            new_ptr.random = new_random</span><br><span class="line">        head = head.<span class="built_in">next</span></span><br><span class="line">    <span class="keyword">return</span> dummy.<span class="built_in">next</span></span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>339. Nested List Weight Sum</summary>
<blockquote>
<p>DFS.</p>
</blockquote>
<p>Run time: $O(n)$, space: $O(n)$</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">depthSum</span>(<span class="params">self, nestedList: <span class="type">List</span>[NestedInteger]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span>(<span class="params">l, dep</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> l:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">for</span> a <span class="keyword">in</span> l:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> a.isInteger():</span><br><span class="line">                helper(a.getList(), dep+<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                self.depth += a.getInteger() * dep</span><br><span class="line">    </span><br><span class="line">    self.depth = <span class="number">0</span></span><br><span class="line">    helper(nestedList, <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> self.depth</span><br></pre></td></tr></table></figure>
<blockquote>
<p>BFS.</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">depthSum</span>(<span class="params">self, nestedList: <span class="type">List</span>[NestedInteger]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">    queue = deque(nestedList)</span><br><span class="line"></span><br><span class="line">    depth = <span class="number">1</span></span><br><span class="line">    total = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="built_in">len</span>(queue) &gt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(queue)):</span><br><span class="line">            nested = queue.pop()</span><br><span class="line">            <span class="keyword">if</span> nested.isInteger():</span><br><span class="line">                total += nested.getInteger() * depth</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                queue.extendleft(nested.getList())</span><br><span class="line">        depth += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> total</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>148. Sort List</summary>
<blockquote>
<p><a href="https://leetcode.com/problems/sort-list/discuss/46711/Python-easy-to-understand-merge-sort-solution">https://leetcode.com/problems/sort-list/discuss/46711/Python-easy-to-understand-merge-sort-solution</a></p>
</blockquote>
<p>Run time: $O(n\log n)$, space: $O(1)$</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sortList</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span></span><br><span class="line">     <span class="keyword">if</span> <span class="keyword">not</span> head <span class="keyword">or</span> <span class="keyword">not</span> head.<span class="built_in">next</span>:</span><br><span class="line">         <span class="keyword">return</span> head</span><br><span class="line">     fast, slow = head.<span class="built_in">next</span>, head</span><br><span class="line">     <span class="keyword">while</span> fast <span class="keyword">and</span> fast.<span class="built_in">next</span>:</span><br><span class="line">         fast = fast.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">         slow = slow.<span class="built_in">next</span></span><br><span class="line">     start = slow.<span class="built_in">next</span></span><br><span class="line">     slow.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line">     l, r = self.sortList(head), self.sortList(start)</span><br><span class="line">     <span class="keyword">return</span> self.merge(l, r)</span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line"> <span class="function"><span class="keyword">def</span> <span class="title">merge</span>(<span class="params">self, l, r</span>):</span></span><br><span class="line">     <span class="keyword">if</span> <span class="keyword">not</span> l <span class="keyword">or</span> <span class="keyword">not</span> r:</span><br><span class="line">         <span class="keyword">return</span> l <span class="keyword">or</span> r</span><br><span class="line">     <span class="keyword">if</span> l.val &gt; r.val:</span><br><span class="line">         l, r = r, l</span><br><span class="line">     <span class="comment"># get the return node &quot;head&quot;</span></span><br><span class="line">     head = pre = l</span><br><span class="line">     l = l.<span class="built_in">next</span></span><br><span class="line">     <span class="keyword">while</span> l <span class="keyword">and</span> r:</span><br><span class="line">         <span class="keyword">if</span> l.val &lt; r.val:</span><br><span class="line">             pre.<span class="built_in">next</span> = l</span><br><span class="line">             l = l.<span class="built_in">next</span></span><br><span class="line">         <span class="keyword">else</span>:</span><br><span class="line">             pre.<span class="built_in">next</span> = r</span><br><span class="line">             r = r.<span class="built_in">next</span></span><br><span class="line">         pre = pre.<span class="built_in">next</span></span><br><span class="line">     <span class="comment"># l and r at least one is None</span></span><br><span class="line">     pre.<span class="built_in">next</span> = l <span class="keyword">or</span> r</span><br><span class="line">     <span class="keyword">return</span> head</span><br></pre></td></tr></table></figure>
<blockquote>
<p>No recursion.</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sortList</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getsize</span>(<span class="params">head</span>):</span></span><br><span class="line">        c = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> head:</span><br><span class="line">            head = head.<span class="built_in">next</span></span><br><span class="line">            c += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> c</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">split</span>(<span class="params">head, size</span>):</span></span><br><span class="line">        tail = head</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(size-<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> tail:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">            tail = tail.<span class="built_in">next</span></span><br><span class="line">            </span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> tail: <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        next_head, tail.<span class="built_in">next</span> = tail.<span class="built_in">next</span>, <span class="literal">None</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> next_head</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">merge</span>(<span class="params">l1, l2, newtail</span>):</span></span><br><span class="line">        <span class="keyword">while</span> l1 <span class="keyword">and</span> l2:</span><br><span class="line">            <span class="keyword">if</span> l1.val &lt;= l2.val:</span><br><span class="line">                newtail.<span class="built_in">next</span> = l1</span><br><span class="line">                l1 = l1.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                newtail.<span class="built_in">next</span> = l2</span><br><span class="line">                l2 = l2.<span class="built_in">next</span></span><br><span class="line">            newtail = newtail.<span class="built_in">next</span></span><br><span class="line">            </span><br><span class="line">        newtail.<span class="built_in">next</span> = l1 <span class="keyword">or</span> l2</span><br><span class="line">        <span class="keyword">while</span> newtail.<span class="built_in">next</span>:</span><br><span class="line">            newtail = newtail.<span class="built_in">next</span></span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> newtail</span><br><span class="line">    </span><br><span class="line">    length = getsize(head)</span><br><span class="line">    newhead = ListNode(<span class="built_in">next</span>=head)</span><br><span class="line">    size = <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> size &lt; length:</span><br><span class="line">        newtail, cur = newhead, newhead.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            h1 = cur</span><br><span class="line">            h2 = split(h1, size)</span><br><span class="line">            cur = split(h2, size)</span><br><span class="line">            newtail = merge(h1, h2, newtail)</span><br><span class="line">        size *= <span class="number">2</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> newhead.<span class="built_in">next</span></span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>19. Remove Nth Node From End of List</summary>
<blockquote>
<p>One pass. The first pointer advances the list by n+1n+1 steps from the beginning, while the second pointer starts from the beginning of the list. Now, both pointers are exactly separated by nn nodes apart. We maintain this constant gap by advancing both pointers together until the first pointer arrives past the last node. The second pointer will be pointing at the nnth node counting from the last. We relink the next pointer of the node referenced by the second pointer to point to the node’s next next node.</p>
</blockquote>
<p>Run time: $O(n)$, space: $O(1)$</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">removeNthFromEnd</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode], n: <span class="built_in">int</span></span>) -&gt; <span class="type">Optional</span>[ListNode]:</span></span><br><span class="line">    fast = slow = head</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        fast = fast.<span class="built_in">next</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> fast:</span><br><span class="line">        <span class="keyword">return</span> head.<span class="built_in">next</span></span><br><span class="line">    <span class="keyword">while</span> fast.<span class="built_in">next</span>:</span><br><span class="line">        fast = fast.<span class="built_in">next</span></span><br><span class="line">        slow = slow.<span class="built_in">next</span></span><br><span class="line">    slow.<span class="built_in">next</span> = slow.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">    <span class="keyword">return</span> head</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Two pass. First time calculate the length. Second time reduce the count till 0, and remove that node.</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">removeNthFromEnd</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode], n: <span class="built_in">int</span></span>) -&gt; <span class="type">Optional</span>[ListNode]:</span></span><br><span class="line">    ans = ListNode(<span class="number">0</span>)</span><br><span class="line">    ans.<span class="built_in">next</span> = head</span><br><span class="line">    ptr = head</span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> ptr:</span><br><span class="line">        count += <span class="number">1</span></span><br><span class="line">        ptr = ptr.<span class="built_in">next</span></span><br><span class="line">    </span><br><span class="line">    count -= n</span><br><span class="line">    ptr = ans</span><br><span class="line">    <span class="keyword">while</span> count &gt; <span class="number">0</span>:</span><br><span class="line">        count -= <span class="number">1</span></span><br><span class="line">        ptr = ptr.<span class="built_in">next</span></span><br><span class="line">    ptr.<span class="built_in">next</span> = ptr.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">    <span class="keyword">return</span> ans.<span class="built_in">next</span></span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>83. Remove Duplicates from Sorted List</summary>
<blockquote>
<p>Recursion. Set the next element to be the function call. Return head.next if it is the same as head, otherwise return head.</p>
</blockquote>
<p>Run time: $O(n)$, space: $O(1)$</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">deleteDuplicates</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span></span><br><span class="line">    <span class="keyword">if</span> head <span class="keyword">and</span> head.<span class="built_in">next</span>:</span><br><span class="line">        head.<span class="built_in">next</span> = self.deleteDuplicates(head.<span class="built_in">next</span>)</span><br><span class="line">        <span class="keyword">if</span> head.<span class="built_in">next</span>.val == head.val:</span><br><span class="line">            <span class="keyword">return</span> head.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">    <span class="keyword">return</span> head</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Iterative. Remember to put moving head in the else statement.</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">deleteDuplicates</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> head <span class="keyword">or</span> <span class="keyword">not</span> head.<span class="built_in">next</span>:</span><br><span class="line">        <span class="keyword">return</span> head</span><br><span class="line">    </span><br><span class="line">    cur = head</span><br><span class="line">    <span class="keyword">while</span> cur <span class="keyword">and</span> cur.<span class="built_in">next</span>:</span><br><span class="line">        <span class="keyword">if</span> cur.val == cur.<span class="built_in">next</span>.val:</span><br><span class="line">            cur.<span class="built_in">next</span> = cur.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            cur = cur.<span class="built_in">next</span></span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> head</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>234. Palindrome Linked List</summary>
<blockquote>
<p>Recursion. If we iterate the nodes in reverse using recursion, and iterate forward at the same time using a variable outside the recursive function, then we can check whether or not we have a palindrome.</p>
</blockquote>
<p>Run time: $O(n)$, space: $O(n)$</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isPalindrome</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">    self.front_ptr = head</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">recursive_check</span>(<span class="params">node</span>):</span></span><br><span class="line">        <span class="keyword">if</span> node:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> recursive_check(node.<span class="built_in">next</span>):</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">if</span> self.front_ptr.val != node.val:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            self.front_ptr = self.front_ptr.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> recursive_check(head)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Copy into Array List and then Use Two Pointer Technique.</p>
</blockquote>
<p>Run time: $O(n)$, space: $O(n)$</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isPalindrome</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">    vals = []</span><br><span class="line">    <span class="keyword">while</span> head:</span><br><span class="line">        vals.append(head.val)</span><br><span class="line">        head = head.<span class="built_in">next</span></span><br><span class="line">    <span class="keyword">return</span> vals == vals[::-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>160. Intersection of Two Linked Lists</summary>
<blockquote>
<p>If we say that cc is the shared part, aa is exclusive part of list A and bb is exclusive part of list B, then we can have one pointer that goes over a + c + b and the other that goes over b + c + a. Have a look at the diagram below, and this should be fairly intuitive.</p>
</blockquote>
<p>Run time: $O(m+n)$, space: $O(1)$</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getIntersectionNode</span>(<span class="params">self, headA: ListNode, headB: ListNode</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span></span><br><span class="line">    p1, p2 = headA, headB</span><br><span class="line">    <span class="keyword">while</span> p1 != p2:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> p1:</span><br><span class="line">            p1 = headB</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            p1 = p1.<span class="built_in">next</span></span><br><span class="line">            </span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> p2:</span><br><span class="line">            p2 = headA</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            p2 = p2.<span class="built_in">next</span></span><br><span class="line">    <span class="keyword">return</span> p1</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Use set to put all nodes in B. Then loop through A once and see if a node is already in the set.</p>
</blockquote>
<p>Run time: $O(m+n)$, space: $O(m)$</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getIntersectionNode</span>(<span class="params">self, headA: ListNode, headB: ListNode</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span></span><br><span class="line">    s = <span class="built_in">set</span>()</span><br><span class="line">    <span class="keyword">while</span> headB:</span><br><span class="line">        s.add(headB)</span><br><span class="line">        headB = headB.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> headA:</span><br><span class="line">        <span class="keyword">if</span> headA <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">return</span> headA</span><br><span class="line">        headA = headA.<span class="built_in">next</span></span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>Brute force. For each node in A, loop through B and see if two nodes are the same.</p>
</blockquote>
<p>Run time: $O(mn)$, space: $O(1)$</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getIntersectionNode</span>(<span class="params">self, headA: ListNode, headB: ListNode</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span></span><br><span class="line">    <span class="keyword">while</span> headA:</span><br><span class="line">        p = headB</span><br><span class="line">        <span class="keyword">while</span> p:</span><br><span class="line">            <span class="keyword">if</span> headA == p:</span><br><span class="line">                <span class="keyword">return</span> headA</span><br><span class="line">            p = p.<span class="built_in">next</span></span><br><span class="line">        headA = headA.<span class="built_in">next</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>24. Swap Nodes in Pairs</summary>
<blockquote>
<p>Recursive. In every function call we take out two nodes which would be swapped and the remaining nodes are passed to the next recursive call. The reason we are adopting a recursive approach here is because a sub-list of the original list would still be a linked list and hence, it would adapt to our recursive strategy.</p>
</blockquote>
<p>Run time: $O(n)$, space: $O(n)$</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">swapPairs</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span></span><br><span class="line">    <span class="keyword">if</span> head <span class="keyword">and</span> head.<span class="built_in">next</span>:</span><br><span class="line">        temp = head.<span class="built_in">next</span></span><br><span class="line">        head.<span class="built_in">next</span> = self.swapPairs(temp.<span class="built_in">next</span>)</span><br><span class="line">        temp.<span class="built_in">next</span> = head</span><br><span class="line">        <span class="keyword">return</span> temp</span><br><span class="line">    <span class="keyword">return</span> head</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Iterative. We break the linked list into pairs by jumping in steps of two. The only difference is, unlike recursion, we swap the nodes on the go. After swapping a pair of nodes, say A and B, we need to link the node B to the node that was right before A. To establish this linkage we save the previous node of node A in prevNode.</p>
</blockquote>
<p>Run time: $O(n)$, space: $O(1)$</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">swapPairs</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> head <span class="keyword">or</span> <span class="keyword">not</span> head.<span class="built_in">next</span>:</span><br><span class="line">        <span class="keyword">return</span> head</span><br><span class="line">    </span><br><span class="line">    ans = ListNode(<span class="number">0</span>)</span><br><span class="line">    ans.<span class="built_in">next</span> = head</span><br><span class="line">    ptr = ans</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> head <span class="keyword">and</span> head.<span class="built_in">next</span>:</span><br><span class="line">        first = head</span><br><span class="line">        second = head.<span class="built_in">next</span></span><br><span class="line">        </span><br><span class="line">        ptr.<span class="built_in">next</span> = second</span><br><span class="line">        first.<span class="built_in">next</span> = second.<span class="built_in">next</span></span><br><span class="line">        second.<span class="built_in">next</span> = first</span><br><span class="line">        </span><br><span class="line">        ptr = first</span><br><span class="line">        head = first.<span class="built_in">next</span></span><br><span class="line">    <span class="keyword">return</span> ans.<span class="built_in">next</span></span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>21. Merge Two Sorted Lists</summary>
<blockquote>
<p>Iterative.</p>
</blockquote>
<p>Run time: $O(m+n)$, space: $O(m+n)$</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mergeTwoLists</span>(<span class="params">self, list1: <span class="type">Optional</span>[ListNode], list2: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span></span><br><span class="line">    ans = ListNode(<span class="number">0</span>)</span><br><span class="line">    ptr = ans</span><br><span class="line">    <span class="keyword">while</span> list1 <span class="keyword">and</span> list2:</span><br><span class="line">        <span class="keyword">if</span> list1.val &lt; list2.val:</span><br><span class="line">            ans.<span class="built_in">next</span> = list1</span><br><span class="line">            list1 = list1.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">else</span>: <span class="comment"># list1 &gt; list2</span></span><br><span class="line">            ans.<span class="built_in">next</span> = list2</span><br><span class="line">            list2 = list2.<span class="built_in">next</span></span><br><span class="line">        ans = ans.<span class="built_in">next</span></span><br><span class="line">    ans.<span class="built_in">next</span> = list1 <span class="keyword">or</span> list2</span><br><span class="line">    <span class="keyword">return</span> ptr.<span class="built_in">next</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>Recursion. We can recursively define the result of a merge operation on two lists as the following (avoiding the corner case logic surrounding empty lists):</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mergeTwoLists</span>(<span class="params">self, list1: <span class="type">Optional</span>[ListNode], list2: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> list1 <span class="keyword">or</span> <span class="keyword">not</span> list2:</span><br><span class="line">        <span class="keyword">return</span> list1 <span class="keyword">or</span> list2</span><br><span class="line">    <span class="keyword">if</span> list1.val &lt; list2.val:</span><br><span class="line">        list1.<span class="built_in">next</span> = self.mergeTwoLists(list1.<span class="built_in">next</span>, list2)</span><br><span class="line">        <span class="keyword">return</span> list1</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        list2.<span class="built_in">next</span> = self.mergeTwoLists(list1, list2.<span class="built_in">next</span>)</span><br><span class="line">        <span class="keyword">return</span> list2</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>206. Reverse Linked List</summary>
>  Iterative solution. Use one variable prev and one called curr that points to head. While curr is not None, use another variable to store the next node, set the next node of curr to be prev, set prev to be curr, in the end set curr to be the temp variable.
<p>Run time: $O(n)$, space: $O(n)$</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reverseList</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span></span><br><span class="line">    prev, curr = <span class="literal">None</span>, head</span><br><span class="line">    <span class="keyword">while</span> curr:</span><br><span class="line">        temp_next = curr.<span class="built_in">next</span></span><br><span class="line">        curr.<span class="built_in">next</span> = prev</span><br><span class="line">        prev = curr</span><br><span class="line">        curr = temp_next</span><br><span class="line">    <span class="keyword">return</span> prev</span><br></pre></td></tr></table></figure>
<blockquote>
<p>The recursive version is slightly trickier and the key is to work backwards. Assume that the rest of the list had already been reversed, now how do I reverse the front part? Let’s assume the list is: n1 → … → nk-1 → nk → nk+1 → … → nm → Ø<br>
Assume from node nk+1 to nm had been reversed and you are at node nk.whilifans.list<br>
n1 → … → nk-1 → nk → nk+1 ← … ← nm<br>
We want nk+1’s next node to point to nk.<br>
So, nk.next.next = nk;<br>
Be very careful that n1’s next must point to Ø. If you forget about this, your linked list has a cycle in it. This bug could be caught if you test your code with a linked list of size 2.</p>
</blockquote>
<p>Run time: $O(n)$, space: $O(n)$</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reverseList</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> head <span class="keyword">or</span> <span class="keyword">not</span> head.<span class="built_in">next</span>:</span><br><span class="line">        <span class="keyword">return</span> head</span><br><span class="line">    </span><br><span class="line">    temp_next = self.reverseList(head.<span class="built_in">next</span>)</span><br><span class="line">    head.<span class="built_in">next</span>.<span class="built_in">next</span> = head</span><br><span class="line">    head.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line">    <span class="keyword">return</span> temp_next</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>304. Range Sum Query 2D - Immutable</summary>
<blockquote>
<p>Sum(ABCD)=Sum(OD)−Sum(OB)−Sum(OC)+Sum(OA)</p>
</blockquote>
<p>Run time: $O(mn)$, space: $O(mn)$</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumMatrix</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, matrix: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> matrix: <span class="keyword">return</span> </span><br><span class="line">        m, n = <span class="built_in">len</span>(matrix), <span class="built_in">len</span>(matrix[<span class="number">0</span>])</span><br><span class="line">        dp = self.dp = [[<span class="number">0</span>] * (n + <span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m + <span class="number">1</span>)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                dp[i+<span class="number">1</span>][j+<span class="number">1</span>] = dp[i][j+<span class="number">1</span>] + dp[i+<span class="number">1</span>][j] + matrix[i][j] - dp[i][j]</span><br><span class="line">                       </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sumRegion</span>(<span class="params">self, row1: <span class="built_in">int</span>, col1: <span class="built_in">int</span>, row2: <span class="built_in">int</span>, col2: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        dp = self.dp</span><br><span class="line">        <span class="keyword">return</span> dp[row2+<span class="number">1</span>][col2+<span class="number">1</span>] - dp[row2+<span class="number">1</span>][col1] - dp[row1][col2+<span class="number">1</span>] + dp[row1][col1]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Your NumMatrix object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"># obj = NumMatrix(matrix)</span></span><br><span class="line"><span class="comment"># param_1 = obj.sumRegion(row1,col1,row2,col2)</span></span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>303. Range Sum Query - Immutable</summary>
<blockquote>
<p>Store the cumulative sum. Return (right+1)-left.</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumArray</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>):</span></span><br><span class="line">        self.cum_sum = [<span class="number">0</span>]*(<span class="built_in">len</span>(nums)+<span class="number">1</span>)</span><br><span class="line">        self.cum_sum[<span class="number">0</span>] = nums[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            self.cum_sum[i+<span class="number">1</span>] = nums[i]+self.cum_sum[i]</span><br><span class="line">        <span class="built_in">print</span>(self.cum_sum)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sumRange</span>(<span class="params">self, left: <span class="built_in">int</span>, right: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.cum_sum[right+<span class="number">1</span>] - self.cum_sum[left]</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>560. Subarray Sum Equals K</summary>
> Create a dict to store <cumulative sum, count>. In the loop, find if cumulative sum - k is in the dict, then add the value to the count.
<p>Run time: $O(n)$, space: $O(n)$</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">subarraySum</span>(<span class="params">self, nums, k</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    :type nums: List[int]</span></span><br><span class="line"><span class="string">    :type k: int</span></span><br><span class="line"><span class="string">    :rtype: int</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    sums = <span class="number">0</span> <span class="comment"># cumulative sum</span></span><br><span class="line">    d = <span class="built_in">dict</span>()</span><br><span class="line">    d[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">        sums += nums[i]</span><br><span class="line">        count += d.get(sums-k,<span class="number">0</span>)</span><br><span class="line">        d[sums] = d.get(sums,<span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span>(count)</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>1570. Dot Product of Two Sparse Vectors</summary>
> Store the index and nonzero values in a dictionary, and check if the keys in another dict is in this dict as well, the compute the product.
<p>Run time: $O(n)$, space: $O(L)$, where $L$ is the number of nonzero values</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SparseVector</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, nums</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self.d = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i, num <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums):</span><br><span class="line">            self.d[i] = num</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    <span class="comment"># Return the dotProduct of two sparse vectors</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dotProduct</span>(<span class="params">self, vec</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type vec: &#x27;SparseVector&#x27;</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i, num <span class="keyword">in</span> self.d.items():</span><br><span class="line">            <span class="keyword">if</span> i <span class="keyword">in</span> vec.d:</span><br><span class="line">                ans += vec.d[i] * num</span><br><span class="line">        <span class="keyword">return</span> ans</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line"><span class="comment"># Your SparseVector object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"># v1 = SparseVector(nums1)</span></span><br><span class="line"><span class="comment"># v2 = SparseVector(nums2)</span></span><br><span class="line"><span class="comment"># ans = v1.dotProduct(v2)</span></span><br></pre></td></tr></table></figure>
</details>
<h1>Stack</h1>
<details>
<summary></summary>
> 
<p>Run time: $O()$, space: $O()$</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>1047. Remove All Adjacent Duplicates In String
</summary>
<blockquote>
<p>Current string character is equal to the last element in stack? Pop that last element out of stack.<br>
Current string character is not equal to the last element in stack? Add the current character into stack.</p>
</blockquote>
<p>Run time: $O(n)$, space: $O(n-d)$, where $d$ is the number of dup char.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">removeDuplicates</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span></span><br><span class="line">    stack = []</span><br><span class="line">    <span class="keyword">for</span> ch <span class="keyword">in</span> s:</span><br><span class="line">        <span class="keyword">if</span> stack <span class="keyword">and</span> ch == stack[-<span class="number">1</span>]:</span><br><span class="line">            stack.pop()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            stack.append(ch)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&quot;</span>.join(stack)</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>716. Max Stack</summary>
<blockquote>
<p>Create a stack and put [value, current index of the max].</p>
</blockquote>
<p>Run time: $O(n)$ for popMax, $O(1)$ for all other calls, space: $O(n)$</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MaxStack</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.stack = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span>(<span class="params">self, x: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.stack <span class="keyword">and</span> x &gt;= self.stack[self.stack[-<span class="number">1</span>][<span class="number">1</span>]][<span class="number">0</span>]:</span><br><span class="line">            i = <span class="built_in">len</span>(self.stack)  <span class="comment"># index of max</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> self.stack:</span><br><span class="line">                i = self.stack[-<span class="number">1</span>][<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">else</span>: </span><br><span class="line">                i = <span class="number">0</span></span><br><span class="line">        self.stack.append((x, i))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.stack.pop()[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">top</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.stack[-<span class="number">1</span>][<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">peekMax</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.stack[self.stack[-<span class="number">1</span>][<span class="number">1</span>]][<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">popMax</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        index = self.stack[-<span class="number">1</span>][<span class="number">1</span>]  <span class="comment"># index where the max exists</span></span><br><span class="line">        result = self.stack[index][<span class="number">0</span>]  <span class="comment"># max value to return</span></span><br><span class="line">        <span class="keyword">if</span> index &gt; <span class="number">0</span>:</span><br><span class="line">            new_max = self.stack[self.stack[index-<span class="number">1</span>][<span class="number">1</span>]][<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            new_max = -<span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)</span><br><span class="line">        <span class="comment"># Scan the stack starting at &#x27;index&#x27; to recompute the max values and shift all</span></span><br><span class="line">        <span class="comment"># values to the left by one:</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(index, <span class="built_in">len</span>(self.stack)-<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> self.stack[i+<span class="number">1</span>][<span class="number">0</span>] &gt;= new_max:</span><br><span class="line">                new_max = self.stack[i+<span class="number">1</span>][<span class="number">0</span>]</span><br><span class="line">                self.stack[i] = (self.stack[i+<span class="number">1</span>][<span class="number">0</span>], i)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                self.stack[i] = (self.stack[i+<span class="number">1</span>][<span class="number">0</span>], self.stack[i-<span class="number">1</span>][<span class="number">1</span>])</span><br><span class="line">        self.stack.pop()</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>772. Basic Calculator III</summary>
<blockquote>
<p>It is much easier to implement the solution if you build the BNF grammar.<br>
inspired by <a href="https://leetcode.com/problems/build-binary-expression-tree-from-infix-expression/discuss/864596/Python-Standard-parser-implementation">https://leetcode.com/problems/build-binary-expression-tree-from-infix-expression/discuss/864596/Python-Standard-parser-implementation</a></p>
</blockquote>
<p>Run time: $O(n)$, space: $O(n)$</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calculate</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">parse_factor</span>(<span class="params">dq</span>):</span></span><br><span class="line">        <span class="keyword">if</span> dq[<span class="number">0</span>].isdigit():</span><br><span class="line">            curr = <span class="number">0</span></span><br><span class="line">            <span class="keyword">while</span> dq <span class="keyword">and</span> dq[<span class="number">0</span>].isdigit():</span><br><span class="line">                curr = curr * <span class="number">10</span> + <span class="built_in">int</span>(dq[<span class="number">0</span>])</span><br><span class="line">                dq.popleft()</span><br><span class="line">            <span class="keyword">return</span> curr</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            dq.popleft()</span><br><span class="line">            tmp = parse_expr(dq)</span><br><span class="line">            dq.popleft()</span><br><span class="line">            <span class="keyword">return</span> tmp</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">parse_term</span>(<span class="params">dq</span>):</span></span><br><span class="line">        lhs = parse_factor(dq)</span><br><span class="line">        <span class="keyword">while</span> dq <span class="keyword">and</span> dq[<span class="number">0</span>] <span class="keyword">in</span> <span class="string">&quot;*/&quot;</span>:</span><br><span class="line">            op = dq.popleft()</span><br><span class="line">            rhs = parse_factor(dq)</span><br><span class="line">            <span class="keyword">if</span> op == <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">                lhs = lhs * rhs </span><br><span class="line">            <span class="keyword">else</span>: </span><br><span class="line">                lhs = <span class="built_in">int</span>(lhs/rhs) <span class="comment"># for this case &quot;(0-3)/4&quot;</span></span><br><span class="line">        <span class="keyword">return</span> lhs</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">parse_expr</span>(<span class="params">dq</span>):</span></span><br><span class="line">        lhs = parse_term(dq)</span><br><span class="line">        <span class="keyword">while</span> dq <span class="keyword">and</span> dq[<span class="number">0</span>] <span class="keyword">in</span> [<span class="string">&#x27;+&#x27;</span>, <span class="string">&#x27;-&#x27;</span>]:</span><br><span class="line">            op = dq.popleft()</span><br><span class="line">            rhs = parse_term(dq)</span><br><span class="line">            lhs = lhs + rhs <span class="keyword">if</span> op == <span class="string">&#x27;+&#x27;</span> <span class="keyword">else</span> lhs - rhs</span><br><span class="line">        <span class="keyword">return</span> lhs</span><br><span class="line">    </span><br><span class="line">    dq = deque(<span class="built_in">list</span>(s))</span><br><span class="line">    <span class="keyword">return</span> parse_expr(dq)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Recursion. <a href="https://leetcode.com/problems/basic-calculator-iii/discuss/371346/Python-recursive-solution">https://leetcode.com/problems/basic-calculator-iii/discuss/371346/Python-recursive-solution</a></p>
</blockquote>
<p>Run time: $O(n)$, space: $O(n)$</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calculate</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getSubExpr</span>(<span class="params">s</span>):</span></span><br><span class="line">        left = <span class="number">1</span></span><br><span class="line">        x = []</span><br><span class="line">        <span class="keyword">while</span> left != <span class="number">0</span>:</span><br><span class="line">            x.append(<span class="built_in">next</span>(s))</span><br><span class="line">            <span class="keyword">if</span> x[-<span class="number">1</span>] == <span class="string">&#x27;(&#x27;</span>:</span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> x[-<span class="number">1</span>] == <span class="string">&#x27;)&#x27;</span>:</span><br><span class="line">                left -= <span class="number">1</span></span><br><span class="line">        <span class="comment"># print(x[:-1])</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>.join(x[:-<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">    s = <span class="built_in">iter</span>(re.findall(<span class="string">&#x27;\d+|\S&#x27;</span>, s))</span><br><span class="line">    operand, sign = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">    total = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> token <span class="keyword">in</span> s:</span><br><span class="line">        <span class="comment"># print(token, operand, sign, total)</span></span><br><span class="line">        <span class="keyword">if</span> token <span class="keyword">in</span> <span class="string">&#x27;+-&#x27;</span>:</span><br><span class="line">            total += sign * operand</span><br><span class="line">            sign = [<span class="number">1</span>, -<span class="number">1</span>][token == <span class="string">&#x27;-&#x27;</span>]</span><br><span class="line">        <span class="keyword">elif</span> token <span class="keyword">in</span> <span class="string">&#x27;/*&#x27;</span>:</span><br><span class="line">            n = <span class="built_in">next</span>(s)</span><br><span class="line">            n = self.calculate(getSubExpr(s)) <span class="keyword">if</span> n == <span class="string">&#x27;(&#x27;</span> <span class="keyword">else</span> <span class="built_in">int</span>(n)</span><br><span class="line">            operand = operand*n <span class="keyword">if</span> token == <span class="string">&#x27;*&#x27;</span> <span class="keyword">else</span> operand/n</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            operand = self.calculate(getSubExpr(s)) <span class="keyword">if</span> token == <span class="string">&#x27;(&#x27;</span> <span class="keyword">else</span> <span class="built_in">int</span>(token)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">int</span>(total + sign * operand)</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>503. Next Greater Element II</summary>
<blockquote>
<p>This approach makes use of a stack. This stack stores the indices of the appropriate elements from numsnums array. The top of the stack refers to the index of the Next Greater Element found so far. We store the indices instead of the elements since there could be duplicates in the numsnums array. The description of the method will make the above statement clearer.</p>
</blockquote>
<p>We start traversing the numsnums array from right towards the left. For an element nums[i] encountered, we pop all the elements stack[top]stack[top] from the stack such that num[stack[top]] ≤ nums[i]. We continue the popping till we encounter a stack[top] satisfying nums[stack[top]]&gt;nums[i]. Now, it is obvious that the current stack[top] only can act as the Next Greater Element for nums[i](right now, considering only the elements lying to the right of nums[i]).</p>
<p>If no element remains on the top of the stack, it means no larger element than nums[i]nums[i] exists to its right. Along with this, we also push the index of the element just encountered(nums[i]), i.e. ii over the top of the stack, so that nums[i](or stack[top]) now acts as the Next Greater Element for the elements lying to its left.</p>
<p>We go through two such passes over the complete nums array. This is done so as to complete a circular traversal over the nums array. The first pass could make some wrong entries in the res array since it considers only the elements lying to the right of nums[i], without a circular traversal. But, these entries are corrected in the second pass.</p>
<p>Run time: $O(n)$, space: $O(n)$</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">nextGreaterElements</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span></span><br><span class="line">    stack, r = [], [-<span class="number">1</span>] * <span class="built_in">len</span>(nums)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">        <span class="keyword">while</span> stack <span class="keyword">and</span> (nums[stack[-<span class="number">1</span>]] &lt; nums[i]):</span><br><span class="line">            r[stack.pop()] = nums[i]</span><br><span class="line">        stack.append(i)</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">        <span class="keyword">while</span> stack <span class="keyword">and</span> (nums[stack[-<span class="number">1</span>]] &lt; nums[i]):</span><br><span class="line">            r[stack.pop()] = nums[i]</span><br><span class="line">        <span class="keyword">if</span> stack == []:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">return</span> r</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>739. Daily Temperatures</summary>
<blockquote>
<p>At each index currDay, check if the current day is the hottest one seen so far. If it is, update hottest and move on. Otherwise, do the following:</p>
</blockquote>
<ul>
<li>Initialize a variable days = 1 because the next warmer day must be at least one day in the future.</li>
<li>While temperatures[currDay + days] &lt;= temperatures[currDay]:</li>
<li>Add answer[currDay + days] to days. This effectively jumps directly to the next warmer day.</li>
<li>Set answer[currDay] = days.</li>
</ul>
<p>Run time: $O(n)$, space: $O(1)$</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dailyTemperatures</span>(<span class="params">self, temperatures: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span></span><br><span class="line">    n = <span class="built_in">len</span>(temperatures)</span><br><span class="line">    hot = <span class="number">0</span></span><br><span class="line">    ans = [<span class="number">0</span>] * n</span><br><span class="line">    <span class="keyword">for</span> curr_day <span class="keyword">in</span> <span class="built_in">range</span>(n-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>):</span><br><span class="line">        temp = temperatures[curr_day]</span><br><span class="line">        <span class="keyword">if</span> temp &gt;= hot:</span><br><span class="line">            hot = temp</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        </span><br><span class="line">        days = <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> temperatures[curr_day+days] &lt;= temp:</span><br><span class="line">            days += ans[curr_day+days]</span><br><span class="line">        </span><br><span class="line">        ans[curr_day] = days</span><br><span class="line">    <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<blockquote>
<p>If the stack is not empty, that means there are previous days for which we have not yet seen a warmer day.</p>
</blockquote>
<p>Run time: $O(n)$, space: $O(n)$</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dailyTemperatures</span>(<span class="params">self, temperatures: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span></span><br><span class="line">    n = <span class="built_in">len</span>(temperatures)</span><br><span class="line">    ans = [<span class="number">0</span>] * n</span><br><span class="line">    stack = []</span><br><span class="line">    <span class="keyword">for</span> day, temp <span class="keyword">in</span> <span class="built_in">enumerate</span>(temperatures):</span><br><span class="line">        <span class="keyword">while</span> stack <span class="keyword">and</span> temperatures[stack[-<span class="number">1</span>]] &lt; temp:</span><br><span class="line">            prev_day = stack.pop()</span><br><span class="line">            ans[prev_day] = day - prev_day</span><br><span class="line">        stack.append(day)</span><br><span class="line">    <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>20. Valid Parentheses</summary>
<blockquote>
<p>Pop the last element from the stack only if stack is not empty and the last element matches in the pair. In the end, check if stack is empty or not.</p>
</blockquote>
<p>Run time: $O(n)$, space: $O(n)$</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isValid</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">    stack = []</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(s) == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> c <span class="keyword">in</span> s:</span><br><span class="line">        <span class="keyword">if</span> stack <span class="keyword">and</span> c==<span class="string">&#x27;]&#x27;</span> <span class="keyword">and</span> stack[-<span class="number">1</span>]==<span class="string">&#x27;[&#x27;</span>:</span><br><span class="line">            stack.pop()</span><br><span class="line">        <span class="keyword">elif</span> stack <span class="keyword">and</span> c==<span class="string">&#x27;&#125;&#x27;</span> <span class="keyword">and</span> stack[-<span class="number">1</span>]==<span class="string">&#x27;&#123;&#x27;</span>:</span><br><span class="line">            stack.pop()</span><br><span class="line">        <span class="keyword">elif</span> stack <span class="keyword">and</span> c==<span class="string">&#x27;)&#x27;</span> <span class="keyword">and</span> stack[-<span class="number">1</span>]==<span class="string">&#x27;(&#x27;</span>:</span><br><span class="line">            stack.pop()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            stack.append(c)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">len</span>(stack)==<span class="number">0</span></span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>155. Min Stack</summary>
> Create a list. Keep track of current element, and the min element so far.
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.stack = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span>(<span class="params">self, val: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.stack:</span><br><span class="line">            self.stack.append((val,val))</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        min_val = self.stack[-<span class="number">1</span>][-<span class="number">1</span>]</span><br><span class="line">        self.stack.append((val,<span class="built_in">min</span>(val, min_val)))</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span>(<span class="params">self</span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">        self.stack.pop()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">top</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.stack[-<span class="number">1</span>][<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getMin</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.stack[-<span class="number">1</span>][<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<blockquote>
<p>two list, one normal list, one containing min element.</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.stack = []</span><br><span class="line">        self.min_stack = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span>(<span class="params">self, val: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">        self.stack.append(val)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.min_stack <span class="keyword">or</span> val &lt;= self.min_stack[-<span class="number">1</span>]:</span><br><span class="line">            self.min_stack.append(val)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span>(<span class="params">self</span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.min_stack[-<span class="number">1</span>] == self.stack[-<span class="number">1</span>]:</span><br><span class="line">            self.min_stack.pop()</span><br><span class="line">        self.stack.pop()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">top</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.stack[-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getMin</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.min_stack[-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>227. Basic Calculator II</summary>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calculate</span>(<span class="params">self, s</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    :type s: str</span></span><br><span class="line"><span class="string">    :rtype: int</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    num, stack, sign = <span class="number">0</span>, [], <span class="string">&quot;+&quot;</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)):</span><br><span class="line">        <span class="keyword">if</span> s[i].isdigit():</span><br><span class="line">            num = num * <span class="number">10</span> + <span class="built_in">int</span>(s[i])</span><br><span class="line">        <span class="keyword">if</span> s[i] <span class="keyword">in</span> <span class="string">&quot;+-*/&quot;</span> <span class="keyword">or</span> i == <span class="built_in">len</span>(s) - <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">if</span> sign == <span class="string">&quot;+&quot;</span>:</span><br><span class="line">                stack.append(num)</span><br><span class="line">            <span class="keyword">elif</span> sign == <span class="string">&quot;-&quot;</span>:</span><br><span class="line">                stack.append(-num)</span><br><span class="line">            <span class="keyword">elif</span> sign == <span class="string">&quot;*&quot;</span>:</span><br><span class="line">                stack.append(stack.pop()*num)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                stack.append(<span class="built_in">int</span>(stack.pop()/num))</span><br><span class="line">            num = <span class="number">0</span></span><br><span class="line">            sign = s[i]</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sum</span>(stack)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Stack. Use helper function <code>update</code> to append the operation result.</p>
</blockquote>
<p>Run time: $O(n)$, space: $O(n)$</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calculate</span>(<span class="params">self, s</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    :type s: str</span></span><br><span class="line"><span class="string">    :rtype: int</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">calc</span>(<span class="params">it</span>):</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">update</span>(<span class="params">op, v</span>):</span></span><br><span class="line">            <span class="keyword">if</span> op == <span class="string">&quot;+&quot;</span>: stack.append(v)</span><br><span class="line">            <span class="keyword">if</span> op == <span class="string">&quot;-&quot;</span>: stack.append(-v)</span><br><span class="line">            <span class="keyword">if</span> op == <span class="string">&quot;*&quot;</span>: stack.append(stack.pop() * v)</span><br><span class="line">            <span class="keyword">if</span> op == <span class="string">&quot;/&quot;</span>: stack.append(<span class="built_in">int</span>(stack.pop() / v))</span><br><span class="line">    </span><br><span class="line">        num, stack, sign = <span class="number">0</span>, [], <span class="string">&quot;+&quot;</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> it &lt; <span class="built_in">len</span>(s):</span><br><span class="line">            <span class="keyword">if</span> s[it].isdigit():</span><br><span class="line">                num = num * <span class="number">10</span> + <span class="built_in">int</span>(s[it])</span><br><span class="line">            <span class="keyword">elif</span> s[it] <span class="keyword">in</span> <span class="string">&quot;+-*/&quot;</span>:</span><br><span class="line">                update(sign, num)</span><br><span class="line">                num, sign = <span class="number">0</span>, s[it]</span><br><span class="line">            <span class="keyword">elif</span> s[it] == <span class="string">&quot;(&quot;</span>:</span><br><span class="line">                num, j = calc(it + <span class="number">1</span>)</span><br><span class="line">                it = j - <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> s[it] == <span class="string">&quot;)&quot;</span>:</span><br><span class="line">                update(sign, num)</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">sum</span>(stack), it + <span class="number">1</span></span><br><span class="line">            it += <span class="number">1</span></span><br><span class="line">        update(sign, num)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sum</span>(stack)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> calc(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<details>
<summary>my approach</summary>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calculate</span>(<span class="params">self, s</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    :type s: str</span></span><br><span class="line"><span class="string">    :rtype: int</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    stack = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)):</span><br><span class="line">        a = s[i]</span><br><span class="line">        <span class="keyword">if</span> a <span class="keyword">in</span> <span class="string">&quot;+-*/&quot;</span>:</span><br><span class="line">            stack.append(a)</span><br><span class="line">        <span class="keyword">elif</span> a.isnumeric():</span><br><span class="line">            j = i+<span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> j &lt; <span class="built_in">len</span>(s) <span class="keyword">and</span> s[j].isnumeric():</span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">            a = <span class="built_in">int</span>(s[i:j])</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(stack) &gt; <span class="number">1</span> <span class="keyword">and</span> stack[-<span class="number">1</span>] <span class="keyword">in</span> <span class="string">&quot;*/&quot;</span>:</span><br><span class="line">                op = stack.pop()</span><br><span class="line">                num = stack.pop()</span><br><span class="line">                <span class="keyword">if</span> op == <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">                    num *= a</span><br><span class="line">                <span class="keyword">elif</span> op == <span class="string">&#x27;/&#x27;</span>:</span><br><span class="line">                    num /= a</span><br><span class="line">                stack.append(num)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                stack.append(a)</span><br><span class="line">            </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> <span class="built_in">len</span>(stack) &gt; <span class="number">2</span>:</span><br><span class="line">        num2 = stack.pop()</span><br><span class="line">        op = stack.pop()</span><br><span class="line">        num1 = stack.pop()</span><br><span class="line">        <span class="keyword">if</span> op == <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">            num1 += num2</span><br><span class="line">        <span class="keyword">elif</span> op == <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">            num1 -= num2</span><br><span class="line">        stack.append(num1)</span><br><span class="line">    <span class="keyword">return</span> stack.pop()</span><br></pre></td></tr></table></figure>
</details>
</details>
<details>
<summary>71. Simplify Path</summary>
> First split the string by `/` and remove `.` and empty string, then create a stack to append each element, or pop from the nonempty stack if we see `..`.
<p>Run time: $O(n)$, space: $O(n)$</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">simplifyPath</span>(<span class="params">self, path</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    :type path: str</span></span><br><span class="line"><span class="string">    :rtype: str</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    places = [p <span class="keyword">for</span> p <span class="keyword">in</span> path.split(<span class="string">&quot;/&quot;</span>) <span class="keyword">if</span> p!=<span class="string">&quot;.&quot;</span> <span class="keyword">and</span> p!=<span class="string">&quot;&quot;</span>]</span><br><span class="line">    stack = []</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> p <span class="keyword">in</span> places:</span><br><span class="line">        <span class="keyword">if</span> p == <span class="string">&quot;..&quot;</span>:</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(stack) &gt; <span class="number">0</span>:</span><br><span class="line">                stack.pop()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            stack.append(p)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;/&quot;</span> + <span class="string">&quot;/&quot;</span>.join(stack)</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>735. Asteroid Collision</summary>
> Put every positive asteroid to a stack, if the next one is negative, compare if the absolute value is greater, then pop the top element since it will be collapsed. Keep doing this until stack is empty.
<p>Run time: $O(n)$, space: $O(n)$</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">asteroidCollision</span>(<span class="params">self, asteroids</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    :type asteroids: List[int]</span></span><br><span class="line"><span class="string">    :rtype: List[int]</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    ans = []</span><br><span class="line">    <span class="keyword">for</span> a <span class="keyword">in</span> asteroids:</span><br><span class="line">        <span class="keyword">while</span> ans <span class="keyword">and</span> a &lt; <span class="number">0</span> &lt; ans[-<span class="number">1</span>]: <span class="comment"># opposite direction</span></span><br><span class="line">            <span class="keyword">if</span> ans[-<span class="number">1</span>] &lt; -a: <span class="comment"># new asteroid is greater than existing one</span></span><br><span class="line">                ans.pop()</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">elif</span> ans[-<span class="number">1</span>] == -a:</span><br><span class="line">                ans.pop()</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            ans.append(a)</span><br><span class="line">    <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>1762. Buildings With an Ocean View</summary>
> Check from right to left and record the max height.
<p>Run time: $O(n)$, space: $O(n)$</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findBuildings</span>(<span class="params">self, heights: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span></span><br><span class="line">    res = collections.deque([<span class="built_in">len</span>(heights) - <span class="number">1</span>])</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(heights) - <span class="number">2</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">if</span> heights[i] &gt; heights[res[<span class="number">0</span>]]:</span><br><span class="line">            res.appendleft(i)</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<details>
<summary>my implementation</summary>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findBuildings</span>(<span class="params">self, heights</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    :type heights: List[int]</span></span><br><span class="line"><span class="string">    :rtype: List[int]</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(heights) == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> [heights[<span class="number">0</span>]]</span><br><span class="line"></span><br><span class="line">    curr_max = heights[-<span class="number">1</span>]</span><br><span class="line">    ans = [<span class="built_in">len</span>(heights)-<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(heights)-<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">        curr_h = heights[i]</span><br><span class="line">        <span class="keyword">if</span> curr_h &gt; curr_max:</span><br><span class="line">            ans.append(i)</span><br><span class="line">            curr_max = curr_h</span><br><span class="line">    <span class="keyword">return</span> ans[::-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
</details>
</details>
<h1>2 Pointers</h1>
<details>
<summary></summary>
> 
<p>Run time: $O()$, space: $O()$</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>125. Valid Palindrome</summary>
<blockquote>
<p>two pointers.</p>
</blockquote>
<p>Run time: $O(n)$, space: $O(1)$</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isPalindrome</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">    i, j = <span class="number">0</span>, <span class="built_in">len</span>(s) - <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> i &lt; j:</span><br><span class="line">        <span class="keyword">while</span> i &lt; j <span class="keyword">and</span> <span class="keyword">not</span> s[i].isalnum():</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; j <span class="keyword">and</span> <span class="keyword">not</span> s[j].isalnum():</span><br><span class="line">            j -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> s[i].lower() != s[j].lower():</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">        j -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>Copy updated string to another variable and reverse.</p>
</blockquote>
<p>Run time: $O(n)$, space: $O(n)$</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isPalindrome</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">    string = <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">for</span> c <span class="keyword">in</span> s:</span><br><span class="line">        <span class="keyword">if</span> c.isalnum():</span><br><span class="line">            string += c.lower()</span><br><span class="line">    <span class="keyword">return</span> string == string[::-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>202. Happy Number</summary>
<blockquote>
<p>Floyd’s Cycle-Finding Algorithm<br>
Regardless of where the tortoise and hare start in the cycle, they are guaranteed to eventually meet. This is because the hare moves one node closer to the tortoise (in their direction of movement) each step.</p>
</blockquote>
<p>Instead of keeping track of just one value in the chain, we keep track of 2, called the slow runner and the fast runner. At each step of the algorithm, the slow runner goes forward by 1 number in the chain, and the fast runner goes forward by 2 numbers (nested calls to the getNext(n) function).</p>
<p>Run time: $O(\log n)$, space: $O(1)$</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isHappy</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_next</span>(<span class="params">number</span>):</span></span><br><span class="line">        total_sum = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> number &gt; <span class="number">0</span>:</span><br><span class="line">            number, digit = <span class="built_in">divmod</span>(number, <span class="number">10</span>)</span><br><span class="line">            total_sum += digit ** <span class="number">2</span></span><br><span class="line">        <span class="keyword">return</span> total_sum</span><br><span class="line"></span><br><span class="line">    slow_runner = n</span><br><span class="line">    fast_runner = get_next(n)</span><br><span class="line">    <span class="keyword">while</span> fast_runner != <span class="number">1</span> <span class="keyword">and</span> slow_runner != fast_runner:</span><br><span class="line">        slow_runner = get_next(slow_runner)</span><br><span class="line">        fast_runner = get_next(get_next(fast_runner))</span><br><span class="line">    <span class="keyword">return</span> fast_runner == <span class="number">1</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>Helper function that find the next number, keep calling this until the number is in the set or it equals 1.<br>
Run time: $O(\log n)$, space: $O(\log n)$</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isHappy</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    s = <span class="built_in">set</span>()</span><br><span class="line">    <span class="keyword">while</span> n <span class="keyword">not</span> <span class="keyword">in</span> s:</span><br><span class="line">        s.add(n)</span><br><span class="line">        temp_sum = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> n &gt; <span class="number">0</span>:</span><br><span class="line">            temp_sum += (n % <span class="number">10</span>)**<span class="number">2</span></span><br><span class="line">            n //= <span class="number">10</span></span><br><span class="line">        <span class="keyword">if</span> temp_sum == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        n = temp_sum</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>31. Next Permutation</summary>
> First find the point where the descending sub-array starts, and then find the last ascending position, swap them, and swap the elements from the start descending position to the end.
<p>Run time: $O(n)$, space: $O(1)$</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">nextPermutation</span>(<span class="params">self, nums</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    :type nums: List[int]</span></span><br><span class="line"><span class="string">    :rtype: None Do not return anything, modify nums in-place instead.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    i = <span class="built_in">len</span>(nums)-<span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> nums[i-<span class="number">1</span>] &gt;= nums[i]:</span><br><span class="line">        i -= <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> i == <span class="number">0</span>:</span><br><span class="line">        nums.reverse()</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># find the last ascending position</span></span><br><span class="line">    i, j = i-<span class="number">1</span>, <span class="built_in">len</span>(nums)-<span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> nums[j] &lt;= nums[i]:</span><br><span class="line">        j -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># reverse</span></span><br><span class="line">    nums[i], nums[j] = nums[j], nums[i]</span><br><span class="line">    l = i+<span class="number">1</span></span><br><span class="line">    r = <span class="built_in">len</span>(nums)-<span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> l &lt; r:</span><br><span class="line">        nums[l], nums[r] = nums[r], nums[l]</span><br><span class="line">        l, r = l+<span class="number">1</span>, r-<span class="number">1</span></span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>680. Valid Palindrome II</summary>
> Use 2 pointers to walk through the string, if not match, then check if removing either start or end character might be palindrome. Then update the pointers.
<p>Run time: $O(n)$, space: $O(1)$</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">validPalindrome</span>(<span class="params">self, s</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    :type s: str</span></span><br><span class="line"><span class="string">    :rtype: bool</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isPalindrome</span>(<span class="params">s</span>):</span></span><br><span class="line">        <span class="keyword">return</span> s == s[::-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">    start, end = <span class="number">0</span>, <span class="built_in">len</span>(s)-<span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> start &lt; end:</span><br><span class="line">        <span class="keyword">if</span> s[start] != s[end]:</span><br><span class="line">            op_1 = s[start+<span class="number">1</span>:end+<span class="number">1</span>] <span class="comment"># remove start</span></span><br><span class="line">            op_2 = s[start:end] <span class="comment"># remove end</span></span><br><span class="line">            <span class="keyword">return</span> isPalindrome(op_1) <span class="keyword">or</span> isPalindrome(op_2)</span><br><span class="line">        start += <span class="number">1</span></span><br><span class="line">        end -= <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>
</details>
<h1>Hash &amp; Heap</h1>
<details>
<summary></summary>
> 
<p>Run time: $O()$, space: $O()$</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>498. Diagonal Traverse</summary>
<blockquote>
<p>Create a dictionary, and use the sum of indices as key, and list of values as values. Reverse the list and append to output array if the key is odd.</p>
</blockquote>
<p>Run time: $O(mn)$, space: $O(mn)$</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">d = defaultdict(<span class="built_in">list</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(mat)):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(mat[<span class="number">0</span>])):</span><br><span class="line">        d[i+j].append(mat[i][j])</span><br><span class="line"></span><br><span class="line">ans = []</span><br><span class="line"><span class="keyword">for</span> k,v <span class="keyword">in</span> d.items():</span><br><span class="line">    <span class="keyword">if</span> k % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">        ans += v[::-<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        ans += v</span><br><span class="line"><span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">      d=&#123;&#125;</span><br><span class="line"><span class="comment">#loop through matrix</span></span><br><span class="line">      <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(matrix)):</span><br><span class="line">          <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(matrix[i])):</span><br><span class="line">		<span class="comment">#if no entry in dictionary for sum of indices aka the diagonal, create one</span></span><br><span class="line">              <span class="keyword">if</span> i + j <span class="keyword">not</span> <span class="keyword">in</span> d:</span><br><span class="line">                  d[i+j] = [matrix[i][j]]</span><br><span class="line">              <span class="keyword">else</span>:</span><br><span class="line">		<span class="comment">#If you&#x27;ve already passed over this diagonal, keep adding elements to it!</span></span><br><span class="line">                  d[i+j].append(matrix[i][j])</span><br><span class="line"><span class="comment"># we&#x27;re done with the pass, let&#x27;s build our answer array</span></span><br><span class="line">      ans= []</span><br><span class="line"><span class="comment">#look at the diagonal and each diagonal&#x27;s elements</span></span><br><span class="line">      <span class="keyword">for</span> entry <span class="keyword">in</span> d.items():</span><br><span class="line">	<span class="comment">#each entry looks like (diagonal level (sum of indices), [elem1, elem2, elem3, ...])</span></span><br><span class="line">	<span class="comment">#snake time, look at the diagonal level</span></span><br><span class="line">          <span class="keyword">if</span> entry[<span class="number">0</span>] % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">		<span class="comment">#Here we append in reverse order because its an even numbered level/diagonal. </span></span><br><span class="line">              [ans.append(x) <span class="keyword">for</span> x <span class="keyword">in</span> entry[<span class="number">1</span>][::-<span class="number">1</span>]]</span><br><span class="line">          <span class="keyword">else</span>:</span><br><span class="line">              [ans.append(x) <span class="keyword">for</span> x <span class="keyword">in</span> entry[<span class="number">1</span>]]</span><br><span class="line">      <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>523. Continuous Subarray Sum</summary>
<blockquote>
<p>Same as Subarray sum equals K with modification. Basic idea is that, If you get the same remainder again, it means that you’ve encountered some sum which is a multiple of K.<br>
why {0:-1}? In the case the sum of the array a multiple of k, we should store {0:-1} so a modulus of two is noted as already existing.</p>
</blockquote>
<p>Run time: $O(n)$, space: $O(k)$</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">checkSubarraySum</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">    prefix_sum = <span class="number">0</span></span><br><span class="line">    <span class="comment"># Dictionary of prefix sums and their indices(0 is seen before the array)</span></span><br><span class="line">    prefix_sum_indices = &#123;<span class="number">0</span>: -<span class="number">1</span>&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> index, num <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums):</span><br><span class="line">        <span class="comment"># Compute the remainder when dividing the new sum by k</span></span><br><span class="line">        prefix_sum = (prefix_sum + num) % k</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># Check if this remainder has been encountered before and of length 2</span></span><br><span class="line">        <span class="keyword">if</span> prefix_sum <span class="keyword">in</span> prefix_sum_indices <span class="keyword">and</span> index - prefix_sum_indices[prefix_sum] &gt; <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># Add this index if it is hasn&#x27;t been encountered before</span></span><br><span class="line">        <span class="keyword">if</span> prefix_sum <span class="keyword">not</span> <span class="keyword">in</span> prefix_sum_indices:</span><br><span class="line">            prefix_sum_indices[prefix_sum] = index</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>249. Group Shifted Strings</summary>
<blockquote>
<p>Put the difference between each character as key, and the original string as value in the dictionary.</p>
</blockquote>
<p>Run time: $O(nk)$, space: $O(nk)$, where $n$ is the length of input strings array, $k$ is the max length of the string in the array.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">groupStrings</span>(<span class="params">self, strings: <span class="type">List</span>[<span class="built_in">str</span>]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">str</span>]]:</span></span><br><span class="line">    d = defaultdict(<span class="built_in">list</span>)</span><br><span class="line">    <span class="keyword">for</span> s <span class="keyword">in</span> strings:</span><br><span class="line">        key = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s) - <span class="number">1</span>):</span><br><span class="line">            <span class="comment"># Throw in 26 so that we can normalzie below</span></span><br><span class="line">            difference = <span class="number">26</span> + <span class="built_in">ord</span>(s[i+<span class="number">1</span>]) - <span class="built_in">ord</span>(s[i])</span><br><span class="line">            <span class="comment"># Wrap around</span></span><br><span class="line">            <span class="comment"># z + 1 = a</span></span><br><span class="line">            key.append(<span class="built_in">str</span>(difference % <span class="number">26</span>))</span><br><span class="line">        d[<span class="string">&#x27;,&#x27;</span>.join(key)].append(s)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> d.values()</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>380. Insert Delete GetRandom O(1)</summary>
> Use a dictionary and a list to keep track of the inserted elements. Use dictionary to check whether the element exists, and when we need to remove element, we find the index and put the last element in the original position of the list, and update the dictionary.
Delete: Retrieve an index of element to delete from the hashmap. Move the last element to the place of the element to delete, \mathcal{O}(1)O(1) time. Pop the last element out, \mathcal{O}(1)O(1) time.
<p>Run time: $O(1)$, space: $O(n)$</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RandomizedSet</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.d = &#123;&#125;</span><br><span class="line">        self.l = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insert</span>(<span class="params">self, val: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        <span class="keyword">if</span> val <span class="keyword">not</span> <span class="keyword">in</span> self.d:</span><br><span class="line">            self.d[val] = <span class="built_in">len</span>(self.l)</span><br><span class="line">            self.l.append(val)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">remove</span>(<span class="params">self, val: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        <span class="keyword">if</span> val <span class="keyword">not</span> <span class="keyword">in</span> self.d:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        last_element = self.l[-<span class="number">1</span>]</span><br><span class="line">        idx = self.d[val]</span><br><span class="line">        </span><br><span class="line">        self.l[idx] = last_element <span class="comment"># rearrange</span></span><br><span class="line">        <span class="keyword">del</span> self.d[val]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getRandom</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="keyword">return</span> random.choice(self.l)</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>242. Valid Anagram</summary>
> Use one or two dictionary to check whether all values are zero in the end, or compare if they are the same.
<p>Run time: $O(n)$, space: $O(n)$</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isAnagram1</span>(<span class="params">self, s, t</span>):</span></span><br><span class="line">    dic1, dic2 = &#123;&#125;, &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> s:</span><br><span class="line">        dic1[item] = dic1.get(item, <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> t:</span><br><span class="line">        dic2[item] = dic2.get(item, <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> dic1 == dic2</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isAnagram2</span>(<span class="params">self, s, t</span>):</span></span><br><span class="line">    dic1, dic2 = [<span class="number">0</span>]*<span class="number">26</span>, [<span class="number">0</span>]*<span class="number">26</span></span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> s:</span><br><span class="line">        dic1[<span class="built_in">ord</span>(item)-<span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>)] += <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> t:</span><br><span class="line">        dic2[<span class="built_in">ord</span>(item)-<span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>)] += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> dic1 == dic2</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isAnagram3</span>(<span class="params">self, s, t</span>):</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sorted</span>(s) == <span class="built_in">sorted</span>(t)</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>287. Find the Duplicate Number</summary>
<blockquote>
<p>Floyd’s Tortoise and Hare (Cycle Detection)<br>
hare = nums[nums[hare]] is twice as fast as tortoise = nums[tortoise]. Since the hare goes fast, it would be the first to enter the cycle and run around the cycle. At some point, the tortoise enters the cycle as well, and since it’s moving slower the hare catches up to the tortoise at some intersection point. Now phase 1 is over, and the tortoise has lost.</p>
</blockquote>
<p>Run time: $O(n)$, space: $O(1)$</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findDuplicate</span>(<span class="params">self, nums</span>):</span></span><br><span class="line">    <span class="comment"># Find the intersection point of the two runners.</span></span><br><span class="line">    tortoise = hare = nums[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        tortoise = nums[tortoise]</span><br><span class="line">        hare = nums[nums[hare]]</span><br><span class="line">        <span class="keyword">if</span> tortoise == hare:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Find the &quot;entrance&quot; to the cycle.</span></span><br><span class="line">    tortoise = nums[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">while</span> tortoise != hare:</span><br><span class="line">        tortoise = nums[tortoise]</span><br><span class="line">        hare = nums[hare]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> hare</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Binary search. If the count of the numbers that are smaller than or equal to the mid, update right pointer.</p>
</blockquote>
<p>In the binary search approach, instead of doing a linear scan from 1 to n, we can apply a binary search with a goal of finding the smallest number that satisfies the aforementioned property. We start with a search space of [1,n] that has a midpoint midmid. If midmid satisfies the property, we narrow our search space to the left half [1, mid - 1] and continue searching, otherwise, we narrow our search space to the right half [mid + 1, n].</p>
<p>Run time: $O(n\log n)$, space: $O(1)$</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findDuplicate</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">    left, right = <span class="number">1</span>, <span class="built_in">len</span>(nums)-<span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> left &lt; right:</span><br><span class="line">        mid = (right + left)//<span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">sum</span>(i &lt;= mid <span class="keyword">for</span> i <span class="keyword">in</span> nums) &gt; mid:</span><br><span class="line">            right = mid</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            left = mid+<span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> right</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Put every element in a set, if it already exists, return it.</p>
</blockquote>
<p>Run time: $O(n)$, space: $O(n)$</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findDuplicate</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">    seen = <span class="built_in">set</span>()</span><br><span class="line">    <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">        <span class="keyword">if</span> num <span class="keyword">in</span> seen:</span><br><span class="line">            <span class="keyword">return</span> num</span><br><span class="line">        seen.add(num)</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>217. Contains Duplicate</summary>
<blockquote>
<p>Build a set using input array. If every element is distinct, then their length should be equal.</p>
</blockquote>
<p>Run time: $O(n)$, space: $O(n)$</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">containsDuplicate</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">    s = <span class="built_in">set</span>(nums)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">len</span>(s) != <span class="built_in">len</span>(nums)</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>448. Find All Numbers Disappeared in an Array</summary>
<blockquote>
<p>Negate the number that is in this index. In the end, if the number is still positive, put the corresponding index+1 to the output array.</p>
</blockquote>
<p>Run time: $O(n)$, space: $O(1)$</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findDisappearedNumbers</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span></span><br><span class="line">    ans = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">        temp = <span class="built_in">abs</span>(nums[i])-<span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> nums[temp] &gt; <span class="number">0</span>:</span><br><span class="line">            nums[temp] *= -<span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">        <span class="keyword">if</span> nums[i] &gt; <span class="number">0</span>:</span><br><span class="line">            ans.append(i+<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Hashset.</p>
</blockquote>
<p>Run time: $O(n)$, space: $O(n)$</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findDisappearedNumbers</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span></span><br><span class="line">    s = <span class="built_in">set</span>(nums)</span><br><span class="line">    n = <span class="built_in">len</span>(nums)</span><br><span class="line">    ans = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n+<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">if</span> i <span class="keyword">not</span> <span class="keyword">in</span> s:</span><br><span class="line">            ans.append(i)</span><br><span class="line">    <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
</details>
<h2 id="Advanced-Hash-Heap">Advanced Hash/Heap</h2>
<details>
<summary></summary>
> 
<p>Run time: $O()$, space: $O()$</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>460. LFU Cache</summary>
<blockquote>
<p><a href="https://leetcode.com/problems/lfu-cache/discuss/1083490/Python-Solution-using-DefaultDict-and-a-Dict%3A-faster%3A77.45-Memory-usageless-88.00">https://leetcode.com/problems/lfu-cache/discuss/1083490/Python-Solution-using-DefaultDict-and-a-Dict%3A-faster%3A77.45-Memory-usageless-88.00</a></p>
</blockquote>
<p>Run time: $O(\log n)$ for put if key not present, $O(1)$ for other calls, space: $O(n)$</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LFUCache</span>:</span></span><br><span class="line">    <span class="keyword">import</span> collections</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, capacity</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type capacity: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self.capacity = capacity</span><br><span class="line">        <span class="comment"># cache will contain key:[value, frequency]</span></span><br><span class="line">        <span class="comment"># default dict will contain all the keys having the same frequency of occurrence.</span></span><br><span class="line">        <span class="comment"># &#123;frequency:[key1, key2, key3]&#125;</span></span><br><span class="line">        self.cache = &#123;&#125;</span><br><span class="line">        self.freqCache = collections.defaultdict(<span class="built_in">list</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span>(<span class="params">self, key</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type key: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        val = self.cache.get(key, -<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">if</span> val == -<span class="number">1</span>: </span><br><span class="line">            <span class="keyword">return</span> val</span><br><span class="line">        </span><br><span class="line">        value,freq = val</span><br><span class="line">        <span class="comment"># if key is found, increase the frequency in frequency cache and data cache</span></span><br><span class="line">        self.freqCache[freq].remove(key)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.freqCache[freq]: </span><br><span class="line">            <span class="keyword">del</span> self.freqCache[freq]</span><br><span class="line">        self.freqCache[freq+<span class="number">1</span>].append(key)</span><br><span class="line"></span><br><span class="line">        self.cache[key] = [value, freq+<span class="number">1</span>]  </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> value</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">put</span>(<span class="params">self, key, value</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type key: int</span></span><br><span class="line"><span class="string">        :type value: int</span></span><br><span class="line"><span class="string">        :rtype: None</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> self.capacity &lt;=<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        val = self.cache.get(key, -<span class="number">1</span>)</span><br><span class="line">        initfreq=<span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>  val == -<span class="number">1</span>:</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(self.cache) == self.capacity:</span><br><span class="line">                <span class="comment">#print self.freqCache.items()</span></span><br><span class="line">                minFreq, delList = <span class="built_in">min</span>(self.freqCache.items(), key=<span class="keyword">lambda</span> x:x[<span class="number">0</span>])</span><br><span class="line">                <span class="comment">#print delList</span></span><br><span class="line">                delkey = delList[<span class="number">0</span>]</span><br><span class="line">                <span class="keyword">del</span> self.cache[delkey]</span><br><span class="line">                self.freqCache[minFreq].remove(delkey)</span><br><span class="line">                </span><br><span class="line">                <span class="comment">#insert in cache</span></span><br><span class="line">                self.cache.update(&#123;key:[value,initfreq]&#125;)</span><br><span class="line">                self.freqCache[initfreq].append(key)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                self.cache.update(&#123;key:[value,initfreq]&#125;)</span><br><span class="line">                self.freqCache[initfreq].append(key)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            oldval,freq = val</span><br><span class="line">            </span><br><span class="line">            self.freqCache[freq].remove(key)</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> self.freqCache[freq]: <span class="keyword">del</span> self.freqCache[freq]</span><br><span class="line">            self.freqCache[freq+<span class="number">1</span>].append(key)</span><br><span class="line">            </span><br><span class="line">            self.cache[key] = [value,freq+<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Your LFUCache object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"># obj = LFUCache(capacity)</span></span><br><span class="line"><span class="comment"># param_1 = obj.get(key)</span></span><br><span class="line"><span class="comment"># obj.put(key,value)</span></span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>146. LRU Cache</summary>
> Use OrderedDict. pop key: d.pop(key). Remove least used key: d.popitem(last=False).
<p>Run time: $O(1)$, space: $O(n)$</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, capacity: <span class="built_in">int</span></span>):</span></span><br><span class="line">        self.cap = capacity</span><br><span class="line">        self.d = collections.OrderedDict()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span>(<span class="params">self, key: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="keyword">if</span> key <span class="keyword">not</span> <span class="keyword">in</span> self.d:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        val = self.d.pop(key)</span><br><span class="line">        self.d[key] = val</span><br><span class="line">        <span class="keyword">return</span> val</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">put</span>(<span class="params">self, key: <span class="built_in">int</span>, value: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">        <span class="keyword">if</span> key <span class="keyword">in</span> self.d:</span><br><span class="line">            self.d.pop(key)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> self.cap &gt; <span class="number">0</span>:</span><br><span class="line">                self.cap -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                self.d.popitem(last=<span class="literal">False</span>)</span><br><span class="line">        self.d[key] = value</span><br><span class="line"></span><br><span class="line"><span class="comment"># Your LRUCache object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"># obj = LRUCache(capacity)</span></span><br><span class="line"><span class="comment"># param_1 = obj.get(key)</span></span><br><span class="line"><span class="comment"># obj.put(key,value)</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>Use dictionary + doubly linked list</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, k, v</span>):</span></span><br><span class="line">        self.key = k</span><br><span class="line">        self.value = v</span><br><span class="line">        self.prev = <span class="literal">None</span></span><br><span class="line">        self.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line">        </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, capacity: <span class="built_in">int</span></span>):</span></span><br><span class="line">        self.cap = capacity</span><br><span class="line">        self.dic = <span class="built_in">dict</span>()</span><br><span class="line">        self.prev = self.<span class="built_in">next</span> = self</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span>(<span class="params">self, key: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="keyword">if</span> key <span class="keyword">in</span> self.dic:</span><br><span class="line">            n = self.dic[key]</span><br><span class="line">            self._remove(n)</span><br><span class="line">            self._add(n)</span><br><span class="line">            <span class="keyword">return</span> n.value</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">put</span>(<span class="params">self, key: <span class="built_in">int</span>, value: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">        <span class="keyword">if</span> key <span class="keyword">in</span> self.dic:</span><br><span class="line">            self._remove(self.dic[key])</span><br><span class="line">        n = Node(key, value)</span><br><span class="line">        self._add(n)</span><br><span class="line">        self.dic[key] = n</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(self.dic) &gt; self.cap:</span><br><span class="line">            n = self.<span class="built_in">next</span></span><br><span class="line">            self._remove(n)</span><br><span class="line">            <span class="keyword">del</span> self.dic[n.key]</span><br><span class="line">            </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_remove</span>(<span class="params">self, node</span>):</span></span><br><span class="line">        p = node.prev</span><br><span class="line">        n = node.<span class="built_in">next</span></span><br><span class="line">        p.<span class="built_in">next</span> = n</span><br><span class="line">        n.prev = p</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_add</span>(<span class="params">self, node</span>):</span></span><br><span class="line">        p = self.prev</span><br><span class="line">        p.<span class="built_in">next</span> = node</span><br><span class="line">        self.prev = node</span><br><span class="line">        node.prev = p</span><br><span class="line">        node.<span class="built_in">next</span> = self</span><br></pre></td></tr></table></figure>
</details>
<h1>Union Find</h1>
<h1>DP</h1>
<details>
<summary></summary>
> 
<p>Run time: $O()$, space: $O()$</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>140. Word Break II</summary>
<blockquote>
<p>For any word (denoted as \text{w}w) in the dictionary, if it matches with a prefix of the input string, we then can divide the string into two parts: the word and the postfix, i.e. s = \text{w} + \text{postfix}s=w+postfix.</p>
</blockquote>
<p>Run time: $ \mathcal{O}(N^2 + 2 ^ N + W)$, space: $ \mathcal{O}(2^N \cdot N + N^2 + W)$</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">wordBreak</span>(<span class="params">self, s: <span class="built_in">str</span>, wordDict: <span class="type">List</span>[<span class="built_in">str</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">str</span>]:</span></span><br><span class="line">    memo = &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">s</span>):</span></span><br><span class="line">        <span class="keyword">if</span> s <span class="keyword">in</span> memo:</span><br><span class="line">            <span class="keyword">return</span> memo[s]</span><br><span class="line">        </span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> wordDict:</span><br><span class="line">            <span class="keyword">if</span> s.startswith(x):</span><br><span class="line">                <span class="keyword">if</span> s == x:</span><br><span class="line">                    res += [x]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">for</span> y <span class="keyword">in</span> dfs(s[<span class="built_in">len</span>(x):]):</span><br><span class="line">                        res += [x + <span class="string">&#x27; &#x27;</span> + y]</span><br><span class="line">        memo[s] = res</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">                    </span><br><span class="line">    <span class="keyword">return</span> dfs(s) </span><br></pre></td></tr></table></figure>
<blockquote>
<p>Recursion</p>
</blockquote>
<p>Run time: $ \mathcal{O}(N^2 + 2 ^ N + W)$, space: $ \mathcal{O}(2^N \cdot N + N^2 + W)$</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">helper</span>(<span class="params">s, string, ans</span>):</span></span><br><span class="line">    <span class="keyword">if</span> s == <span class="string">&quot;&quot;</span>:</span><br><span class="line">        ans.append(string.strip())</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)+<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">if</span> s[:i] <span class="keyword">in</span> wordDict:</span><br><span class="line">            temp = string + <span class="string">&quot; &quot;</span>+ s[:i]</span><br><span class="line">            helper(s[i:], temp, ans)</span><br><span class="line"></span><br><span class="line">ans = []</span><br><span class="line">helper(s, <span class="string">&quot;&quot;</span>, ans)</span><br><span class="line"><span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>53. Maximum Subarray</summary>
> One variable to keep track of current subarray, one variable to track max subarray.
<p>Run time: $O(n)$, space: $O(1)$</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">maxSubArray</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">    current_subarray = max_subarray = nums[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> num <span class="keyword">in</span> nums[<span class="number">1</span>:]:</span><br><span class="line">        current_subarray = <span class="built_in">max</span>(num, current_subarray + num)</span><br><span class="line">        max_subarray = <span class="built_in">max</span>(max_subarray, current_subarray)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> max_subarray</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>121. Best Time to Buy and Sell Stock</summary>
> Keep track of lowest price, and update max profit.
<p>Run time: $O(n)$, space: $O(1)$</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span>(<span class="params">self, prices: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">    buy = <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)</span><br><span class="line">    profit = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> p <span class="keyword">in</span> prices:</span><br><span class="line">        buy = <span class="built_in">min</span>(buy, p)</span><br><span class="line">        profit = <span class="built_in">max</span>(profit, p-buy)</span><br><span class="line">    <span class="keyword">return</span> profit</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>10. Regular Expression Matching</summary>
<blockquote>
<p>dp[i][j] represents whether the string s ending at index i could be expressed by string p ending at index j.</p>
</blockquote>
<p>Run time: $O(mn)$, space: $O(mn)$</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isMatch</span>(<span class="params">self, s: <span class="built_in">str</span>, p: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">    m,n = <span class="built_in">len</span>(s), <span class="built_in">len</span>(p)</span><br><span class="line">    dp = [[<span class="literal">False</span>]*(n+<span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m+<span class="number">1</span>)]</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">True</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n+<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">if</span> p[i-<span class="number">1</span>] == <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">            dp[<span class="number">0</span>][i] = dp[<span class="number">0</span>][i-<span class="number">2</span>] <span class="comment"># same as the char before *</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, m+<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> p[j-<span class="number">1</span>] == <span class="string">&#x27;.&#x27;</span>: <span class="comment"># skip current one</span></span><br><span class="line">                dp[i][j] = dp[i-<span class="number">1</span>][j-<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">elif</span> p[j-<span class="number">1</span>] != <span class="string">&#x27;*&#x27;</span>: <span class="comment"># normal char must match</span></span><br><span class="line">                dp[i][j] = dp[i-<span class="number">1</span>][j-<span class="number">1</span>] <span class="keyword">and</span> p[j-<span class="number">1</span>] == s[i-<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">elif</span> p[j-<span class="number">2</span>] != <span class="string">&#x27;.&#x27;</span> <span class="keyword">and</span> p[j-<span class="number">2</span>] != s[i-<span class="number">1</span>]: <span class="comment"># ended at *</span></span><br><span class="line">                dp[i][j] = dp[i][j-<span class="number">2</span>]</span><br><span class="line">            <span class="keyword">else</span>: <span class="comment"># all other cases</span></span><br><span class="line">                dp[i][j] = dp[i-<span class="number">1</span>][j] <span class="keyword">or</span> dp[i][j-<span class="number">1</span>] <span class="keyword">or</span> dp[i][j-<span class="number">2</span>]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> dp[-<span class="number">1</span>][-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>416. Partition Equal Subset Sum</summary>
<blockquote>
<p>We could further optimize Approach 3. We must understand that for any array element ii, we need results of the previous iteration (i-1) only. Hence, we could achieve the same using a one-dimensional array as well.</p>
</blockquote>
<p>Run time: $O(mn)$, space: $O(m)$</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">canPartition</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">    sum_ = <span class="built_in">sum</span>(nums)</span><br><span class="line">    <span class="keyword">if</span> sum_ % <span class="number">2</span> != <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    </span><br><span class="line">    half = sum_ // <span class="number">2</span></span><br><span class="line">    n = <span class="built_in">len</span>(nums)</span><br><span class="line">    </span><br><span class="line">    dp = [<span class="literal">False</span>]*(sum_+<span class="number">1</span>)</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="literal">True</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n+<span class="number">1</span>):</span><br><span class="line">        curr = nums[i-<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(sum_, curr-<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">            dp[j] = dp[j] <span class="keyword">or</span> dp[j-curr]</span><br><span class="line">    <span class="keyword">return</span> dp[sum_]</span><br></pre></td></tr></table></figure>
<blockquote>
<p>We maintain a 2D array ,dp[n][subSetSum] For an array element ii and sum jj in array nums,</p>
</blockquote>
<p>dp[i][j]=true if the sum jj can be formed by array elements in subset nums[0]…nums[i],otherwise dp[i][j]=false</p>
<p>Run time: $O(mn)$, space: $O(mn)$</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">canPartition</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">    sum_ = <span class="built_in">sum</span>(nums)</span><br><span class="line">    <span class="keyword">if</span> sum_ % <span class="number">2</span> != <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    </span><br><span class="line">    half = sum_ // <span class="number">2</span></span><br><span class="line">    n = <span class="built_in">len</span>(nums)</span><br><span class="line">    </span><br><span class="line">    dp = [[<span class="literal">False</span>]*(sum_+<span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n+<span class="number">1</span>)]</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">True</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n+<span class="number">1</span>):</span><br><span class="line">        curr = nums[i-<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(sum_ + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> j &lt; curr:</span><br><span class="line">                dp[i][j] = dp[i-<span class="number">1</span>][j]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                dp[i][j] = dp[i-<span class="number">1</span>][j] <span class="keyword">or</span> dp[i-<span class="number">1</span>][j-curr]</span><br><span class="line">    <span class="keyword">return</span> dp[n][sum_]</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>300. Longest Increasing Subsequence</summary>
<blockquote>
<p>Use finary search <code>bisect_left</code></p>
</blockquote>
<p>Run time: $O(n\log n)$, space: $O(n)$</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lengthOfLIS</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">    tails = [<span class="number">0</span>] * <span class="built_in">len</span>(nums)</span><br><span class="line">    size = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> nums:</span><br><span class="line">        lo, hi = <span class="number">0</span>, size</span><br><span class="line">        <span class="keyword">while</span> lo != hi:</span><br><span class="line">            mid = (lo + hi) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> tails[mid] &lt; x:</span><br><span class="line">                lo = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                hi = mid</span><br><span class="line">        tails[lo] = x</span><br><span class="line">        size = <span class="built_in">max</span>(lo + <span class="number">1</span>, size)</span><br><span class="line">    <span class="keyword">return</span> size</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Double for loop and update max if the inner value is smaller than current value.</p>
</blockquote>
<p>Run time: $O(n^2)$, space: $O(n)$</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lengthOfLIS</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">    n = <span class="built_in">len</span>(nums)</span><br><span class="line">    dp = [<span class="number">1</span>] * (n+<span class="number">1</span>)</span><br><span class="line">    max_len = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i):</span><br><span class="line">            <span class="keyword">if</span> nums[j] &lt; nums[i]:</span><br><span class="line">                dp[i] = <span class="built_in">max</span>(dp[j]+<span class="number">1</span>, dp[i])</span><br><span class="line">        max_len = <span class="built_in">max</span>(dp[i], max_len)</span><br><span class="line">    <span class="keyword">return</span> max_len</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>139. Word Break</summary>
<blockquote>
<p>First put list into a set for easier access. Initialize an array of size n+1 and set the first entry to be True. Loop from 1 to n, and loop from 0 to i-1, check if dp[j] is True and the substring between j and i is valid. If so, set this entry of the dp array to be true.</p>
</blockquote>
<p>Run time: $O(n^3)$, space: $O(n)$</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">wordBreak</span>(<span class="params">self, s: <span class="built_in">str</span>, wordDict: <span class="type">List</span>[<span class="built_in">str</span>]</span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">    word_set = <span class="built_in">set</span>(wordDict)</span><br><span class="line">    n = <span class="built_in">len</span>(s)</span><br><span class="line">    dp = [<span class="literal">False</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n+<span class="number">1</span>)]</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n+<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i):</span><br><span class="line">            <span class="keyword">if</span> dp[j] <span class="keyword">and</span> s[j:i] <span class="keyword">in</span> word_set:</span><br><span class="line">                dp[i] = <span class="literal">True</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">return</span> dp[<span class="built_in">len</span>(s)]</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>279. Perfect Squares</summary>
> To calculate the value of numSquares(n), first we need to calculate all the values before n.
<p>Run time: $O(n\sqrt{n})$ or $O(\frac{\sqrt{n}^{h+1}-1}{\sqrt{n}-1})=O(n^{\frac{h}{2}})$, space: $O(n)$ or $O((\sqrt{n})^h)$, where h is the height of the N-ary tree.</p>
<blockquote>
<p>Again, first of all, we prepare a list of square numbers (named square_nums) that are less than the given number n.<br>
We then create a queue variable which would keep all the remainders to enumerate at each level.<br>
In the main loop, we iterate over the queue variable. At each iteration, we check if the remainder is one of the square numbers. If the remainder is not a square number, we subtract it with one of the square numbers to obtain a new remainder and then add the new remainder to the next_queue for the iteration of the next level. We break out of the loop once we encounter a remainder that is of a square number, which also means that we find the solution.</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numSquares</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        queue = deque([(n, <span class="number">0</span>)])</span><br><span class="line">        visited = &#123;n&#125;</span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            curr, step = queue.popleft()</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">int</span>(curr ** <span class="number">0.5</span>) == curr ** <span class="number">0.5</span>:</span><br><span class="line">                <span class="keyword">return</span> step + <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">int</span>(curr ** <span class="number">0.5</span>) + <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> curr - (i ** <span class="number">2</span>) <span class="keyword">not</span> <span class="keyword">in</span> visited:</span><br><span class="line">                    queue.append((curr - (i ** <span class="number">2</span>), step + <span class="number">1</span>))</span><br><span class="line">                    visited.add(curr - (i ** <span class="number">2</span>))</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">numSquares</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">    dp = [i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n+<span class="number">1</span>)]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>, n+<span class="number">1</span>):</span><br><span class="line">        j = <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> j**<span class="number">2</span> &lt;= i:</span><br><span class="line">            dp[i] = <span class="built_in">min</span>(dp[i], dp[i-j**<span class="number">2</span>]+<span class="number">1</span>)</span><br><span class="line">            j += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> dp[-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>221. Maximal Square</summary>
<blockquote>
<p>Find squares whose bottom right corner is formed by the current cell. If we can modify the input, the space complexity can be further reduced to $O(1)$.</p>
</blockquote>
<p>Run time: $O(mn)$, space: $O(mn)$ or $O(n)$ or $O(1)$</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">maximalSquare</span>(<span class="params">self, matrix: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">str</span>]]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">    m, n, ans = <span class="built_in">len</span>(matrix), <span class="built_in">len</span>(matrix[<span class="number">0</span>]), <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i, j <span class="keyword">in</span> product(<span class="built_in">range</span>(m-<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>), <span class="built_in">range</span>(n-<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>)):</span><br><span class="line">        <span class="keyword">if</span> i == m-<span class="number">1</span> <span class="keyword">or</span> j == n-<span class="number">1</span>:</span><br><span class="line">            matrix[i][j] = <span class="built_in">int</span>(matrix[i][j])</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, matrix[i][j])</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> matrix[i][j] == <span class="string">&#x27;1&#x27;</span>:</span><br><span class="line">                matrix[i][j] = <span class="number">1</span> + <span class="built_in">min</span>(matrix[i+<span class="number">1</span>][j], matrix[i][j+<span class="number">1</span>], matrix[i+<span class="number">1</span>][j+<span class="number">1</span>])</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                matrix[i][j] = <span class="number">0</span></span><br><span class="line">            ans = <span class="built_in">max</span>(ans, matrix[i][j])</span><br><span class="line">    <span class="keyword">return</span> ans * ans</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">maximalSquare</span>(<span class="params">self, matrix: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">str</span>]]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">    m, n, ans = <span class="built_in">len</span>(matrix), <span class="built_in">len</span>(matrix[<span class="number">0</span>]), <span class="number">0</span></span><br><span class="line">    dp = [[<span class="number">0</span>]*(n+<span class="number">1</span>) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m+<span class="number">1</span>)]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i, j <span class="keyword">in</span> product(<span class="built_in">range</span>(m-<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>), <span class="built_in">range</span>(n-<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>)):</span><br><span class="line">        <span class="keyword">if</span> matrix[i][j] == <span class="string">&#x27;1&#x27;</span>:</span><br><span class="line">            dp[i][j] = <span class="number">1</span> + <span class="built_in">min</span>(dp[i+<span class="number">1</span>][j], dp[i][j+<span class="number">1</span>], dp[i+<span class="number">1</span>][j+<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            dp[i][j] = <span class="number">0</span></span><br><span class="line">        ans = <span class="built_in">max</span>(ans, dp[i][j])</span><br><span class="line">    <span class="keyword">return</span> ans * ans</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>542. 01 Matrix</summary>
<blockquote>
<p>Two for loops, one goes from top left to bottom right, one goes from bottom right to top left. In this way we could find the minimum distance over all four directions.</p>
</blockquote>
<p>Run time: $O(n^2)$, space: $O(1)$</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">updateMatrix</span>(<span class="params">self, mat: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span></span><br><span class="line">    m, n = <span class="built_in">len</span>(mat), <span class="built_in">len</span>(mat[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> r <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">if</span> mat[r][c] &gt; <span class="number">0</span>:</span><br><span class="line">                top = mat[r - <span class="number">1</span>][c] <span class="keyword">if</span> r &gt; <span class="number">0</span> <span class="keyword">else</span> math.inf</span><br><span class="line">                left = mat[r][c - <span class="number">1</span>] <span class="keyword">if</span> c &gt; <span class="number">0</span> <span class="keyword">else</span> math.inf</span><br><span class="line">                mat[r][c] = <span class="built_in">min</span>(top, left) + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> r <span class="keyword">in</span> <span class="built_in">range</span>(m - <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> <span class="built_in">range</span>(n - <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> mat[r][c] &gt; <span class="number">0</span>:</span><br><span class="line">                bottom = mat[r + <span class="number">1</span>][c] <span class="keyword">if</span> r &lt; m - <span class="number">1</span> <span class="keyword">else</span> math.inf</span><br><span class="line">                right = mat[r][c + <span class="number">1</span>] <span class="keyword">if</span> c &lt; n - <span class="number">1</span> <span class="keyword">else</span> math.inf</span><br><span class="line">                mat[r][c] = <span class="built_in">min</span>(mat[r][c], bottom + <span class="number">1</span>, right + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> mat</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>64. Minimum Path Sum</summary>
<blockquote>
<p>Instead of using a 2D matrix for dp, we can do the same work using a dp array of the row size, since for making the current entry all we need is the dp entry for the bottom and the right element. Thus, we start by initializing only the last element of the array as the last element of the given matrix. The last entry is the bottom rightmost element of the given matrix.</p>
</blockquote>
<p>Run time: $O(n^2)$, space: $O(n^2)$ or $O(n)$ or $O(1)$</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">minPathSum</span>(<span class="params">self, grid: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">    m,n = <span class="built_in">len</span>(grid), <span class="built_in">len</span>(grid[<span class="number">0</span>])</span><br><span class="line">    dp = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m-<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n-<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> i == m-<span class="number">1</span> <span class="keyword">and</span> j != n-<span class="number">1</span>:</span><br><span class="line">                dp[j] = grid[i][j] + dp[j+<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">elif</span> j == n-<span class="number">1</span> <span class="keyword">and</span> i != m-<span class="number">1</span>:</span><br><span class="line">                dp[j] = grid[i][j] + dp[j]</span><br><span class="line">            <span class="keyword">elif</span> i != m-<span class="number">1</span> <span class="keyword">and</span> j != n-<span class="number">1</span>:</span><br><span class="line">                dp[j] = grid[i][j] + <span class="built_in">min</span>(dp[j], dp[j+<span class="number">1</span>])</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                dp[j] = grid[i][j]</span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">0</span>]</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">minPathSum</span>(<span class="params">self, grid: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">    m = <span class="built_in">len</span>(grid)</span><br><span class="line">    n = <span class="built_in">len</span>(grid[<span class="number">0</span>])</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n):</span><br><span class="line">        grid[<span class="number">0</span>][i] += grid[<span class="number">0</span>][i-<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, m):</span><br><span class="line">        grid[i][<span class="number">0</span>] += grid[i-<span class="number">1</span>][<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, m):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n):</span><br><span class="line">            grid[i][j] += <span class="built_in">min</span>(grid[i-<span class="number">1</span>][j], grid[i][j-<span class="number">1</span>])</span><br><span class="line">    <span class="keyword">return</span> grid[-<span class="number">1</span>][-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>413. Arithmetic Slices</summary>
<blockquote>
<p>we only require the element dp[i−1] to determine the value to be entered at dp[i]. Thus, instead of making use of a 1-D array to store the required data, we can simply keep a track of just the last element.</p>
</blockquote>
<p>Run time: $O(n)$, space: $O(n)$ or $O(1)$</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">numberOfArithmeticSlices</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">    dp = <span class="number">0</span></span><br><span class="line">    total = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, <span class="built_in">len</span>(nums)):</span><br><span class="line">        <span class="keyword">if</span> nums[i] - nums[i-<span class="number">1</span>] == nums[i-<span class="number">1</span>] - nums[i-<span class="number">2</span>]:</span><br><span class="line">            dp += <span class="number">1</span></span><br><span class="line">            total += dp</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            dp = <span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> total</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">numberOfArithmeticSlices</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(nums) &lt; <span class="number">3</span>: </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    dp = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums))]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, <span class="built_in">len</span>(nums)):</span><br><span class="line">        <span class="keyword">if</span> nums[i] - nums[i-<span class="number">1</span>] == nums[i-<span class="number">1</span>] - nums[i-<span class="number">2</span>]:</span><br><span class="line">            dp[i] = dp[i-<span class="number">1</span>]+<span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sum</span>(dp)</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>198. House Robber</summary>
> Either steal this house and the n-2 ones, or not steal this one. We could just use two variables and keep shifting them.
<p>Run time: $O(n)$, space: $O(n)$ or $O(1)$</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rob</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            </span><br><span class="line">    rob_prev_two = <span class="number">0</span></span><br><span class="line">    rob_prev_one = nums[<span class="number">0</span>]</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># DP table calculations.</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(nums)):</span><br><span class="line">        current = <span class="built_in">max</span>(rob_prev_one, rob_prev_two + nums[i])</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># Update the variables</span></span><br><span class="line">        rob_prev_two = rob_prev_one</span><br><span class="line">        rob_prev_one = current</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> rob_prev_one</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rob</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(nums) == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> nums[<span class="number">0</span>]</span><br><span class="line">    </span><br><span class="line">    ans = [nums[<span class="number">0</span>], <span class="built_in">max</span>(nums[<span class="number">0</span>], nums[<span class="number">1</span>])]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, <span class="built_in">len</span>(nums)):</span><br><span class="line">        ans.append(<span class="built_in">max</span>(nums[i] + ans[i-<span class="number">2</span>], ans[i-<span class="number">1</span>]))</span><br><span class="line">    <span class="keyword">return</span> ans[-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>70. Climbing Stairs</summary>
> Since the `i`th stairs can be reached either from the `i-1`th stair or `i-2`th stair, so the number of ways is the sum of ways at `i-1`th stair and `i-2`th stair.
<p>Run time: $O(n)$, space: $O(n)$ or $O(1)$</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">climbStairs</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">    a, b = <span class="number">1</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        a, b = b, a + b</span><br><span class="line">    <span class="keyword">return</span> a</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">climbStairs</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">    <span class="keyword">if</span> n &lt;= <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">    ans = [<span class="number">1</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n+<span class="number">1</span>)]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, n+<span class="number">1</span>):</span><br><span class="line">        ans[i] = ans[i-<span class="number">1</span>] + ans[i-<span class="number">2</span>]</span><br><span class="line">    <span class="keyword">return</span> ans[n]</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>1048. Longest String Chain</summary>
<blockquote>
<p>Store the word and the length of longest chain in a dictionary. For each word in the sorted list by length, first initialize the length to be 1, then loop through each char and form substring by removing it. If this substring is in the dictionary, update the key of this word, and update the final result.</p>
</blockquote>
<p>Run time: $O(n\log n)+O(NSS)$, where word length $S\leq 16$, space: $O(NS)$</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">longestStrChain</span>(<span class="params">self, words: <span class="type">List</span>[<span class="built_in">str</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">    dp = &#123;&#125;</span><br><span class="line">    result = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> word <span class="keyword">in</span> <span class="built_in">sorted</span>(words, key=<span class="built_in">len</span>):</span><br><span class="line">        dp[word] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(word)):</span><br><span class="line">            prev = word[:i] + word[i + <span class="number">1</span>:]</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> prev <span class="keyword">in</span> dp:</span><br><span class="line">                dp[word] = <span class="built_in">max</span>(dp[prev] + <span class="number">1</span>, dp[word])</span><br><span class="line">                result = <span class="built_in">max</span>(result, dp[word])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
</details>
<h1>DP coord + connected</h1>
<h2 id="DP-sliding-array-memory-search">DP sliding array + memory search</h2>
<h2 id="DP-interval-backpack">DP interval + backpack</h2>
<h1>Tree</h1>
<h2 id="Binary-Tree-Divide-Conquer">Binary Tree / Divide &amp; Conquer</h2>
<details>
<summary></summary>
> 
<p>Run time: $O()$, space: $O()$</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>173. Binary Search Tree Iterator</summary>
<blockquote>
<p>Push all left nodes to the stack. Once a node is popped from the stack, push its right node back to the stack, and return its value.</p>
</blockquote>
<p>Run time: $O(1)$, space: $O(\log n)$</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BSTIterator</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>):</span></span><br><span class="line">        self.stack = []</span><br><span class="line">        self.pushAll(root)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">next</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        tmpNode = self.stack.pop()</span><br><span class="line">        self.pushAll(tmpNode.right)</span><br><span class="line">        <span class="keyword">return</span> tmpNode.val</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hasNext</span>(<span class="params">self</span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.stack</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pushAll</span>(<span class="params">self, node</span>):</span></span><br><span class="line">        <span class="keyword">while</span> node:</span><br><span class="line">            self.stack.append(node)</span><br><span class="line">            node = node.left</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Flatten the BST and use a pointer for index.</p>
</blockquote>
<p>Run time: $O(1)$, space: $O(n)$</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BSTIterator</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>):</span></span><br><span class="line">        self.arr = []</span><br><span class="line">        self.ind = -<span class="number">1</span></span><br><span class="line">        self._inorder(root)</span><br><span class="line">            </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_inorder</span>(<span class="params">self, root</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        self._inorder(root.left)</span><br><span class="line">        self.arr.append(root.val)</span><br><span class="line">        self._inorder(root.right)</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">next</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.hasNext():</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        self.ind += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> self.arr[self.ind]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hasNext</span>(<span class="params">self</span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.ind+<span class="number">1</span> &lt; <span class="built_in">len</span>(self.arr)</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>199. Binary Tree Right Side View</summary>
<blockquote>
<p>DFS, Recursion.</p>
</blockquote>
<p>Run time: $O(n)$, space: $O(n)$</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rightSideView</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span></span><br><span class="line">    self.ans = []</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span>(<span class="params">node, level</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">if</span> level &gt;= <span class="built_in">len</span>(self.ans):</span><br><span class="line">            self.ans.append(node.val)</span><br><span class="line"></span><br><span class="line">        helper(node.right, level+<span class="number">1</span>)</span><br><span class="line">        helper(node.left, level+<span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line">    helper(root, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> self.ans</span><br></pre></td></tr></table></figure>
<blockquote>
<p>BFS, iterative.</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rightSideView</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span></span><br><span class="line">    view = []</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line">    </span><br><span class="line">    q = collections.deque()</span><br><span class="line">    q.append((root, <span class="number">0</span>))</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> q:</span><br><span class="line">        curr, level = q.popleft()</span><br><span class="line">        <span class="keyword">if</span> level == <span class="number">0</span> <span class="keyword">or</span> <span class="keyword">not</span> q <span class="keyword">or</span> q[<span class="number">0</span>][<span class="number">1</span>] &gt; level:</span><br><span class="line">            view.append(curr.val)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> curr.left:</span><br><span class="line">            q.append((curr.left, level + <span class="number">1</span>))</span><br><span class="line">        <span class="keyword">if</span> curr.right:</span><br><span class="line">            q.append((curr.right, level + <span class="number">1</span>))</span><br><span class="line">    <span class="keyword">return</span> view</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>987. Vertical Order Traversal of a Binary Tree</summary>
<blockquote>
<p>Use defaultdict instead of normal dict to get rid of key not exist case. Put &lt;level, value&gt; as value into the dictionary, use placement as key. In the end sort placement, and sort the level.</p>
</blockquote>
<p>Run time: $O(n\log n)$, space: $O()$</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">verticalTraversal</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span>(<span class="params">placement, level, node, dic</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        dic[placement].append((level, node.val))</span><br><span class="line">        helper(placement-<span class="number">1</span>, level+<span class="number">1</span>, node.left, dic)</span><br><span class="line">        helper(placement+<span class="number">1</span>, level+<span class="number">1</span>, node.right, dic)</span><br><span class="line">        </span><br><span class="line">    dic = defaultdict(<span class="built_in">list</span>)</span><br><span class="line">    helper(<span class="number">0</span>,<span class="number">0</span>,root,dic)</span><br><span class="line">    res = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">sorted</span>(dic.keys()):</span><br><span class="line">        temp = []</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">sorted</span>(dic[i]):</span><br><span class="line">            temp.append(j[<span class="number">1</span>])</span><br><span class="line">        res.append(temp)</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>938. Range Sum of BST</summary>
<blockquote>
<p>Recursion. Need to check if strictly less than or greater than the range, then call helper function recursively.</p>
</blockquote>
<p>Run time: $O(n)$, space: $O(n)$</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rangeSumBST</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode], low: <span class="built_in">int</span>, high: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">    self.rangeSum = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span>(<span class="params">node, lo, hi</span>):</span></span><br><span class="line">        <span class="keyword">if</span> node:</span><br><span class="line">            <span class="keyword">if</span> lo &lt;= node.val &lt;= hi:</span><br><span class="line">                self.rangeSum += node.val</span><br><span class="line">            <span class="keyword">if</span> lo &lt; node.val:</span><br><span class="line">                    helper(node.left, lo, hi)</span><br><span class="line">            <span class="keyword">if</span> node.val &lt; hi:</span><br><span class="line">                helper(node.right, lo, hi)</span><br><span class="line">            </span><br><span class="line">    helper(root, low, high)</span><br><span class="line">    <span class="keyword">return</span> self.rangeSum</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Iterative</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rangeSumBST</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode], low: <span class="built_in">int</span>, high: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">    ans = <span class="number">0</span></span><br><span class="line">    stack = [root]</span><br><span class="line">    <span class="keyword">while</span> stack:</span><br><span class="line">        node = stack.pop()</span><br><span class="line">        <span class="keyword">if</span> node:</span><br><span class="line">            <span class="keyword">if</span> L &lt;= node.val &lt;= R:</span><br><span class="line">                ans += node.val</span><br><span class="line">            <span class="keyword">if</span> L &lt; node.val:</span><br><span class="line">                stack.append(node.left)</span><br><span class="line">            <span class="keyword">if</span> node.val &lt; R:</span><br><span class="line">                stack.append(node.right)</span><br><span class="line">    <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>426. Convert Binary Search Tree to Sorted Doubly Linked List</summary>
<blockquote>
<p>Recursion</p>
</blockquote>
<p>Run time: $O(n)$, space: $O(n)$</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">treeToDoublyList</span>(<span class="params">self, root: <span class="string">&#x27;Optional[Node]&#x27;</span></span>) -&gt; &#x27;<span class="type">Optional</span>[Node]&#x27;:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span>(<span class="params">node</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Performs standard inorder traversal:</span></span><br><span class="line"><span class="string">        left -&gt; node -&gt; right</span></span><br><span class="line"><span class="string">        and links all nodes into DLL</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> node:</span><br><span class="line">            <span class="comment"># left</span></span><br><span class="line">            helper(node.left)</span><br><span class="line">            <span class="comment"># node </span></span><br><span class="line">            <span class="keyword">if</span> self.last:</span><br><span class="line">                <span class="comment"># link the previous node (last)</span></span><br><span class="line">                <span class="comment"># with the current one (node)</span></span><br><span class="line">                self.last.right = node</span><br><span class="line">                node.left = self.last</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># keep the smallest node</span></span><br><span class="line">                <span class="comment"># to close DLL later on</span></span><br><span class="line">                self.first = node        </span><br><span class="line">            self.last = node</span><br><span class="line">            <span class="comment"># right</span></span><br><span class="line">            helper(node.right)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># the smallest (first) and the largest (last) nodes</span></span><br><span class="line">    self.first, self.last = <span class="literal">None</span>, <span class="literal">None</span></span><br><span class="line">    helper(root)</span><br><span class="line">    <span class="comment"># close DLL</span></span><br><span class="line">    self.last.right = self.first</span><br><span class="line">    self.first.left = self.last</span><br><span class="line">    <span class="keyword">return</span> self.first</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>1110. Delete Nodes And Return Forest</summary>
<blockquote>
<p>DFS.</p>
</blockquote>
<p>Run time: $O(n)$, space: $O(n)$</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">delNodes</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode], to_delete: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[TreeNode]:</span></span><br><span class="line">      ans = []</span><br><span class="line">      to_delete = <span class="built_in">set</span>(to_delete)</span><br><span class="line">      </span><br><span class="line">      <span class="function"><span class="keyword">def</span> <span class="title">helper</span>(<span class="params">node</span>):</span></span><br><span class="line">          <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">              <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">          node.left = helper(node.left)</span><br><span class="line">          node.right = helper(node.right)</span><br><span class="line">	</span><br><span class="line">	<span class="comment"># add children of a node that is to be deleted</span></span><br><span class="line">          <span class="keyword">if</span> node.val <span class="keyword">in</span> to_delete:</span><br><span class="line">              <span class="keyword">if</span> node.left: </span><br><span class="line">                  ans.append(node.left)</span><br><span class="line">              <span class="keyword">if</span> node.right:</span><br><span class="line">                  ans.append(node.right)</span><br><span class="line">              <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">          <span class="keyword">return</span> node</span><br><span class="line">              </span><br><span class="line">      helper(root)</span><br><span class="line"><span class="comment"># if root is not to be deleted then add it</span></span><br><span class="line">      <span class="keyword">if</span> root.val <span class="keyword">not</span> <span class="keyword">in</span> to_delete:</span><br><span class="line">          ans.append(root)</span><br><span class="line">      <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<blockquote>
<p>BFS.</p>
</blockquote>
<p>Run time: $O(n)$, space: $O(n)$</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delNodes</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode], to_delete: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[TreeNode]:</span></span><br><span class="line">    output = []</span><br><span class="line">    to_delete_set = <span class="built_in">set</span>(to_delete)</span><br><span class="line">    tree_queue = [root]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> tree_queue:</span><br><span class="line">        curr_tree = tree_queue.pop(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> curr_tree:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">if</span> curr_tree.val <span class="keyword">in</span> to_delete_set:</span><br><span class="line">            tree_queue.append(curr_tree.left)</span><br><span class="line">            tree_queue.append(curr_tree.right)</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        </span><br><span class="line">        node_queue = [curr_tree]</span><br><span class="line">        <span class="keyword">while</span> node_queue:</span><br><span class="line">            curr_node = node_queue.pop(<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> curr_node:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> curr_node.left <span class="keyword">and</span> curr_node.left.val <span class="keyword">in</span> to_delete_set:</span><br><span class="line">                tree_queue.append(curr_node.left.left)</span><br><span class="line">                tree_queue.append(curr_node.left.right)</span><br><span class="line">                curr_node.left = <span class="literal">None</span></span><br><span class="line">            <span class="keyword">if</span> curr_node.right <span class="keyword">and</span> curr_node.right.val <span class="keyword">in</span> to_delete_set:</span><br><span class="line">                tree_queue.append(curr_node.right.left)</span><br><span class="line">                tree_queue.append(curr_node.right.right)</span><br><span class="line">                curr_node.right = <span class="literal">None</span></span><br><span class="line">                </span><br><span class="line">            node_queue.append(curr_node.left)</span><br><span class="line">            node_queue.append(curr_node.right)</span><br><span class="line">            </span><br><span class="line">        output.append(curr_tree)</span><br><span class="line">    <span class="keyword">return</span> output</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>235. Lowest Common Ancestor of a Binary Search Tree</summary>
<blockquote>
<p>Recursion. Since the input tree is a binary search tree, we can utilize the property and determine the LCA. If both p and q values are smaller or greater than the current node val, we know that the LCA could be further reduced.</p>
</blockquote>
<p>Run time: $O(n)$, space: $O(n)$</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lowestCommonAncestor</span>(<span class="params">self, root: <span class="string">&#x27;TreeNode&#x27;</span>, p: <span class="string">&#x27;TreeNode&#x27;</span>, q: <span class="string">&#x27;TreeNode&#x27;</span></span>) -&gt; &#x27;TreeNode&#x27;:</span></span><br><span class="line">    <span class="keyword">if</span> root.val &lt; p.val <span class="keyword">and</span> root.val &lt; q.val:</span><br><span class="line">        <span class="keyword">return</span> self.lowestCommonAncestor(root.right, p, q)</span><br><span class="line">    <span class="keyword">elif</span> root.val &gt; p.val <span class="keyword">and</span> root.val &gt; q.val:</span><br><span class="line">        <span class="keyword">return</span> self.lowestCommonAncestor(root.left, p, q)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Iterative.</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lowestCommonAncestor</span>(<span class="params">self, root: <span class="string">&#x27;TreeNode&#x27;</span>, p: <span class="string">&#x27;TreeNode&#x27;</span>, q: <span class="string">&#x27;TreeNode&#x27;</span></span>) -&gt; &#x27;TreeNode&#x27;:</span></span><br><span class="line">    node = root</span><br><span class="line">    <span class="keyword">while</span> node:</span><br><span class="line">        <span class="keyword">if</span> node.val &lt; p.val <span class="keyword">and</span> node.val &lt; q.val:</span><br><span class="line">            node = node.right</span><br><span class="line">        <span class="keyword">elif</span> node.val &gt; p.val <span class="keyword">and</span> node.val &gt; q.val:</span><br><span class="line">            node = node.left</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> node</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>637. Average of Levels in Binary Tree</summary>
> DFS. Create a list of list where the index is the height. If the current node height is greater than or equal to the output array length, then append an empty array. Then access the array at index height and append the value. Use list comprehension to get the average for each list.
<p>Run time: $O(n)$, space: $O(n)$</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">averageOfLevels</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="built_in">float</span>]:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getH</span>(<span class="params">node, height</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">if</span> height &gt;= <span class="built_in">len</span>(self.ans):</span><br><span class="line">            self.ans.append([])</span><br><span class="line">        self.ans[height].append(node.val)</span><br><span class="line">        getH(node.left, height+<span class="number">1</span>)</span><br><span class="line">        getH(node.right, height+<span class="number">1</span>)</span><br><span class="line">        </span><br><span class="line">    self.ans = []</span><br><span class="line">    getH(root, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> [<span class="built_in">sum</span>(s)/<span class="built_in">len</span>(s) <span class="keyword">for</span> s <span class="keyword">in</span> self.ans]</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>450. Delete Node in a BST</summary>
> There are three possible situations here :
- Node is a leaf, and one could delete it straightforward : node = null.
- Node is not a leaf and has a right child. Then the node could be replaced by its successor which is somewhere lower in the right subtree. Then one could proceed down recursively to delete the successor.
- Node is not a leaf, has no right child and has a left child. That means that its successor is somewhere upper in the tree but we don't want to go back. Let's use the predecessor here which is somewhere lower in the left subtree. The node could be replaced by its predecessor and then one could proceed down recursively to delete the predecessor.
<p>Run time: $O(\log n)$, space: $O(h)$, where $h$ is the tree height, when $h=\log n$, it is a balanced tree.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">deleteNode</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode], key: <span class="built_in">int</span></span>) -&gt; <span class="type">Optional</span>[TreeNode]:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">successor</span>(<span class="params">root</span>):</span></span><br><span class="line">        root = root.right</span><br><span class="line">        <span class="keyword">while</span> root.left:</span><br><span class="line">            root = root.left</span><br><span class="line">        <span class="keyword">return</span> root.val</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">predecessor</span>(<span class="params">root</span>):</span></span><br><span class="line">        root = root.left</span><br><span class="line">        <span class="keyword">while</span> root.right:</span><br><span class="line">            root = root.right</span><br><span class="line">        <span class="keyword">return</span> root.val</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">        <span class="keyword">return</span> root</span><br><span class="line">    <span class="keyword">if</span> root.val &gt; key:</span><br><span class="line">        root.left = self.deleteNode(root.left, key)</span><br><span class="line">    <span class="keyword">elif</span> root.val &lt; key:</span><br><span class="line">        root.right = self.deleteNode(root.right, key)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root.left <span class="keyword">and</span> <span class="keyword">not</span> root.right:</span><br><span class="line">            root = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">elif</span> root.right:</span><br><span class="line">            root.val = successor(root)</span><br><span class="line">            root.right = self.deleteNode(root.right, root.val)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            root.val = predecessor(root)</span><br><span class="line">            root.left = self.deleteNode(root.left, root.val)</span><br><span class="line">            </span><br><span class="line">    <span class="keyword">return</span> root</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>328. Odd Even Linked List</summary>
<blockquote>
<p>Put the odd nodes in a linked list and the even nodes in another. Then link the evenList to the tail of the oddList.</p>
</blockquote>
<p>Run time: $O(n)$, space: $O(1)$</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">oddEvenList</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span></span><br><span class="line">    d1 = odd = ListNode(<span class="number">0</span>)</span><br><span class="line">    d2 = even = ListNode(<span class="number">0</span>)</span><br><span class="line">    i = <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> head:</span><br><span class="line">        <span class="keyword">if</span> i%<span class="number">2</span>:</span><br><span class="line">            odd.<span class="built_in">next</span>, odd = head,head</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            even.<span class="built_in">next</span>, even = head,head</span><br><span class="line">        head = head.<span class="built_in">next</span></span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">    odd.<span class="built_in">next</span>, even.<span class="built_in">next</span> = d2.<span class="built_in">next</span>,<span class="literal">None</span></span><br><span class="line">    <span class="keyword">return</span> d1.<span class="built_in">next</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">oddEvenList</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> head:</span><br><span class="line">        <span class="keyword">return</span> head</span><br><span class="line">    odd = head</span><br><span class="line">    even = head.<span class="built_in">next</span></span><br><span class="line">    evenHead = even</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> even <span class="keyword">and</span> even.<span class="built_in">next</span>:</span><br><span class="line">        odd.<span class="built_in">next</span> = even.<span class="built_in">next</span></span><br><span class="line">        odd = odd.<span class="built_in">next</span></span><br><span class="line">        even.<span class="built_in">next</span> = odd.<span class="built_in">next</span></span><br><span class="line">        even = even.<span class="built_in">next</span></span><br><span class="line">    odd.<span class="built_in">next</span> = evenHead</span><br><span class="line">    <span class="keyword">return</span> head</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>101. Symmetric Tree</summary>
<blockquote>
<p>Iterative. Maintain a queue and pop two elements at a time and compare, then append their child nodes pairs to the queue.</p>
</blockquote>
<p>Run time: $O(n)$, space: $O(n)$</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isSymmetric</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">    q = [root, root]</span><br><span class="line">    <span class="keyword">while</span> q:</span><br><span class="line">        n1 = q.pop()</span><br><span class="line">        n2 = q.pop()</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> n1 <span class="keyword">and</span> <span class="keyword">not</span> n2:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">elif</span> <span class="keyword">not</span> n1 <span class="keyword">or</span> <span class="keyword">not</span> n2:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">elif</span> n1.val != n2.val:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        q.append(n1.left)</span><br><span class="line">        q.append(n2.right)</span><br><span class="line">        q.append(n1.right)</span><br><span class="line">        q.append(n2.left)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>Recursion. Use a helper function to check whether the current two nodes have the same value, and check left==right and right==left.</p>
</blockquote>
<p>Run time: $O(n)$, space: $O(n)$</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isSymmetric</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span>(<span class="params">n1, n2</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> n1 <span class="keyword">and</span> <span class="keyword">not</span> n2:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">elif</span> <span class="keyword">not</span> n1 <span class="keyword">or</span> <span class="keyword">not</span> n2:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> n1.val == n2.val <span class="keyword">and</span> \</span><br><span class="line">               helper(n1.right, n2.left) <span class="keyword">and</span> \</span><br><span class="line">               helper(n1.left, n2.right)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> helper(root, root)</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>437. Path Sum III</summary>
<blockquote>
<p>Use a variable to track the current prefix sum and a hashmap “prefix sum -&gt; how many times was it seen so far”. Parse the input structure and count the requested subarrays/submatrices/tree paths along the way with the help of that hashmap. How to count?<br>
The logic is simple: the current prefix sum is curr_sum, and some elements before the prefix sum was curr_sum - target. All the elements in between sum up to curr_sum - (curr_sum - target) = target.</p>
</blockquote>
<p>Run time: $O(n)$, space: $O(n)$</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pathSum</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode], targetSum: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">preorder</span>(<span class="params">node: TreeNode, curr_sum</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        curr_sum += node.val</span><br><span class="line">        <span class="keyword">if</span> curr_sum == k:</span><br><span class="line">            self.count += <span class="number">1</span></span><br><span class="line">        self.count += h[curr_sum-k]</span><br><span class="line">        h[curr_sum] += <span class="number">1</span></span><br><span class="line">        preorder(node.left, curr_sum)</span><br><span class="line">        preorder(node.right, curr_sum)</span><br><span class="line">        </span><br><span class="line">    self.count = <span class="number">0</span></span><br><span class="line">    k = targetSum</span><br><span class="line">    h = defaultdict(<span class="built_in">int</span>)</span><br><span class="line">    preorder(root, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> self.count</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pathSum</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode], targetSum: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">    <span class="keyword">return</span> self.helper(root, targetSum, [targetSum])</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">helper</span>(<span class="params">self, node, origin, targets</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> node: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    hit = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> t <span class="keyword">in</span> targets:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> t-node.val: hit += <span class="number">1</span>                          <span class="comment"># count if sum == target</span></span><br><span class="line">    targets = [t-node.val <span class="keyword">for</span> t <span class="keyword">in</span> targets]+[origin]         <span class="comment"># update the targets</span></span><br><span class="line">    <span class="keyword">return</span> hit+self.helper(node.left, origin, targets)+self.helper(node.right, origin, targets)</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>543. Diameter of Binary Tree</summary>
<blockquote>
<p>we know that the longest path in the tree would consist of a node, its longest left branch, and its longest right branch. So, our algorithm to solve this problem will find the node where the sum of its longest left and right branches is maximized. This would hint at us to apply Depth-first search (DFS) to count each node’s branch lengths, because it would allow us to dive deep into the leaves first, and then start counting the edges upwards.</p>
</blockquote>
<p>Run time: $O(n)$, space: $O(n)$</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">diameterOfBinaryTree</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">    self.diameter = <span class="number">0</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longest</span>(<span class="params">node</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        left = longest(node.left)</span><br><span class="line">        right = longest(node.right)</span><br><span class="line">        </span><br><span class="line">        self.diameter = <span class="built_in">max</span>(self.diameter, left+right)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(left, right)+<span class="number">1</span></span><br><span class="line">   </span><br><span class="line">    longest(root)</span><br><span class="line">    <span class="keyword">return</span> self.diameter</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>110. Balanced Binary Tree</summary>
<blockquote>
<p>Bottom up. If node is None, return 0. Then check for its left and right child, if any of them returns -1, then it means the subtree is not balanced. Or if the difference is greater than 1, the subtree is also not balanced. In the end return 1 + max of left and right child.</p>
</blockquote>
<p>Run time: $O()$, space: $O()$</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isBalanced</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">check</span>(<span class="params">root</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        left  = check(root.left)</span><br><span class="line">        right = check(root.right)</span><br><span class="line">        <span class="keyword">if</span> left == -<span class="number">1</span> <span class="keyword">or</span> right == -<span class="number">1</span> <span class="keyword">or</span> <span class="built_in">abs</span>(left - right) &gt; <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + <span class="built_in">max</span>(left, right)</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> check(root) != -<span class="number">1</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>if recursive calls before conditional check, then its bottom up. If recursive call after conditional check, its top down.</p>
</blockquote>
<p>Run time: $O(n\log n)$, space: $O(n)$</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isBalanced</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">height</span>(<span class="params">node</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(height(node.left), height(node.right))+<span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">abs</span>(height(root.left) - height(root.right)) &lt; <span class="number">2</span> \</span><br><span class="line">        <span class="keyword">and</span> self.isBalanced(root.left) \</span><br><span class="line">        <span class="keyword">and</span> self.isBalanced(root.right)</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>236. Lowest Common Ancestor of a Binary Tree</summary>
> Recursive solution, DFS
<p>Run time: $O(n)$, space: $O(h)$</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lowestCommonAncestor</span>(<span class="params">self, root, p, q</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    :type root: TreeNode</span></span><br><span class="line"><span class="string">    :type p: TreeNode</span></span><br><span class="line"><span class="string">    :type q: TreeNode</span></span><br><span class="line"><span class="string">    :rtype: TreeNode</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    <span class="keyword">if</span> p == root <span class="keyword">or</span> q == root:</span><br><span class="line">        <span class="keyword">return</span> root</span><br><span class="line">    left = self.lowestCommonAncestor(root.left, p, q)</span><br><span class="line">    right = self.lowestCommonAncestor(root.right, p, q)</span><br><span class="line">    <span class="keyword">if</span> left <span class="keyword">and</span> right:</span><br><span class="line">        <span class="keyword">return</span> root</span><br><span class="line">    <span class="keyword">elif</span> <span class="keyword">not</span> left:</span><br><span class="line">        <span class="keyword">return</span> right</span><br><span class="line">    <span class="keyword">elif</span> <span class="keyword">not</span> right:</span><br><span class="line">        <span class="keyword">return</span> left</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Iterative, BFS. Use a stack to keep track of each viewed node, and a parent dict to track a node’s parent. If <code>p</code> and <code>q</code> are not in the parent dict, keep popping from the stack, add to parent dict, and append to stack. Then we create a set called <code>ancestors</code>, keep finding p’s parent. Then find q’s parent until q is in the ancestors, then return q.</p>
</blockquote>
<p>Run time: $O(n)$, space: $O(h)$</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lowestCommonAncestor</span>(<span class="params">self, root, p, q</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    :type root: TreeNode</span></span><br><span class="line"><span class="string">    :type p: TreeNode</span></span><br><span class="line"><span class="string">    :type q: TreeNode</span></span><br><span class="line"><span class="string">    :rtype: TreeNode</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    stack = [root]</span><br><span class="line">    parent_dict = &#123;root: <span class="literal">None</span>&#125;</span><br><span class="line">    <span class="keyword">while</span> p <span class="keyword">not</span> <span class="keyword">in</span> parent_dict <span class="keyword">or</span> q <span class="keyword">not</span> <span class="keyword">in</span> parent_dict:</span><br><span class="line">        node = stack.pop()</span><br><span class="line">        <span class="keyword">if</span> node.left:</span><br><span class="line">            parent_dict[node.left] = node</span><br><span class="line">            stack.append(node.left)</span><br><span class="line">        <span class="keyword">if</span> node.right:</span><br><span class="line">            parent_dict[node.right] = node</span><br><span class="line">            stack.append(node.right)</span><br><span class="line">    </span><br><span class="line">    ancestors = <span class="built_in">set</span>()</span><br><span class="line">    <span class="keyword">while</span> p:</span><br><span class="line">        ancestors.add(p)</span><br><span class="line">        p = parent_dict[p]</span><br><span class="line">    <span class="keyword">while</span> q <span class="keyword">not</span> <span class="keyword">in</span> ancestors:</span><br><span class="line">        ancestors.add(q)</span><br><span class="line">        q = parent_dict[q]</span><br><span class="line">    <span class="keyword">return</span> q</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>1650. Lowest Common Ancestor of a Binary Tree III</summary>
> Use two pointers to keep track of the parents, until they point to the same node. When either of the pointers points to the root, i.e., parent is None, then set it to the other original node.
<p>Run time: $O(n)$, space: $O(1)$</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lowestCommonAncestor</span>(<span class="params">self, p, q</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    :type node: Node</span></span><br><span class="line"><span class="string">    :rtype: Node</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    p1, p2 = p, q</span><br><span class="line">    <span class="keyword">while</span> p1 != p2:</span><br><span class="line">        p1 =  p1.parent <span class="keyword">if</span> p1.parent <span class="keyword">else</span> q</span><br><span class="line">        p2 = p2.parent <span class="keyword">if</span> p2.parent <span class="keyword">else</span> p</span><br><span class="line">    <span class="keyword">return</span> p1</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>314. Binary Tree Vertical Order Traversal</summary>
> BFS, obtain the range of the column indices, walk through the column range [min_column, max_column] and retrieve the results accordingly.
<p>Run time: $O(n)$, space: $O(n)$</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">verticalOrder</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span></span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line"></span><br><span class="line">        columnTable = defaultdict(<span class="built_in">list</span>)</span><br><span class="line">        min_column = max_column = <span class="number">0</span></span><br><span class="line">        queue = deque([(root, <span class="number">0</span>)])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            node, column = queue.popleft()</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> node <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                columnTable[column].append(node.val)</span><br><span class="line">                min_column = <span class="built_in">min</span>(min_column, column)</span><br><span class="line">                max_column = <span class="built_in">max</span>(max_column, column)</span><br><span class="line"></span><br><span class="line">                queue.append((node.left, column - <span class="number">1</span>))</span><br><span class="line">                queue.append((node.right, column + <span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> [columnTable[x] <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(min_column, max_column + <span class="number">1</span>)]</span><br></pre></td></tr></table></figure>
<blockquote>
<p>BFS, store the current node in the answer, and if left/right child is not None, enqueue.</p>
</blockquote>
<p>Run time: $O(n \log n)$, space: $O(n)$</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">verticalOrder</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line">    </span><br><span class="line">    result = collections.defaultdict(<span class="built_in">list</span>)</span><br><span class="line">    queue = [(root, <span class="number">0</span>)]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> node, distance <span class="keyword">in</span> queue:</span><br><span class="line">        result[distance].append(node.val)</span><br><span class="line">        <span class="keyword">if</span> node.left:</span><br><span class="line">            queue.append((node.left, distance-<span class="number">1</span>))</span><br><span class="line">        <span class="keyword">if</span> node.right:</span><br><span class="line">            queue.append((node.right, distance+<span class="number">1</span>))</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> [order <span class="keyword">for</span> distance, order <span class="keyword">in</span> <span class="built_in">sorted</span>(result.items())]</span><br></pre></td></tr></table></figure>
<details>
<summary>my implementation</summary>
Run time: $O(n)$, space: $O(n)$
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">verticalOrder</span>(<span class="params">self, root</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: List[List[int]]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">helper</span>(<span class="params">node, level</span>):</span></span><br><span class="line">            <span class="keyword">if</span> node <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> node.left <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">if</span> level-<span class="number">1</span> <span class="keyword">not</span> <span class="keyword">in</span> d:</span><br><span class="line">                    d[level-<span class="number">1</span>] = []</span><br><span class="line">                d[level-<span class="number">1</span>].append(node.left.val)</span><br><span class="line">            <span class="keyword">if</span> node.right <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">if</span> level+<span class="number">1</span> <span class="keyword">not</span> <span class="keyword">in</span> d:</span><br><span class="line">                    d[level+<span class="number">1</span>] = []</span><br><span class="line">                d[level+<span class="number">1</span>].append(node.right.val)</span><br><span class="line">            helper(node.left, level-<span class="number">1</span>)</span><br><span class="line">            helper(node.right, level+<span class="number">1</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        d = &#123;&#125;</span><br><span class="line">        d[<span class="number">0</span>] = [root.val]</span><br><span class="line">        helper(root, <span class="number">0</span>)</span><br><span class="line">        </span><br><span class="line">        ans = []</span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">sorted</span>(d):</span><br><span class="line">            ans.append(d[k])</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
</details>
</details>
<h2 id="Trie">Trie</h2>
<details>
<summary></summary>
> 
<p>Run time: $O()$, space: $O()$</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>208. Implement Trie (Prefix Tree)</summary>
<blockquote>
<p>Maintain a dictionary and keep adding empty entries if the character does not exist, and update the pointer to the key.</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Trie</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.trie = &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insert</span>(<span class="params">self, word: <span class="built_in">str</span></span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">        curr_d = self.trie</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> word:</span><br><span class="line">            <span class="keyword">if</span> c <span class="keyword">not</span> <span class="keyword">in</span> curr_d:</span><br><span class="line">                curr_d[c] = &#123;&#125;</span><br><span class="line">            curr_d = curr_d[c]</span><br><span class="line">        curr_d[<span class="string">&#x27;-&#x27;</span>] = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search</span>(<span class="params">self, word: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        curr_d = self.trie</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> word:</span><br><span class="line">            <span class="keyword">if</span> c <span class="keyword">not</span> <span class="keyword">in</span> curr_d:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            curr_d = curr_d[c]</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;-&#x27;</span> <span class="keyword">in</span> curr_d</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">startsWith</span>(<span class="params">self, prefix: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        curr_d = self.trie</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> prefix:</span><br><span class="line">            <span class="keyword">if</span> c <span class="keyword">not</span> <span class="keyword">in</span> curr_d:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            curr_d = curr_d[c]</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>
</details>
<h2 id="Segment-Tree">Segment Tree</h2>
<h1>String</h1>
<details>
<summary></summary>
> 
<p>Run time: $O()$, space: $O()$</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>791. Custom Sort String</summary>
> 
<p>Run time: $O(\max(m,n))$, space: $O(n)$</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">customSortString</span>(<span class="params">self, order: <span class="built_in">str</span>, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span></span><br><span class="line">      freq = Counter(s) <span class="comment">#O(n) + O(1)</span></span><br><span class="line"><span class="comment"># equivalent:</span></span><br><span class="line"><span class="comment"># freq = &#123;&#125;</span></span><br><span class="line">      <span class="comment"># for ch in s: #O(n) where n is len(s)</span></span><br><span class="line">      <span class="comment">#     freq[ch] = freq.get(ch, 0) + 1</span></span><br><span class="line"></span><br><span class="line">      chars = []</span><br><span class="line">      <span class="keyword">for</span> ch <span class="keyword">in</span> order: <span class="comment">#O(m) where m is the len(order)</span></span><br><span class="line">          chars.append(ch*freq.pop(ch, <span class="number">0</span>)) <span class="comment">#O(1)</span></span><br><span class="line">      </span><br><span class="line">      <span class="keyword">for</span> key <span class="keyword">in</span> freq.keys(): <span class="comment">#O(k) where k is the size of keys present in s but not in order</span></span><br><span class="line">          chars.append(key*freq[key]) <span class="comment">#O(1)</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;&quot;</span>.join(chars)</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>766. Toeplitz Matrix</summary>
<blockquote></blockquote>
<p>Run time: $O(mn)$, space: $O(1)$</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isToeplitzMatrix</span>(<span class="params">self, matrix: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(matrix)-<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(matrix[<span class="number">0</span>])-<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> matrix[i][j] != matrix[i + <span class="number">1</span>][j + <span class="number">1</span>]:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">def</span> <span class="title">isToeplitzMatrix</span>(<span class="params">self, matrix: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">     <span class="keyword">if</span> <span class="keyword">not</span> matrix <span class="keyword">or</span> <span class="keyword">not</span> matrix[<span class="number">0</span>]:</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">False</span>                </span><br><span class="line">     </span><br><span class="line">     <span class="comment"># Create a deque tracking the expected values for the next row</span></span><br><span class="line">     expected = deque(matrix[<span class="number">0</span>])</span><br><span class="line">     </span><br><span class="line">     <span class="comment"># Iterate through all the remaining rows, verifying they align with the</span></span><br><span class="line">     <span class="comment">#   expected row.</span></span><br><span class="line">     <span class="keyword">for</span> row_i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(matrix)):</span><br><span class="line">         row = matrix[row_i]</span><br><span class="line">         expected.pop()</span><br><span class="line">         expected.appendleft(row[<span class="number">0</span>])</span><br><span class="line">         </span><br><span class="line"><span class="comment"># Only check from index 1 and down as we&#x27;ve just added index 0 to expected</span></span><br><span class="line">         <span class="keyword">for</span> col_i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(row)):</span><br><span class="line">             <span class="keyword">if</span> row[col_i] != expected[col_i]:</span><br><span class="line">                 <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">     </span><br><span class="line">     <span class="comment"># If we&#x27;ve reached here, all diagonals aligned</span></span><br><span class="line">     <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>953. Verifying an Alien Dictionary</summary>
<blockquote>
<p>Two cases: 1. prev and curr in correct order but prev length is longer, 2. prev and curr not in order.</p>
</blockquote>
<p>Run time: $O(n)$, space: $O(1)$</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">def</span> <span class="title">isAlienSorted</span>(<span class="params">self, words: <span class="type">List</span>[<span class="built_in">str</span>], order: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">     d = &#123;&#125;</span><br><span class="line">     <span class="keyword">for</span> i, c <span class="keyword">in</span> <span class="built_in">enumerate</span>(order):</span><br><span class="line">         d[c] = i</span><br><span class="line"></span><br><span class="line">     <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(words)):</span><br><span class="line">         <span class="comment">#flag = 1 here means inner loop is break out due to pre less than cur</span></span><br><span class="line"><span class="comment">#flag = 0 here means inner loop done iteration but two strings length are not equal</span></span><br><span class="line">         pre, cur, flag = words[i-<span class="number">1</span>], words[i], <span class="number">0</span></span><br><span class="line">         <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">min</span>(<span class="built_in">len</span>(pre),<span class="built_in">len</span>(cur))):</span><br><span class="line">             <span class="keyword">if</span> d[pre[j]] &lt; d[cur[j]]:</span><br><span class="line">                 flag = <span class="number">1</span></span><br><span class="line">                 <span class="keyword">break</span></span><br><span class="line">             <span class="keyword">elif</span> d[pre[j]] &gt; d[cur[j]]:</span><br><span class="line">                 <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">         <span class="keyword">if</span> <span class="keyword">not</span> flag <span class="keyword">and</span> <span class="built_in">len</span>(pre) &gt; <span class="built_in">len</span>(cur): </span><br><span class="line">             <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">     <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>65. Valid Number</summary>
> 
<p>Run time: $O(n)$, space: $O(1)$</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isNumber</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">    seen_digit = seen_exponent = seen_dot =  <span class="literal">False</span></span><br><span class="line">    <span class="keyword">for</span> i, c <span class="keyword">in</span> <span class="built_in">enumerate</span>(s):</span><br><span class="line">        <span class="keyword">if</span> c.isdigit():</span><br><span class="line">            seen_digit = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">elif</span> c <span class="keyword">in</span> <span class="string">&quot;+-&quot;</span>:</span><br><span class="line">            <span class="keyword">if</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> s[i - <span class="number">1</span>] != <span class="string">&quot;e&quot;</span> <span class="keyword">and</span> s[i - <span class="number">1</span>] != <span class="string">&quot;E&quot;</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">elif</span> c <span class="keyword">in</span> <span class="string">&quot;Ee&quot;</span>:</span><br><span class="line">            <span class="keyword">if</span> seen_exponent <span class="keyword">or</span> <span class="keyword">not</span> seen_digit:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            seen_exponent = <span class="literal">True</span></span><br><span class="line">            seen_digit = <span class="literal">False</span></span><br><span class="line">        <span class="keyword">elif</span> c == <span class="string">&quot;.&quot;</span>:</span><br><span class="line">            <span class="keyword">if</span> seen_dot <span class="keyword">or</span> seen_exponent:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            seen_dot = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> seen_digit</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Deterministic Finite Automaton (DFA). Initialize the DFA as an array of hash tables. Each hash table’s keys will be a character group, and the values will be the state it should transition to. We can use the indexes of the array to handle state transitions. Set the currentState = 0.<br>
Iterate through the input. For each character, first determine what group it belongs to. Then, check if that group exists in the current state’s hash table. If it does, transition to the next state. Otherwise, return false.<br>
At the end, check if we are currently in a valid end state: 1, 4, or 7.</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isNumber</span>(<span class="params">self, s</span>):</span></span><br><span class="line">        <span class="comment"># This is the DFA we have designed above</span></span><br><span class="line">        dfa = [</span><br><span class="line">            &#123;<span class="string">&quot;digit&quot;</span>: <span class="number">1</span>, <span class="string">&quot;sign&quot;</span>: <span class="number">2</span>, <span class="string">&quot;dot&quot;</span>: <span class="number">3</span>&#125;,</span><br><span class="line">            &#123;<span class="string">&quot;digit&quot;</span>: <span class="number">1</span>, <span class="string">&quot;dot&quot;</span>: <span class="number">4</span>, <span class="string">&quot;exponent&quot;</span>: <span class="number">5</span>&#125;,</span><br><span class="line">            &#123;<span class="string">&quot;digit&quot;</span>: <span class="number">1</span>, <span class="string">&quot;dot&quot;</span>: <span class="number">3</span>&#125;,</span><br><span class="line">            &#123;<span class="string">&quot;digit&quot;</span>: <span class="number">4</span>&#125;,</span><br><span class="line">            &#123;<span class="string">&quot;digit&quot;</span>: <span class="number">4</span>, <span class="string">&quot;exponent&quot;</span>: <span class="number">5</span>&#125;,</span><br><span class="line">            &#123;<span class="string">&quot;sign&quot;</span>: <span class="number">6</span>, <span class="string">&quot;digit&quot;</span>: <span class="number">7</span>&#125;,</span><br><span class="line">            &#123;<span class="string">&quot;digit&quot;</span>: <span class="number">7</span>&#125;,</span><br><span class="line">            &#123;<span class="string">&quot;digit&quot;</span>: <span class="number">7</span>&#125;</span><br><span class="line">        ]</span><br><span class="line">        </span><br><span class="line">        current_state = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> c.isdigit():</span><br><span class="line">                group = <span class="string">&quot;digit&quot;</span></span><br><span class="line">            <span class="keyword">elif</span> c <span class="keyword">in</span> [<span class="string">&quot;+&quot;</span>, <span class="string">&quot;-&quot;</span>]:</span><br><span class="line">                group = <span class="string">&quot;sign&quot;</span></span><br><span class="line">            <span class="keyword">elif</span> c <span class="keyword">in</span> [<span class="string">&quot;e&quot;</span>, <span class="string">&quot;E&quot;</span>]:</span><br><span class="line">                group = <span class="string">&quot;exponent&quot;</span></span><br><span class="line">            <span class="keyword">elif</span> c == <span class="string">&quot;.&quot;</span>:</span><br><span class="line">                group = <span class="string">&quot;dot&quot;</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> group <span class="keyword">not</span> <span class="keyword">in</span> dfa[current_state]:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            </span><br><span class="line">            current_state = dfa[current_state][group]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> current_state <span class="keyword">in</span> [<span class="number">1</span>, <span class="number">4</span>, <span class="number">7</span>]</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>5. Longest Palindromic Substring</summary>
<blockquote>
<p>Helper function that gets the start and end indices. Then use max function and set key=lambda x: x[1] - x[0]).</p>
</blockquote>
<p>Run time: $O(n)$, space: $O(1)$ or $O(n)$</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">longestPalindrome</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">f</span>(<span class="params">i, j</span>):</span></span><br><span class="line">        <span class="keyword">while</span> i &gt;= <span class="number">0</span> <span class="keyword">and</span> j &lt; <span class="built_in">len</span>(s) <span class="keyword">and</span> s[i] == s[j]:</span><br><span class="line">            i -= <span class="number">1</span></span><br><span class="line">            j += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> i, j</span><br><span class="line">    </span><br><span class="line">    i = j = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)):</span><br><span class="line">        i, j = <span class="built_in">max</span>((i, j), f(k, k), f(k, k+<span class="number">1</span>), key=<span class="keyword">lambda</span> x: x[<span class="number">1</span>] - x[<span class="number">0</span>])</span><br><span class="line">    <span class="keyword">return</span> s[i+<span class="number">1</span>:j] </span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">longestPalindrome</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span>(<span class="params">s, start, end</span>):</span></span><br><span class="line">        <span class="keyword">while</span> start &gt;= <span class="number">0</span> <span class="keyword">and</span> end &lt; <span class="built_in">len</span>(s) <span class="keyword">and</span> s[start] == s[end]:</span><br><span class="line">            start -= <span class="number">1</span></span><br><span class="line">            end += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> s[start+<span class="number">1</span>:end]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> s:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span></span><br><span class="line">    longest = <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)):</span><br><span class="line">        curr_substr1 = helper(s, i, i)</span><br><span class="line">        curr_substr2 = helper(s, i, i+<span class="number">1</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(curr_substr1) &gt; <span class="built_in">len</span>(longest):</span><br><span class="line">            longest = curr_substr1</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(curr_substr2) &gt; <span class="built_in">len</span>(longest):</span><br><span class="line">            longest = curr_substr2</span><br><span class="line">    <span class="keyword">return</span> longest</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>3. Longest Substring Without Repeating Characters</summary>
<blockquote>
<p>Sliding window. We use a dictionary to store the character as the key, the last appear index has been seen so far as value. seen[charactor] = index<br>
Move the pointer when you met a repeated character in your window.</p>
</blockquote>
<p>Run time: $O(n)$, space: $O(m)$, where $n$ is the length of the input string, $m$ is the number of unique characters of the input.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lengthOfLongestSubstring</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">    used = &#123;&#125;</span><br><span class="line">    max_length = start = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i, c <span class="keyword">in</span> <span class="built_in">enumerate</span>(s):</span><br><span class="line">        <span class="keyword">if</span> c <span class="keyword">in</span> used <span class="keyword">and</span> start &lt;= used[c]:</span><br><span class="line">            start = used[c] + <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            max_length = <span class="built_in">max</span>(max_length, i - start + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        used[c] = i</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> max_length</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Brute force.</p>
</blockquote>
<p>Run time: $O(n^2)$, space: $O(min(m,n))$</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lengthOfLongestSubstring</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> s:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    count = <span class="number">1</span></span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> i &lt; <span class="built_in">len</span>(s):</span><br><span class="line">        seen = <span class="built_in">set</span>()</span><br><span class="line">        seen.add(s[i])</span><br><span class="line">        j = i+<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> j &lt; <span class="built_in">len</span>(s) <span class="keyword">and</span> s[j] <span class="keyword">not</span> <span class="keyword">in</span> seen:</span><br><span class="line">            seen.add(s[j])</span><br><span class="line">            j += <span class="number">1</span></span><br><span class="line">        count = <span class="built_in">max</span>(count, j-i)</span><br><span class="line">        i = j</span><br><span class="line">    <span class="keyword">return</span> count</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>647. Palindromic Substrings</summary>
> There are 2N-1 possible centers for the palindrome: we could have a center at S[0], between S[0] and S[1], at S[1], between S[1] and S[2], at S[2], etc.
<p>Run time: $O(n)$, space: $O(1)$</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">countSubstrings</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> s:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    n = <span class="built_in">len</span>(s)</span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>*n-<span class="number">1</span>):</span><br><span class="line">        left = i//<span class="number">2</span></span><br><span class="line">        right = (i+<span class="number">1</span>)//<span class="number">2</span></span><br><span class="line">        <span class="keyword">while</span> left &gt;= <span class="number">0</span> <span class="keyword">and</span> right &lt; n <span class="keyword">and</span> s[left] == s[right]:</span><br><span class="line">            left -= <span class="number">1</span></span><br><span class="line">            right += <span class="number">1</span></span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> count</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Intuitive solution.</p>
</blockquote>
<p>Run time: $O(n^2)$, space: $O(1)$</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">countSubstrings</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span>(<span class="params">s, i</span>):</span></span><br><span class="line">        <span class="keyword">if</span> i &lt; <span class="number">0</span> <span class="keyword">or</span> i &gt;= <span class="built_in">len</span>(s):</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        count = <span class="number">1</span></span><br><span class="line">        left,right = i-<span class="number">1</span>,i+<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> left &gt;=<span class="number">0</span> <span class="keyword">and</span> right &lt; <span class="built_in">len</span>(s):</span><br><span class="line">            <span class="keyword">if</span> s[left] == s[right]:</span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">            left, right = left-<span class="number">1</span>, right+<span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> i+<span class="number">1</span> &lt; <span class="built_in">len</span>(s) <span class="keyword">and</span> s[i] == s[i+<span class="number">1</span>]:</span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line">            left,right = i-<span class="number">1</span>,i+<span class="number">2</span></span><br><span class="line">            <span class="keyword">while</span> left &gt;=<span class="number">0</span> <span class="keyword">and</span> right &lt; <span class="built_in">len</span>(s):</span><br><span class="line">                <span class="keyword">if</span> s[left] == s[right]:</span><br><span class="line">                    count += <span class="number">1</span></span><br><span class="line">                left, right = left-<span class="number">1</span>, right+<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> count</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> s:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    ans = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)):</span><br><span class="line">        ans += helper(s, i)</span><br><span class="line">    <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>415. Add Strings</summary>
> use `chr()` to convert integer to character. `ord()` converts a charactor to integer.
<p>Run time: $O(max(two strings))$, space: $O(max(two strings))$</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">addStrings</span>(<span class="params">self, num1, num2</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    :type num1: str</span></span><br><span class="line"><span class="string">    :type num2: str</span></span><br><span class="line"><span class="string">    :rtype: str</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    ans = []</span><br><span class="line">    i1, i2 = <span class="built_in">len</span>(num1)-<span class="number">1</span>, <span class="built_in">len</span>(num2)-<span class="number">1</span></span><br><span class="line">    carry = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> i1 &gt;= <span class="number">0</span> <span class="keyword">or</span> i2 &gt;= <span class="number">0</span> <span class="keyword">or</span> carry &gt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">if</span> i1 &gt;= <span class="number">0</span>:</span><br><span class="line">            carry += <span class="built_in">ord</span>(num1[i1]) - <span class="built_in">ord</span>(<span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">            i1 -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> i2 &gt;= <span class="number">0</span>:</span><br><span class="line">            carry += <span class="built_in">ord</span>(num2[i2]) - <span class="built_in">ord</span>(<span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">            i2 -= <span class="number">1</span></span><br><span class="line">        ans.append(<span class="built_in">chr</span>(carry % <span class="number">10</span> + <span class="built_in">ord</span>(<span class="string">&#x27;0&#x27;</span>)))</span><br><span class="line">        carry //= <span class="number">10</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&quot;</span>.join(ans)[::-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<details>
<summary>My approach</summary>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">addStrings</span>(<span class="params">self, num1, num2</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    :type num1: str</span></span><br><span class="line"><span class="string">    :type num2: str</span></span><br><span class="line"><span class="string">    :rtype: str</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    ans = <span class="number">0</span></span><br><span class="line">    digit = <span class="number">0</span></span><br><span class="line">    i, j = <span class="built_in">len</span>(num1)-<span class="number">1</span>, <span class="built_in">len</span>(num2)-<span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> i &gt;= <span class="number">0</span> <span class="keyword">and</span> j &gt;= <span class="number">0</span>:</span><br><span class="line">        d1 = <span class="built_in">int</span>(num1[i])</span><br><span class="line">        d2 = <span class="built_in">int</span>(num2[j])</span><br><span class="line">        temp_sum = d1+d2</span><br><span class="line">        temp = <span class="number">10</span>**digit * (temp_sum % <span class="number">10</span>) + <span class="number">10</span>**(digit+<span class="number">1</span>) *(temp_sum//<span class="number">10</span>)</span><br><span class="line">        ans += temp</span><br><span class="line">        digit += <span class="number">1</span></span><br><span class="line">        i, j = i-<span class="number">1</span>, j-<span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> i &lt; <span class="number">0</span> <span class="keyword">and</span> j &lt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">str</span>(ans)</span><br><span class="line">    <span class="keyword">elif</span> i &lt; <span class="number">0</span>:</span><br><span class="line">        ans += (<span class="number">10</span>**digit) * <span class="built_in">int</span>(num2[:j+<span class="number">1</span>])</span><br><span class="line">    <span class="keyword">elif</span> j &lt; <span class="number">0</span>:</span><br><span class="line">        ans += (<span class="number">10</span>**digit) * <span class="built_in">int</span>(num1[:i+<span class="number">1</span>])</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">str</span>(ans)</span><br></pre></td></tr></table></figure>
</details>
</details>
<details>
<summary>68. Text Justification</summary>
> Use one list for final output, one list for current line, one variable to keep track of current character count. Since the current length also represents the minimum space added between words, if the length of current line, plus current character count, plus current word length exceeds `maxWidth`, then we should not add this word, and need to add more space to make the words on the current line distributed evenly. 
Therefore, we loop from 0 to `maxWidth-char_count`, which is the number of space to be added on this line, then we take modulo. For example, if there are three words on this line, and we need to add 5 space. We first get 0%(3-1), which is 0. Then we calculate 1%(3-1), which is 1. Then we calculate 2%(3-1), which is 0. Then we calculate 3%(3-1), which is 1. Then we calculate 4%(3-1), which is 0. 
<p>Run time: $O(n)$, space: $O(n)$</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fullJustify</span>(<span class="params">self, words, maxWidth</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    :type words: List[str]</span></span><br><span class="line"><span class="string">    :type maxWidth: int</span></span><br><span class="line"><span class="string">    :rtype: List[str]</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    ans = []</span><br><span class="line">    cur = []</span><br><span class="line">    char_count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> w <span class="keyword">in</span> words:</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(cur) + char_count + <span class="built_in">len</span>(w) &gt; maxWidth:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(maxWidth - char_count):</span><br><span class="line">                cur[i % (<span class="built_in">len</span>(cur)-<span class="number">1</span> <span class="keyword">or</span> <span class="number">1</span>)] += <span class="string">&#x27; &#x27;</span></span><br><span class="line">            ans.append(<span class="string">&#x27;&#x27;</span>.join(cur))</span><br><span class="line">            cur = []</span><br><span class="line">            char_count = <span class="number">0</span></span><br><span class="line">        cur += [w]</span><br><span class="line">        char_count += <span class="built_in">len</span>(w)</span><br><span class="line">    <span class="comment"># form last line by join with space and left justify to maxWidth using ljust (python method)</span></span><br><span class="line">    <span class="comment"># that means pad additional spaces to the right to make string length equal to maxWidth</span></span><br><span class="line">    <span class="keyword">return</span> ans + [<span class="string">&#x27; &#x27;</span>.join(cur).ljust(maxWidth)]</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>408. Valid Word Abbreviation</summary>
> Use two pointers, one for index in the word, one for the abbr.
<p>Run time: $O(n)$, space: $O(1)$</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">validWordAbbreviation</span>(<span class="params">self, word, abbr</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    :type word: str</span></span><br><span class="line"><span class="string">    :type abbr: str</span></span><br><span class="line"><span class="string">    :rtype: bool</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    i = j = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> i &lt; <span class="built_in">len</span>(word) <span class="keyword">and</span> j &lt; <span class="built_in">len</span>(abbr):</span><br><span class="line">        <span class="keyword">if</span> word[i] == abbr[j]:</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">            j += <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> abbr[j] == <span class="string">&quot;0&quot;</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">elif</span> abbr[j].isdigit():</span><br><span class="line">            k = j+<span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> k &lt; <span class="built_in">len</span>(abbr) <span class="keyword">and</span> abbr[k].isdigit():</span><br><span class="line">                k += <span class="number">1</span></span><br><span class="line">            i += <span class="built_in">int</span>(abbr[j:k])</span><br><span class="line">            j = k</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> i == <span class="built_in">len</span>(word) <span class="keyword">and</span> j == <span class="built_in">len</span>(abbr)</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>921. Minimum Add to Make Parentheses Valid</summary>
> Maintain a count of current ungrouped parentheses, and a count of parentheses needed to be inserted. If we see a (, increment the count, otherwise decrement the count if it is greater than 0, or increment the final count.
<p>Run time: $O(n)$, space: $O(1)$</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">minAddToMakeValid</span>(<span class="params">self, s</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    :type s: str</span></span><br><span class="line"><span class="string">    :rtype: int</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    ans = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> c <span class="keyword">in</span> s:</span><br><span class="line">        <span class="keyword">if</span> c == <span class="string">&#x27;(&#x27;</span>:</span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> count == <span class="number">0</span>:</span><br><span class="line">            ans += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            count -= <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> ans + count</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>1249. Minimum Remove to Make Valid Parentheses</summary>
> Use stack to store "(" only, and when encounter ")" and stack is empty, record this index. If stack is not empy, then pop one "(". In the end union the stack and the list and skip these indices when building the final string.
<p>Run time: $O(n)$, space: $O(n)$</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">minRemoveToMakeValid</span>(<span class="params">self, s</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    :type s: str</span></span><br><span class="line"><span class="string">    :rtype: str</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">remove_invalid</span>(<span class="params">s, good, bad</span>):</span></span><br><span class="line">        sb = []</span><br><span class="line">        bal = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> c == good:</span><br><span class="line">                bal += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> c == bad:</span><br><span class="line">                <span class="keyword">if</span> bal == <span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                bal -= <span class="number">1</span></span><br><span class="line">            sb.append(c)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>.join(sb)</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    s = remove_invalid(s, <span class="string">&quot;(&quot;</span>, <span class="string">&quot;)&quot;</span>)    </span><br><span class="line">    s = remove_invalid(s[::-<span class="number">1</span>], <span class="string">&quot;)&quot;</span>, <span class="string">&quot;(&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> s[::-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">minRemoveToMakeValid</span>(<span class="params">self, s</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    :type s: str</span></span><br><span class="line"><span class="string">    :rtype: str</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    ind_remove = <span class="built_in">set</span>()</span><br><span class="line">    stack = []</span><br><span class="line">    <span class="keyword">for</span> i, c <span class="keyword">in</span> <span class="built_in">enumerate</span>(s):</span><br><span class="line">        <span class="keyword">if</span> c <span class="keyword">not</span> <span class="keyword">in</span> <span class="string">&quot;()&quot;</span>:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">if</span> c == <span class="string">&quot;(&quot;</span>: <span class="comment"># add ( to stack</span></span><br><span class="line">            stack.append(i)</span><br><span class="line">        <span class="keyword">elif</span> <span class="keyword">not</span> stack: <span class="comment"># ) and stack empty, need to remove</span></span><br><span class="line">            ind_remove.add(i)</span><br><span class="line">        <span class="keyword">else</span>: <span class="comment"># ) and stack not empty, pop one</span></span><br><span class="line">            stack.pop()</span><br><span class="line">        </span><br><span class="line">    ind_remove = ind_remove.union(<span class="built_in">set</span>(stack))</span><br><span class="line">    sb = []</span><br><span class="line">    <span class="keyword">for</span> i, c <span class="keyword">in</span> <span class="built_in">enumerate</span>(s):</span><br><span class="line">        <span class="keyword">if</span> i <span class="keyword">not</span> <span class="keyword">in</span> ind_remove:</span><br><span class="line">            sb.append(c)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&quot;</span>.join(sb)</span><br></pre></td></tr></table></figure>
</details>
<h1>Recursion / Math</h1>
<details>
<summary></summary>
> 
<p>Run time: $O()$, space: $O()$</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>670. Maximum Swap</summary>
<blockquote>
<p>Iterate the list of digits backwards and keep tracking of the max digit, as well as the digit that is smaller than the max.<br>
<a href="https://leetcode.com/problems/maximum-swap/discuss/1593049/Python-simple-1-pass-solution">https://leetcode.com/problems/maximum-swap/discuss/1593049/Python-simple-1-pass-solution</a></p>
</blockquote>
<p>Run time: $O(n)$, space: $O(1)$</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">maximumSwap</span>(<span class="params">self, num: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">    digits = <span class="built_in">list</span>(<span class="built_in">str</span>(num))</span><br><span class="line">    min_ind, max_ind, max_i = -<span class="number">1</span>, -<span class="number">1</span>, <span class="built_in">len</span>(digits)-<span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(max_i-<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">if</span> digits[i] &gt; digits[max_i]:</span><br><span class="line">            max_i = i</span><br><span class="line">        <span class="keyword">elif</span> digits[i] &lt; digits[max_i]:</span><br><span class="line">            min_ind, max_ind = i, max_i</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> min_ind &gt; -<span class="number">1</span>:</span><br><span class="line">        digits[min_ind], digits[max_ind] = digits[max_ind], digits[min_ind]</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">int</span>(<span class="string">&#x27;&#x27;</span>.join(digits))</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>48. Rotate Image</summary>
> rotate the image by 90 degrees (clockwise) is equivalent to transpose + reflection.
<p>Run time: $O(mn)$, space: $O(1)$</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rotate</span>(<span class="params">self, matrix: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Do not return anything, modify matrix in-place instead.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">transpose</span>(<span class="params">ma</span>):</span></span><br><span class="line">        n = <span class="built_in">len</span>(ma)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i+<span class="number">1</span>, n):</span><br><span class="line">                ma[j][i], ma[i][j] = ma[i][j], ma[j][i]</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reflect</span>(<span class="params">ma</span>):</span></span><br><span class="line">        n = <span class="built_in">len</span>(ma)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n//<span class="number">2</span>):</span><br><span class="line">                ma[i][j], ma[i][-j-<span class="number">1</span>] = ma[i][-j-<span class="number">1</span>], ma[i][j]</span><br><span class="line"></span><br><span class="line">    transpose(matrix)</span><br><span class="line">    reflect(matrix)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Directly rotate. ~ means invert, ~j = -j-1</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rotate</span>(<span class="params">self, matrix: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Do not return anything, modify matrix in-place instead.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    n = <span class="built_in">len</span>(matrix)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n//<span class="number">2</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n - n//<span class="number">2</span>):</span><br><span class="line">            matrix[i][j], matrix[~j][i], matrix[~i][~j], matrix[j][~i] = \</span><br><span class="line">                     matrix[~j][i], matrix[~i][~j], matrix[j][~i], matrix[i][j]</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>268. Missing Number</summary>
<blockquote>
<p>Gauss’ Formula. Compute expected sum and actual sum, the difference is the missing number.</p>
</blockquote>
<p>Run time: $O(n)$, space: $O(1)$</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">missingNumber</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">    n = <span class="built_in">len</span>(nums)</span><br><span class="line">    expected = n*(n+<span class="number">1</span>) // <span class="number">2</span></span><br><span class="line">    actual = <span class="built_in">sum</span>(nums)</span><br><span class="line">    <span class="keyword">return</span> expected-actual</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Bit Manipulation.<br>
Intuition<br>
We can harness the fact that XOR is its own inverse to find the missing element in linear time.</p>
</blockquote>
<p>Algorithm<br>
Because we know that nums contains nn numbers and that it is missing exactly one number on the range [0…n-1][0…n−1], we know that nn definitely replaces the missing number in nums. Therefore, if we initialize an integer to nn and XOR it with every index and value, we will be left with the missing number. Consider the following example (the values have been sorted for intuitive convenience, but need not be):</p>
<p>Run time: $O(n)$, space: $O(1)$</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">missingNumber</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">    missing = <span class="built_in">len</span>(nums)</span><br><span class="line">    <span class="keyword">for</span> i, num <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums):</span><br><span class="line">        missing ^= i ^ num</span><br><span class="line">    <span class="keyword">return</span> missing</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Initialize a set using the input array. Loop through the length of array + 1, if not in set, return this number.</p>
</blockquote>
<p>Run time: $O(n)$, space: $O(n)$</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">missingNumber</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">    num_set = <span class="built_in">set</span>(nums)</span><br><span class="line">    n = <span class="built_in">len</span>(nums) + <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> number <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        <span class="keyword">if</span> number <span class="keyword">not</span> <span class="keyword">in</span> num_set:</span><br><span class="line">            <span class="keyword">return</span> number</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>238. Product of Array Except Self</summary>
> The output array does not count toward the space complexity. Use original output array to find the cumulative sum from left, then use one variable to keep track of the cumulative sum from right, and multiply it to the output array.
<p>Run time: $O(n)$, space: $O(1)$</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">productExceptSelf</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span></span><br><span class="line">    n = <span class="built_in">len</span>(nums)</span><br><span class="line">    ans = [<span class="number">1</span>] * n</span><br><span class="line">    right = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n): <span class="comment"># cumulative sum from left</span></span><br><span class="line">        ans[i] = ans[i-<span class="number">1</span>]*nums[i-<span class="number">1</span>]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n-<span class="number">2</span>,-<span class="number">1</span>,-<span class="number">1</span>): <span class="comment"># cumulative sum from right</span></span><br><span class="line">        right *= nums[i+<span class="number">1</span>]</span><br><span class="line">        ans[i] *= right</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">productExceptSelf</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span></span><br><span class="line">    n = <span class="built_in">len</span>(nums)</span><br><span class="line">    left, right = <span class="number">1</span>, <span class="number">1</span></span><br><span class="line">    ans = [<span class="number">1</span>]*n</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n):</span><br><span class="line">        left *= nums[i-<span class="number">1</span>]</span><br><span class="line">        ans[i] = left</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n-<span class="number">2</span>,-<span class="number">1</span>,-<span class="number">1</span>):</span><br><span class="line">        right *= nums[i+<span class="number">1</span>]</span><br><span class="line">        ans[i] *= right</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<blockquote>
<p>One array to track the cumulative sum from left, one array to track the cumulative sum from right. In the end, multiply them together on the same index.</p>
</blockquote>
<p>Run time: $O(n)$, space: $O(n)$</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">productExceptSelf</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span></span><br><span class="line">    n = <span class="built_in">len</span>(nums)</span><br><span class="line">    left, right = [<span class="number">1</span>]*n, [<span class="number">1</span>]*n</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n):</span><br><span class="line">        left[i] = nums[i-<span class="number">1</span>] * left[i-<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n-<span class="number">2</span>,-<span class="number">1</span>,-<span class="number">1</span>):</span><br><span class="line">        right[i] = nums[i+<span class="number">1</span>] * right[i+<span class="number">1</span>]</span><br><span class="line">    <span class="built_in">print</span>(left, right)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        left[i] *= right[i]</span><br><span class="line">    <span class="keyword">return</span> left</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>67. Add Binary</summary>
<blockquote>
<p>XOR: ^, AND: &amp;, left-shifted: &lt;&lt;</p>
</blockquote>
<p>Run time: $O(m+n)$, space: $O(max(m,n))$</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">addBinary</span>(<span class="params">self, a: <span class="built_in">str</span>, b: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span></span><br><span class="line">    x, y = <span class="built_in">int</span>(a,<span class="number">2</span>), <span class="built_in">int</span>(b,<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">while</span> y:</span><br><span class="line">        ans = x ^ y</span><br><span class="line">        carry = (x &amp; y) &lt;&lt; <span class="number">1</span></span><br><span class="line">        x, y = ans, carry</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">bin</span>(x)[<span class="number">2</span>:]</span><br></pre></td></tr></table></figure>
<blockquote>
<p>two pointers, and one carry</p>
</blockquote>
<p>Run time: $O(max(m,n))$, space: $O(max(m,n))$</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">addBinary</span>(<span class="params">self, a: <span class="built_in">str</span>, b: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span></span><br><span class="line">    ans = <span class="string">&quot;&quot;</span></span><br><span class="line">    i,j = <span class="built_in">len</span>(a)-<span class="number">1</span>, <span class="built_in">len</span>(b)-<span class="number">1</span></span><br><span class="line">    carry = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> i&gt;= <span class="number">0</span> <span class="keyword">or</span> j&gt;=<span class="number">0</span> <span class="keyword">or</span> carry&gt;<span class="number">0</span>:</span><br><span class="line">        <span class="keyword">if</span> i&gt;=<span class="number">0</span>:</span><br><span class="line">            carry += <span class="built_in">int</span>(a[i])</span><br><span class="line">        <span class="keyword">if</span> j&gt;=<span class="number">0</span>:</span><br><span class="line">            carry += <span class="built_in">int</span>(b[j])</span><br><span class="line">        <span class="keyword">if</span> carry == <span class="number">3</span>:</span><br><span class="line">            ans += <span class="string">&quot;1&quot;</span></span><br><span class="line">            carry = <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> carry == <span class="number">2</span>:</span><br><span class="line">            ans += <span class="string">&quot;0&quot;</span></span><br><span class="line">            carry = <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> carry == <span class="number">1</span>:</span><br><span class="line">            ans += <span class="string">&quot;1&quot;</span></span><br><span class="line">            carry = <span class="number">0</span></span><br><span class="line">        i,j = i-<span class="number">1</span>,j-<span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> ans[::-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
</details>
</details>
<details>
<summary>69. Sqrt(x)</summary>
<blockquote>
<p>Newton method. $x_{n+1} = x_n - \frac{f(x_n)}{f’(x_n)}$, where $f(x) = x^2-a = 0$.</p>
</blockquote>
<p>Run time: $O(\log n)$, space: $O(1)$</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mySqrt</span>(<span class="params">self, x</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    :type x: int</span></span><br><span class="line"><span class="string">    :rtype: int</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    a = x</span><br><span class="line">    <span class="keyword">while</span> a**<span class="number">2</span> &gt; x:</span><br><span class="line">        a = (a + x/a)//<span class="number">2</span></span><br><span class="line">    <span class="keyword">return</span> a</span><br></pre></td></tr></table></figure>
<blockquote>
<p>binary search.</p>
</blockquote>
<p>Run time: $O(\log n)$, space: $O(1)$</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mySqrt</span>(<span class="params">self, x</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    :type x: int</span></span><br><span class="line"><span class="string">    :rtype: int</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> x == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    lo, hi = <span class="number">1</span>, x</span><br><span class="line">    <span class="keyword">while</span> lo &lt;= hi:</span><br><span class="line">        mid = lo + (hi-lo)//<span class="number">2</span></span><br><span class="line">        sqrt = x // mid</span><br><span class="line">        <span class="keyword">if</span> sqrt == mid:</span><br><span class="line">            <span class="keyword">return</span> mid</span><br><span class="line">        <span class="keyword">elif</span> sqrt &lt; mid:</span><br><span class="line">            hi = mid-<span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            lo = mid +<span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> hi</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>50. Pow(x, n)</summary>
<blockquote>
<p>First check if power is 0, and check if power is negative. If so, flip the sign of the power and return the reciprocal. Then calculate the half of the power, and if the original power is odd, multiply by one more <code>x</code>.</p>
</blockquote>
<p>Run time: $O(\log n)$, space: $O(1)$</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">myPow</span>(<span class="params">self, x, n</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    :type x: float</span></span><br><span class="line"><span class="string">    :type n: int</span></span><br><span class="line"><span class="string">    :rtype: float</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span>: <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> n &lt; <span class="number">0</span>: <span class="keyword">return</span> <span class="number">1.0</span> / self.myPow(x, -n)</span><br><span class="line">    half = self.myPow(x, n // <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">if</span> n % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> half * half</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> half * half * x</span><br></pre></td></tr></table></figure>
</details>]]></content>
  </entry>
  <entry>
    <title>LeetCode Summary</title>
    <url>/leetcode-summary/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Template:</p>
<details>
<summary></summary>
</details>
<h2 id="Union-Find">Union-Find</h2>
<hr>
<details>
<summary></summary>
<blockquote></blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>721. Accounts Merge</summary>
<blockquote>
<p>Use three maps: &lt;email, name&gt;, &lt;email, parent email&gt; for “find”, &lt;parent email, child emails in sorted order&gt; for “union”.<br>
First for each account, put &lt;email, username&gt; and set the parent email as itself.<br>
Then for each account, find the parent email of the first email, then set the parent of the rest emails to be this email<br>
Then for each account, find the parent email of the first email, then put the parent email as the key, and all emails (including parent) as the values in the tree set<br>
For each key in the union map, transform the tree set to list, and add the username to the first position, and add to the result list</p>
</blockquote>
<p>Run time: $O(n)$, space: $O(n)$</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; accountsMerge(List&lt;List&lt;String&gt;&gt; accounts) &#123;</span><br><span class="line">    Map&lt;String, String&gt; owner = <span class="keyword">new</span> HashMap&lt;&gt;(); <span class="comment">// email, name</span></span><br><span class="line">    Map&lt;String, String&gt; parents = <span class="keyword">new</span> HashMap&lt;&gt;(); <span class="comment">// email, parent</span></span><br><span class="line">    Map&lt;String, TreeSet&lt;String&gt;&gt; unions = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(List&lt;String&gt; acc: accounts)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; acc.size(); i++)&#123; <span class="comment">// initialize </span></span><br><span class="line">            owner.put(acc.get(i), acc.get(<span class="number">0</span>));</span><br><span class="line">            parents.put(acc.get(i), acc.get(i)); <span class="comment">// set parent to be itself</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(List&lt;String&gt; acc: accounts)&#123;</span><br><span class="line">        String p = find(acc.get(<span class="number">1</span>), parents); <span class="comment">// find parent</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; acc.size(); i++)&#123;</span><br><span class="line">            parents.put(find(acc.get(i), parents), p);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(List&lt;String&gt; acc : accounts) &#123;</span><br><span class="line">        String p = find(acc.get(<span class="number">1</span>), parents);</span><br><span class="line">        <span class="keyword">if</span> (!unions.containsKey(p)) unions.put(p, <span class="keyword">new</span> TreeSet&lt;&gt;());</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; acc.size(); i++)</span><br><span class="line">            unions.get(p).add(acc.get(i)); <span class="comment">// add child</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    List&lt;List&lt;String&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (String p : unions.keySet()) &#123;</span><br><span class="line">        List&lt;String&gt; emails = <span class="keyword">new</span> ArrayList(unions.get(p)); <span class="comment">// get all children</span></span><br><span class="line">        emails.add(<span class="number">0</span>, owner.get(p)); <span class="comment">// add name</span></span><br><span class="line">        res.add(emails);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> String <span class="title">find</span><span class="params">(String s, Map&lt;String, String&gt; p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p.get(s) == s) <span class="keyword">return</span> s;</span><br><span class="line">    <span class="keyword">return</span> find(p.get(s), p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>BFS</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; accountsMerge2(List&lt;List&lt;String&gt;&gt; accounts) &#123;</span><br><span class="line">    Map&lt;String, Set&lt;String&gt;&gt; graph = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    Map&lt;String, String&gt; emailToName = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// step 1: build graph that connects all emails have relationships</span></span><br><span class="line">    <span class="keyword">for</span> (List&lt;String&gt; account : accounts) &#123;</span><br><span class="line">        String name = account.get(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; account.size(); i++) &#123;</span><br><span class="line">            graph.putIfAbsent(account.get(i), <span class="keyword">new</span> HashSet&lt;&gt;());</span><br><span class="line">            emailToName.put(account.get(i), name);</span><br><span class="line">            <span class="keyword">if</span> (i != <span class="number">1</span>) &#123;</span><br><span class="line">                graph.get(account.get(i)).add(account.get(i - <span class="number">1</span>));</span><br><span class="line">                graph.get(account.get(i - <span class="number">1</span>)).add(account.get(i));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// step 2: BFS traversal to traverse all nodes in every single component and generate each result list individually</span></span><br><span class="line">    List&lt;List&lt;String&gt;&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    Set&lt;String&gt; visited = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (String email : graph.keySet()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!visited.contains(email)) &#123;</span><br><span class="line">            visited.add(email);</span><br><span class="line">            List&lt;String&gt; newList = bfs(graph, visited, email);</span><br><span class="line">            Collections.sort(newList);</span><br><span class="line">            newList.add(<span class="number">0</span>, emailToName.get(newList.get(<span class="number">0</span>)));</span><br><span class="line">            result.add(newList);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">bfs</span><span class="params">(Map&lt;String, Set&lt;String&gt;&gt; graph, Set&lt;String&gt; visited, String startPoint)</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; newList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    Queue&lt;String&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    queue.offer(startPoint);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(!queue.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> size = queue.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            String curEmail = queue.poll();</span><br><span class="line">            newList.add(curEmail);</span><br><span class="line">            Set&lt;String&gt; neighbors = graph.get(curEmail);</span><br><span class="line">            <span class="keyword">for</span> (String neighbor : neighbors) &#123;</span><br><span class="line">                <span class="comment">// WARING: DO NOT FORGET to check whether current email has been visited before</span></span><br><span class="line">                <span class="keyword">if</span> (!visited.contains(neighbor)) &#123;</span><br><span class="line">                    visited.add(neighbor);</span><br><span class="line">                    queue.offer(neighbor);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>DFS</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; accountsMerge3(List&lt;List&lt;String&gt;&gt; accounts) &#123;</span><br><span class="line">    Map&lt;String, Set&lt;String&gt;&gt; graph = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    Map&lt;String, String&gt; emailToName = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// step 1: build graph that connects all emails have relationships</span></span><br><span class="line">    <span class="keyword">for</span> (List&lt;String&gt; account : accounts) &#123;</span><br><span class="line">        String name = account.get(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; account.size(); i++) &#123;</span><br><span class="line">            graph.putIfAbsent(account.get(i), <span class="keyword">new</span> HashSet&lt;&gt;());</span><br><span class="line">            emailToName.put(account.get(i), name);</span><br><span class="line">            <span class="keyword">if</span> (i != <span class="number">1</span>) &#123;</span><br><span class="line">                graph.get(account.get(i)).add(account.get(i - <span class="number">1</span>));</span><br><span class="line">                graph.get(account.get(i - <span class="number">1</span>)).add(account.get(i));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// step 2: DFS traversal to traverse all nodes in every single component and generate each result list individually</span></span><br><span class="line">    List&lt;List&lt;String&gt;&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    Set&lt;String&gt; visited = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (String email : graph.keySet()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!visited.contains(email)) &#123;</span><br><span class="line">            visited.add(email);</span><br><span class="line">            List&lt;String&gt; newList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            dfs(newList, graph, visited, email);</span><br><span class="line">            Collections.sort(newList);</span><br><span class="line">            newList.add(<span class="number">0</span>, emailToName.get(newList.get(<span class="number">0</span>)));</span><br><span class="line">            result.add(newList);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(List&lt;String&gt; result, Map&lt;String, Set&lt;String&gt;&gt; graph, Set&lt;String&gt; visited, String curPoint)</span> </span>&#123;</span><br><span class="line">    result.add(curPoint);</span><br><span class="line">    Set&lt;String&gt; neighbors = graph.get(curPoint);</span><br><span class="line">    <span class="keyword">for</span> (String neighbor : neighbors) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!visited.contains(neighbor)) &#123;</span><br><span class="line">            visited.add(neighbor);</span><br><span class="line">            dfs(result, graph, visited, neighbor);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>RestrictedPaths (G)</summary>
<blockquote>
<p>Relevant post: <a href="https://www.careercup.com/question?id=5735650041528320">link</a><br>
A graph has N vertices numbered from 1 to N. We have two lists. One list M consisted of edges between vertices. The other list K consists of restricted paths. We have to add edges one by one from M and check whether the addition of the particular edge leads to a path between the restricted vertices given in K. If it creates a path, we have to discard the edge.</p>
</blockquote>
<ol>
<li>
<p>First build the graph ( like 2d array) of n nodes using edge list</p>
</li>
<li>
<p>Then pick a pair from restricted nodes and recursively check does current node pass through any other node which is restricted, if so, simply remove that edge(s).<br>
Complexity = there can be at most n^2 edges = M size O(m) , You need to pick a pair from k list O(k), and check all possible connections from source to destination of picked pair O(m)<br>
$O(nkm^2)$</p>
</li>
<li></li>
</ol>
<p>2.1 build hash to set of given k list O(k)<br>
2.2 Rater bulding graph, while building it check the restrictions recursively using 2d matrix,<br>
Complexity = you need to traverse whole matrix to check restrictions O(n^2)<br>
For each pair from edge list O(m) , keeping hash to set of nodes from k list O(1)<br>
O(mn^2)</p>
<ol start="3">
<li>Efficient<br>
Use union find algo, assuming path compression is used.<br>
3.1 union edges from m list one by one if they are not connected, before connecting them see O(m)</li>
</ol>
<p>a) the parent (s) of pair source does not lies in k list O(logn)<br>
B) child of pair of destinations node not lies in k list O(logn)<br>
If either of its true, then discard</p>
<p>Complexity = O(logn + logn) * O(m)<br>
$O(mk\log n)$</p>
<blockquote>
<p>Other option still using disjoint set is for each edge, before adding it, check the sets for each vertex in the edge (say sets x and y) and for each edge in the K list check also the sets of its vertices (say sets w and z), in case (x == z &amp;&amp; y == w) || (x == w &amp;&amp; y == z) discard the edge.</p>
</blockquote>
<p>Complexity is O(mk logn)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RestrictedPaths</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;UndirectedGraph.Edge&gt; create(List&lt;UndirectedGraph.Edge&gt; edges, List&lt;UndirectedGraph.Edge&gt; restricted, <span class="keyword">int</span> n) &#123;</span><br><span class="line">        DisjointSet ds = <span class="keyword">new</span> DisjointSet(n);</span><br><span class="line">        List&lt;UndirectedGraph.Edge&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (UndirectedGraph.Edge edge: edges) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> x = ds.find(edge.getSrc());</span><br><span class="line">            <span class="keyword">int</span> y = ds.find(edge.getDest());</span><br><span class="line"></span><br><span class="line">            <span class="keyword">boolean</span> validEdge = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">for</span> (UndirectedGraph.Edge r: restricted) &#123;</span><br><span class="line">                <span class="keyword">int</span> z = ds.find(r.getSrc());</span><br><span class="line">                <span class="keyword">int</span> w = ds.find(r.getDest());</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> ((x == z &amp;&amp; y == w) || (x == w &amp;&amp; y == z)) &#123;</span><br><span class="line">                    validEdge = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (validEdge) &#123;</span><br><span class="line">                result.add(edge);</span><br><span class="line">                ds.union(x, y);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>Peers and Managers (G)</summary>
<blockquote>
<p>A company has a bunch of employees; each employee has a single direct manager. There is a stream of actions:<br>
set_manager(A, B) -&gt; Set B’s direct manager to A<br>
set_peer(A, B) -&gt; set A and B’s direct manager to the same<br>
query_manager(A,B) -&gt; returns true if A is on the management chain of B, false otherwise.</p>
</blockquote>
<p>Relevant posts: <a href="https://www.1point3acres.com/bbs/thread-138543-1-1.html">2015</a>, <a href="https://www.1point3acres.com/bbs/thread-422437-1-1.html">2018</a><br>
Union Find, HashMap checking cycle, or DFS</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QueryMangerImpl</span> <span class="keyword">implements</span> <span class="title">QueryManger</span></span>&#123;</span><br><span class="line">    Map&lt;Integer, Integer&gt; employmentMap;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">QueryMangerImpl</span> <span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setManger</span><span class="params">(<span class="keyword">int</span> manager, <span class="keyword">int</span> employee)</span> <span class="keyword">throws</span> CyclicRelationFoundException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (queryManager(employee, manager)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> CyclicRelationFoundException(String.format(<span class="string">&quot;There is management relation from %s to %s&quot;</span>,</span><br><span class="line">                    manager, employee));</span><br><span class="line">        &#125;</span><br><span class="line">        employmentMap.put(employee, manager);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPeer</span><span class="params">(<span class="keyword">int</span> managerFrom, <span class="keyword">int</span> employee)</span> <span class="keyword">throws</span> EmployeeNotFoundException, CyclicRelationFoundException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!employmentMap.containsKey(managerFrom)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> EmployeeNotFoundException(String.format(<span class="string">&quot;Employee %s is not found&quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> newManager = employmentMap.get(managerFrom);</span><br><span class="line">        <span class="keyword">if</span> (queryManager(employee, newManager)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> CyclicRelationFoundException(String.format(<span class="string">&quot;There is management relation from %s to %s&quot;</span>, newManager, employee));</span><br><span class="line">        &#125;</span><br><span class="line">        employmentMap.put(employee, newManager);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">queryManager</span><span class="params">(<span class="keyword">int</span> manager, <span class="keyword">int</span> employee)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (manager == employee) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (employmentMap.containsKey(employee)) &#123;</span><br><span class="line">            employee = employmentMap.get(employee);</span><br><span class="line">            <span class="keyword">if</span> (employee == manager) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">QueryManger</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setManger</span><span class="params">(<span class="keyword">int</span> manager, <span class="keyword">int</span> employee)</span> <span class="keyword">throws</span> CyclicRelationFoundException</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPeer</span><span class="params">(<span class="keyword">int</span> managerFrom, <span class="keyword">int</span> target)</span> <span class="keyword">throws</span> CyclicRelationFoundException, EmployeeNotFoundException</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">queryManager</span><span class="params">(<span class="keyword">int</span> manager, <span class="keyword">int</span> employee)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CyclicRelationFoundException</span> <span class="keyword">extends</span> <span class="title">Exception</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CyclicRelationFoundException</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EmployeeNotFoundException</span> <span class="keyword">extends</span> <span class="title">Exception</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">EmployeeNotFoundException</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Union set/find?</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//assume there are N employees with id 0 to N-1</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">peer_manager</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span>[] manager;</span><br><span class="line">	<span class="keyword">int</span>[] ids;</span><br><span class="line">	<span class="keyword">int</span>[] sz;   </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">peer_manager</span><span class="params">(<span class="keyword">int</span> N)</span></span>&#123;</span><br><span class="line">		manager = <span class="keyword">new</span> <span class="keyword">int</span>[N]; </span><br><span class="line">		Arrays.fill(manager, -<span class="number">1</span>); </span><br><span class="line">		</span><br><span class="line">		ids = <span class="keyword">new</span> <span class="keyword">int</span>[N];</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) ids[i] = i;</span><br><span class="line">		</span><br><span class="line">		sz = <span class="keyword">new</span> <span class="keyword">int</span>[N]; </span><br><span class="line">		Arrays.fill(sz, <span class="number">1</span>); </span><br><span class="line">	&#125;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">//indicate p and q have the same direct manager</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set_peer</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pr = root(p);</span><br><span class="line">        <span class="keyword">int</span> qr = root(q);</span><br><span class="line">        <span class="keyword">int</span> mgr = max(manager[pr], manager[qr]);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(sz[pr] &gt; sz[qr])&#123;</span><br><span class="line">            ids[qr] = pr;</span><br><span class="line">            sz[pr] += sz[qr];</span><br><span class="line">            manager[pr] = mgr;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ids[pr] = qr;</span><br><span class="line">            sz[qr] += sz[pr];</span><br><span class="line">            manager[qr] = mgr;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">//indicate p is the direct manager of q</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set_manager</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> qr = root(q);</span><br><span class="line">        manager[qr] = p;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">//check if p is in the management chain of q</span></span><br><span class="line">    <span class="function">bool <span class="title">query_manager</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> qr = root(q);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(manager[qr] == -<span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(manager[qr] == p) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//follow managerment chain</span></span><br><span class="line">            q = manager[qr];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">root</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(i != ids[i]) i = ids[i];</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>1101. The Earliest Moment When Everyone Become Friends</summary>
<blockquote>
<p>First sort the logs by chronological (increasing) order.<br>
Create a UnionFind class and initialize an array of length N, the number of people, set each parent to be itself.<br>
For each log, call union method in the UnionFind class, first find the parents of each person.<br>
If they are not the same, update the date. Also set the parent of person x to be person y.<br>
In the find method, recursively find the top parent. That is, if x does not equal to the parent of x, then call find(parent[x]) to find the top parent and assign to parent[x].<br>
The check method will check the top parent for each person is the same or not.</p>
</blockquote>
<p>Run time: $O(m\log^* n)$, space: $O(n)$, where $m$ is number of logs, $n$ is number of people</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">private class Myc implements Comparator&lt;int[]&gt;&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">int</span>[] a1, <span class="keyword">int</span>[] a2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a1[<span class="number">0</span>]-a2[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">earliestAcq</span><span class="params">(<span class="keyword">int</span>[][] logs, <span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">    Myc myc = <span class="keyword">new</span> Myc();</span><br><span class="line">    Arrays.sort(logs,myc);</span><br><span class="line">    Unionfind unionf = <span class="keyword">new</span> Unionfind(N);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span>[] log : logs)&#123;</span><br><span class="line">        unionf.Union(log[<span class="number">1</span>],log[<span class="number">2</span>],log[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(unionf.check()) <span class="keyword">return</span> unionf.ans;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Unionfind</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] parent;</span><br><span class="line">    <span class="keyword">int</span> ans = -<span class="number">1</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Unionfind</span><span class="params">(<span class="keyword">int</span> N)</span></span>&#123;</span><br><span class="line">        parent= <span class="keyword">new</span> <span class="keyword">int</span>[N];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>; i&lt; N; i++)&#123;</span><br><span class="line">            parent[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x != parent[x])&#123;</span><br><span class="line">            parent[x] = Find(parent[x]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> parent[x];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Union</span><span class="params">(<span class="keyword">int</span> x ,<span class="keyword">int</span> y,<span class="keyword">int</span> data)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> px = Find(x);</span><br><span class="line">        <span class="keyword">int</span> py = Find(y);</span><br><span class="line">        <span class="comment">//System.out.println(px+&quot; &quot;+ py);</span></span><br><span class="line">        <span class="keyword">if</span>(px!=py) ans = data;</span><br><span class="line">        parent[px] = py;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">check</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> t = Find(<span class="number">0</span>);          </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> a = <span class="number">0</span>; a&lt;parent.length; a++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(Find(a)!=t)<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<h2 id="Trees-and-Nodes">Trees and Nodes</h2>
<hr>
<details>
<summary></summary>
<blockquote></blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>173. Binary Search Tree Iterator (M)</summary>
<blockquote>
<p>Use a stack and push the root and left nodes to it<br>
When we want the next smallest number, if the top node has a right node, use the same way to push the right node to the stack, and return the current value</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BSTIterator</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;TreeNode&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BSTIterator</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        pushAll(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** <span class="doctag">@return</span> whether we have a next smallest number */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> !stack.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** <span class="doctag">@return</span> the next smallest number */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        TreeNode tmpNode = stack.pop();</span><br><span class="line">        pushAll(tmpNode.right);</span><br><span class="line">        <span class="keyword">return</span> tmpNode.val;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">pushAll</span><span class="params">(TreeNode node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (node != <span class="keyword">null</span>)&#123;</span><br><span class="line">            stack.push(node);</span><br><span class="line">            node = node.left;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Use in-order traversal to transform tree to list and update the pointer</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BSTIterator</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; list;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BSTIterator</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        helper(list, root);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">helper</span><span class="params">(List&lt;Integer&gt; list, TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        helper(list, root.left);</span><br><span class="line">        list.add(root.val);</span><br><span class="line">        helper(list, root.right);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** <span class="doctag">@return</span> the next smallest number */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> list.get(i++);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** <span class="doctag">@return</span> whether we have a next smallest number */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i &gt;= list.size()) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>655. Print Binary Tree (M)</summary>
<blockquote></blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; printTree(TreeNode root) &#123;</span><br><span class="line">    List&lt;List&lt;String&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> res;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> rows = getHeight(root);</span><br><span class="line">    <span class="keyword">int</span> cols = (<span class="keyword">int</span>) Math.pow(<span class="number">2</span>, rows) - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows; i++) &#123;</span><br><span class="line">        List&lt;String&gt; row = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cols; j++) &#123;</span><br><span class="line">            row.add(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        res.add(row);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    Queue&lt;<span class="keyword">int</span>[]&gt; indexQ = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    queue.offer(root);</span><br><span class="line">    indexQ.offer(<span class="keyword">new</span> <span class="keyword">int</span>[] &#123; <span class="number">0</span>, cols - <span class="number">1</span> &#125;);</span><br><span class="line">    <span class="keyword">int</span> row = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        row++;</span><br><span class="line">        <span class="keyword">int</span> size = queue.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            TreeNode cur = queue.poll();</span><br><span class="line">            <span class="keyword">int</span>[] indices = indexQ.poll();</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (cur == <span class="keyword">null</span>) <span class="keyword">continue</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">int</span> left = indices[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> right = indices[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            res.get(row).set(mid, String.valueOf(cur.val));</span><br><span class="line">            </span><br><span class="line">            queue.offer(cur.left);</span><br><span class="line">            queue.offer(cur.right);</span><br><span class="line">            indexQ.offer(<span class="keyword">new</span> <span class="keyword">int</span>[] &#123; left, mid - <span class="number">1</span> &#125;);</span><br><span class="line">            indexQ.offer(<span class="keyword">new</span> <span class="keyword">int</span>[] &#123; mid + <span class="number">1</span>, right &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getHeight</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>)  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> + Math.max(getHeight(root.left), getHeight(root.right));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Recursive</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; printTree(TreeNode root) &#123;</span><br><span class="line">    List&lt;List&lt;String&gt;&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span> row = getHeight(root);</span><br><span class="line">    <span class="keyword">int</span> col = (<span class="keyword">int</span>) Math.pow(<span class="number">2</span>, row) - <span class="number">1</span>;</span><br><span class="line">    List&lt;String&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; col; i++)  ans.add(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; i++)  result.add(<span class="keyword">new</span> ArrayList&lt;&gt;(ans));</span><br><span class="line">    populateResult(root, result, <span class="number">0</span>, row, <span class="number">0</span>, col - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">populateResult</span><span class="params">(TreeNode root, List&lt;List&lt;String&gt;&gt; result, <span class="keyword">int</span> curRow, <span class="keyword">int</span> totalRow, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span> || curRow == totalRow)  <span class="keyword">return</span>;</span><br><span class="line">    result.get(curRow).set((i + j) / <span class="number">2</span>, String.valueOf(root.val));</span><br><span class="line">    populateResult(root.left, result, curRow + <span class="number">1</span>, totalRow, i, ((i + j) / <span class="number">2</span>) - <span class="number">1</span>);</span><br><span class="line">    populateResult(root.right, result, curRow + <span class="number">1</span>, totalRow, ((i + j) / <span class="number">2</span>) + <span class="number">1</span>, j);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getHeight</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>)  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> + Math.max(getHeight(root.left), getHeight(root.right));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>114. Flatten Binary Tree to Linked List (M)</summary>
<blockquote>
<p>Iterative: Use a pointer for the current node<br>
If left child exists, use another pointer to find the rightest leaf node<br>
Assign the right child of current node to be the right child of the leaf node<br>
Then move the left node to be the right child of the current node<br>
Set left child to be null<br>
Move on to the next right child</p>
</blockquote>
<p>Run time: $O(n)$, space: $O(1)$</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">flatten</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    TreeNode cur = root;</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cur.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            TreeNode last = cur.left;</span><br><span class="line">            <span class="keyword">while</span> (last.right != <span class="keyword">null</span>) last = last.right; <span class="comment">// find the rightest leaf</span></span><br><span class="line">            last.right = cur.right; <span class="comment">// right child of the rightest leaf</span></span><br><span class="line">            cur.right = cur.left; <span class="comment">// right child of the root</span></span><br><span class="line">            cur.left = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cur = cur.right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Recursive: post-order traversal, use a pointer node to keep track of the node to be attached to the next node, then update this pointer</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> TreeNode prev = <span class="keyword">null</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">flatten</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    flatten(root.right);</span><br><span class="line">    flatten(root.left);</span><br><span class="line">    root.right = prev;</span><br><span class="line">    root.left = <span class="keyword">null</span>;</span><br><span class="line">    prev = root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>1261. Find Elements in a Contaminated Binary Tree</summary>
<blockquote>
<p>Use DFS to explore every node, and assign value to left child and right child, then put value into a HashSet.</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FindElements</span> </span>&#123;</span><br><span class="line">    Set&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FindElements</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        dfs(root, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode n, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        set.add(v);</span><br><span class="line">        n.val = v;</span><br><span class="line">        dfs(n.left, <span class="number">2</span> * v + <span class="number">1</span>);</span><br><span class="line">        dfs(n.right, <span class="number">2</span> * v + <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> set.contains(target);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>116. Populating Next Right Pointers in Each Node</summary>
<blockquote>
<p>From observation, the next node’s left child is the current node’s right child’s next node, so we need a pointer to the root node. In the while loop, if current node and the left child are not null, set the left child’s next node to be the right child. If the next node of the current node is not null, then set as discussed before.</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">connect</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    Node cur = root;</span><br><span class="line">    <span class="keyword">while</span>(cur != <span class="keyword">null</span> &amp;&amp; cur.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">        cur.left.next = cur.right;</span><br><span class="line">        <span class="keyword">if</span>(cur.next != <span class="keyword">null</span>) cur.right.next = cur.next.left;</span><br><span class="line">        cur = cur.next;</span><br><span class="line">    &#125;</span><br><span class="line">    connect(root.left);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>95. Unique Binary Search Trees II (M)</summary>
<blockquote>
<p>Find out that the number of unique BST with same number of nodes does not change, so we can use DP to find the unique BST with 1 to <code>n</code> node.</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;TreeNode&gt; <span class="title">generateTrees</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    ArrayList&lt;TreeNode&gt;[] dp = <span class="keyword">new</span> ArrayList[n + <span class="number">1</span>];</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="keyword">new</span> ArrayList&lt;TreeNode&gt;();</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    dp[<span class="number">0</span>].add(<span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> len = <span class="number">1</span>; len &lt;= n; len++) &#123; <span class="comment">//长度为 1 到 n</span></span><br><span class="line">        dp[len] = <span class="keyword">new</span> ArrayList&lt;TreeNode&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> root = <span class="number">1</span>; root &lt;= len; root++) &#123; <span class="comment">//将不同的数字作为根节点，只需要考虑到 len</span></span><br><span class="line">            <span class="keyword">int</span> left = root - <span class="number">1</span>;  <span class="comment">//左子树的长度</span></span><br><span class="line">            <span class="keyword">int</span> right = len - root; <span class="comment">//右子树的长度</span></span><br><span class="line">            <span class="keyword">for</span> (TreeNode leftTree : dp[left]) &#123;</span><br><span class="line">                <span class="keyword">for</span> (TreeNode rightTree : dp[right]) &#123;</span><br><span class="line">                    TreeNode treeRoot = <span class="keyword">new</span> TreeNode(root);</span><br><span class="line">                    treeRoot.left = leftTree;</span><br><span class="line">                    treeRoot.right = clone(rightTree, root); <span class="comment">//克隆右子树并且加上偏差</span></span><br><span class="line">                    dp[len].add(treeRoot);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> TreeNode <span class="title">clone</span><span class="params">(TreeNode n, <span class="keyword">int</span> offset)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    TreeNode node = <span class="keyword">new</span> TreeNode(n.val + offset);</span><br><span class="line">    node.left = clone(n.left, offset);</span><br><span class="line">    node.right = clone(n.right, offset);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>Sum of all leaf nodes of binary tree (G)</summary>
<blockquote>
<p>Relevant link: <a href="https://www.geeksforgeeks.org/sum-leaf-nodes-binary-tree/">GFG</a><br>
The idea is to traverse the tree in any fashion and check if the node is the leaf node or not. If the node is the leaf node, add node data to sum variable.</p>
</blockquote>
<p>Run time: $O(n)$, space: $O(n)$</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">leafSum</span><span class="params">(Node root)</span></span>&#123; </span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">   </span><br><span class="line">    <span class="keyword">if</span> (root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>) <span class="keyword">return</span> root.val; </span><br><span class="line">   </span><br><span class="line">    <span class="keyword">return</span> leafSum(root.left) + leafSum(root.right); </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>951. Flip Equivalent Binary Trees (G)</summary>
<blockquote>
<p>Recursion way<br>
If any of the two nodes is null, check if they are the same<br>
If none of them is null. check if the values are the same<br>
Return if fleft=left and right=right, or left=right and right=left</p>
</blockquote>
<p>Run time: $O(m+n)$, space: $O(m+n)$</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">flipEquiv</span><span class="params">(TreeNode r1, TreeNode r2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (r1 == <span class="keyword">null</span> || r2 == <span class="keyword">null</span>) <span class="keyword">return</span> r1 == r2;</span><br><span class="line">    <span class="keyword">if</span>(r1.val != r2.val) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">return</span> (flipEquiv(r1.left, r2.left) &amp;&amp; flipEquiv(r1.right, r2.right)) || </span><br><span class="line">           (flipEquiv(r1.left, r2.right) &amp;&amp; flipEquiv(r1.right, r2.left));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Iterative (BFS): Helper function to check if two nodes are same<br>
Store nodes in a queue, each time poll two nodes<br>
If they are both null, continue; if they are not the same, return false<br>
Check if left1=left2 and right1=right2, put left1, left2, right1, right2 into the queue<br>
Check if left1=right2 and right1=left2, put left1, right2, right1, left2 into the queue<br>
Otherwise return false</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">flipEquiv</span><span class="params">(TreeNode root1, TreeNode root2)</span> </span>&#123;</span><br><span class="line">    Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    queue.offer(root1);</span><br><span class="line">    queue.offer(root2);</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        TreeNode curr1 = queue.poll();</span><br><span class="line">        TreeNode curr2 = queue.poll();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (curr1 == <span class="keyword">null</span> &amp;&amp; curr2 == <span class="keyword">null</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (!isEquals(curr1, curr2)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (isEquals(curr1.left, curr2.left) &amp;&amp; isEquals(curr1.right, curr2.right)) &#123;</span><br><span class="line">            queue.offer(curr1.left);</span><br><span class="line">            queue.offer(curr2.left);</span><br><span class="line">            queue.offer(curr1.right);</span><br><span class="line">            queue.offer(curr2.right);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isEquals(curr1.left, curr2.right) &amp;&amp; isEquals(curr1.right, curr2.left)) &#123;</span><br><span class="line">            queue.offer(curr1.left);</span><br><span class="line">            queue.offer(curr2.right);</span><br><span class="line">            queue.offer(curr1.right);</span><br><span class="line">            queue.offer(curr2.left);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isEquals</span><span class="params">(TreeNode root1, TreeNode root2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root1 == <span class="keyword">null</span> || root2 == <span class="keyword">null</span>) <span class="keyword">return</span> root1 == root2;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (root1.val == root2.val) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>2. Add Two Numbers</summary>
<blockquote>
<p>Create a pointer node and a node for result<br>
While either of the nodes is not null or the temp sum is greater than 0<br>
Collect the values, if greater than 10, subtract 10 and increment the carry-in<br>
Set the next Node value, and move the pointer<br>
Set the sum to be carry-in, and set the carry-in to be zero</p>
</blockquote>
<p>Run time: $O(m+n)$, space: $O(m+n)$</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">    ListNode res = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">    ListNode cur = res;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(l1 != <span class="keyword">null</span> || l2 != <span class="keyword">null</span> || sum &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(l1 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            sum += l1.val;</span><br><span class="line">            l1 = l1.next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(l2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            sum += l2.val;</span><br><span class="line">            l2 = l2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(sum &gt;= <span class="number">10</span>) &#123;</span><br><span class="line">            sum %= <span class="number">10</span>;</span><br><span class="line">            carry += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        cur.next = <span class="keyword">new</span> ListNode(sum);</span><br><span class="line">        cur = cur.next;</span><br><span class="line">        sum = carry;</span><br><span class="line">        carry = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Recursion way</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">public</span> ListNode <span class="title">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (l1 == <span class="keyword">null</span> &amp;&amp; l2 == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">	<span class="keyword">if</span> (l1 == <span class="keyword">null</span> || l2 == <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> l1 == <span class="keyword">null</span> ? l2 : l1;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> val1 = l1.val;</span><br><span class="line">	<span class="keyword">int</span> val2 = l2.val;</span><br><span class="line"></span><br><span class="line">	ListNode ln = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (val1 + val2 &lt; <span class="number">10</span>) &#123;</span><br><span class="line">		ln = <span class="keyword">new</span> ListNode(val1 + val2);</span><br><span class="line">		ln.next = addTwoNumbers(l1.next, l2.next);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		ln = <span class="keyword">new</span> ListNode(val1 + val2 - <span class="number">10</span>);</span><br><span class="line">		ListNode overflow = <span class="keyword">new</span> ListNode(<span class="number">1</span>);</span><br><span class="line">		overflow.next = <span class="keyword">null</span>;</span><br><span class="line">		ListNode temp = addTwoNumbers(overflow, l1.next);</span><br><span class="line">		ln.next = addTwoNumbers(temp, l2.next);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ln;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>133. Clone Graph</summary>
<blockquote>
<p>Use HashMap to put &lt;node.val, Node&gt;, use a helper method to go through all the neighbors<br>
If the Node has been visited(in the map), then directly return it<br>
Otherwise, create a new Node and walk through its neighbors</p>
</blockquote>
<p>Run time: $O(n)$, space: $O(n)$</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">cloneGraph</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    Map&lt;Integer, Node&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">return</span> helper(map, node);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">helper</span><span class="params">(Map&lt;Integer, Node&gt; map, Node n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span>(map.containsKey(n.val)) <span class="keyword">return</span> map.get(n.val);</span><br><span class="line">    Node tempNode = <span class="keyword">new</span> Node(n.val, <span class="keyword">new</span> ArrayList&lt;Node&gt;());</span><br><span class="line">    map.put(n.val, tempNode);</span><br><span class="line">    <span class="keyword">for</span>(Node neighbor: n.neighbors) tempNode.neighbors.add(helper(map, neighbor));</span><br><span class="line">    <span class="keyword">return</span> tempNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>21. Merge Two Sorted Lists</summary>
<blockquote>
<p>Recursion: look organized!</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l1 == <span class="keyword">null</span>) <span class="keyword">return</span> l2;</span><br><span class="line">        <span class="keyword">if</span>(l2 == <span class="keyword">null</span>) <span class="keyword">return</span> l1;</span><br><span class="line">        <span class="keyword">if</span>(l1.val &lt; l2.val)&#123;</span><br><span class="line">            l1.next = mergeTwoLists(l1.next, l2);</span><br><span class="line">            <span class="keyword">return</span> l1;</span><br><span class="line">        &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">            l2.next = mergeTwoLists(l1, l2.next);</span><br><span class="line">            <span class="keyword">return</span> l2;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Straightforward way: use a while loop and copy the values one by one</p>
</blockquote>
<p>Run time: $O(n)$, space: $O(n)$</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l2 == <span class="keyword">null</span>) <span class="keyword">return</span> l1;</span><br><span class="line">    <span class="keyword">if</span>(l1 == <span class="keyword">null</span>) <span class="keyword">return</span> l2;</span><br><span class="line">    ListNode head = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">    ListNode ptr = head;</span><br><span class="line">    <span class="keyword">while</span>(l1 != <span class="keyword">null</span> &amp;&amp; l2 != <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(l1.val &lt; l2.val)&#123;</span><br><span class="line">            head.next = <span class="keyword">new</span> ListNode(l1.val);</span><br><span class="line">            l1 = l1.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            head.next = <span class="keyword">new</span> ListNode(l2.val);</span><br><span class="line">            l2 = l2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        head = head.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(l1 != <span class="keyword">null</span>) head.next = l1;</span><br><span class="line">    <span class="keyword">if</span>(l2 != <span class="keyword">null</span>) head.next = l2;</span><br><span class="line">    <span class="keyword">return</span> ptr.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>23. Merge k Sorted Lists</summary>
<blockquote>
<p>Put all nodes in a priority queue in increasing order.<br>
Put out all nodes in the list into PQ.<br>
Create a head node with value 0, and a pointer node pointing to head.<br>
Loop through this PQ, and set the next node of the pointer to the node that was just polled out.<br>
Update the polled node to the next one, and put it back to the PQ if it is not null.<br>
Return the next node of the head node.</p>
</blockquote>
<p>Run time: $O(n\log k)$, space: $O(n\log k)$, where $k$ is the max length of nodes</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeKLists</span><span class="params">(List&lt;ListNode&gt; lists)</span> </span>&#123;</span><br><span class="line">    Queue&lt;ListNode&gt; heap = <span class="keyword">new</span> PriorityQueue(<span class="keyword">new</span> Comparator&lt;ListNode&gt;()&#123;</span><br><span class="line">        <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123; </span><br><span class="line">            <span class="keyword">return</span> l1.val - l2.val; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    ListNode head = <span class="keyword">new</span> ListNode(<span class="number">0</span>), tail = head;</span><br><span class="line">    <span class="keyword">for</span> (ListNode node : lists) <span class="keyword">if</span> (node != <span class="keyword">null</span>) heap.offer(node);</span><br><span class="line">    <span class="keyword">while</span> (!heap.isEmpty()) &#123;</span><br><span class="line">        tail.next = heap.poll();</span><br><span class="line">        tail = tail.next;</span><br><span class="line">        <span class="keyword">if</span> (tail.next != <span class="keyword">null</span>) heap.offer(tail.next);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>146. LRU Cache (M)</summary>
<blockquote>
<p>Use double linked list (Node) and HashMap<br>
Node class: key and value, prev and next nodes<br>
Map: &lt;Integer, Node&gt; --&gt; key, node</p>
</blockquote>
<p>Run time: $O(1)$ for each method, space: $O(n)$</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node head = <span class="keyword">new</span> Node(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">final</span> Node tail = <span class="keyword">new</span> Node(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">final</span> Map&lt;Integer, Node&gt; map;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> capacity;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LRUCache</span><span class="params">(<span class="keyword">int</span> capacity)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.capacity = capacity;</span><br><span class="line">        map = <span class="keyword">new</span> HashMap(capacity);</span><br><span class="line">        head.next = tail;</span><br><span class="line">        tail.prev = head;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">int</span> res = -<span class="number">1</span>;</span><br><span class="line">      <span class="keyword">if</span>(map.containsKey(key))&#123;</span><br><span class="line">        Node n = map.get(key);</span><br><span class="line">        remove(n);</span><br><span class="line">        insertToHead(n);</span><br><span class="line">        res = n.value;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> res;   </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(map.containsKey(key))&#123;</span><br><span class="line">        Node n = map.get(key);</span><br><span class="line">        remove(n);</span><br><span class="line">        n.value = value;</span><br><span class="line">        insertToHead(n);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(map.size() == capacity)&#123;</span><br><span class="line">           map.remove(tail.prev.key); </span><br><span class="line">           remove(tail.prev);</span><br><span class="line">        &#125; </span><br><span class="line">        </span><br><span class="line">        Node n = <span class="keyword">new</span> Node(key, value);</span><br><span class="line">        insertToHead(n);</span><br><span class="line">        map.put(key, n);</span><br><span class="line">      &#125;  </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> key, value;</span><br><span class="line">        Node prev, next;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.key = key;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">      </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(Node n)</span></span>&#123; <span class="comment">// skip this node</span></span><br><span class="line">      n.prev.next = n.next;</span><br><span class="line">      n.next.prev = n.prev;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">insertToHead</span><span class="params">(Node n)</span></span>&#123;</span><br><span class="line">      Node headNext = head.next;</span><br><span class="line">      head.next = n;</span><br><span class="line">      headNext.prev = n;</span><br><span class="line">      n.prev = head;</span><br><span class="line">      n.next = headNext;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Alternative way</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">DListNode</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> key;</span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        DListNode prev;</span><br><span class="line">        DListNode next;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">DListNode</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.key = key;</span><br><span class="line">            <span class="keyword">this</span>.val = val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Map&lt;Integer, DListNode&gt; map;</span><br><span class="line">    DListNode oldestNode;</span><br><span class="line">    DListNode latestNode;</span><br><span class="line">    <span class="keyword">int</span> capacity;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LRUCache</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.capacity = capacity;</span><br><span class="line">        map = <span class="keyword">new</span> HashMap&lt;&gt;(capacity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        DListNode node = map.get(key);</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (node.next == <span class="keyword">null</span>) <span class="keyword">return</span> node.val;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (node.prev == <span class="keyword">null</span>) &#123;</span><br><span class="line">                oldestNode = node.next;</span><br><span class="line">                oldestNode.prev = <span class="keyword">null</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                node.prev.next = node.next;</span><br><span class="line">                node.next.prev = node.prev;</span><br><span class="line">            &#125;</span><br><span class="line">            node.next = <span class="keyword">null</span>;</span><br><span class="line">            node.prev = latestNode;</span><br><span class="line">            latestNode.next = node;</span><br><span class="line">            latestNode = node;</span><br><span class="line">            <span class="keyword">return</span> node.val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> val = get(key);</span><br><span class="line">        <span class="keyword">if</span> (val == -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (map.size() == capacity) &#123;</span><br><span class="line">                map.remove(oldestNode.key);</span><br><span class="line">                <span class="keyword">if</span> (oldestNode.next != <span class="keyword">null</span>)</span><br><span class="line">                    oldestNode.next.prev = <span class="keyword">null</span>;</span><br><span class="line">                oldestNode = oldestNode.next;</span><br><span class="line">            &#125;</span><br><span class="line">            DListNode node = <span class="keyword">new</span> DListNode(key, value);</span><br><span class="line">            <span class="keyword">if</span> (map.size() == <span class="number">0</span>) &#123;</span><br><span class="line">                oldestNode = node;</span><br><span class="line">                latestNode = node;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                latestNode.next = node;</span><br><span class="line">                node.prev = latestNode;</span><br><span class="line">                latestNode = node;</span><br><span class="line">            &#125;</span><br><span class="line">            map.put(key, node);</span><br><span class="line">        &#125; <span class="keyword">else</span> map.get(key).val = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Straight forward way: use LinkedHashMap and override the removeEldestEntry method<br>
&quot;LinkedHashMap is just like HashMap with an additional feature of maintaining an order of elements inserted into it. HashMap provided the advantage of quick insertion, search and deletion but it never maintained the track and order of insertion which the LinkedHashMap provides where the elements can be accessed in their insertion order. &quot;<br>
“The removeEldestEntry(Map.Entry) method may be overridden to impose a policy for removing stale mappings automatically when new mappings are added to the map.”</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;Integer, Integer&gt; cache;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> capacity;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LRUCache</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.capacity = capacity;</span><br><span class="line">        <span class="comment">// create cache with initial capacity of 16 items</span></span><br><span class="line">        <span class="comment">// load factor of 75% and using access order (LRU style) retrieval</span></span><br><span class="line">        <span class="keyword">this</span>.cache = <span class="keyword">new</span> LinkedHashMap&lt;Integer, Integer&gt;(<span class="number">16</span>, <span class="number">0.75f</span>, <span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="comment">//anonymous inner class to override removeEldestEntry behaivor. </span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">removeEldestEntry</span><span class="params">(Map.Entry&lt;Integer, Integer&gt; eldest)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span>  cache.size() &gt; capacity;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cache.getOrDefault(key, -<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        cache.put(key, value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>138. Copy List with Random Pointer (9/19 Bloomberg, FAILED)</summary>
<blockquote>
<p>Use a node start from head<br>
Use a map to store &lt;current node, new node with same val, next.val, random.val&gt;<br>
Reset the node to be head<br>
Go through each node and get the new node from the map</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">copyRandomList</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    </span><br><span class="line">    Map&lt;Node,Node&gt; map = <span class="keyword">new</span> HashMap&lt;Node,Node&gt;();</span><br><span class="line">    </span><br><span class="line">    Node ans = head;</span><br><span class="line">    <span class="keyword">while</span>(ans != <span class="keyword">null</span>)&#123;</span><br><span class="line">        map.put(ans, <span class="keyword">new</span> Node(ans.val,ans.next,ans.random));</span><br><span class="line">        ans = ans.next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ans = head;</span><br><span class="line">    <span class="keyword">while</span>(ans != <span class="keyword">null</span>)&#123;</span><br><span class="line">        map.get(ans).next = map.get(ans.next);</span><br><span class="line">        map.get(ans).random = map.get(ans.random);</span><br><span class="line">        ans = ans.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> map.get(head);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> RandomListNode <span class="title">copyRandomList</span><span class="params">(RandomListNode head)</span> </span>&#123;</span><br><span class="line">  RandomListNode iter = head, next;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// First round: make copy of each node,</span></span><br><span class="line">  <span class="comment">// and link them together side-by-side in a single list.</span></span><br><span class="line">  <span class="keyword">while</span> (iter != <span class="keyword">null</span>) &#123;</span><br><span class="line">    next = iter.next;</span><br><span class="line"></span><br><span class="line">    RandomListNode copy = <span class="keyword">new</span> RandomListNode(iter.label);</span><br><span class="line">    iter.next = copy;</span><br><span class="line">    copy.next = next;</span><br><span class="line"></span><br><span class="line">    iter = next;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Second round: assign random pointers for the copy nodes.</span></span><br><span class="line">  iter = head;</span><br><span class="line">  <span class="keyword">while</span> (iter != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (iter.random != <span class="keyword">null</span>) &#123;</span><br><span class="line">      iter.next.random = iter.random.next;</span><br><span class="line">    &#125;</span><br><span class="line">    iter = iter.next.next;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Third round: restore the original list, and extract the copy list.</span></span><br><span class="line">  iter = head;</span><br><span class="line">  RandomListNode pseudoHead = <span class="keyword">new</span> RandomListNode(<span class="number">0</span>);</span><br><span class="line">  RandomListNode copy, copyIter = pseudoHead;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (iter != <span class="keyword">null</span>) &#123;</span><br><span class="line">    next = iter.next.next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// extract the copy</span></span><br><span class="line">    copy = iter.next;</span><br><span class="line">    copyIter.next = copy;</span><br><span class="line">    copyIter = copy;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// restore the original list</span></span><br><span class="line">    iter.next = next;</span><br><span class="line"></span><br><span class="line">    iter = next;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> pseudoHead.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<h2 id="Dynamic-Programming-DP">Dynamic Programming (DP)</h2>
<hr>
<details>
<summary></summary>
<blockquote></blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>1278. Palindrome Partitioning III</summary>
<blockquote>
<p>This question essentially is a knapsack problem.<br>
<code>dp[i][j]</code> means that the mininal number of change if we partition the string at <code>j</code> for <code>i</code>th time.</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;String, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">palindromePartition</span><span class="params">(String s, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s.length() == k) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> len = s.length();</span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[k][len + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i)&#123;</span><br><span class="line">        dp[<span class="number">0</span>][i + <span class="number">1</span>] = helper(s.substring(<span class="number">0</span>, i + <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; k; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt;= len; j++)&#123;</span><br><span class="line">            <span class="keyword">int</span> cur = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> p = j; p &gt;= i; p--)&#123;</span><br><span class="line">                cur = Math.min(cur, dp[i - <span class="number">1</span>][p - <span class="number">1</span>] + helper(s.substring(p - <span class="number">1</span>,j )));</span><br><span class="line">            &#125;</span><br><span class="line">            dp[i][j] = cur;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[k - <span class="number">1</span>][len];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">helper</span><span class="params">(String str)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (str == <span class="keyword">null</span> || str.length() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (map.containsKey(str)) <span class="keyword">return</span> map.get(str);</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.length(); ++i)&#123;</span><br><span class="line">        <span class="keyword">if</span> (str.charAt(i) != str.charAt(str.length() - i - <span class="number">1</span>)) res++;</span><br><span class="line">    &#125;</span><br><span class="line">    res /= <span class="number">2</span>;</span><br><span class="line">    map.put(str, res);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>1277. Count Square Submatrices with All Ones</summary>
<blockquote>
<p><code>dp[i][j]</code> represents the length of the square which lower right corner is located at <code>(i, j)</code>.<br>
If the value of this cell is also 1, then the length of the square is the minimum of: the one above, its left, and diagonal up-left value +1. Because if one side is short or missing, it will not form a square.</p>
</blockquote>
<p>Run time: $O(mn)$, space: $O(mn)$</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countSquares</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> total = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> rows = matrix.length, cols = matrix[<span class="number">0</span>].length;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cols; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(matrix[i][j] == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(i == <span class="number">0</span> || j == <span class="number">0</span>)&#123;</span><br><span class="line">                total += matrix[i][j];</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> min = Math.min(matrix[i-<span class="number">1</span>][j], Math.min(matrix[i][j-<span class="number">1</span>], matrix[i-<span class="number">1</span>][j-<span class="number">1</span>]));</span><br><span class="line">            matrix[i][j] += min;</span><br><span class="line">            total += matrix[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> total;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>494. Target Sum</summary>
<blockquote></blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findTargetSumWays</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> S)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> n: nums) sum += n;</span><br><span class="line">    <span class="keyword">if</span> (S &lt; -sum || S &gt; sum) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length + <span class="number">1</span>][ <span class="number">2</span>*sum + <span class="number">1</span>];</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>+sum] = <span class="number">1</span>; <span class="comment">// 0 + sum means 0, 0 means -sum,  check below graph</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= nums.length; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">2</span> * sum + <span class="number">1</span>; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(j + nums[i-<span class="number">1</span>] &lt; <span class="number">2</span>*sum + <span class="number">1</span>) dp[i][j] += dp[i-<span class="number">1</span>][j+nums[i-<span class="number">1</span>]];</span><br><span class="line">            <span class="keyword">if</span>(j - nums[i-<span class="number">1</span>] &gt;= <span class="number">0</span>) dp[i][j] += dp[i-<span class="number">1</span>][j-nums[i-<span class="number">1</span>]];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[nums.length][sum + S];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>1269. Number of Ways to Stay in the Same Place After Some Steps</summary>
<blockquote>
<p>Recursion takes forever to solve this problem, so use 1-D array of the same length as the given array length, and fill in 1 to the first two cells.<br>
For each number of steps, initialize a new array, and use a for loop to iterate from 0 to <code>n-1</code> or <code>current remaining steps</code>. Find the result of staying, moving left, and moving right, update the count, and assign to the temp array. At last, assign the temp array to the original array, since this would be the last state of the array. In the end, return the value in the first cell in <code>arr</code>.</p>
</blockquote>
<p>Run time: $O(steps)$, space: $O(n)$</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> mod = (<span class="keyword">int</span>)Math.pow(<span class="number">10</span>, <span class="number">9</span>) + <span class="number">7</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numWays</span><span class="params">(<span class="keyword">int</span> steps, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">    <span class="keyword">if</span>(n &lt;= <span class="number">1</span>) <span class="keyword">return</span> n;</span><br><span class="line">    arr[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    arr[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; steps; j++)&#123;</span><br><span class="line">        <span class="keyword">int</span>[] temp = <span class="keyword">new</span> <span class="keyword">int</span>[n]; <span class="comment">// configuration of the array from the previous state.</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= Math.min(n - <span class="number">1</span>, steps - j); i++)&#123;</span><br><span class="line">            <span class="keyword">long</span> ans = arr[i]; <span class="comment">// stay</span></span><br><span class="line">            <span class="keyword">if</span>(i &gt; <span class="number">0</span>) ans = (ans + arr[i - <span class="number">1</span>]) % mod; <span class="comment">// right</span></span><br><span class="line">            <span class="keyword">if</span>(i &lt; n - <span class="number">1</span>) ans = (ans + arr[i + <span class="number">1</span>]) % mod; <span class="comment">// left</span></span><br><span class="line">            temp[i] = (<span class="keyword">int</span>) ans;</span><br><span class="line">        &#125;</span><br><span class="line">        arr = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>63. Unique Paths II (M)</summary>
<blockquote>
<p>Keep track of num ways to reach this position in row i</p>
</blockquote>
<p>Run time: $O(n^2)$, space: $O(n)$</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">uniquePathsWithObstacles</span><span class="params">(<span class="keyword">int</span>[][] obstacleGrid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> width = obstacleGrid[<span class="number">0</span>].length;</span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[width];</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span>[] row : obstacleGrid) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; width; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (row[j] == <span class="number">1</span>) dp[j] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (j &gt; <span class="number">0</span>) dp[j] += dp[j - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[width - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>55. Jump Game (M)</summary>
<blockquote>
<p>Start from last index, then a loop back to the start<br>
If the sum of current index and current step is not less than the last step, update the last step to be the current index<br>
At last check if the last index is smaller than or equal to 0</p>
</blockquote>
<p>Run time: $O(n)$, space: $O(1)$</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canJump</span><span class="params">(<span class="keyword">int</span> nums[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> last = nums.length-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = last-<span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i + nums[i] &gt;= last) last = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> last &lt;= <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Work forward (Greedy?): Update the maximum steps each time, check if the current index is greater than the max step</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canJump</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i &gt; max) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        max = Math.max(max, nums[i]+i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>53. Maximum Subarray (M)</summary>
<blockquote>
<p>Keep track of the max and the max sum ended at current index, update the entry if the previous element is positive, otherwise just take the current element</p>
</blockquote>
<p>Run time: $O(n)$, space: $O(n)$</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] A)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = A.length;</span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n]; <span class="comment">//dp[i]: the maximum subarray ending with A[i]</span></span><br><span class="line">    dp[<span class="number">0</span>] = A[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> max = dp[<span class="number">0</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">        dp[i] = A[i] + (dp[i - <span class="number">1</span>] &gt; <span class="number">0</span> ? dp[i - <span class="number">1</span>] : <span class="number">0</span>);</span><br><span class="line">        max = Math.max(max, dp[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Another way: update maxSoFar and maxEndingHere</p>
</blockquote>
<p>Run time: $O(n)$, space: $O(1)$</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] A)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> maxSoFar = A[<span class="number">0</span>], maxEndingHere = A[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; A.length; i++)&#123;</span><br><span class="line">        maxEndingHere = Math.max(maxEndingHere + A[i], A[i]);</span><br><span class="line">        maxSoFar = Math.max(maxSoFar, maxEndingHere);	</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxSoFar;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>Dijkstra’s Algorithm with Path Printing (G)</summary>
<blockquote>
<p>Relevant link: <a href="https://www.geeksforgeeks.org/java-program-for-dijkstras-algorithm-with-path-printing/">GFG</a>, <a href="https://www.1point3acres.com/bbs/thread-558859-1-1.html">link</a></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner; <span class="comment">//Scanner Function to take in the Input Values </span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dijkstra</span> </span>&#123; </span><br><span class="line">    <span class="keyword">static</span> Scanner scan; <span class="comment">// scan is a Scanner Object </span></span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line">        <span class="keyword">int</span>[] preD = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">5</span>]; </span><br><span class="line">        <span class="keyword">int</span> min = <span class="number">999</span>, nextNode = <span class="number">0</span>; <span class="comment">// min holds the minimum value, nextNode holds the value for the next node. </span></span><br><span class="line">        scan = <span class="keyword">new</span> Scanner(System.in); </span><br><span class="line">        <span class="keyword">int</span>[] distance = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">5</span>]; <span class="comment">// the distance matrix </span></span><br><span class="line">        <span class="keyword">int</span>[][] matrix = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">5</span>][<span class="number">5</span>]; <span class="comment">// the actual matrix </span></span><br><span class="line">        <span class="keyword">int</span>[] visited = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">5</span>]; <span class="comment">// the visited array </span></span><br><span class="line">  </span><br><span class="line">        System.out.println(<span class="string">&quot;Enter the cost matrix&quot;</span>); </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; distance.length; i++) &#123; </span><br><span class="line">            visited[i] = <span class="number">0</span>; <span class="comment">//initialize visited array to zeros </span></span><br><span class="line">            preD[i] = <span class="number">0</span>; </span><br><span class="line">  </span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; distance.length; j++) &#123; </span><br><span class="line">                matrix[i][j] = scan.nextInt(); <span class="comment">//fill the matrix </span></span><br><span class="line">                <span class="keyword">if</span> (matrix[i][j]==<span class="number">0</span>) </span><br><span class="line">                    matrix[i][j] = <span class="number">999</span>; <span class="comment">// make the zeros as 999 </span></span><br><span class="line">            &#125; </span><br><span class="line">        &#125; </span><br><span class="line">  </span><br><span class="line">        distance = matrix[<span class="number">0</span>]; <span class="comment">//initialize the distance array </span></span><br><span class="line">        visited[<span class="number">0</span>] = <span class="number">1</span>; <span class="comment">//set the source node as visited </span></span><br><span class="line">        distance[<span class="number">0</span>] = <span class="number">0</span>; <span class="comment">//set the distance from source to source to zero which is the starting point </span></span><br><span class="line">  </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> counter = <span class="number">0</span>; counter &lt; <span class="number">5</span>; counter++) &#123; </span><br><span class="line">            min = <span class="number">999</span>; </span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123; </span><br><span class="line">                <span class="keyword">if</span> (min &gt; distance[i] &amp;&amp; visited[i]!=<span class="number">1</span>) &#123; </span><br><span class="line">                    min = distance[i]; </span><br><span class="line">                    nextNode = i; </span><br><span class="line">                &#125; </span><br><span class="line">            &#125; </span><br><span class="line">  </span><br><span class="line">            visited[nextNode] = <span class="number">1</span>; </span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123; </span><br><span class="line">                <span class="keyword">if</span> (visited[i]!=<span class="number">1</span>) &#123; </span><br><span class="line">                    <span class="keyword">if</span> (min+matrix[nextNode][i] &lt; distance[i]) &#123; </span><br><span class="line">                        distance[i] = min+matrix[nextNode][i]; </span><br><span class="line">                        preD[i] = nextNode; </span><br><span class="line">                    &#125; </span><br><span class="line">                &#125; </span><br><span class="line">            &#125; </span><br><span class="line">        &#125; </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) System.out.print(<span class="string">&quot;|&quot;</span> + distance[i]); </span><br><span class="line">  </span><br><span class="line">        System.out.println(<span class="string">&quot;|&quot;</span>); </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">int</span> j; </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123; </span><br><span class="line">            <span class="keyword">if</span> (i!=<span class="number">0</span>) &#123; </span><br><span class="line">                System.out.print(<span class="string">&quot;Path = &quot;</span> + i); </span><br><span class="line">                j = i; </span><br><span class="line">                <span class="keyword">while</span>(j!= <span class="number">0</span>) &#123; </span><br><span class="line">                    j = preD[j]; </span><br><span class="line">                    System.out.print(<span class="string">&quot; &lt;- &quot;</span> + j); </span><br><span class="line">                &#125; </span><br><span class="line">            &#125; </span><br><span class="line">            System.out.println(); </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>Check for possible path in 2D matrix (G)</summary>
<blockquote>
<p>1 = road, 0 = wall<br>
First, change the value of the first top left element value to 2. Then get the next (current) value in the first row and compare to the previous value. Set this current value equal to the previous value only if it is reachable (not equal to 0). Similarly, do the same for column values, by comparing and setting the current with the previous column’s value if it is reachable.<br>
Then start from the first-row &amp; first column and take the values of previous row &amp; the previous column. Find the max between them, and set the current index to that max. If the current index value is 0 then there’s no change.</p>
</blockquote>
<p>Run time: $O(mn)$, space: $O(1)$</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isPath</span><span class="params">(<span class="keyword">int</span>[][] arr, <span class="keyword">int</span>[] start, <span class="keyword">int</span>[] end)</span> </span>&#123; </span><br><span class="line">    arr[start[<span class="number">0</span>]][start[<span class="number">1</span>]] = <span class="number">2</span>; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.length; i++) </span><br><span class="line">        <span class="keyword">if</span> (arr[<span class="number">0</span>][i] != <span class="number">0</span>) arr[<span class="number">0</span>][i] = arr[<span class="number">0</span>][i - <span class="number">1</span>]; </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; arr[<span class="number">0</span>].length; j++) </span><br><span class="line">        <span class="keyword">if</span> (arr[j][<span class="number">0</span>] != <span class="number">0</span>) arr[j][<span class="number">0</span>] = arr[j - <span class="number">1</span>][<span class="number">0</span>]; </span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.length; i++) </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; arr[<span class="number">0</span>].length; j++) </span><br><span class="line">            <span class="keyword">if</span> (arr[i][j] != <span class="number">0</span>) arr[i][j] = Math.max(arr[i][j - <span class="number">1</span>], arr[i - <span class="number">1</span>][j]); </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> (arr[end[<span class="number">0</span>]][end[<span class="number">1</span>]] == <span class="number">1</span>); </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>Rhyme Schemes (G)</summary>
<blockquote>
<p>Relevant posts: <a href="https://www.1point3acres.com/bbs/thread-476768-2-1.html">link1</a>, <a href="https://www.1point3acres.com/bbs/thread-484956-1-1.html">link2</a><br>
Relevant links: <a href="https://en.wikipedia.org/wiki/Bell_number">Bell number</a>, <a href="https://en.wikipedia.org/wiki/Bell_triangle">Bell triangle</a>, <a href="https://en.wikipedia.org/wiki/Binomial_coefficient">Binomial coefficient</a></p>
</blockquote>
<blockquote>
<p>This way: <code>dp[current length][current last char][biggest char seen]</code></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getPatternCount</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[][][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>][<span class="number">26</span>][<span class="number">26</span>];</span><br><span class="line">    dp[<span class="number">1</span>][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>; <span class="comment">// &#x27;A&#x27;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> len = <span class="number">1</span>; len != n; len++) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j != <span class="number">26</span>; j++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= j; i++) &#123;</span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= j; k++)</span><br><span class="line">            dp[len + <span class="number">1</span>][k][j] += dp[len][i][j];</span><br><span class="line">          <span class="keyword">if</span> (j + <span class="number">1</span> != <span class="number">26</span>)</span><br><span class="line">            dp[len + <span class="number">1</span>][j + <span class="number">1</span>][j + <span class="number">1</span>] += dp[len][i][j];</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i != <span class="number">26</span>; i++)</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j != <span class="number">26</span>; j++)</span><br><span class="line">        res += dp[n][i][j];</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Backtracking: not very efficient if only return number of ways of permutations<br>
This solution return exact paths (original version is C++, not sure if I translated right)</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">List&lt;String&gt; <span class="title">findRhyme</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;()</span><br><span class="line">        List&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        String path = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">int</span>[] visited = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">        backtracking(path, n, res, visited);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backtracking</span><span class="params">(String path, <span class="keyword">int</span> n, List&lt;String&gt; res, <span class="keyword">int</span>[] visited)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(path.size() == n)&#123;</span><br><span class="line">            res.add(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; visited.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(visited[i] != <span class="number">0</span>)&#123;</span><br><span class="line">                path.add(<span class="string">&#x27;A&#x27;</span> + i);</span><br><span class="line">                backtracking(path, n, res, visited);</span><br><span class="line">                path.remove();</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                path.add(<span class="string">&#x27;A&#x27;</span> + i);</span><br><span class="line">                visited[i] = <span class="number">1</span>;</span><br><span class="line">                backtracking(path, n, res, visited);</span><br><span class="line">                visited[i] = <span class="number">0</span>;</span><br><span class="line">                path.remove();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>91. Decode Ways (G) (M)</summary>
<blockquote>
<p>Keep track of # decoding ways for substring ended at index <code>i-1</code><br>
Fill in <code>dp[0] = 1</code> and if first char is not 0, then <code>dp[1] = 1</code>, otherwise fill in 0</p>
</blockquote>
<p>Run time: $O(n)$, space: $O(n)$</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numDecodings</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s == <span class="keyword">null</span> || s.length() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n = s.length();</span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    dp[<span class="number">1</span>] = s.charAt(<span class="number">0</span>) != <span class="string">&#x27;0&#x27;</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> first = Integer.valueOf(s.substring(i-<span class="number">1</span>, i));</span><br><span class="line">        <span class="keyword">int</span> second = Integer.valueOf(s.substring(i-<span class="number">2</span>, i));</span><br><span class="line">        <span class="keyword">if</span>(first &gt;= <span class="number">1</span> &amp;&amp; first &lt;= <span class="number">9</span>) &#123;</span><br><span class="line">           dp[i] += dp[i-<span class="number">1</span>];  </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(second &gt;= <span class="number">10</span> &amp;&amp; second &lt;= <span class="number">26</span>) &#123;</span><br><span class="line">            dp[i] += dp[i-<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>1246. Palindrome Removal</summary>
<blockquote>
<p>Intuition: A[i] can be removed alone or it makes a pair.</p>
</blockquote>
<blockquote>
<p>Top down DP</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[][] dp;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minimumMoves</span><span class="params">(<span class="keyword">int</span>[] A)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = A.length;</span><br><span class="line">    dp = <span class="keyword">new</span> <span class="keyword">int</span>[n][n];</span><br><span class="line">    <span class="keyword">return</span> dfs(<span class="number">0</span>, n - <span class="number">1</span>, A);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span>[] A)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &gt; j) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (dp[i][j] &gt; <span class="number">0</span>) <span class="keyword">return</span> dp[i][j];</span><br><span class="line">    <span class="keyword">int</span> res = dfs(i, j - <span class="number">1</span>, A) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (j &gt; <span class="number">0</span> &amp;&amp; A[j] == A[j - <span class="number">1</span>])</span><br><span class="line">        res = Math.min(res, dfs(i, j - <span class="number">2</span>, A) + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = i; k &lt; j - <span class="number">1</span>; ++k)</span><br><span class="line">        <span class="keyword">if</span> (A[k] == A[j])</span><br><span class="line">            res = Math.min(res, dfs(i, k - <span class="number">1</span>, A) + dfs(k + <span class="number">1</span>, j - <span class="number">1</span>, A));</span><br><span class="line">    dp[i][j] = res;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Bottom up DP</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minimumMoves</span><span class="params">(<span class="keyword">int</span>[] A)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N = A.length;</span><br><span class="line">    <span class="comment">//  declare dp array and initialize it with 0s</span></span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[N + <span class="number">1</span>][N + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= N; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= N; j++)</span><br><span class="line">            dp[i][j] = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// loop for subarray length we are considering</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> len = <span class="number">1</span>; len &lt;= N; len++) &#123;</span><br><span class="line">        <span class="comment">// loop with two variables i and j, denoting starting and ending of subarray</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, j = len - <span class="number">1</span>; j &lt; N; i++, j++) &#123;</span><br><span class="line">            <span class="comment">// If subarray length is 1, then 1 step will be needed</span></span><br><span class="line">            <span class="keyword">if</span> (len == <span class="number">1</span>)</span><br><span class="line">                dp[i][j] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// delete A[i] individually and assign result for subproblem (i+1,j)</span></span><br><span class="line">                dp[i][j] = <span class="number">1</span> + dp[i + <span class="number">1</span>][j];</span><br><span class="line">                <span class="comment">// if current and next element are same, choose min from current and subproblem (i+2,j)</span></span><br><span class="line">                <span class="keyword">if</span> (A[i] == A[i + <span class="number">1</span>])</span><br><span class="line">                    dp[i][j] = Math.min(<span class="number">1</span> + dp[i + <span class="number">2</span>][j], dp[i][j]);</span><br><span class="line">                <span class="comment">// loop over all right elements and suppose Kth element is same as A[i] then</span></span><br><span class="line">                <span class="comment">// choose minimum from current and two subarray after ignoring ith and A[K]</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> K = i + <span class="number">2</span>; K &lt;= j; K++)</span><br><span class="line">                    <span class="keyword">if</span> (A[i] == A[K])</span><br><span class="line">                        dp[i][j] = Math.min(dp[i + <span class="number">1</span>][K - <span class="number">1</span>] + dp[K + <span class="number">1</span>][j], dp[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">0</span>][N - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>1105. Filling Bookcase Shelves</summary>
<blockquote>
<p>Use an array to store the min levels to put i books<br>
For each book, first assume it is put at a new level, then loop back and see if the previous level and fit this book (both width and height), then update the levels</p>
</blockquote>
<p>Run time: $O(n^2)$, space: $O(n)$</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minHeightShelves</span><span class="params">(<span class="keyword">int</span>[][] books, <span class="keyword">int</span> shelf_width)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[books.length + <span class="number">1</span>]; <span class="comment">// store the min levels to put i books</span></span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= books.length; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> width = books[i-<span class="number">1</span>][<span class="number">0</span>], height = books[i-<span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">        dp[i] = dp[i-<span class="number">1</span>] + height; <span class="comment">// another level</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i - <span class="number">1</span>; j &gt; <span class="number">0</span> &amp;&amp; width + books[j-<span class="number">1</span>][<span class="number">0</span>] &lt;= shelf_width; j--) &#123;</span><br><span class="line">            height = Math.max(height, books[j-<span class="number">1</span>][<span class="number">1</span>]); <span class="comment">// get max height on this level</span></span><br><span class="line">            width += books[j-<span class="number">1</span>][<span class="number">0</span>]; <span class="comment">// put this book</span></span><br><span class="line">            dp[i] = Math.min(dp[i], dp[j-<span class="number">1</span>] + height); <span class="comment">// update min</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[books.length];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>72. Edit Distance (G)</summary>
<blockquote>
<p>Use a 2-D array to keep track of number of changes from char i in word1 to char j in word2</p>
</blockquote>
<p>Run time: $O(mn)$, space: $O(mn)$ (m, n are the length of words)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minDistance</span><span class="params">(String word1, String word2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (word1.equals(word2)) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// exactly same</span></span><br><span class="line">    <span class="keyword">if</span> (word1.length() == <span class="number">0</span> || word2.length() == <span class="number">0</span>) <span class="comment">// one of them is empty</span></span><br><span class="line">        <span class="keyword">return</span> Math.abs(word1.length() - word2.length());</span><br><span class="line">    <span class="comment">// num changes from char i in word1 to char j in word2</span></span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[word1.length() + <span class="number">1</span>][word2.length() + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= word1.length(); i++) dp[i][<span class="number">0</span>] = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= word2.length(); i++) dp[<span class="number">0</span>][i] = i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= word1.length(); i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= word2.length(); j++) &#123;</span><br><span class="line">            <span class="comment">// same char, just copy the count from previous character</span></span><br><span class="line">            <span class="keyword">if</span> (word1.charAt(i-<span class="number">1</span>) == word2.charAt(j-<span class="number">1</span>)) dp[i][j] = dp[i-<span class="number">1</span>][j-<span class="number">1</span>];</span><br><span class="line">            <span class="comment">// need to do an operation, copy the minimum num changes from previous step</span></span><br><span class="line">            <span class="keyword">else</span> dp[i][j] = Math.min(dp[i-<span class="number">1</span>][j-<span class="number">1</span>], Math.min(dp[i-<span class="number">1</span>][j], dp[i][j-<span class="number">1</span>])) + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[word1.length()][word2.length()];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>1027. Longest Arithmetic Sequence</summary>
<blockquote>
<p>Use an array of HashMap to store &lt;difference, current length&gt;</p>
</blockquote>
<p>Run time: $O(n^2)$, space: $O(n^2)$</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestArithSeqLength</span><span class="params">(<span class="keyword">int</span>[] A)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">2</span>, n = A.length;</span><br><span class="line">    HashMap&lt;Integer, Integer&gt;[] dp = <span class="keyword">new</span> HashMap[n];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; A.length; j++) &#123;</span><br><span class="line">        dp[j] = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; j; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> diff = A[j] - A[i];</span><br><span class="line">            dp[j].put(diff, dp[i].getOrDefault(diff, <span class="number">1</span>) + <span class="number">1</span>);</span><br><span class="line">            res = Math.max(res, dp[j].get(diff));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>739. Daily Temperatures</summary>
<blockquote>
<p>For each temperature, walk back to fill in the number of days</p>
</blockquote>
<p>Run time: $O(n)$, space: $O(n)$</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] dailyTemperatures(<span class="keyword">int</span>[] T) &#123;</span><br><span class="line">    <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[T.length];</span><br><span class="line">    <span class="keyword">int</span> top = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span>[] ret = <span class="keyword">new</span> <span class="keyword">int</span>[T.length];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; T.length; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span>(top &gt; -<span class="number">1</span> &amp;&amp; T[i] &gt; T[arr[top]]) &#123;</span><br><span class="line">            <span class="keyword">int</span> idx = arr[top--];</span><br><span class="line">            ret[idx] = i - idx;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[++top] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Descending stack</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] dailyTemperatures(<span class="keyword">int</span>[] T) &#123;</span><br><span class="line">    Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span>[] ret = <span class="keyword">new</span> <span class="keyword">int</span>[T.length];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; T.length; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty() &amp;&amp; T[i] &gt; T[stack.peek()]) &#123;</span><br><span class="line">            <span class="keyword">int</span> idx = stack.pop();</span><br><span class="line">            ret[idx] = i - idx;</span><br><span class="line">        &#125;</span><br><span class="line">        stack.push(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>322. Coin Change</summary>
<blockquote>
<p>Initialize an array of length “amount+1”, fill it from index 1 (one dollar) to the end<br>
First fill in the max value, then loop through every possible coin<br>
If the current amount is greater than the coin, update the number of coins by finding the value [i-this coin]+1</p>
</blockquote>
<p>Run time: $O(n\times amount)$, space: $O(amount)$</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">coinChange</span><span class="params">(<span class="keyword">int</span>[] coins, <span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[amount + <span class="number">1</span>];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i &lt; dp.length; i++) &#123;</span><br><span class="line">    dp[i] = dp.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>; j &lt; coins.length; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (i &gt;= coins[j]) dp[i] = Math.min(dp[i], dp[i-coins[j]] + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> dp[amount] == dp.length ? -<span class="number">1</span> : dp[amount];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Similar way</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">coinChange</span><span class="params">(<span class="keyword">int</span>[] coins, <span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (coins == <span class="keyword">null</span> || coins.length == <span class="number">0</span> || amount &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span>[] minNumber = <span class="keyword">new</span> <span class="keyword">int</span>[amount + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= amount; i++) &#123;</span><br><span class="line">        minNumber[i] = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; coins.length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (coins[j] &lt;= i &amp;&amp; minNumber[i - coins[j]] != Integer.MAX_VALUE)</span><br><span class="line">                minNumber[i] = Integer.min(minNumber[i], <span class="number">1</span> + minNumber[i - coins[j]]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (minNumber[amount] == Integer.MAX_VALUE) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> minNumber[amount];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>121. Best Time to Buy and Sell Stock (M)</summary>
<blockquote>
<p>Update the lowest buy price, and update the maximum earn (current price - buy price)</p>
</blockquote>
<p>Run time: $O(n)$, space: $O(1)$</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(prices == <span class="keyword">null</span> || prices.length &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> buy = prices[<span class="number">0</span>], earn = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.length; i++)&#123;</span><br><span class="line">        buy = Math.min(buy, prices[i]);</span><br><span class="line">        earn = Math.max(earn, prices[i]-buy);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> earn;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>304. Range Sum Query 2D - Immutable</summary>
<blockquote>
<p>Use a matrix to calculate the sum of rectangle that the current entry is the lower right corner<br>
In the method, use the max entry subtracts the lower left and upper right entries, and add the upper left entry.</p>
</blockquote>
<p>Run time: $O(n^2)$, space: $O(n^2)$</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span>[][] dp;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">NumMatrix</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(matrix == <span class="keyword">null</span>||matrix.length == <span class="number">0</span>||matrix[<span class="number">0</span>].length == <span class="number">0</span>) <span class="keyword">return</span>;   </span><br><span class="line">    <span class="keyword">int</span> m = matrix.length, n = matrix[<span class="number">0</span>].length;</span><br><span class="line"></span><br><span class="line">    dp = <span class="keyword">new</span> <span class="keyword">int</span>[m+<span class="number">1</span>][n+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)&#123; <span class="comment">// store the sum of neighbors</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)&#123;</span><br><span class="line">            dp[i][j] = dp[i-<span class="number">1</span>][j] + dp[i][j-<span class="number">1</span>] - dp[i-<span class="number">1</span>][j-<span class="number">1</span>] + matrix[i-<span class="number">1</span>][j-<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sumRegion</span><span class="params">(<span class="keyword">int</span> row1, <span class="keyword">int</span> col1, <span class="keyword">int</span> row2, <span class="keyword">int</span> col2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> iMin = Math.min(row1, row2);</span><br><span class="line">    <span class="keyword">int</span> iMax = Math.max(row1, row2);</span><br><span class="line">    <span class="keyword">int</span> jMin = Math.min(col1, col2);</span><br><span class="line">    <span class="keyword">int</span> jMax = Math.max(col1, col2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[iMax + <span class="number">1</span>][jMax + <span class="number">1</span>] - dp[iMax + <span class="number">1</span>][jMin] - dp[iMin][jMax + <span class="number">1</span>] + dp[iMin][jMin];    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>123. Best Time to Buy and Sell Stock III</summary>
<blockquote>
<p>Use four variables: first buy price (min), profit after first sell (max), profit after second buy (max), and profit after second sell (max).</p>
</blockquote>
<p>Run time: $O(n)$, space: $O(1)$</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = prices.length;</span><br><span class="line">    <span class="keyword">if</span>(prices.length &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> firstBuy = prices[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> firstSell = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> secondBuy = Integer.MIN_VALUE;</span><br><span class="line">    <span class="keyword">int</span> secondSell = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> p: prices)&#123;</span><br><span class="line">        firstBuy = Math.min(firstBuy, p); <span class="comment">// buy at lowest price</span></span><br><span class="line">        firstSell = Math.max(firstSell, p-firstBuy); <span class="comment">// max profit</span></span><br><span class="line">        secondBuy = Math.max(secondBuy, firstSell-p); <span class="comment">// profit after buying second stock</span></span><br><span class="line">        secondSell = Math.max(secondSell, p+secondBuy); <span class="comment">// final profit</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> secondSell;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>1218. Longest Arithmetic Subsequence of Given Difference</summary>
<blockquote>
<p>Use a map to store the length of the sequence that contains this number; if the previous element exist, then put this element with new length into the map.</p>
</blockquote>
<p>Run time: $O(n)$, space: $O(n)$</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestSubsequence</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> difference)</span> </span>&#123;</span><br><span class="line">	HashMap&lt;Integer, Integer&gt; dp = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">	<span class="keyword">int</span> longest = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;arr.length; i++) &#123;</span><br><span class="line">		dp.put(arr[i], dp.getOrDefault(arr[i] - difference, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">		longest = Math.max(longest, dp.get(arr[i]));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> longest;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>403. Frog Jump</summary>
<blockquote>
<p>Faster way</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canCross</span><span class="params">(<span class="keyword">int</span>[] stones)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(stones.length == <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(stones[<span class="number">1</span>]-stones[<span class="number">0</span>] == <span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Map&lt;Integer,Boolean&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;stones.length-<span class="number">1</span>;i++)&#123;</span><br><span class="line">        map.put(stones[i],<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=stones.length-<span class="number">2</span>;i&gt;=<span class="number">1</span>;--i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(bottomUp(map,stones[i],stones[stones.length-<span class="number">1</span>]-stones[i]))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;   </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">bottomUp</span><span class="params">(Map&lt;Integer,Boolean&gt; map,<span class="keyword">int</span> stone,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(stone == <span class="number">0</span>) <span class="keyword">return</span> k == <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(k &lt;= <span class="number">0</span> || stone &lt; <span class="number">0</span> || !map.containsKey(stone)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">return</span> bottomUp(map,stone - (k-<span class="number">1</span>),k-<span class="number">1</span>) || bottomUp(map,stone-k,k) || bottomUp(map,stone-(k+<span class="number">1</span>),k+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Use a map to store the stone location and a set of possible steps<br>
Put the initial location (0) and possible step (1) into the map<br>
Loop through every stone, get the step, calculate the location<br>
Then get the set of location, put three possible steps into the set</p>
</blockquote>
<p>Run time: $O(n^2)$, space: $O(n^2)$</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canCross</span><span class="params">(<span class="keyword">int</span>[] stones)</span> </span>&#123;</span><br><span class="line"><span class="comment">// the most progressive arrange is [0, 1, 3, 6, 10, 15, 21, ...]</span></span><br><span class="line"><span class="comment">// the right-most point is at most 0 + (1 + len - 1) * (len - 1) / 2</span></span><br><span class="line"><span class="keyword">if</span>(stones == <span class="keyword">null</span> || stones.length == <span class="number">0</span> || stones[<span class="number">1</span>] != <span class="number">1</span> ||</span><br><span class="line">               stones[stones.length - <span class="number">1</span>] &gt; (stones.length * (stones.length - <span class="number">1</span>)) / <span class="number">2</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">       </span><br><span class="line">       HashMap&lt;Integer, HashSet&lt;Integer&gt;&gt; map = <span class="keyword">new</span> HashMap&lt;Integer, HashSet&lt;Integer&gt;&gt;(stones.length);</span><br><span class="line">       map.put(<span class="number">0</span>, <span class="keyword">new</span> HashSet&lt;Integer&gt;());</span><br><span class="line">       map.get(<span class="number">0</span>).add(<span class="number">1</span>);</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; stones.length; i++) &#123;</span><br><span class="line">       		map.put(stones[i], <span class="keyword">new</span> HashSet&lt;Integer&gt;() );</span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; stones.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">       		<span class="keyword">int</span> stone = stones[i];</span><br><span class="line">       		<span class="keyword">for</span> (<span class="keyword">int</span> step : map.get(stone)) &#123;</span><br><span class="line">       			<span class="keyword">int</span> reach = step + stone;</span><br><span class="line">       			<span class="keyword">if</span> (reach == stones[stones.length - <span class="number">1</span>]) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">       			HashSet&lt;Integer&gt; set = map.get(reach);</span><br><span class="line">       			<span class="keyword">if</span> (set != <span class="keyword">null</span>) &#123;</span><br><span class="line">       		    		set.add(step);</span><br><span class="line">       		    		<span class="keyword">if</span> (step - <span class="number">1</span> &gt; <span class="number">0</span>) set.add(step - <span class="number">1</span>);</span><br><span class="line">       		    		set.add(step + <span class="number">1</span>);</span><br><span class="line">       			&#125;</span><br><span class="line">       		&#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">   &#125; </span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>42. Trapping Rain Water</summary>
<blockquote>
<p>Use two arrays to keep track of the index with higher bars<br>
The minimum of left and right bars minus the current height is the water for this location<br>
Run time: $O(n)$, space: $O(n)$</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">trap</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ans = <span class="number">0</span>, n = height.length, leftSoFar = <span class="number">0</span>, rightSoFar = n-<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">int</span>[] left = <span class="keyword">new</span> <span class="keyword">int</span>[n], right = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(height[leftSoFar] &lt; height[i]) leftSoFar = i;</span><br><span class="line">		<span class="keyword">if</span>(height[rightSoFar] &lt; height[n-<span class="number">1</span>-i]) rightSoFar = n-<span class="number">1</span>-i;</span><br><span class="line">		left[i] = leftSoFar;</span><br><span class="line">		right[n-<span class="number">1</span>-i] = rightSoFar;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">		ans += Math.min(height[left[i]], height[right[i]])-height[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<h2 id="Search">Search</h2>
<hr>
<h3 id="Trie">Trie</h3>
<details>
<summary></summary>
<blockquote></blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>1268. Search Suggestions System</summary>
<blockquote>
<p>Use trie tree to store the characters and sort them, then add corresponding words to the list by moving a pointer in the trie tree</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Trie</span> </span>&#123;</span><br><span class="line">    Trie[] sub = <span class="keyword">new</span> Trie[<span class="number">26</span>];</span><br><span class="line">    LinkedList&lt;String&gt; suggestion = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; suggestedProducts(String[] products, String searchWord) &#123;</span><br><span class="line">    Trie root = <span class="keyword">new</span> Trie();</span><br><span class="line">    <span class="keyword">for</span> (String p : products) &#123; <span class="comment">// build Trie.</span></span><br><span class="line">        Trie t = root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : p.toCharArray()) &#123; <span class="comment">// insert current product into Trie.</span></span><br><span class="line">            <span class="keyword">if</span> (t.sub[c - <span class="string">&#x27;a&#x27;</span>] == <span class="keyword">null</span>) t.sub[c - <span class="string">&#x27;a&#x27;</span>] = <span class="keyword">new</span> Trie();</span><br><span class="line">            t = t.sub[c - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">            t.suggestion.offer(p); <span class="comment">// put products with same prefix into suggestion list.</span></span><br><span class="line">            Collections.sort(t.suggestion); <span class="comment">// sort products.</span></span><br><span class="line">            <span class="keyword">if</span> (t.suggestion.size() &gt; <span class="number">3</span>) <span class="comment">// maintain 3 lexicographically minimum strings.</span></span><br><span class="line">                t.suggestion.pollLast();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    List&lt;List&lt;String&gt;&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> c : searchWord.toCharArray()) &#123; <span class="comment">// search product.</span></span><br><span class="line">        <span class="keyword">if</span> (root != <span class="keyword">null</span>) <span class="comment">// if current Trie is NOT null.</span></span><br><span class="line">            root = root.sub[c - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        ans.add(root == <span class="keyword">null</span> ? Arrays.asList() : root.suggestion); <span class="comment">// add it if there exist products with current prefix.</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; suggestedProducts(String[] products, String searchWord) &#123;</span><br><span class="line">    Arrays.sort(products);</span><br><span class="line">    List&lt;List&lt;String&gt;&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">char</span> c: searchWord.toCharArray())&#123;</span><br><span class="line">        sb.append(c);</span><br><span class="line">        List&lt;String&gt; temp = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(String s: products)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s.startsWith(sb.toString()))&#123;</span><br><span class="line">                <span class="keyword">if</span>(temp.size() &gt;= <span class="number">3</span>) <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">else</span> temp.add(s);</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">        Collections.sort(temp);</span><br><span class="line">        ans.add(temp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>211. Add and Search Word - Data structure design</summary>
<blockquote>
<p>Create a class called TrieNode, and in each class there’s a array of 26 TrieNodes<br>
When adding a word, look through each character and move a pointer from the root node to the corresponding child node. Create a new node if there’s no node in the entry<br>
Given a word, walk through each letter and keep track of the length and the node pointer<br>
If it is a dot, loop through all children nodes if it is not null<br>
Otherwise, call the helper function recursively</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WordDictionary</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TrieNode</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> TrieNode[] children = <span class="keyword">new</span> TrieNode[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">boolean</span> isWord;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> TrieNode root = <span class="keyword">new</span> TrieNode();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Adds a word into the data structure.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addWord</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">        TrieNode node = root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : word.toCharArray()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (node.children[c-<span class="string">&#x27;a&#x27;</span>] == <span class="keyword">null</span>) &#123;</span><br><span class="line">                node.children[c-<span class="string">&#x27;a&#x27;</span>] = <span class="keyword">new</span> TrieNode();</span><br><span class="line">            &#125;</span><br><span class="line">            node = node.children[c - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        node.isWord = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Returns if the word is in the data structure. A word could</span></span><br><span class="line">    <span class="comment">// contain the dot character &#x27;.&#x27; to represent any one letter.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">search</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> match(word.toCharArray(), <span class="number">0</span>, root);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">match</span><span class="params">(<span class="keyword">char</span>[] chs, <span class="keyword">int</span> k, TrieNode node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (k == chs.length) <span class="keyword">return</span> node.isWord;</span><br><span class="line">        <span class="keyword">if</span> (chs[k] == <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; node.children.length; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (node.children[i] != <span class="keyword">null</span> &amp;&amp; match(chs, k + <span class="number">1</span>, node.children[i])) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> node.children[chs[k] - <span class="string">&#x27;a&#x27;</span>] != <span class="keyword">null</span> &amp;&amp; match(chs, k + <span class="number">1</span>, node.children[chs[k] - <span class="string">&#x27;a&#x27;</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>208. Implement Trie (Prefix Tree) (M)</summary>
<blockquote>
<p>Build TrieNode to hold a list of TrieNode for searching</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Trie</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">TrieNode</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">char</span> val;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">boolean</span> isWord; </span><br><span class="line">        <span class="keyword">public</span> TrieNode[] children = <span class="keyword">new</span> TrieNode[<span class="number">26</span>];</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">TrieNode</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">        TrieNode(<span class="keyword">char</span> c)&#123;</span><br><span class="line">            TrieNode node = <span class="keyword">new</span> TrieNode();</span><br><span class="line">            node.val = c;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> TrieNode root;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Trie</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        root = <span class="keyword">new</span> TrieNode();</span><br><span class="line">        root.val = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Inserts a word into the trie. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">        TrieNode ws = root;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; word.length(); i++)&#123;</span><br><span class="line">            <span class="keyword">char</span> c = word.charAt(i);</span><br><span class="line">            <span class="keyword">if</span>(ws.children[c - <span class="string">&#x27;a&#x27;</span>] == <span class="keyword">null</span>)&#123;</span><br><span class="line">                ws.children[c - <span class="string">&#x27;a&#x27;</span>] = <span class="keyword">new</span> TrieNode(c);</span><br><span class="line">            &#125;</span><br><span class="line">            ws = ws.children[c - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        ws.isWord = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Returns if the word is in the trie. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">search</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">        TrieNode ws = root; </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; word.length(); i++)&#123;</span><br><span class="line">            <span class="keyword">char</span> c = word.charAt(i);</span><br><span class="line">            <span class="keyword">if</span>(ws.children[c - <span class="string">&#x27;a&#x27;</span>] == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            ws = ws.children[c - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ws.isWord;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Returns if there is any word in the trie that starts with the given prefix. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">startsWith</span><span class="params">(String prefix)</span> </span>&#123;</span><br><span class="line">        TrieNode ws = root; </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prefix.length(); i++)&#123;</span><br><span class="line">            <span class="keyword">char</span> c = prefix.charAt(i);</span><br><span class="line">            <span class="keyword">if</span>(ws.children[c - <span class="string">&#x27;a&#x27;</span>] == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            ws = ws.children[c - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<h3 id="Breadth-First-Search-BFS">Breadth-First Search (BFS)</h3>
<details>
<summary></summary>
<blockquote></blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>1091. Shortest Path in Binary Matrix</summary>
<blockquote>
<p>Be careful that the size of queue is dynamic so each time we need to use an int to memorize the current size and run for loop to poll the element. Also use a boolean matrix to keep track of the visited cells.</p>
</blockquote>
<p>Run time: $O(n^2)$, space: $O(n^2)$</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">shortestPathBinaryMatrix</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(grid == <span class="keyword">null</span> || grid.length == <span class="number">0</span> || grid[<span class="number">0</span>].length == <span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> steps = <span class="number">0</span>, m = grid.length, n = grid[<span class="number">0</span>].length;</span><br><span class="line">    <span class="keyword">if</span>(grid[<span class="number">0</span>][<span class="number">0</span>] == <span class="number">1</span> || grid[m-<span class="number">1</span>][n-<span class="number">1</span>] == <span class="number">1</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            </span><br><span class="line">    Queue&lt;<span class="keyword">int</span>[]&gt; q = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    q.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">0</span>,<span class="number">0</span>&#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">boolean</span>[][] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[m][n];</span><br><span class="line">    visited[<span class="number">0</span>][<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>[] dX = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,-<span class="number">1</span>,<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>,<span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span>[] dY = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>,-<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,-<span class="number">1</span>,<span class="number">1</span>,-<span class="number">1</span>,<span class="number">1</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(!q.isEmpty())&#123;</span><br><span class="line">        <span class="keyword">int</span> size = q.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span>[] cur = q.poll();</span><br><span class="line">            <span class="keyword">if</span>(cur[<span class="number">0</span>] == m-<span class="number">1</span> &amp;&amp; cur[<span class="number">1</span>] == n-<span class="number">1</span>) <span class="keyword">return</span> steps+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">8</span>; j++)&#123;</span><br><span class="line">                <span class="keyword">int</span> tempX = cur[<span class="number">0</span>] + dX[j], tempY = cur[<span class="number">1</span>] + dY[j];</span><br><span class="line">                <span class="keyword">if</span>(tempX &lt; <span class="number">0</span> || tempY &lt; <span class="number">0</span> || tempX &gt;= m || </span><br><span class="line">                   tempY &gt;= n || grid[tempX][tempY] == <span class="number">1</span> || </span><br><span class="line">                   visited[tempX][tempY]) <span class="keyword">continue</span>;</span><br><span class="line">                q.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;tempX, tempY&#125;);</span><br><span class="line">                visited[tempX][tempY] = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        steps++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>1263. Minimum Moves to Move a Box to Their Target Location</summary>
<blockquote>
<p>BFS+backtracking<br>
First find the positions of player, box, and target<br>
Use a HashSet to keep track of the visited positions<br>
Use a Queue to record the possible movements<br>
For each possible movement, use a helper function to test if the player could reach the position to push the box. If valid, offer this position to the queue, and add it to the set<br>
Use a count to keep track of the movements<br>
Poll the position from the queue, if the box is at the end position, return the number of steps<br>
Otherwise, mark the box position as wall, similarly explore 4 possible movements.<br>
If the movement is valid (in the bound, not visited, can reached by player), add it to the queue and mark as visited<br>
After trying 4 movements, reset the position as road<br>
Update the number of movements after we polled the element from queue</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">int</span>[] dir = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;-<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minPushBox</span><span class="params">(<span class="keyword">char</span>[][] grid)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">int</span> rowLen = grid.length, colLen = rowLen == <span class="number">0</span> ? <span class="number">0</span> : grid[<span class="number">0</span>].length;</span><br><span class="line">      <span class="keyword">int</span>[] start = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];  <span class="comment">// start position of the box</span></span><br><span class="line"><span class="keyword">int</span>[] end = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];  <span class="comment">// target position where the box should be moved to</span></span><br><span class="line"><span class="keyword">int</span>[] player = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];  <span class="comment">// start position of the person</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// initialize three important positions</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> row = <span class="number">0</span>; row &lt; rowLen; row++) &#123;</span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> col = <span class="number">0</span>; col &lt; colLen; col++) &#123;</span><br><span class="line">              <span class="keyword">if</span> (grid[row][col] == <span class="string">&#x27;B&#x27;</span>) &#123;</span><br><span class="line">                  start[<span class="number">0</span>] = row;</span><br><span class="line">                  start[<span class="number">1</span>] = col;</span><br><span class="line">              &#125; <span class="keyword">else</span> <span class="keyword">if</span> (grid[row][col] == <span class="string">&#x27;T&#x27;</span>) &#123;</span><br><span class="line">                  end[<span class="number">0</span>] = row;</span><br><span class="line">                  end[<span class="number">1</span>] = col;</span><br><span class="line">              &#125; <span class="keyword">else</span> <span class="keyword">if</span> (grid[row][col] == <span class="string">&#x27;S&#x27;</span>) &#123;</span><br><span class="line">                  player[<span class="number">0</span>] = row;</span><br><span class="line">                  player[<span class="number">1</span>] = col;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// record both the position of the box and the position to push the box</span></span><br><span class="line">      Queue&lt;<span class="keyword">int</span>[][]&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();  </span><br><span class="line">      <span class="comment">// same as queue for deduplication</span></span><br><span class="line">      Set&lt;String&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;(); </span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123; <span class="comment">// 4 possible positions to push the box</span></span><br><span class="line">          <span class="keyword">int</span>[] push = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;start[<span class="number">0</span>] + dir[i], start[<span class="number">1</span>] + dir[i+<span class="number">1</span>]&#125;;  </span><br><span class="line">          <span class="comment">// skip if the person is not able to reach the push position</span></span><br><span class="line">          <span class="keyword">if</span> (!canReach(grid, player, push)) <span class="keyword">continue</span>;</span><br><span class="line">          queue.offer(<span class="keyword">new</span> <span class="keyword">int</span>[][]&#123;start, push&#125;);  </span><br><span class="line">          String visited = (start[<span class="number">0</span>] * colLen + start[<span class="number">1</span>]) + <span class="string">&quot;,&quot;</span> + (push[<span class="number">0</span>] * colLen + push[<span class="number">1</span>]);</span><br><span class="line">          set.add(visited); </span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">int</span> move = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">          <span class="keyword">int</span> size = queue.size();  <span class="comment">// search each level</span></span><br><span class="line">          <span class="keyword">while</span> (size-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">              <span class="keyword">int</span>[][] curr = queue.poll();</span><br><span class="line">              <span class="keyword">int</span>[] box = curr[<span class="number">0</span>], push = curr[<span class="number">1</span>];</span><br><span class="line">              <span class="keyword">if</span> (Arrays.equals(box, end)) <span class="keyword">return</span> move;</span><br><span class="line">          </span><br><span class="line">              grid[box[<span class="number">0</span>]][box[<span class="number">1</span>]] = <span class="string">&#x27;#&#x27;</span>;  <span class="comment">// set the box to be impassible </span></span><br><span class="line">              <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">                  <span class="comment">// the position where the box is moved  to</span></span><br><span class="line">                  <span class="keyword">int</span> nextRow = box[<span class="number">0</span>] + dir[i], nextCol = box[<span class="number">1</span>] + dir[i + <span class="number">1</span>];  </span><br><span class="line">                  <span class="comment">// the position where the person should stand in order to move the box</span></span><br><span class="line">                  <span class="keyword">int</span>[] nextPush = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;box[<span class="number">0</span>] - dir[i], box[<span class="number">1</span>] - dir[i + <span class="number">1</span>]&#125;;  </span><br><span class="line">                  String visited = (nextRow * colLen + nextCol) + <span class="string">&quot;,&quot;</span> + (nextPush[<span class="number">0</span>] * colLen + nextPush[<span class="number">1</span>]);</span><br><span class="line">                  </span><br><span class="line">			<span class="comment">// skip if this position is not valid</span></span><br><span class="line">			<span class="keyword">if</span> (nextRow &lt; <span class="number">0</span> || nextRow &gt;= rowLen || nextCol &lt; <span class="number">0</span> || </span><br><span class="line">                      nextCol &gt;= colLen || grid[nextRow][nextCol] == <span class="string">&#x27;#&#x27;</span> || </span><br><span class="line">                      set.contains(visited) || !canReach(grid, push, nextPush)) <span class="keyword">continue</span>; </span><br><span class="line"></span><br><span class="line">                  queue.offer(<span class="keyword">new</span> <span class="keyword">int</span>[][]&#123;<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;nextRow, nextCol&#125;, nextPush&#125;);</span><br><span class="line">                  set.add(visited);</span><br><span class="line">              &#125;</span><br><span class="line">              grid[box[<span class="number">0</span>]][box[<span class="number">1</span>]] = <span class="string">&#x27;.&#x27;</span>;  <span class="comment">// reset  </span></span><br><span class="line">          &#125;</span><br><span class="line">          move++;  <span class="comment">// update move</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// unable to reach the target position or even the beginning position to push the box</span></span><br><span class="line">      <span class="keyword">return</span> -<span class="number">1</span>;  </span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/** check if a person can reach the destination position from the source position */</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">canReach</span><span class="params">(<span class="keyword">char</span>[][] grid, <span class="keyword">int</span>[] source, <span class="keyword">int</span>[] destination)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">int</span> rowLen = grid.length, colLen = rowLen == <span class="number">0</span> ? <span class="number">0</span> : grid[<span class="number">0</span>].length;</span><br><span class="line">      Queue&lt;<span class="keyword">int</span>[]&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">      Set&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">      queue.offer(source);</span><br><span class="line">      set.add(source[<span class="number">0</span>] * colLen + source[<span class="number">1</span>]);</span><br><span class="line">      <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">          <span class="keyword">int</span>[] curr = queue.poll();</span><br><span class="line">          <span class="keyword">if</span> (Arrays.equals(curr, destination)) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">              <span class="comment">// the next position where the person is going</span></span><br><span class="line">              <span class="keyword">int</span> nextRow = curr[<span class="number">0</span>] + dir[i], nextCol = curr[<span class="number">1</span>] + dir[i+<span class="number">1</span>];  </span><br><span class="line">              <span class="keyword">int</span> nextIndex = nextRow * colLen + nextCol;</span><br><span class="line">             </span><br><span class="line">	    <span class="comment">// skip if this position is not valid</span></span><br><span class="line">              <span class="keyword">if</span> (nextRow &lt; <span class="number">0</span> || nextRow &gt;= rowLen || nextCol &lt; <span class="number">0</span> || nextCol &gt;= colLen ||</span><br><span class="line">                  grid[nextRow][nextCol] == <span class="string">&#x27;#&#x27;</span> || set.contains(nextIndex)) <span class="keyword">continue</span>;   </span><br><span class="line">              </span><br><span class="line">              queue.offer(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;nextRow, nextCol&#125;);</span><br><span class="line">              set.add(nextIndex);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>126. Word Ladder II</summary>
<blockquote>
<p>Use BFS to find the shortest distance between start and end, tracing the distance of crossing nodes from start node to end node, and store node’s next level neighbors to HashMap;<br>
Use DFS to output paths with the same distance as the shortest distance from distance HashMap: compare if the distance of the next level node equals the distance of the current node + 1.</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; findLadders(String beginWord, String endWord, List&lt;String&gt; wordList) &#123;</span><br><span class="line">    Set&lt;String&gt; dict = <span class="keyword">new</span> HashSet&lt;&gt;(wordList);</span><br><span class="line">    List&lt;List&lt;String&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (!dict.contains(endWord)) &#123;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    Map&lt;String, List&lt;String&gt;&gt; map = getChildren(beginWord, endWord, dict);</span><br><span class="line">    List&lt;String&gt; path = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    path.add(beginWord);</span><br><span class="line">    findLadders(beginWord, endWord, map, res, path);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">findLadders</span><span class="params">(String beginWord, String endWord, Map&lt;String, List&lt;String&gt;&gt; map, List&lt;List&lt;String&gt;&gt; res, List&lt;String&gt; path)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (beginWord.equals(endWord)) &#123;</span><br><span class="line">        res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(path));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!map.containsKey(beginWord)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (String next : map.get(beginWord)) &#123;</span><br><span class="line">        path.add(next);</span><br><span class="line">        findLadders(next, endWord, map, res, path);</span><br><span class="line">        path.remove(path.size() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Map&lt;String, List&lt;String&gt;&gt; getChildren(String beginWord, String endWord, Set&lt;String&gt; dict) &#123;</span><br><span class="line">    Map&lt;String, List&lt;String&gt;&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    Set&lt;String&gt; start = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    start.add(beginWord);</span><br><span class="line">    Set&lt;String&gt; end = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    Set&lt;String&gt; visited = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    end.add(endWord);</span><br><span class="line">    <span class="keyword">boolean</span> found = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">boolean</span> isBackward = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">while</span> (!start.isEmpty() &amp;&amp; !found) &#123;</span><br><span class="line">        <span class="keyword">if</span> (start.size() &gt; end.size()) &#123;</span><br><span class="line">            Set&lt;String&gt; tem = start;</span><br><span class="line">            start = end;</span><br><span class="line">            end = tem;</span><br><span class="line">            isBackward = !isBackward;</span><br><span class="line">        &#125;</span><br><span class="line">        Set&lt;String&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String cur : start) &#123;</span><br><span class="line">            visited.add(cur);</span><br><span class="line">            <span class="keyword">for</span> (String next : getNext(cur, dict)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (visited.contains(next) || start.contains(next)) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (end.contains(next)) &#123;</span><br><span class="line">                    found = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                set.add(next);</span><br><span class="line">                String parent = isBackward ? next : cur;</span><br><span class="line">                String child = isBackward ? cur : next;</span><br><span class="line">                <span class="keyword">if</span> (!map.containsKey(parent)) &#123;</span><br><span class="line">                    map.put(parent, <span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">                &#125;</span><br><span class="line">                map.get(parent).add(child);</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        start = set;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> map;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> List&lt;String&gt; <span class="title">getNext</span><span class="params">(String cur, Set&lt;String&gt; dict)</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">char</span>[] chars = cur.toCharArray();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; chars.length; i++) &#123;</span><br><span class="line">        <span class="keyword">char</span> old = chars[i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c = <span class="string">&#x27;a&#x27;</span>; c &lt;= <span class="string">&#x27;z&#x27;</span>; c++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (c == old) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            chars[i] = c;</span><br><span class="line">            String next = <span class="keyword">new</span> String(chars);</span><br><span class="line">            <span class="keyword">if</span> (dict.contains(next)) &#123;</span><br><span class="line">                res.add(next);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        chars[i] = old;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>752. Open the Lock (G)</summary>
<blockquote>
<p>GFG link: <a href="https://www.geeksforgeeks.org/bidirectional-search/">Bidirectional Search</a>: 2-end BFS<br>
Suppose if branching factor of tree is b and distance of goal vertex from source is d, then the normal BFS/DFS searching complexity would be $O(b^d)$. On the other hand, if we execute two search operation then the complexity would be $O(b^{d/2})$ for each search and total complexity would be $O(b^{d/2}+b^{d/2})$ which is far less than $O(b^d)$.</p>
</blockquote>
<p>Run time: $O(b^{d/2})$, space: $O(b^{d/2})$</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">openLock</span><span class="params">(String[] deadends, String target)</span> </span>&#123;</span><br><span class="line">    Set&lt;String&gt; begin = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    Set&lt;String&gt; end = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    Set&lt;String&gt; deads = <span class="keyword">new</span> HashSet&lt;&gt;(Arrays.asList(deadends));</span><br><span class="line">    begin.add(<span class="string">&quot;0000&quot;</span>);</span><br><span class="line">    end.add(target);</span><br><span class="line">    <span class="keyword">int</span> level = <span class="number">0</span>;</span><br><span class="line">    Set&lt;String&gt; temp;</span><br><span class="line">    <span class="keyword">while</span>(!begin.isEmpty() &amp;&amp; !end.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (begin.size() &gt; end.size()) &#123;</span><br><span class="line">            temp = begin;</span><br><span class="line">            begin = end;</span><br><span class="line">            end = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        temp = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(String s : begin) &#123;</span><br><span class="line">            <span class="keyword">if</span>(end.contains(s)) <span class="keyword">return</span> level; <span class="comment">// found</span></span><br><span class="line">            <span class="keyword">if</span>(deads.contains(s)) <span class="keyword">continue</span>; <span class="comment">// dead end or appear before</span></span><br><span class="line">            deads.add(s);</span><br><span class="line">            StringBuilder sb = <span class="keyword">new</span> StringBuilder(s);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i ++) &#123; <span class="comment">// all possible moves</span></span><br><span class="line">                <span class="keyword">char</span> c = sb.charAt(i);</span><br><span class="line">                String s1 = sb.substring(<span class="number">0</span>, i) + (c == <span class="string">&#x27;9&#x27;</span> ? <span class="number">0</span> : c - <span class="string">&#x27;0&#x27;</span> + <span class="number">1</span>) + sb.substring(i + <span class="number">1</span>);</span><br><span class="line">                String s2 = sb.substring(<span class="number">0</span>, i) + (c == <span class="string">&#x27;0&#x27;</span> ? <span class="number">9</span> : c - <span class="string">&#x27;0&#x27;</span> - <span class="number">1</span>) + sb.substring(i + <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span>(!deads.contains(s1)) temp.add(s1);</span><br><span class="line">                <span class="keyword">if</span>(!deads.contains(s2)) temp.add(s2);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        level++;</span><br><span class="line">        begin = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>127. Word Ladder</summary>
<blockquote>
<p>2-end like DFS</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">ladderLength</span><span class="params">(String beginWord, String endWord, List&lt;String&gt; wordList)</span> </span>&#123;</span><br><span class="line">    Set&lt;String&gt; beginSet = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    Set&lt;String&gt; endSet = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    beginSet.add(beginWord);</span><br><span class="line">    endSet.add(endWord);</span><br><span class="line">    Set&lt;String&gt; dict = <span class="keyword">new</span> HashSet&lt;&gt;(wordList);</span><br><span class="line">    <span class="keyword">if</span>(!dict.contains(endWord)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> search(beginSet, endSet, dict, <span class="keyword">true</span>, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(Set&lt;String&gt; beginSet, Set&lt;String&gt; endSet, Set&lt;String&gt; dict, <span class="keyword">boolean</span> isForward, <span class="keyword">int</span> cnt)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(beginSet.isEmpty() || endSet.isEmpty()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    cnt++;</span><br><span class="line">    dict.removeAll(beginSet);</span><br><span class="line">    Set&lt;String&gt; nextSet = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(String str : beginSet)&#123;</span><br><span class="line">        <span class="keyword">char</span>[] chs = str.toCharArray();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; chs.length; i++)&#123;</span><br><span class="line">            <span class="keyword">char</span> c = chs[i];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">char</span> j = <span class="string">&#x27;a&#x27;</span>; j &lt;= <span class="string">&#x27;z&#x27;</span>; j++)&#123;</span><br><span class="line">                chs[i] = j;</span><br><span class="line">                String tmp = <span class="keyword">new</span> String(chs);</span><br><span class="line">                <span class="keyword">if</span>(!dict.contains(tmp)) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span>(endSet.contains(tmp)) <span class="keyword">return</span> cnt;</span><br><span class="line">                nextSet.add(tmp);</span><br><span class="line">            &#125;</span><br><span class="line">            chs[i] = c;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nextSet.size() &gt; endSet.size() ? search(endSet, nextSet, dict, <span class="keyword">false</span>, cnt) : search(nextSet, endSet, dict, <span class="keyword">true</span>, cnt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>2-end BFS without helper method</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">ladderLength</span><span class="params">(String beginWord, String endWord, List&lt;String&gt; wordList)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!wordList.contains(endWord)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Set&lt;String&gt; dict = <span class="keyword">new</span> HashSet&lt;&gt;(wordList);</span><br><span class="line">    Set&lt;String&gt; beginSet = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    Set&lt;String&gt; endSet = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    beginSet.add(beginWord);</span><br><span class="line">    endSet.add(endWord);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> step = <span class="number">1</span>;</span><br><span class="line">    Set&lt;String&gt; visited = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    <span class="keyword">while</span> (!beginSet.isEmpty() &amp;&amp; !endSet.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (beginSet.size() &gt; endSet.size()) &#123;</span><br><span class="line">            Set&lt;String&gt; set = beginSet;</span><br><span class="line">            beginSet = endSet;</span><br><span class="line">            endSet = set;</span><br><span class="line">        &#125;</span><br><span class="line">        Set&lt;String&gt; temp = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String word : beginSet) &#123;</span><br><span class="line">            <span class="keyword">char</span>[] chs = word.toCharArray();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; chs.length; i++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">char</span> c = <span class="string">&#x27;a&#x27;</span>; c &lt;= <span class="string">&#x27;z&#x27;</span>; c++) &#123;</span><br><span class="line">                    <span class="keyword">char</span> old = chs[i];</span><br><span class="line">                    chs[i] = c;</span><br><span class="line">                    String target = String.valueOf(chs);</span><br><span class="line">                    <span class="keyword">if</span> (endSet.contains(target)) &#123;</span><br><span class="line">                        <span class="keyword">return</span> step + <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (!visited.contains(target) &amp;&amp; dict.contains(target)) &#123;</span><br><span class="line">                        temp.add(target);</span><br><span class="line">                        visited.add(target);</span><br><span class="line">                    &#125;</span><br><span class="line">                    chs[i] = old;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        beginSet = temp;</span><br><span class="line">        step++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Use a queue to add the begin word, then add any transformations that are in the dictionary</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">ladderLength</span><span class="params">(String beginWord, String endWord, List&lt;String&gt; wordList)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!wordList.contains(endWord)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    HashSet&lt;String&gt; set = <span class="keyword">new</span> HashSet&lt;String&gt;(wordList);</span><br><span class="line">    Queue&lt;String&gt; q = <span class="keyword">new</span> LinkedList&lt;String&gt;();</span><br><span class="line">    <span class="keyword">int</span> length = <span class="number">0</span>;</span><br><span class="line">    set.add(endWord);</span><br><span class="line">    q.add(beginWord);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (!q.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> size = q.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            String w = q.poll();</span><br><span class="line">            <span class="keyword">if</span> (w.equals(endWord)) <span class="keyword">return</span> length + <span class="number">1</span>;</span><br><span class="line">            wordMatch(w, set, q);</span><br><span class="line">        &#125;</span><br><span class="line">        length++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">wordMatch</span><span class="params">(String w, Set&lt;String&gt; set, Queue&lt;String&gt; q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; w.length(); i++) &#123;</span><br><span class="line">        <span class="keyword">char</span>[] word = w.toCharArray();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">26</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = (<span class="keyword">char</span>) (<span class="string">&#x27;a&#x27;</span> + j);</span><br><span class="line">            <span class="keyword">if</span> (word[i] == c) <span class="keyword">continue</span>;</span><br><span class="line">            word[i] = c;</span><br><span class="line">            String s = String.valueOf(word);</span><br><span class="line">            <span class="keyword">if</span> (set.contains(s)) &#123;</span><br><span class="line">                set.remove(s);</span><br><span class="line">                q.offer(s);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>743. Network Delay Time</summary>
<blockquote>
<p>Dijkstra: use list to store N+1 node lists, every time get the list of source node, add sink and cost<br>
Create priority queue and override comparator as “(a,b) -&gt; (a[1]-b[1])” get min cost<br>
Pretty similar idea as below</p>
</blockquote>
<p>Run time: $O(n)$, space: $O(n)$</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">networkDelayTime</span><span class="params">(<span class="keyword">int</span>[][] times, <span class="keyword">int</span> N, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">    List&lt;List&lt;<span class="keyword">int</span>[]&gt;&gt; graph = <span class="keyword">new</span> ArrayList&lt;&gt;(N + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= N; i++) graph.add(<span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span>[] time : times) graph.get(time[<span class="number">0</span>]).add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;time[<span class="number">1</span>], time[<span class="number">2</span>]&#125;);</span><br><span class="line">    PriorityQueue&lt;<span class="keyword">int</span>[]&gt; pq = <span class="keyword">new</span> PriorityQueue&lt;&gt;(<span class="keyword">new</span> Comparator&lt;<span class="keyword">int</span>[]&gt;()&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span>[] b)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> a[<span class="number">1</span>] - b[<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    pq.offer(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;K, <span class="number">0</span>&#125;);</span><br><span class="line">    Set&lt;Integer&gt; visited = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span> dist = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!pq.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] curr = pq.poll();</span><br><span class="line">        <span class="keyword">if</span>(!visited.add(curr[<span class="number">0</span>])) <span class="keyword">continue</span>;</span><br><span class="line">        dist = curr[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span>[] neighbor : graph.get(curr[<span class="number">0</span>])) &#123;</span><br><span class="line">            <span class="keyword">if</span>(!visited.contains(neighbor[<span class="number">0</span>])) pq.offer(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;neighbor[<span class="number">0</span>], neighbor[<span class="number">1</span>] + curr[<span class="number">1</span>]&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> visited.size() == N ? dist : -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>BFS: use Map&lt;source, Map&lt;sink, cost&gt;&gt; to store all info<br>
Create priority queue and override comparator as “(a,b) -&gt; (a[0]-b[0])”<br>
PQ stores int[]{total cost, next node}<br>
A boolean array to record whether the node is visited or not<br>
Skip visited node, and mark unvisited node, update total cost<br>
Decrement N (num of nodes), if it’s zero, return the cost<br>
Add new array to PQ</p>
</blockquote>
<p>Run time: $O(n)$, space: $O(n)$</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">networkDelayTime</span><span class="params">(<span class="keyword">int</span>[][] times, <span class="keyword">int</span> N, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">    Map&lt;Integer, Map&lt;Integer, Integer&gt;&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span>[] time: times)&#123;</span><br><span class="line">        map.putIfAbsent(time[<span class="number">0</span>], <span class="keyword">new</span> HashMap&lt;&gt;());</span><br><span class="line">        map.get(time[<span class="number">0</span>]).put(time[<span class="number">1</span>], time[<span class="number">2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    Queue&lt;<span class="keyword">int</span>[]&gt; pq = <span class="keyword">new</span> PriorityQueue&lt;&gt;((a,b) -&gt; (a[<span class="number">0</span>]-b[<span class="number">0</span>]));</span><br><span class="line">    pq.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">0</span>,K&#125;);</span><br><span class="line">    <span class="keyword">boolean</span>[] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[N+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(!pq.isEmpty())&#123;</span><br><span class="line">        <span class="keyword">int</span>[] cur = pq.remove();</span><br><span class="line">        <span class="keyword">int</span> curNode = cur[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> curDist = cur[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">if</span>(visited[curNode]) <span class="keyword">continue</span>;</span><br><span class="line">        visited[curNode] = <span class="keyword">true</span>;</span><br><span class="line">        res = curDist;</span><br><span class="line">        N--;</span><br><span class="line">        <span class="keyword">if</span>(N == <span class="number">0</span>) <span class="keyword">return</span> res; </span><br><span class="line">        <span class="keyword">if</span>(map.containsKey(curNode))&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> nextNode: map.get(curNode).keySet())&#123;</span><br><span class="line">                pq.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;curDist+map.get(curNode).get(nextNode), nextNode&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>317. Shortest Distance from All Buildings (G)</summary>
<blockquote>
<p>Create two 2D arrays to keep track of the smallest distance and the number of building that this location can reach<br>
Helper method:</p>
</blockquote>
<p>Run time: $O()$, space: $O()$</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">shortestDistance</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[][] distance = <span class="keyword">new</span> <span class="keyword">int</span>[grid.length][grid[<span class="number">0</span>].length];</span><br><span class="line">    <span class="keyword">int</span>[][] reach = <span class="keyword">new</span> <span class="keyword">int</span>[grid.length][grid[<span class="number">0</span>].length];</span><br><span class="line">    <span class="keyword">int</span> numBuilding = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; grid.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; grid[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (grid[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">                helper(grid, distance, reach, i, j);</span><br><span class="line">                numBuilding++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">int</span> result = Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; grid.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; grid[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (grid[i][j] == <span class="number">0</span> &amp;&amp; reach[i][j] == numBuilding) &#123;</span><br><span class="line">                result = Math.min(result, distance[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> result == Integer.MAX_VALUE ? -<span class="number">1</span> : result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">helper</span><span class="params">(<span class="keyword">int</span>[][] grid, <span class="keyword">int</span>[][] distance, <span class="keyword">int</span>[][] reach, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">int</span>[] dx = &#123;-<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span>[] dy = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>&#125;;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//two queue, one for direction, one for distance tracking</span></span><br><span class="line">    LinkedList&lt;<span class="keyword">int</span>[]&gt; q = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    LinkedList&lt;Integer&gt; qDist = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"> </span><br><span class="line">    q.offer(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;i, j&#125;);</span><br><span class="line">    qDist.offer(<span class="number">1</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">while</span> (!q.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] head = q.poll();</span><br><span class="line">        <span class="keyword">int</span> dis = qDist.poll();</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; k++) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = head[<span class="number">0</span>] + dx[k];</span><br><span class="line">            <span class="keyword">int</span> y = head[<span class="number">1</span>] + dy[k];</span><br><span class="line"> </span><br><span class="line">            <span class="keyword">if</span> (x &gt;= <span class="number">0</span> &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; x &lt; grid.length &amp;&amp; y &lt; grid[<span class="number">0</span>].length &amp;&amp; grid[x][y] == <span class="number">0</span>) &#123; <span class="comment">// valid move</span></span><br><span class="line">                grid[x][y] = -<span class="number">1</span>;</span><br><span class="line"> </span><br><span class="line">                q.offer(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;x, y&#125;);</span><br><span class="line">                qDist.offer(dis + <span class="number">1</span>); <span class="comment">// distance from current new location to building</span></span><br><span class="line"> </span><br><span class="line">                distance[x][y] += dis;</span><br><span class="line">                reach[x][y]++; <span class="comment">// reachable</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> m = <span class="number">0</span>; m &lt; grid.length; m++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> n = <span class="number">0</span>; n &lt; grid[<span class="number">0</span>].length; n++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (grid[m][n] == -<span class="number">1</span>) &#123;</span><br><span class="line">                grid[m][n] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<h3 id="Depth-First-Search-DFS">Depth-First Search (DFS)</h3>
<details>
<summary></summary>
<blockquote></blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>695. Max Area of Island</summary>
<blockquote>
<p>A helper method to explore the neighbors. If the cell is 1, set it to 0, and return the sum of helper methods taking its neighbors’ positions, plus 1</p>
</blockquote>
<p>Run time: $O(mn)$, space: $O(1)$</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxAreaOfIsland</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> max = <span class="number">0</span>, m = grid.length, n = grid[<span class="number">0</span>].length;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(grid[i][j] == <span class="number">1</span>) max = Math.max(max, findArea(grid, i, j));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">findArea</span><span class="params">(<span class="keyword">int</span>[][] grid, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = grid.length, n = grid[<span class="number">0</span>].length;</span><br><span class="line">    <span class="keyword">if</span>(i &lt; <span class="number">0</span> || j &lt; <span class="number">0</span> || i &gt;= m || j &gt;= n || grid[i][j] == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    grid[i][j] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> findArea(grid, i+<span class="number">1</span>, j) + findArea(grid, i-<span class="number">1</span>, j) + </span><br><span class="line">        findArea(grid, i, j+<span class="number">1</span>) + findArea(grid, i, j-<span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>79. Word Search (M)</summary>
<blockquote>
<p>Backtracking: if this current character is valid, mark it as visited, then explore its neighbors, and then reset</p>
</blockquote>
<p>Run time: $O(mn)$, space: $O(1)$</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">exist</span><span class="params">(<span class="keyword">char</span>[][] board, String word)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; board.length; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; board[<span class="number">0</span>].length; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(exist(board, i, j, word, <span class="number">0</span>))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">exist</span><span class="params">(<span class="keyword">char</span>[][] board, <span class="keyword">int</span> i, <span class="keyword">int</span> j, String word, <span class="keyword">int</span> ind)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(ind == word.length()) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(i &gt;= board.length || i &lt; <span class="number">0</span> || j &lt; <span class="number">0</span> || j &gt;= board[<span class="number">0</span>].length || </span><br><span class="line">       board[i][j] != word.charAt(ind)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    </span><br><span class="line">    board[i][j] = <span class="string">&#x27;*&#x27;</span>; <span class="comment">// mark as visited</span></span><br><span class="line">    <span class="keyword">boolean</span> result = exist(board, i-<span class="number">1</span>, j, word, ind+<span class="number">1</span>) ||</span><br><span class="line">                     exist(board, i, j-<span class="number">1</span>, word, ind+<span class="number">1</span>) ||</span><br><span class="line">                     exist(board, i, j+<span class="number">1</span>, word, ind+<span class="number">1</span>) ||</span><br><span class="line">                     exist(board, i+<span class="number">1</span>, j, word, ind+<span class="number">1</span>);</span><br><span class="line">    board[i][j] = word.charAt(ind); <span class="comment">// put it back</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>200. Number of Islands (M)</summary>
<blockquote>
<p>Use a helper function to explore the island<br>
As long as the position is valid and is 1, mark it as 0, since it would be counted as one island</p>
</blockquote>
<p>Run time: $O(mn)$, space: $O(1)$</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numIslands</span><span class="params">(<span class="keyword">char</span>[][] grid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; grid.length; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; grid[<span class="number">0</span>].length; j++)&#123;</span><br><span class="line">            ans += helper(grid, i, j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">helper</span><span class="params">(<span class="keyword">char</span>[][] grid, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i &lt; <span class="number">0</span> || j &lt; <span class="number">0</span> || i &gt;= grid.length || j &gt;= grid[<span class="number">0</span>].length || grid[i][j] == <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    grid[i][j] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    <span class="comment">// explore all neighbors and mark them as visited</span></span><br><span class="line">    helper(grid, i+<span class="number">1</span>, j);</span><br><span class="line">    helper(grid, i-<span class="number">1</span>, j);</span><br><span class="line">    helper(grid, i, j+<span class="number">1</span>);</span><br><span class="line">    helper(grid, i, j-<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>663. Walls and Gates (LintCode)</summary>
<blockquote>
<p>搜索0的位置，每找到一个0，以其周围四个相邻点为起点，开始 DFS 遍历，并带入深度值1，如果遇到的值大于当前深度值，将位置值赋为当前深度值，并对当前点的四个相邻点开始DFS遍历，注意此时深度值需要加1，这样遍历完成后，所有的位置就被正确地更新了</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">wallsAndGates</span><span class="params">(<span class="keyword">int</span>[][] rooms)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rooms.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; rooms[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (rooms[i][j] == <span class="number">0</span>) dfs(rooms, i, j, <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[][] rooms, <span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= rooms.length || j &lt; <span class="number">0</span> || j &gt;= rooms[<span class="number">0</span>].length || rooms[i][j] &lt; val) <span class="keyword">return</span>;</span><br><span class="line">        rooms[i][j] = val;</span><br><span class="line">        dfs(rooms, i + <span class="number">1</span>, j, val + <span class="number">1</span>);</span><br><span class="line">        dfs(rooms, i - <span class="number">1</span>, j, val + <span class="number">1</span>);</span><br><span class="line">        dfs(rooms, i, j + <span class="number">1</span>, val + <span class="number">1</span>);</span><br><span class="line">        dfs(rooms, i, j - <span class="number">1</span>, val + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>BFS 的解法，需要借助 queue，首先把门的位置都排入 queue 中，然后开始循环，对于门位置的四个相邻点，判断其是否在矩阵范围内，并且位置值是否大于上一位置的值加1，如果满足这些条件，将当前位置赋为上一位置加1，并将次位置排入 queue 中，这样等 queue 中的元素遍历完了，所有位置的值就被正确地更新了</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">wallsAndGates</span><span class="params">(<span class="keyword">int</span>[][] rooms)</span> </span>&#123;</span><br><span class="line">    Queue&lt;<span class="keyword">int</span>[]&gt; q = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span>[][] dirs = &#123;&#123;<span class="number">0</span>, -<span class="number">1</span>&#125;, &#123;-<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rooms.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; rooms[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (rooms[i][j] == <span class="number">0</span>) q.push(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;i, j&#125;);   </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> i = q.front().first, j = q.front().second; q.pop();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; dirs.length; k++) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = i + dirs[k][<span class="number">0</span>], y = j + dirs[k][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (x &lt; <span class="number">0</span> || x &gt;= rooms.length || y &lt; <span class="number">0</span> || y &gt;= rooms[<span class="number">0</span>].length || rooms[x][y] &lt; rooms[i][j] + <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">            rooms[x][y] = rooms[i][j] + <span class="number">1</span>;</span><br><span class="line">            q.push(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;x, y&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>934. Shortest Bridge (M)</summary>
<blockquote>
<p>DFS + BFS: first mark all islands from 1 to 2, if we found the second unexplored island, add the position to the queue<br>
In the queue, poll the position and try to explore the neighbors. If the movement is valid, check if it is 2 (found already), or check if it is 1 (on the same island), or check if it is 0 (valid change), then mark is as 1 and add to the queue.</p>
</blockquote>
<p>Run time: $O(n^2)$, space: $O(1)$</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">shortestBridge</span><span class="params">(<span class="keyword">int</span>[][] A)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> level = <span class="number">0</span>;</span><br><span class="line">    Queue&lt;<span class="keyword">int</span>[]&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">boolean</span> found = <span class="keyword">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A.length; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; A[<span class="number">0</span>].length; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(A[i][j] == <span class="number">1</span> &amp;&amp; !found)&#123;</span><br><span class="line">                dfs(A, i, j, A.length, A[<span class="number">0</span>].length);</span><br><span class="line">                found = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(found &amp;&amp; A[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">                queue.add(<span class="keyword">new</span> <span class="keyword">int</span>[] &#123;i, j&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span>[][] d = &#123;&#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">0</span>, -<span class="number">1</span>&#125;, &#123;-<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line">    <span class="keyword">while</span>(!queue.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> size = queue.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> s = <span class="number">0</span>; s &lt; size; s++) &#123;</span><br><span class="line">            <span class="keyword">int</span>[] pos = queue.remove();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">int</span> x = pos[<span class="number">0</span>] + d[i][<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">int</span> y = pos[<span class="number">1</span>] + d[i][<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span>(x &lt; <span class="number">0</span> || x &gt;= A.length || y &lt; <span class="number">0</span> || y &gt;= A[<span class="number">0</span>].length) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span>(A[x][y] == <span class="number">2</span>) <span class="keyword">return</span> level;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(A[x][y] == <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(A[x][y] == <span class="number">0</span>) &#123;</span><br><span class="line">                    A[x][y] = <span class="number">1</span>;</span><br><span class="line">                    queue.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;x, y&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        level++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[][] A, <span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    A[i][j] = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(i - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; A[i-<span class="number">1</span>][j] == <span class="number">1</span>) dfs(A, i - <span class="number">1</span>, j, m, n);</span><br><span class="line">    <span class="keyword">if</span>(i + <span class="number">1</span> &lt; m &amp;&amp; A[i+<span class="number">1</span>][j] == <span class="number">1</span>) dfs(A, i + <span class="number">1</span>, j, m, n);</span><br><span class="line">    <span class="keyword">if</span>(j - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; A[i][j - <span class="number">1</span>] == <span class="number">1</span>) dfs(A, i, j - <span class="number">1</span>, m, n);</span><br><span class="line">    <span class="keyword">if</span>(j + <span class="number">1</span> &lt; n &amp;&amp; A[i][j + <span class="number">1</span>] == <span class="number">1</span>) dfs(A, i, j + <span class="number">1</span>, m, n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>1245. Tree Diameter</summary>
<blockquote>
<p>Traverse all the nodes of the tree. The diameter of the tree is maximum of the longest path through each node.<br>
Longest path through a node is sum of top 2 depths of children’s tree.</p>
</blockquote>
<p>Run time: $O(n)$, space: $O(n)$, where $n$ is edges.length</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> diameter = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">treeDiameter</span><span class="params">(<span class="keyword">int</span>[][] edges)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = edges.length + <span class="number">1</span>;</span><br><span class="line">    LinkedList&lt;Integer&gt;[] adjacencyList = <span class="keyword">new</span> LinkedList[n];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) adjacencyList[i] = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span>[] edge : edges) &#123;</span><br><span class="line">        adjacencyList[edge[<span class="number">0</span>]].add(edge[<span class="number">1</span>]);</span><br><span class="line">        adjacencyList[edge[<span class="number">1</span>]].add(edge[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    diameter = <span class="number">0</span>;</span><br><span class="line">    depth(<span class="number">0</span>, -<span class="number">1</span>, adjacencyList);</span><br><span class="line">    <span class="keyword">return</span> diameter;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">depth</span><span class="params">(<span class="keyword">int</span> root, <span class="keyword">int</span> parent, LinkedList&lt;Integer&gt;[] adjacencyList)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> maxDepth1st = <span class="number">0</span>, maxDepth2nd = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> child : adjacencyList[root]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (child != parent) &#123; <span class="comment">// Only one way from root node to child node, don&#x27;t allow child node go to root node again!</span></span><br><span class="line">            <span class="keyword">int</span> childDepth = depth(child, root, adjacencyList);</span><br><span class="line">            <span class="keyword">if</span> (childDepth &gt; maxDepth1st) &#123;</span><br><span class="line">                maxDepth2nd = maxDepth1st;</span><br><span class="line">                maxDepth1st = childDepth;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (childDepth &gt; maxDepth2nd) &#123;</span><br><span class="line">                maxDepth2nd = childDepth;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> longestPathThroughRoot = maxDepth1st + maxDepth2nd; <span class="comment">// Sum of the top 2 highest depths is the longest path through this root</span></span><br><span class="line">    diameter = Math.max(diameter, longestPathThroughRoot);</span><br><span class="line">    <span class="keyword">return</span> maxDepth1st + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>1239. Maximum Length of a Concatenated String with Unique Character</summary>
<blockquote>
<p>Given an array of strings arr. String s is a concatenation of a sub-sequence of arr which have unique characters. Return the maximum possible length of s.</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxLength</span><span class="params">(List&lt;String&gt; arr)</span> </span>&#123;</span><br><span class="line">    dfs(arr, <span class="number">0</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(List&lt;String&gt; arr, <span class="keyword">int</span> index, String concatenatStr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isUnique(concatenatStr)) max = Math.max(max, concatenatStr.length());</span><br><span class="line">    <span class="keyword">if</span> (index == arr.size() || !isUnique(concatenatStr))  <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = index; i &lt; arr.size(); i++) &#123;</span><br><span class="line">        dfs(arr, i + <span class="number">1</span>, concatenatStr + arr.get(i));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isUnique</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] alpha = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) alpha[s.charAt(i) - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; alpha.length; i++) <span class="keyword">if</span> (alpha[i] &gt; <span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>My way</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxLength</span><span class="params">(List&lt;String&gt; arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.size(); i++)&#123;</span><br><span class="line">        String str = arr.get(i);</span><br><span class="line">        Set&lt;Character&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(x &lt; str.length())&#123;</span><br><span class="line">            <span class="keyword">char</span> c = str.toCharArray()[x];</span><br><span class="line">            <span class="keyword">if</span>(!set.add(c)) <span class="keyword">break</span>;</span><br><span class="line">            x++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(x == str.length())&#123;</span><br><span class="line">            len = Math.max(len, helper(set, arr, i));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">helper</span><span class="params">(Set&lt;Character&gt; set, List&lt;String&gt; arr, <span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(index &gt;= arr.size()) <span class="keyword">return</span> set.size();</span><br><span class="line">    <span class="keyword">int</span> maxLen = set.size();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = index+<span class="number">1</span>; i &lt; arr.size(); i++)&#123;</span><br><span class="line">        String str = arr.get(i);</span><br><span class="line">        Set&lt;Character&gt; newSet = <span class="keyword">new</span> HashSet&lt;&gt;(set);</span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// System.out.println(arr.get(index)+&quot; &quot;+str +&quot; &quot;+ newSet.size());</span></span><br><span class="line">        <span class="keyword">while</span>(x &lt; str.length())&#123;</span><br><span class="line">            <span class="keyword">char</span> c = str.toCharArray()[x];</span><br><span class="line">            <span class="keyword">if</span>(!newSet.add(c)) <span class="keyword">break</span>;</span><br><span class="line">            x++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// System.out.println(set.size()+str.length());</span></span><br><span class="line">        <span class="keyword">if</span>(x == str.length())&#123;</span><br><span class="line">            maxLen = Math.max(maxLen, helper(newSet, arr, i));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxLen;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>1219. Path with Maximum Gold</summary>
<blockquote>
<p>Use a helper function to find the max points; if the cell is invalid, return the current sum.<br>
First update the sum of points, then mark the cell visited, and call helper function to explore the neighbor cells and update the temp max. At last mark the cell unvisited and return the temp max.</p>
</blockquote>
<p>Run time: $O(mn)$, space: $O(1)$</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span>[] d = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, <span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMaximumGold</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; grid.length; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; grid[<span class="number">0</span>].length; ++j) &#123;</span><br><span class="line">            ans = Math.max(ans, dfs(grid, i, j, <span class="number">0</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[][] g, <span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= g.length || j &lt; <span class="number">0</span> || j &gt;= g[<span class="number">0</span>].length || g[i][j] == <span class="number">0</span> || g[i][j] &gt; <span class="number">100</span>) </span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    sum += g[i][j];</span><br><span class="line">    g[i][j] += <span class="number">1000</span>; <span class="comment">// mark visited.</span></span><br><span class="line">    <span class="keyword">int</span> mx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; ++k) &#123; <span class="comment">// traverse 4 neighbors to get max value.</span></span><br><span class="line">        mx = Math.max(mx, dfs(g, i + d[k], j + d[k + <span class="number">1</span>], sum));</span><br><span class="line">    &#125;</span><br><span class="line">    g[i][j] -= <span class="number">1000</span>; <span class="comment">// change back.</span></span><br><span class="line">    <span class="keyword">return</span> mx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>694. Number of Distinct Islands</summary>
<blockquote>
<p>Use set1 to store the string version of set2 storing island shape<br>
Explore up, down, left, right location and if it’s 1, then add the location difference to the set2</p>
</blockquote>
<p>Run time: $O(n^3)$, space: $O(n^2)$</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numDistinctIslands</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (grid == <span class="keyword">null</span> || grid.length &lt; <span class="number">1</span> || grid[<span class="number">0</span>].length &lt; <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> m = grid.length, n = grid[<span class="number">0</span>].length;</span><br><span class="line">    Set&lt;String&gt; res = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            Set&lt;String&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">            <span class="keyword">if</span> (grid[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">                dfs(grid, i, j, i, j, set);</span><br><span class="line">                res.add(set.toString());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res.size();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[][] grid, <span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> baseX, <span class="keyword">int</span> baseY, Set&lt;String&gt; set)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = grid.length, n = grid[<span class="number">0</span>].length;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= m || j &lt; <span class="number">0</span> || j &gt;= n || grid[i][j] == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    set.add((i - baseX) + <span class="string">&quot;_&quot;</span> + (j - baseY));</span><br><span class="line">    grid[i][j] = <span class="number">0</span>;</span><br><span class="line">    dfs(grid, i + <span class="number">1</span>, j, baseX, baseY, set);</span><br><span class="line">    dfs(grid, i - <span class="number">1</span>, j, baseX, baseY, set);</span><br><span class="line">    dfs(grid, i, j - <span class="number">1</span>, baseX, baseY, set);</span><br><span class="line">    dfs(grid, i, j + <span class="number">1</span>, baseX, baseY, set);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>329. Longest Increasing Path in a Matrix</summary>
<blockquote>
<p>Use cache of same size as the matrix, walk through each entry<br>
Use helper function to check if this movement is valid and the next entry is larger than the current one, then update max; check 4 directions, then update max and return it<br>
Run time: $O(n^4)$, space: $O(n^2)$</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestIncreasingPath</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (matrix.length == <span class="number">0</span> || matrix[<span class="number">0</span>].length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span>[][] cache = <span class="keyword">new</span> <span class="keyword">int</span>[matrix.length][matrix[<span class="number">0</span>].length];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; matrix.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j =<span class="number">0</span>; j &lt; matrix[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">            max = Math.max(dfs(matrix, i, j, cache), max);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span>[][] cache)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (cache[i][j] &gt; <span class="number">0</span>) <span class="keyword">return</span> cache[i][j];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> count1 = <span class="number">0</span>,count2=<span class="number">0</span>,count3=<span class="number">0</span>,count4=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (j - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; matrix[i][ j - <span class="number">1</span>] &gt; matrix[i][j])</span><br><span class="line">    		count1 = dfs(matrix, i, j - <span class="number">1</span>, cache);</span><br><span class="line">    <span class="keyword">if</span> (i - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; matrix[i - <span class="number">1</span>][j] &gt; matrix[i][j])</span><br><span class="line">   		 count2 = dfs(matrix, i - <span class="number">1</span>, j, cache);</span><br><span class="line">    <span class="keyword">if</span> (j + <span class="number">1</span> &lt; matrix[<span class="number">0</span>].length &amp;&amp; matrix[i][j + <span class="number">1</span>] &gt; matrix[i][j])</span><br><span class="line">    		count3 = dfs(matrix, i, j + <span class="number">1</span>, cache);</span><br><span class="line">    <span class="keyword">if</span> (i + <span class="number">1</span> &lt; matrix.length &amp;&amp; matrix[i + <span class="number">1</span>][j] &gt; matrix[i][j])</span><br><span class="line">    		count4 = dfs(matrix, i + <span class="number">1</span>, j, cache);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> longestIncreasingPath = Math.max(Math.max(count1, count2), Math.max(count3, count4));</span><br><span class="line">    cache[i][j] = <span class="number">1</span> + longestIncreasingPath;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> cache[i][j];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>248. Strobogrammatic Number III</summary>
<blockquote>
<p>Loop through num of low digits to num of high digits<br>
Check a couple of edge cases(length, starting 0, smaller/larger)<br>
Run time: $O(n)$, space: $O(1)$</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">strobogrammaticInRange</span><span class="params">(String low, String high)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">       find(low, high, <span class="string">&quot;&quot;</span>, i, res);</span><br><span class="line">       find(low, high, <span class="string">&quot;0&quot;</span>, i, res);</span><br><span class="line">       find(low, high, <span class="string">&quot;1&quot;</span>, i, res);</span><br><span class="line">       find(low, high, <span class="string">&quot;8&quot;</span>, i, res);</span><br><span class="line">       <span class="keyword">return</span> res;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">find</span><span class="params">(String low, String high, String w, <span class="keyword">int</span> res)</span></span>&#123;</span><br><span class="line">   	<span class="keyword">if</span>(w.length() &gt;= low.length() &amp;&amp; w.length() &lt;= high.length())&#123;</span><br><span class="line">	<span class="keyword">if</span>(w.length() &gt;= high.length() &amp;&amp; w.compareTo(high) &gt; <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">if</span>((w.length() &lt;= <span class="number">1</span> || w.charAt(<span class="number">0</span>) != <span class="string">&#x27;0&#x27;</span>) &amp;&amp; (w.length() != low.length() || w.compareTo(low) &gt;= <span class="number">0</span>) res++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(w.length+<span class="number">2</span> &gt; high.size()) <span class="keyword">return</span>;</span><br><span class="line">       find(low, high, <span class="string">&quot;0&quot;</span> + w + <span class="string">&quot;0&quot;</span>, res);</span><br><span class="line">       find(low, high, <span class="string">&quot;1&quot;</span> + w + <span class="string">&quot;1&quot;</span>, res);</span><br><span class="line">       find(low, high, <span class="string">&quot;6&quot;</span> + w + <span class="string">&quot;9&quot;</span>, res);</span><br><span class="line">       find(low, high, <span class="string">&quot;8&quot;</span> + w + <span class="string">&quot;8&quot;</span>, res);</span><br><span class="line">       find(low, high, <span class="string">&quot;9&quot;</span> + w + <span class="string">&quot;6&quot;</span>, res);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>98. Validate Binary Search Tree</summary>
<blockquote>
<p>Recursion<br>
Run time $O(n)$, space $O(h)$</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer prev = <span class="keyword">null</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidBST</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(!isValidBST(root.left)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(prev != <span class="keyword">null</span> &amp;&amp; prev &gt;= root.val) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">else</span> prev = root.val;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(!isValidBST(root.right)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>min max comparison<br>
Run time $O(n)$, space $O(h)$</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidBST</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span> valid(root, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">valid</span><span class="params">(TreeNode n, Integer min, Integer max)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((min != <span class="keyword">null</span> &amp;&amp; n.val &lt;= min) || (max != <span class="keyword">null</span> &amp;&amp; n.val &gt;= max))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> valid(n.left, min, n.val) &amp;&amp; valid(n.right, n.val,max);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>200. Number of Islands (M)</summary>
<blockquote>
<p>DFS: $O(n^2)$, space complexity: $O(1)$</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numIslands</span><span class="params">(<span class="keyword">char</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; grid.length; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; grid[<span class="number">0</span>].length; j++)&#123;</span><br><span class="line">                ans += helper(i, j, grid);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">helper</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">char</span>[][] grid)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i&lt;<span class="number">0</span> || j&lt;<span class="number">0</span> || i&gt;=grid.length || j&gt;=grid[<span class="number">0</span>].length||</span><br><span class="line">          grid[i][j] == <span class="string">&#x27;0&#x27;</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        grid[i][j] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        helper(i+<span class="number">1</span>,j,grid);</span><br><span class="line">        helper(i-<span class="number">1</span>,j,grid);</span><br><span class="line">        helper(i,j+<span class="number">1</span>,grid);</span><br><span class="line">        helper(i,j-<span class="number">1</span>,grid);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</details>
<h3 id="Backtracking-DFS">Backtracking (DFS)</h3>
<details>
<summary></summary>
<blockquote></blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>37. Sudoku Solver</summary>
<blockquote>
<p>Every time see an empty cell, try value from 1 to 9 if it is valid<br>
Call helper function and if it is true return true, otherwise reset this cell<br>
After trying all possible values but none of them works, return false</p>
</blockquote>
<p>We could replace ‘.’ one by one with a digit that is compatible, if we can’t find a compatible digit for a cube, we backtrace to a cube and fill it with another compatible digit. if we have replace all ‘.’ with a compatible digit, we get a solution<br>
Heuristic method: The key point is which ‘.’ should we replace first? we should first replace intuitively a ‘.’ which has the fewest compatible digit. why? let‘s say，we chosed a digit for the first ‘.’ and finally we find it is a wrong digit, we have to traceback to this first ‘.’, it would be painfully inefficient, so, we should first replace a ‘.’ which we are most likely choose a right digit for it. The fewer compatible digits the ‘.’ has, the more likely we can choose a right digits for it.<br>
The code can be improved, Welcome to share your own tricks and implementation</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">solveSudoku</span><span class="params">(<span class="keyword">char</span>[][] board)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(board == <span class="keyword">null</span> || board.length == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        solve(board);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">solve</span><span class="params">(<span class="keyword">char</span>[][] board)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; board.length; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; board[<span class="number">0</span>].length; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(board[i][j] == <span class="string">&#x27;.&#x27;</span>)&#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">char</span> c = <span class="string">&#x27;1&#x27;</span>; c &lt;= <span class="string">&#x27;9&#x27;</span>; c++)&#123;<span class="comment">//trial. Try 1 through 9</span></span><br><span class="line">                        <span class="keyword">if</span>(isValid(board, i, j, c))&#123;</span><br><span class="line">                            board[i][j] = c; <span class="comment">//Put c for this cell</span></span><br><span class="line">                            </span><br><span class="line">                            <span class="keyword">if</span>(solve(board)) <span class="keyword">return</span> <span class="keyword">true</span>; <span class="comment">//If it&#x27;s the solution return true</span></span><br><span class="line">                            <span class="keyword">else</span> board[i][j] = <span class="string">&#x27;.&#x27;</span>; <span class="comment">//Otherwise go back</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(<span class="keyword">char</span>[][] board, <span class="keyword">int</span> row, <span class="keyword">int</span> col, <span class="keyword">char</span> c)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(board[i][col] != <span class="string">&#x27;.&#x27;</span> &amp;&amp; board[i][col] == c) <span class="keyword">return</span> <span class="keyword">false</span>; <span class="comment">//check row</span></span><br><span class="line">            <span class="keyword">if</span>(board[row][i] != <span class="string">&#x27;.&#x27;</span> &amp;&amp; board[row][i] == c) <span class="keyword">return</span> <span class="keyword">false</span>; <span class="comment">//check column</span></span><br><span class="line">            <span class="keyword">if</span>(board[<span class="number">3</span> * (row / <span class="number">3</span>) + i / <span class="number">3</span>][ <span class="number">3</span> * (col / <span class="number">3</span>) + i % <span class="number">3</span>] != <span class="string">&#x27;.&#x27;</span> &amp;&amp; </span><br><span class="line">board[<span class="number">3</span> * (row / <span class="number">3</span>) + i / <span class="number">3</span>][<span class="number">3</span> * (col / <span class="number">3</span>) + i % <span class="number">3</span>] == c) <span class="keyword">return</span> <span class="keyword">false</span>; <span class="comment">//check 3*3 block</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>465. Optimal Account Balancing (G)</summary>
<blockquote>
<p>Given a list of transactions between a group of people, return the minimum number of transactions required to settle the debt.<br>
Use a map to store &lt;person, balance&gt;, where positive balance means extra money, negative implies somebody owes this person.<br>
First record all transactions into the map, then add all nonzero values into a list<br>
Create a Long array to store nonzero balances<br>
Helper method: if current entry is zero, continue till the end, return count</p>
</blockquote>
<p>Relevant post: <a href="http://shibaili.blogspot.com/2018/11/465-optimal-account-balancing.html">link</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minTransfers</span><span class="params">(<span class="keyword">int</span>[][] transactions)</span> </span>&#123;</span><br><span class="line">        Map&lt;Integer, Long&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span>[] t : transactions)&#123;</span><br><span class="line">            <span class="keyword">long</span> val1 = map.getOrDefault(t[<span class="number">0</span>], <span class="number">0L</span>);<span class="comment">//balance</span></span><br><span class="line">            <span class="keyword">long</span> val2 = map.getOrDefault(t[<span class="number">1</span>], <span class="number">0L</span>);</span><br><span class="line">            map.put(t[<span class="number">0</span>], val1-t[<span class="number">2</span>]);</span><br><span class="line">            map.put(t[<span class="number">1</span>], val2+t[<span class="number">2</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        List&lt;Long&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">long</span> val : map.values())&#123;</span><br><span class="line">            <span class="keyword">if</span>(val!=<span class="number">0</span>) list.add(val);</span><br><span class="line">        &#125;</span><br><span class="line">        Long[] debts = <span class="keyword">new</span> Long[list.size()];</span><br><span class="line">        debts = list.toArray(debts);</span><br><span class="line">        <span class="keyword">return</span> helper(debts, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">helper</span><span class="params">(Long[] debts, <span class="keyword">int</span> pos, <span class="keyword">int</span> count )</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(pos &lt; debts.length &amp;&amp; debts[pos] == <span class="number">0</span>) pos++;</span><br><span class="line">        <span class="keyword">if</span>(pos&gt;=debts.length) <span class="keyword">return</span> count;</span><br><span class="line">        <span class="keyword">int</span> res = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=pos+<span class="number">1</span>; i&lt;debts.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>((debts[pos] ^ debts[i]) &lt; <span class="number">0</span>)&#123; <span class="comment">// debts[pos] and debts[i] has different signs</span></span><br><span class="line">                debts[i] += debts[pos];</span><br><span class="line">                res = Math.min(res, helper(debts, pos+<span class="number">1</span>, count+<span class="number">1</span>));</span><br><span class="line">                debts[i] -= debts[pos];<span class="comment">//backtracking</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Speed up:<br>
有一点greedy + backtracking的感觉，首先用sort找出-5, 5这种pair, 然后从debts list中移除。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minTransfers</span><span class="params">(<span class="keyword">int</span>[][] transactions)</span> </span>&#123;</span><br><span class="line">    Map&lt;Integer, Long&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span>[] t : transactions)&#123;</span><br><span class="line">        <span class="keyword">long</span> val1 = map.getOrDefault(t[<span class="number">0</span>], <span class="number">0L</span>);<span class="comment">//balance</span></span><br><span class="line">        <span class="keyword">long</span> val2 = map.getOrDefault(t[<span class="number">1</span>], <span class="number">0L</span>);</span><br><span class="line">        map.put(t[<span class="number">0</span>], val1-t[<span class="number">2</span>]);</span><br><span class="line">        map.put(t[<span class="number">1</span>], val2+t[<span class="number">2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    List&lt;Long&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">long</span> val : map.values())&#123;</span><br><span class="line">        <span class="keyword">if</span>(val!=<span class="number">0</span>) list.add(val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> matchCount = removeMatch(list);</span><br><span class="line">    <span class="keyword">return</span> matchCount + minTransStartFrom(list, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">removeMatch</span><span class="params">(List&lt;Long&gt; list)</span> </span>&#123;</span><br><span class="line">    Collections.sort(list);</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> right = list.size() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> matchCount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="keyword">if</span> (list.get(left) + list.get(right) == <span class="number">0</span>) &#123;</span><br><span class="line">            list.remove(left);</span><br><span class="line">            list.remove(right - <span class="number">1</span>);</span><br><span class="line">            right -= <span class="number">2</span>;</span><br><span class="line">            matchCount++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (list.get(left) + list.get(right) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            left++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> matchCount;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">minTransStartFrom</span><span class="params">(List&lt;Long&gt; list, <span class="keyword">int</span> start)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result = Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">int</span> n = list.size();</span><br><span class="line">    <span class="keyword">while</span> (start &lt; n &amp;&amp; list.get(start) == <span class="number">0</span>) &#123;</span><br><span class="line">        start++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (start == n) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = start + <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (list.get(i) * list.get(start) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            list.set(i, list.get(i) + list.get(start));</span><br><span class="line">            result = Math.min(result, <span class="number">1</span> + minTransStartFrom(list, start + <span class="number">1</span>));</span><br><span class="line">            list.set(i, list.get(i) - list.get(start));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>9999. Construct a word using dice (G)</summary>
<blockquote>
<p><a href="https://leetcode.com/discuss/interview-question/267985/">Onsite interview problem</a><br>
Given a word of length n and n six-sided dice with a character in each side. Find out if this word can be constructed by the set of given dice.</p>
</blockquote>
<p>Run time: $O(|word|)$, space: $O(26)$ assuming alphabet</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">canConstruct</span><span class="params">(String word, <span class="keyword">char</span>[][] M)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(word == <span class="keyword">null</span> || word.isEmpty() || word.length() &gt; M.length)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    Map&lt;Character, List&lt;Integer&gt;&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; M.length; i++) &#123;</span><br><span class="line">        <span class="keyword">char</span>[] A = M[i];</span><br><span class="line">        addToMap(A, i, map);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; word.length()) &#123;</span><br><span class="line">        <span class="keyword">char</span> c = word.charAt(i++);</span><br><span class="line">        <span class="keyword">boolean</span> hasFound = findCharFromMap(c, map);</span><br><span class="line">        <span class="keyword">if</span>( !hasFound) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (i == word.length());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">findCharFromMap</span><span class="params">(<span class="keyword">char</span> c, Map&lt;Character, List&lt;Integer&gt;&gt; map)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; list = map.get(c);</span><br><span class="line">    <span class="keyword">if</span>(list == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        list.remove(list.size()-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(list.size() == <span class="number">0</span>) map.remove(c);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addToMap</span><span class="params">(<span class="keyword">char</span>[] A, <span class="keyword">int</span> i, Map&lt;Character, List&lt;Integer&gt;&gt; map)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">char</span> c: A ) &#123;</span><br><span class="line">        List&lt;Integer&gt; list = map.get(c);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(list == <span class="keyword">null</span>) &#123;</span><br><span class="line">            list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            list.add(i);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(!list.contains(i)) list.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">        map.put(c, list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>1240. Tiling a Rectangle with the Fewest Squares</summary>
<blockquote>
<p>// 基本思路是从底往上填充整个方块，每次优先填充最底下的没填充的方块，并选择不同的可能的size的正方形把他填充了。我们在dfs的时候维护一个height数组（天际线）。这个天际线是状态的标识。我们最终要求的结果就是天际线是n个m的那个状态的最小方块数。当然纯暴力的话时间复杂度会很高，但是可以通过以下三点来剪枝，或者优化。<br>
// 1、 当前这个天际线的cnt（也就是方块数）已经超过了当前的全局最优解的值，那么直接return<br>
// 2、 当前的这个天际线已经遍历过了，而且之前的cnt比当前的cnt要小，那么直接return<br>
// 3、 当我们找到左下角的空方块后，选取下一个填充方块的的时候优先从较大的方块开始选取，这样可以使得程序快速收敛。（这一点不是剪枝，但是是很重要的优化）</p>
</blockquote>
<p>The basic idea is to fill the entire block bottom up. In every step, find the lowest left unfilled square first, and select a square with different possible sizes to fill it. We maintain a height array (skyline) with length n while dfs. This skyline is the identity of the state. The final result we ask for is the minimum number of squares for the state [m, m, m, m, m, m, m] (The length of this array is n). Of course, backtrack without optimization will have a huge time complexity, but it can be pruned or optimized by the following three methods.</p>
<p>When the current cnt (that is, the number of squares) of this skyline has exceeded the value of the current global optimal solution, then return directly.<br>
When the current skyline has been traversed, and the previous cnt is smaller than the current cnt, then return directly.<br>
When we find the empty square in the lowest left corner, we pick larger size for the next square first. This can make the program converge quickly. (It is a very important optimization)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;Long, Integer&gt; set = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"><span class="keyword">int</span> res = Integer.MAX_VALUE;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">tilingRectangle</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == m) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (n &gt; m) &#123;</span><br><span class="line">        <span class="keyword">int</span> temp = n;</span><br><span class="line">        n = m;</span><br><span class="line">        m = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(n, m, <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>], <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m, <span class="keyword">int</span>[] h, <span class="keyword">int</span> cnt)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (cnt &gt;= res) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">boolean</span> isFull = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">int</span> pos = -<span class="number">1</span>, minH = Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (h[i] &lt; m) isFull = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (h[i] &lt; minH) &#123;</span><br><span class="line">            pos = i;</span><br><span class="line">            minH = h[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (isFull) &#123;</span><br><span class="line">        res = Math.min(cnt, res);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">long</span> key = <span class="number">0</span>, base = m + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        key += h[i] * base;</span><br><span class="line">        base *= m + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (set.containsKey(key) &amp;&amp; set.get(key) &lt;= cnt) <span class="keyword">return</span>;</span><br><span class="line">    set.put(key, cnt);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> end = pos;</span><br><span class="line">    <span class="keyword">while</span> (end + <span class="number">1</span> &lt;= n &amp;&amp; h[end + <span class="number">1</span>] == h[pos] &amp;&amp; (end + <span class="number">1</span> - pos + <span class="number">1</span> + minH) &lt;= m) end++;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = end; j &gt;= pos; j--) &#123;</span><br><span class="line">        <span class="keyword">int</span> curH = j - pos + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (curH + minH &gt; m) <span class="keyword">break</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span>[] next  = Arrays.copyOf(h, n + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = pos; k &lt;= j; k++) &#123;</span><br><span class="line">            next[k] += curH;</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(n, m, next, cnt + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>489. Robot Room Cleaner</summary>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] dx = &#123;-<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span>[] dy = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,-<span class="number">1</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cleanRoom</span><span class="params">(Robot robot)</span></span>&#123;</span><br><span class="line">	dfs(robot, <span class="keyword">new</span> HashSet&lt;&gt;(), <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>); <span class="comment">// 0: up, 90: right, 180: down, 270: left</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(Robot robot, Set&lt;String&gt; visited, <span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> curDir)</span></span>&#123;</span><br><span class="line">	String key = x + <span class="string">&quot;@&quot;</span> + y; <span class="comment">// current location</span></span><br><span class="line">	<span class="keyword">if</span>(visited.contains(key)) <span class="keyword">return</span>;</span><br><span class="line">	visited.add(key); <span class="comment">// not visited, add to hashset</span></span><br><span class="line">	robot.clean();</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)&#123; <span class="comment">// go up, right, down, left --&gt; clockwise</span></span><br><span class="line">		<span class="keyword">if</span>(robot.move())&#123;</span><br><span class="line">			dfs(robot, visited, x+dx[curDir], y+dy[curDir], curDir);</span><br><span class="line">			backtrack(robot); <span class="comment">// back to original position before call dfs!</span></span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		robot.turnRight();</span><br><span class="line">		curDIr += <span class="number">1</span>;</span><br><span class="line">		curDir %= <span class="number">4</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(Robot robot)</span></span>&#123;</span><br><span class="line">	robot.turnLeft();</span><br><span class="line">	robot.turnLeft();</span><br><span class="line">	robot.move();</span><br><span class="line">	robot.turnRight();</span><br><span class="line">	robot.turnRight();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>301. Remove Invalid Parentheses</summary>
<blockquote>
<p>Still need time to understand this solution<br>
Limit max removal rmL and rmR for backtracking boundary. Otherwise it will exhaust all possible valid substrings, not shortest ones.<br>
Scan from left to right, avoiding invalid strs (on the fly) by checking num of open parens.<br>
If it’s ‘(’, either use it, or remove it.<br>
If it’s ‘(’, either use it, or remove it.<br>
Otherwise just append it.</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">removeInvalidParentheses</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> rmL = <span class="number">0</span>, rmR = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> c: s.toCharArray()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">&#x27;(&#x27;</span>) rmL++;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;)&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (rmL != <span class="number">0</span>) rmL--;</span><br><span class="line">            <span class="keyword">else</span> rmR++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    List&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    dfs(s, <span class="number">0</span>, res, <span class="string">&quot;&quot;</span>, rmL, rmR, <span class="number">0</span>, <span class="string">&#x27;&amp;&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(String s, <span class="keyword">int</span> i, List&lt;String&gt; res, String temp, <span class="keyword">int</span> rmL, <span class="keyword">int</span> rmR, <span class="keyword">int</span> open, <span class="keyword">char</span> lastSkipped)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (rmL &lt; <span class="number">0</span> || rmR &lt; <span class="number">0</span> || open &lt; <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (i == s.length()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (rmL == <span class="number">0</span> &amp;&amp; rmR == <span class="number">0</span> &amp;&amp; open == <span class="number">0</span>) res.add(temp);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> c = s.charAt(i);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (c == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (rmL &gt; <span class="number">0</span>) dfs(s, i + <span class="number">1</span>, res, temp, rmL - <span class="number">1</span>, rmR, open, <span class="string">&#x27;(&#x27;</span>); <span class="comment">// not use (</span></span><br><span class="line">        <span class="keyword">if</span> (lastSkipped != <span class="string">&#x27;(&#x27;</span>) </span><br><span class="line">            dfs(s, i + <span class="number">1</span>, res, temp + c, rmL, rmR, open + <span class="number">1</span>, <span class="string">&#x27;&amp;&#x27;</span>); <span class="comment">// use (</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;)&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (rmR &gt; <span class="number">0</span>) dfs(s, i + <span class="number">1</span>, res, temp, rmL, rmR - <span class="number">1</span>, open, <span class="string">&#x27;)&#x27;</span>);	<span class="comment">// not use  )</span></span><br><span class="line">        <span class="keyword">if</span> (open &gt; <span class="number">0</span> &amp;&amp; (lastSkipped != <span class="string">&#x27;)&#x27;</span>))</span><br><span class="line">            dfs(s, i + <span class="number">1</span>, res, temp + c, rmL, rmR, open - <span class="number">1</span>, <span class="string">&#x27;&amp;&#x27;</span>);  	    <span class="comment">// use )</span></span><br><span class="line">    &#125; <span class="keyword">else</span> dfs(s, i + <span class="number">1</span>, res, temp + c, rmL, rmR, open, <span class="string">&#x27;&amp;&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>399. Evaluate Division (G)</summary>
<blockquote>
<p>Graph+DFS+backtracking<br>
Use directed graph and store value on the edge: $[“a”, “c”] = a -&gt; b -&gt; c = 2.0 * 3.0 = 6.0$</p>
</blockquote>
<p>Create a Graph class, with addNode (void), addConnection (return boolean)<br>
Create a Node class, with addConnections<br>
Initialize a Graph object before the real method</p>
<ul>
<li>add &lt;src, tgt, val&gt; and &lt;tgt, src, 1/val&gt; to graph</li>
<li>DFS: check mutiple edge cases, val *= sNode.connections.get(s), visited.add(s)</li>
<li>return 0 or the final product</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Graph</span></span>&#123;</span><br><span class="line">        Map&lt;String, Node&gt; nodes = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">addNode</span><span class="params">(String key)</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(nodes.containsKey(key)) <span class="keyword">return</span>;</span><br><span class="line">            nodes.put(key, <span class="keyword">new</span> Node(key));</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">boolean</span> <span class="title">addConnection</span><span class="params">(String src, String tgt, <span class="keyword">double</span> val)</span></span>&#123;</span><br><span class="line">            addNode(src);</span><br><span class="line">            nodes.get(src).addConnection(tgt, val);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">        String key;</span><br><span class="line">        Map&lt;String, Double&gt; connections = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(String key)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.key = key;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">addConnection</span><span class="params">(String tgt, <span class="keyword">double</span> val)</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(connections.containsKey(tgt)) <span class="keyword">return</span>;</span><br><span class="line">            connections.put(tgt, val);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    Graph graph = <span class="keyword">new</span> Graph();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">double</span>[] calcEquation(List&lt;List&lt;String&gt;&gt; equations, <span class="keyword">double</span>[] values, List&lt;List&lt;String&gt;&gt; queries) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;equations.size(); i++)&#123;</span><br><span class="line">            List&lt;String&gt; equation = equations.get(i);</span><br><span class="line">            String src = equation.get(<span class="number">0</span>);</span><br><span class="line">            String tgt = equation.get(<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">double</span> val = values[i];</span><br><span class="line">            graph.addConnection(src, tgt, val);</span><br><span class="line">            graph.addConnection(tgt, src, <span class="number">1</span>/val);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">double</span>[] ans = <span class="keyword">new</span> <span class="keyword">double</span>[queries.size()];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;queries.size(); i++)&#123;</span><br><span class="line">            List&lt;String&gt; query = queries.get(i);</span><br><span class="line">            String src = query.get(<span class="number">0</span>);</span><br><span class="line">            String tgt = query.get(<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>(graph.nodes.containsKey(src) &amp;&amp; </span><br><span class="line">               graph.nodes.containsKey(tgt))&#123;</span><br><span class="line">                ans[i] = dfs(src, tgt, <span class="number">1</span>, <span class="keyword">new</span> HashSet&lt;String&gt;());</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(ans[i] == <span class="number">0</span>) ans[i] = -<span class="number">1</span>;</span><br><span class="line">            <span class="comment">// ans[i] = (res[i] == 0)?-1:ans[i];</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">double</span> <span class="title">dfs</span><span class="params">(String src, String tgt, <span class="keyword">double</span> val, Set&lt;String&gt; visited)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(val == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(src.equals(tgt)) <span class="keyword">return</span> val;</span><br><span class="line">        Node sNode = graph.nodes.get(src);</span><br><span class="line">        <span class="keyword">if</span>(sNode == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(String s: sNode.connections.keySet())&#123;</span><br><span class="line">            <span class="keyword">if</span>(visited.contains(s)) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(s.equals(tgt)) <span class="keyword">return</span> val*sNode.connections.get(s);</span><br><span class="line">            val *= sNode.connections.get(s);</span><br><span class="line">            visited.add(s);</span><br><span class="line">            <span class="keyword">double</span> res = dfs(s, tgt, val, visited);</span><br><span class="line">            <span class="keyword">if</span>(res != <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">            visited.remove(s);</span><br><span class="line">            val = val / sNode.connections.get(s);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<h3 id="Traversal">Traversal</h3>
<details>
<summary></summary>
<blockquote></blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>102. Binary Tree Level Order Traversal (M)</summary>
<blockquote>
<p>(DFS?) Similar to LC103, and we do not need to care about the insertion position</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    helper(ans, root, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">helper</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; ans, TreeNode root, <span class="keyword">int</span> level)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(ans.size() &lt;= level) ans.add(<span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">    ans.get(level).add(root.val);</span><br><span class="line">    helper(ans, root.left, level+<span class="number">1</span>);</span><br><span class="line">    helper(ans, root.right, level+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>103. Binary Tree Zigzag Level Order Traversal (M)</summary>
<blockquote>
<p>Use a helper function that takes the level of the node and determines the node should be added to first or last position of the corresponding list</p>
</blockquote>
<p>Run time: $O(n)$, space: $O(n)$</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; zigzagLevelOrder(TreeNode root) &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    helper(ans, root, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">helper</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; ans, TreeNode root, <span class="keyword">int</span> level)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(ans.size() &lt;= level) ans.add(<span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(level % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">        ans.get(level).add(root.val);</span><br><span class="line">    &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">        ans.get(level).add(<span class="number">0</span>, root.val);</span><br><span class="line">    &#125;</span><br><span class="line">    helper(ans, root.left, level+<span class="number">1</span>);</span><br><span class="line">    helper(ans, root.right, level+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>106. Construct Binary Tree from Inorder and Postorder Traversal (M)</summary>
<blockquote>
<p>Add the node backwards in the postorder list into stack, and keep track of the left node in the inorder list</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] inorder, <span class="keyword">int</span>[] postorder)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(inorder.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">int</span> j = postorder.length-<span class="number">1</span>;</span><br><span class="line">    Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack();</span><br><span class="line">    TreeNode root = <span class="keyword">new</span> TreeNode(postorder[j--]); <span class="comment">// root node</span></span><br><span class="line">    stack.push(root);</span><br><span class="line">    TreeNode node = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = inorder.length-<span class="number">1</span>; j &gt;= <span class="number">0</span>; j--)&#123;</span><br><span class="line">        TreeNode cur = <span class="keyword">new</span> TreeNode(postorder[j]); <span class="comment">// right subtree</span></span><br><span class="line">        <span class="keyword">while</span>(stack.size() &gt; <span class="number">0</span> &amp;&amp; stack.peek().val == inorder[i])&#123;</span><br><span class="line">            node = stack.pop();</span><br><span class="line">            i--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(node != <span class="keyword">null</span>)&#123;</span><br><span class="line">            node.left = cur;</span><br><span class="line">            node = <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">            stack.peek().right = cur;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        stack.push(cur);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>572. Subtree of Another Tree</summary>
<blockquote>
<p>Use a helper method to check each child node and see if they are the same.</p>
</blockquote>
<p>Run time: $O(m+n)$, space: $O(1)$</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSubtree</span><span class="params">(TreeNode s, TreeNode t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (isSame(s, t)) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">return</span> isSubtree(s.left, t) || isSubtree(s.right, t);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isSame</span><span class="params">(TreeNode s, TreeNode t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span> &amp;&amp; t == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span> || t == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (s.val != t.val) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> isSame(s.left, t.left) &amp;&amp; isSame(s.right, t.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>428	. Serialize and Deserialize N-ary Tree</summary>
<blockquote>
<p>Same idea as a binary tree!</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Encodes a tree to a single string.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">serialize</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">         </span><br><span class="line">        Queue&lt;Node&gt; que = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        sb.append(Integer.toString(root.val)).append(<span class="string">&quot;,#,&quot;</span>);</span><br><span class="line">        que.add(root);</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">while</span> (!que.isEmpty()) &#123;</span><br><span class="line">            Node node = que.poll();</span><br><span class="line">            <span class="keyword">for</span> (Node n : node.children) &#123;</span><br><span class="line">                sb.append(Integer.toString(n.val)).append(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">                que.add(n);</span><br><span class="line">            &#125;</span><br><span class="line">            sb.append(<span class="string">&quot;#,&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Decodes your encoded data to tree.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">deserialize</span><span class="params">(String data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (data.length() == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        String[] s = data.split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line"> </span><br><span class="line">        Queue&lt;Node&gt; que = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        Node root = <span class="keyword">new</span> Node(Integer.parseInt(s[<span class="number">0</span>]), <span class="keyword">new</span> ArrayList&lt;Node&gt;());</span><br><span class="line">        que.add(root);</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">while</span> (!que.isEmpty()) &#123;</span><br><span class="line">            Node node = que.poll();</span><br><span class="line">            i++;</span><br><span class="line">            <span class="keyword">while</span> (!s[i].equals(<span class="string">&quot;#&quot;</span>)) &#123;</span><br><span class="line">                Node c = <span class="keyword">new</span> Node(Integer.parseInt(s[i]), <span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">                node.children.add(c);</span><br><span class="line">                que.add(c);</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>297. Serialize and Deserialize Binary Tree (M)</summary>
<blockquote>
<p>Serialize: return current value, and recursively call children<br>
Deserialize: Store in a queue, works life BFS</p>
</blockquote>
<p>Run time: $O(n)$, space: $O(n)$</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Encodes a tree to a single string.</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">serialize</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="string">&quot;null&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> root.val+<span class="string">&quot;,&quot;</span>+serialize(root.left)+<span class="string">&quot;,&quot;</span>+serialize(root.right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Decodes your encoded data to tree.</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">deserialize</span><span class="params">(String data)</span> </span>&#123;</span><br><span class="line">    Queue&lt;String&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;(Arrays.asList(data.split(<span class="string">&quot;,&quot;</span>)));</span><br><span class="line">    <span class="keyword">return</span> helper(queue);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">TreeNode <span class="title">helper</span><span class="params">(Queue&lt;String&gt; q)</span></span>&#123;</span><br><span class="line">    String s = q.poll();</span><br><span class="line">    <span class="keyword">if</span>(s.equals(<span class="string">&quot;null&quot;</span>)) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    TreeNode root = <span class="keyword">new</span> TreeNode(Integer.valueOf(s));</span><br><span class="line">    root.left = helper(q);</span><br><span class="line">    root.right = helper(q);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>199. Binary Tree Right Side View</summary>
<blockquote>
<p>Use helper function, check if the level equals to the size of the list<br>
This way makes sure that only the rightest node will be added to the list<br>
Call right child, then left child</p>
</blockquote>
<p>Run time: $O(n)$, space: $O(n)$</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">rightSideView</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    helper(root, ans, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">helper</span><span class="params">(TreeNode root, List&lt;Integer&gt; ans, <span class="keyword">int</span> level)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(level == ans.size()) ans.add(root.val);</span><br><span class="line">    helper(root.right, ans, level+<span class="number">1</span>);</span><br><span class="line">    helper(root.left, ans, level+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<h3 id="Binary-Search">Binary Search</h3>
<details>
<summary></summary>
<blockquote></blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>1201. Ugly Number III</summary>
<blockquote>
<p>Calculate how many numbers from 1 to num are divisible by either a, b or c by using the formula:<br>
$(num / a) + (num / b) + (num / c) – (num / lcm(a, b)) – (num / lcm(b, c)) – (num / lcm(a, c)) + (num / lcm(a, b, c))$</p>
</blockquote>
<p>Run time: $O(n \log n)$, space: $O(1)$</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">gcd</span><span class="params">(<span class="keyword">long</span> a, <span class="keyword">long</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a == <span class="number">0</span>) <span class="keyword">return</span> b;</span><br><span class="line">    <span class="keyword">return</span> gcd(b % a, a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">lcm</span><span class="params">(<span class="keyword">long</span> a, <span class="keyword">long</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (a * b) / gcd(a, b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">count</span><span class="params">(<span class="keyword">long</span> a, <span class="keyword">long</span> b, <span class="keyword">long</span> c, <span class="keyword">long</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">int</span>) ((num / a) + (num / b) + (num / c)</span><br><span class="line">            - (num / lcm(a, b))</span><br><span class="line">            - (num / lcm(b, c))</span><br><span class="line">            - (num / lcm(a, c))</span><br><span class="line">            + (num / lcm(a, lcm(b, c)))); <span class="comment">// lcm(a,b,c) = lcm(a,lcm(b,c))</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">nthUglyNumber</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> low = <span class="number">1</span>, high = Integer.MAX_VALUE, mid;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (low &lt; high) &#123;</span><br><span class="line">        mid = low + (high - low) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (count((a), b, c, mid) &lt; n) low = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> high = mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> high;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>Chocolate Sweetness (G)</summary>
<blockquote>
<p>Relevant post: <a href="https://leetcode.com/discuss/interview-question/350800/Google-or-Onsite-or-Chocolate-Sweetness">link</a></p>
</blockquote>
<p>Run time: $O(n \log (sum - min))$, space: $O(1)$</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">splitArray</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> low = <span class="number">0</span>, high = Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = low + (high - low) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (canSplit(nums, m, mid)) &#123;</span><br><span class="line">            low = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            high = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> high;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// for a certian min sum requirement, check whether this can split into m groups</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">canSplit</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> m, <span class="keyword">int</span> minSum)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">long</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        sum += nums[i];</span><br><span class="line">        <span class="keyword">if</span> (sum &gt;= minSum) &#123;</span><br><span class="line">            sum = <span class="number">0</span>;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count &gt;= m;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>Find Median in Large Integer File of Integers (Airbnb)</summary>
<blockquote>
<p>Relevant link: <a href="https://github.com/allaboutjst/airbnb/blob/master/src/main/java/find_median_in_large_file_of_integers/FindMedianinLargeIntegerFileofIntegers.java">GitHub repo</a></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// if length is even, return the larger element in array</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String []args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">7</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">22</span>,<span class="number">1</span>&#125;;</span><br><span class="line">       System.out.println(findMedian(arr));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">findMedian</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> helper(arr, Integer.MIN_VALUE, Integer.MAX_VALUE);</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">helper</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> loBound, <span class="keyword">int</span> hiBound)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (loBound &gt;= hiBound) <span class="keyword">return</span> loBound;</span><br><span class="line">      </span><br><span class="line">       <span class="keyword">int</span> mid = (loBound + hiBound) / <span class="number">2</span>;</span><br><span class="line">       <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">int</span> smallerCount = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> a : arr) &#123;</span><br><span class="line">           <span class="keyword">if</span>(a &lt; mid) smallerCount++;</span><br><span class="line">           <span class="keyword">if</span> (a &lt;= mid) count++;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (smallerCount &lt;= arr.length/<span class="number">2</span> &amp;&amp; count &gt;= arr.length/<span class="number">2</span>) <span class="keyword">return</span> mid;</span><br><span class="line">       <span class="keyword">else</span> <span class="keyword">if</span> (count &lt; arr.length/<span class="number">2</span>) <span class="keyword">return</span> helper(arr, mid+<span class="number">1</span>, hiBound);</span><br><span class="line">       <span class="keyword">return</span> helper(arr, loBound, mid);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>1011. Capacity To Ship Packages Within D Days (G)</summary>
<blockquote>
<p>One iteration to find total sum (hi) and maximum package(lo)<br>
While lo is less than hi, find mid and see if the mid capacity could finish. If it is, assign mid to hi, otherwise assign mid+1 to lo.<br>
Helper function basically check if the current capacity would work or not. Use a sum to keep track of the current capacity at day “cnt”.</p>
</blockquote>
<p>Run time: $O(\log m)$, space: $O(1)$, where $m$ is total weight-max weight</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">shipWithinDays</span><span class="params">(<span class="keyword">int</span>[] weights, <span class="keyword">int</span> D)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; weights.length; i++) &#123;</span><br><span class="line">        sum += weights[i];</span><br><span class="line">        max = Math.max(max, weights[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> lo = max, hi = sum;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (lo &lt; hi) &#123;</span><br><span class="line">        <span class="keyword">int</span> m = lo + (hi - lo) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (satisfy(weights, m, D)) &#123;</span><br><span class="line">            hi = m;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            lo = m + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> lo;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">satisfy</span><span class="params">(<span class="keyword">int</span>[] weights, <span class="keyword">int</span> cap, <span class="keyword">int</span> D)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; weights.length; i++) &#123;</span><br><span class="line">        sum += weights[i];</span><br><span class="line">        <span class="keyword">if</span> (sum &gt; cap) &#123;</span><br><span class="line">            sum = weights[i];</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt &lt;= D;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Brute force: Check from capacity 1, if not work then increment by 1</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">shipWithinDays</span><span class="params">(<span class="keyword">int</span>[] weights, <span class="keyword">int</span> D)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cap = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">boolean</span> shipAll = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">while</span>(!shipAll)&#123;</span><br><span class="line">        <span class="keyword">int</span> day = <span class="number">0</span>, i = <span class="number">0</span>, curCap = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(day &lt; D &amp;&amp; i &lt; weights.length)&#123;</span><br><span class="line">            <span class="keyword">int</span> cur = weights[i];</span><br><span class="line">            <span class="keyword">if</span>(curCap+cur &lt;= cap) curCap += cur;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (cur &lt;= cap)&#123;</span><br><span class="line">                curCap = cur;</span><br><span class="line">                day++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                cap++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// System.out.println(cap+&quot; day:&quot;+day+&quot; &quot;+curCap);</span></span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(day &gt;= D) cap++;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(i == weights.length)&#123;</span><br><span class="line">            <span class="keyword">if</span>(day &lt;= D) shipAll = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">else</span> cap++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>Airbnb OA - Halloween Candy</summary>
<blockquote></blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getMinDandies</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> hours)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> r = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> n : nums)</span><br><span class="line">		r = Math.max(r, n);</span><br><span class="line">	<span class="keyword">int</span> l = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(l &lt; r) &#123;</span><br><span class="line">		<span class="keyword">int</span> m = l + (r - l)/<span class="number">2</span>;</span><br><span class="line">		<span class="keyword">if</span>(canFinish(nums, hours, m)) &#123;</span><br><span class="line">			r = m;</span><br><span class="line">		&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">			l = m+<span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">canFinish</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> hours, <span class="keyword">int</span> m)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> n : nums) &#123;</span><br><span class="line">		res += n/m;</span><br><span class="line">		<span class="keyword">if</span>(n%m &gt; <span class="number">0</span>) res++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res &lt;= hours;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>153. Find Minimum in Rotated Sorted Array (M)</summary>
<blockquote>
<p>Trick: check <code>left &lt; right-1</code> in the while loop<br>
if a[mid] &gt; a[right], go right; if a[mid] &lt; a[right], go left.</p>
</blockquote>
<p>Run time: $O(\log n)$, space: $O(1)$</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMin</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">return</span> Integer.MIN_VALUE;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.length-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right-<span class="number">1</span>) &#123;  <span class="comment">// while (left &lt; right-1) is a useful technique</span></span><br><span class="line">        <span class="keyword">int</span> mid = left + (right-left)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &gt; nums[right]) left = mid;</span><br><span class="line">        <span class="keyword">else</span> right = mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (nums[left] &gt; nums[right]) <span class="keyword">return</span> nums[right];</span><br><span class="line">    <span class="keyword">return</span> nums[left];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>278. First Bad Version</summary>
<blockquote>
<p>Binary search on the number of version from <code>1</code> to <code>n</code>, return <code>hi</code> index</p>
</blockquote>
<p>Run time: $O(\log n)$, space: $O(1)$</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">firstBadVersion</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> helper(<span class="number">1</span>, n);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">helper</span><span class="params">(<span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(lo &lt; hi)&#123;</span><br><span class="line">        <span class="keyword">int</span> md = lo+(hi-lo)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(isBadVersion(md)) hi = md;</span><br><span class="line">        <span class="keyword">else</span> lo = md + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> hi;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>34. Find First and Last Position of Element in Sorted Array (FB FT, failed in 2019)</summary>
<blockquote>
<p>Use <strong>binary search</strong> with a helper function<br>
It first compares the end points and immediately returns [lo, hi] if that whole part of nums is full of target, and immediately returns [-1, -1] if target is outside the range. The interesting case is when target can be in the range but doesn’t fill it completely.</p>
</blockquote>
<p>Run time: $O(\log n)$, space: $O(1)$</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] searchRange(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">	<span class="keyword">if</span>(nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;-<span class="number">1</span>,-<span class="number">1</span>&#125;;</span><br><span class="line">	<span class="keyword">return</span> helper(nums, target, <span class="number">0</span>, nums.length-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span>[] helper(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi) &#123;</span><br><span class="line">	<span class="keyword">if</span>(nums[lo] == target &amp;&amp; nums[hi] == target) <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;-<span class="number">1</span>,-<span class="number">1</span>&#125;;</span><br><span class="line">	<span class="keyword">if</span>(nums[lo] &lt;= target &amp;&amp; nums[hi] &gt;= target)&#123;</span><br><span class="line">		<span class="keyword">int</span> mid = lo + (lo+hi)/<span class="number">2</span>;</span><br><span class="line">		<span class="keyword">int</span>[] left = helper(nums, target, lo, mid);</span><br><span class="line">		<span class="keyword">int</span>[] right = helper(nums, target, mid+<span class="number">1</span>, hi);</span><br><span class="line">		<span class="keyword">if</span>(left[<span class="number">0</span>] == -<span class="number">1</span>) <span class="keyword">return</span> right;</span><br><span class="line">		<span class="keyword">if</span>(right[<span class="number">0</span>] == -<span class="number">1</span>) <span class="keyword">return</span> left;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;left[<span class="number">0</span>], right[<span class="number">1</span>]&#125;;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;-<span class="number">1</span>,-<span class="number">1</span>&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>315. Count of Smaller Numbers After Self (G)</summary>
<blockquote>
<p>Binary Indexed Tree<br>
Run time: $O()$, space: $O(n)$</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">BIT</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] bit;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BIT</span><span class="params">(<span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">        bit = <span class="keyword">new</span> <span class="keyword">int</span>[size + <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">increase</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> diff)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; bit.length) &#123;</span><br><span class="line">            ++bit[i];</span><br><span class="line">            i += (i &amp; -i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            count += bit[i];</span><br><span class="line">            i -= (i &amp; -i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">countSmaller</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; list = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">return</span> list;</span><br><span class="line">    <span class="keyword">int</span> n = nums.length;</span><br><span class="line">    <span class="keyword">int</span> max = Integer.MIN_VALUE, min = Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i : nums) &#123;</span><br><span class="line">        max = Math.max(max, i);</span><br><span class="line">        min = Math.min(min, i);</span><br><span class="line">    &#125;</span><br><span class="line">    BIT bit = <span class="keyword">new</span> BIT(max - min + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">        list.add(<span class="number">0</span>, bit.query(nums[i] - min));</span><br><span class="line">        bit.increase(nums[i] - min + <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>One efficient way: binary search only<br>
Build a ordered list and perform binary search on it, return the left index<br>
Run time: $O(n^2)$ (worst case), space: $O(n)$</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">countSmaller</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    LinkedList&lt;Integer&gt; res = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = nums.length-<span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">        res.addFirst(search(<span class="number">0</span>, list.size()-<span class="number">1</span>, list, nums[i]));</span><br><span class="line">        insert(list, nums[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, List&lt;Integer&gt; list, <span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l &gt; r) <span class="keyword">return</span> l;</span><br><span class="line">    <span class="keyword">int</span> m = (l+r)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(list.get(m) &lt; target) <span class="keyword">return</span> search(m+<span class="number">1</span>, r, list, target);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> search(l, m-<span class="number">1</span>, list, target);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(List&lt;Integer&gt; list, <span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> id = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(id &lt; list.size() &amp;&amp; list.get(id) &lt; num) id++;</span><br><span class="line">    list.add(id, num);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Slowest &amp; brute force way: directly count<br>
Run time: $O(n^2)$, space: $O(n)$</p>
</blockquote>
</details>
<details>
<summary>4. Median of Two Sorted Arrays</summary>
<blockquote>
<p>Find the average of two medians, no need to consider whether the sum of length is odd or not<br>
If out of range, then return the other one<br>
if size is one, return the smaller one<br>
Update the median by updating index+k/2-1<br>
Run time: $O(\log(m+n))$, space: $O(1)$</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = nums1.length, n = nums2.length;</span><br><span class="line">    <span class="keyword">int</span> l = (m + n + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> r = (m + n + <span class="number">2</span>) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> (getkth(nums1, <span class="number">0</span>, nums2, <span class="number">0</span>, l) + getkth(nums1, <span class="number">0</span>, nums2, <span class="number">0</span>, r)) / <span class="number">2.0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getkth</span><span class="params">(<span class="keyword">int</span>[] A, <span class="keyword">int</span> aStart, <span class="keyword">int</span>[] B, <span class="keyword">int</span> bStart, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (aStart &gt; A.length - <span class="number">1</span>) <span class="keyword">return</span> B[bStart + k - <span class="number">1</span>];            </span><br><span class="line">    <span class="keyword">if</span> (bStart &gt; B.length - <span class="number">1</span>) <span class="keyword">return</span> A[aStart + k - <span class="number">1</span>];                </span><br><span class="line">    <span class="keyword">if</span> (k == <span class="number">1</span>) <span class="keyword">return</span> Math.min(A[aStart], B[bStart]); <span class="comment">// size one for each array</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> aMid = Integer.MAX_VALUE, bMid = Integer.MAX_VALUE; <span class="comment">// new median</span></span><br><span class="line">    <span class="keyword">if</span> (aStart + k/<span class="number">2</span> - <span class="number">1</span> &lt; A.length) aMid = A[aStart + k/<span class="number">2</span> - <span class="number">1</span>]; </span><br><span class="line">    <span class="keyword">if</span> (bStart + k/<span class="number">2</span> - <span class="number">1</span> &lt; B.length) bMid = B[bStart + k/<span class="number">2</span> - <span class="number">1</span>];        </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (aMid &lt; bMid) </span><br><span class="line">        <span class="keyword">return</span> getkth(A, aStart + k/<span class="number">2</span>, B, bStart,       k - k/<span class="number">2</span>); <span class="comment">// Check: aRight + bLeft </span></span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        <span class="keyword">return</span> getkth(A, aStart,       B, bStart + k/<span class="number">2</span>, k - k/<span class="number">2</span>); <span class="comment">// Check: bRight + aLeft</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<h3 id="Topological-Sort">Topological Sort</h3>
<details>
<summary></summary>
<blockquote></blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>210. Course Schedule II (M)</summary>
<blockquote>
<p>Use an array to count the number of courses that need this class as a prerequisite<br>
Use an array of list to store the exact courses that need this class as a prerequisite<br>
Then use a queue to get the current course that does not need any prerequisite, update the other courses and push to the queue</p>
</blockquote>
<p>Run time: $O(n)$, space: $O(n)$</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] findOrder(<span class="keyword">int</span> numCourses, <span class="keyword">int</span>[][] prerequisites) &#123;</span><br><span class="line">    <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[numCourses];</span><br><span class="line">    <span class="keyword">int</span>[] numPreq = <span class="keyword">new</span> <span class="keyword">int</span>[numCourses];</span><br><span class="line">    ArrayList&lt;Integer&gt;[] graph = <span class="keyword">new</span> ArrayList[numCourses];</span><br><span class="line">    Queue&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span> ptr = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCourses; i++) graph[i] = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span>[] pre: prerequisites)&#123;</span><br><span class="line">        graph[pre[<span class="number">1</span>]].add(pre[<span class="number">0</span>]);</span><br><span class="line">        numPreq[pre[<span class="number">0</span>]]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCourses; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(numPreq[i] == <span class="number">0</span>) queue.add(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">        <span class="keyword">int</span> cur = queue.poll();</span><br><span class="line">        result[ptr++] = cur;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> rest: graph[cur])&#123;</span><br><span class="line">            numPreq[rest]--;</span><br><span class="line">            <span class="keyword">if</span>(numPreq[rest] == <span class="number">0</span>) queue.add(rest);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(ptr != numCourses) <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>269. Alien Dictionary</summary>
<blockquote>
<ol>
<li>Get all characters used in the dictionary, which will be nodes. But this dictionary will also be used in the traverse.</li>
</ol>
</blockquote>
<ol start="2">
<li>Extract edges from the input. Just find the same prefix and use the first different character.</li>
<li>Perform Topological sort.</li>
</ol>
<p>Run time: $O(n)$, space: $O(n)$</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">alienOrder</span><span class="params">(String[] words)</span> </span>&#123;</span><br><span class="line">	Map&lt;Character, Set&lt;Character&gt;&gt; graph = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">	<span class="keyword">int</span>[] degree = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">	</span><br><span class="line">	buildGraph(word, graph, degree);</span><br><span class="line">	</span><br><span class="line">	String order = topologicalSort(graph, degree);</span><br><span class="line">        	<span class="keyword">return</span> order.length() == graph.size() ? order : <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildGraph</span><span class="params">(String[] word, Map&lt;Character, Set&lt;Character&gt;&gt; graph, <span class="keyword">int</span>[] degree)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (String word : words) &#123; <span class="comment">// put every showed alphabet into the graph</span></span><br><span class="line">         	<span class="keyword">for</span> (<span class="keyword">char</span> c : word.toCharArray()) graph.put(c, <span class="keyword">new</span> HashSet&lt;&gt;());</span><br><span class="line">        &#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; words.length; i++) &#123;</span><br><span class="line">            	String first = words[i - <span class="number">1</span>]; <span class="comment">// previous word</span></span><br><span class="line">            	String second = words[i]; <span class="comment">// current word</span></span><br><span class="line">            	<span class="keyword">int</span> length = Math.min(first.length(), second.length());</span><br><span class="line">            </span><br><span class="line">            	<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; length; j++) &#123;</span><br><span class="line">                		 <span class="keyword">char</span> parent = first.charAt(j);</span><br><span class="line">                		 <span class="keyword">char</span> child = second.charAt(j);</span><br><span class="line">                		<span class="keyword">if</span> (parent != child) &#123;</span><br><span class="line">                    		<span class="keyword">if</span> (!graph.get(parent).contains(child)) &#123; <span class="comment">// add child to the parent set</span></span><br><span class="line">                        			graph.get(parent).add(child);</span><br><span class="line">                        			inDegree[child - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">                    		&#125;</span><br><span class="line">                    		<span class="keyword">break</span>;</span><br><span class="line">               		 &#125;</span><br><span class="line">            	&#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> String <span class="title">topologicalSort</span><span class="params">(Map&lt;Character, Set&lt;Character&gt;&gt; graph, <span class="keyword">int</span>[] inDegree)</span> </span>&#123;</span><br><span class="line">        Queue&lt;Character&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : graph.keySet()) &#123;</span><br><span class="line">            	<span class="keyword">if</span> (inDegree[c - <span class="string">&#x27;a&#x27;</span>] == <span class="number">0</span>) queue.offer(c);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        	StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        	<span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            	<span class="keyword">char</span> c = queue.poll();</span><br><span class="line">            	sb.append(c);</span><br><span class="line">            	<span class="keyword">for</span> (<span class="keyword">char</span> neighbor : graph.get(c)) &#123;</span><br><span class="line">                		inDegree[neighbor - <span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">                		<span class="keyword">if</span> (inDegree[neighbor - <span class="string">&#x27;a&#x27;</span>] == <span class="number">0</span>) &#123;</span><br><span class="line">                    		queue.offer(neighbor);</span><br><span class="line">                		&#125;</span><br><span class="line">            	&#125;</span><br><span class="line">        	&#125;</span><br><span class="line">        	<span class="keyword">return</span> sb.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<h2 id="Recursion">Recursion</h2>
<hr>
<details>
<summary></summary>
<blockquote></blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>206. Reverse Linked List (M)</summary>
<blockquote>
<p>Recursive</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> reverseListInt(head, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> ListNode <span class="title">reverseListInt</span><span class="params">(ListNode head, ListNode newHead)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>) <span class="keyword">return</span> newHead;</span><br><span class="line">    ListNode next = head.next;</span><br><span class="line">    head.next = newHead;</span><br><span class="line">    <span class="keyword">return</span> reverseListInt(next, head);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Iterative</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    ListNode newHead = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">while</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ListNode next = head.next;</span><br><span class="line">        head.next = newHead;</span><br><span class="line">        newHead = head;</span><br><span class="line">        head = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newHead;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>236. Lowest Common Ancestor of a Binary Tree</summary>
<blockquote>
<p>If the root is null, or it equals either p or q, we should return it, since that satisfies LCA<br>
Get the left LCA and right LCA, if either of them is null, which means the two nodes are on one side of the (sub)tree. Otherwise, we should just return the root.</p>
</blockquote>
<p>Run time: $O(n)$, space: $O(1)$</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span> || root == p || root == q) <span class="keyword">return</span> root;</span><br><span class="line">    TreeNode left = lowestCommonAncestor(root.left, p, q);</span><br><span class="line">    TreeNode right = lowestCommonAncestor(root.right, p, q);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(left == <span class="keyword">null</span>) <span class="keyword">return</span> right;</span><br><span class="line">    <span class="keyword">if</span>(right == <span class="keyword">null</span>) <span class="keyword">return</span> left;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>112. Path Sum (M)</summary>
<blockquote>
<p>If node is null, return false<br>
If current node is leaf (no left/right child), check if the value equals to the remaining sum<br>
Return the left path or the right path that may contain the sum</p>
</blockquote>
<p>Run time: $O(n)$, space: $O(1)$</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasPathSum</span><span class="params">(TreeNode root, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>) <span class="keyword">return</span> sum == root.val;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> hasPathSum(root.left, sum - root.val) || hasPathSum(root.right, sum - root.val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>104. Maximum Depth of Binary Tree</summary>
<blockquote>
<p>Call the function recursively</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> Math.max(maxDepth(root.left), maxDepth(root.right))+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>235. Lowest Common Ancestor of a Binary Search Tree</summary>
<blockquote>
<p>Recursive way</p>
</blockquote>
<p>Run time: $O(n)$, space: $O(1)$</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span>(root == p || root == q) <span class="keyword">return</span> root;</span><br><span class="line">    <span class="keyword">if</span>((root.val &gt; p.val &amp;&amp; root.val &lt; q.val) ||</span><br><span class="line">       (root.val &gt; q.val &amp;&amp; root.val &lt; p.val)) <span class="keyword">return</span> root;</span><br><span class="line">    <span class="keyword">if</span>(root.val &gt; p.val &amp;&amp; root.val &gt; q.val) <span class="keyword">return</span> lowestCommonAncestor(root.left, p, q);</span><br><span class="line">    <span class="keyword">return</span> lowestCommonAncestor(root.right, p, q);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Iterative way</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(root != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(root.val &gt; p.val &amp;&amp; root.val &gt; q.val)</span><br><span class="line">            root = root.left;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ( root.val &lt; p.val &amp;&amp; root.val &lt; q.val)</span><br><span class="line">            root = root.right;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>101. Symmetric Tree (M)</summary>
<blockquote>
<p>Recursive way</p>
</blockquote>
<p>Run time: $O(n)$, space: $O(1)$</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSymmetric</span><span class="params">(TreeNode root)</span> </span>&#123; <span class="comment">// recursive</span></span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">return</span> isMirror(root.left,root.right);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isMirror</span><span class="params">(TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p==<span class="keyword">null</span> &amp;&amp; q==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(p==<span class="keyword">null</span> || q==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">return</span> (p.val == q.val) &amp;&amp; isMirror(p.left,q.right) &amp;&amp; isMirror(p.right,q.left);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Iterative way</p>
</blockquote>
<p>Run time: $O(n)$, space: $O(n)$</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSymmetric</span><span class="params">(TreeNode root)</span> </span>&#123; <span class="comment">// iterative</span></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    stack.push(root.left);</span><br><span class="line">    stack.push(root.right);</span><br><span class="line">    <span class="keyword">while</span> (!stack.empty()) &#123;</span><br><span class="line">        TreeNode n1 = stack.pop(), n2 = stack.pop();</span><br><span class="line">        <span class="keyword">if</span> (n1 == <span class="keyword">null</span> &amp;&amp; n2 == <span class="keyword">null</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (n1 == <span class="keyword">null</span> || n2 == <span class="keyword">null</span> || n1.val != n2.val) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        stack.push(n1.left);</span><br><span class="line">        stack.push(n2.right);</span><br><span class="line">        stack.push(n1.right);</span><br><span class="line">        stack.push(n2.left);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>124. Binary Tree Maximum Path Sum</summary>
<blockquote>
<p>Helper method finds the left max and right max, then update the total max, and return the sum of root value with either left or right sum<br>
Notice: The reference variable int[] is in MA, the address is copied (and passed as value), and the initial variable will be changed.</p>
</blockquote>
<p>Run time: $O(n)$, space: $O(1)$</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxPathSum</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] max = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">1</span>];</span><br><span class="line">    max[<span class="number">0</span>] = Integer.MIN_VALUE;</span><br><span class="line">    maxPathSum(max, root);</span><br><span class="line">    <span class="keyword">return</span> max[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">maxPathSum</span><span class="params">(<span class="keyword">int</span>[] max, TreeNode root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> leftMax =  Math.max(<span class="number">0</span>, maxPathSum(max, root.left));</span><br><span class="line">    <span class="keyword">int</span> rightMax = Math.max(<span class="number">0</span>, maxPathSum(max, root.right));</span><br><span class="line">    max[<span class="number">0</span>] = Math.max(max[<span class="number">0</span>],  root.val+leftMax+rightMax);</span><br><span class="line">    <span class="keyword">return</span> root.val+Math.max(leftMax,rightMax);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>394. Decode String</summary>
<blockquote>
<p>Recursion: if meet a number, update count c = 10*c +c-‘0’<br>
If meet a open bracket, use two variable to count num of open and close brackets in a while loop, until index reaches the end or the brackets is balance<br>
Call recursion! Append the result<br>
Other cases, just append the char</p>
</blockquote>
<p>Run time: $O(n)$, space: $O(1)$</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">decodeString</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;s.length();i++) &#123;</span><br><span class="line">        <span class="keyword">char</span> c = s.charAt(i);</span><br><span class="line">        <span class="keyword">if</span> (c &lt;= <span class="string">&#x27;9&#x27;</span> &amp;&amp; c &gt;= <span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;prev: &quot;</span>+count);</span><br><span class="line">            count = count * <span class="number">10</span> + c -<span class="string">&#x27;0&#x27;</span>; <span class="comment">// the number can be more than one digit!</span></span><br><span class="line">            System.out.println(count);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;[&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> j = i+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> open = <span class="number">1</span>, close = <span class="number">0</span>;</span><br><span class="line">            i++;</span><br><span class="line">            <span class="keyword">while</span> (i &lt; s.length() &amp;&amp; open != close) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s.charAt(i) == <span class="string">&#x27;[&#x27;</span>) open++;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (s.charAt(i) == <span class="string">&#x27;]&#x27;</span>) close++;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            String sub = decodeString(s.substring(j,--i));</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> f = <span class="number">0</span>; f &lt; count;f++) &#123;</span><br><span class="line">                sb.append(sub);</span><br><span class="line">            &#125;</span><br><span class="line">            count = <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            sb.append(c);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> sb.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Usual way: use a stack to keep all chars, once meet a close bracket, pop chars from stack until see a open bracket and number</p>
</blockquote>
</details>
<details>
<summary>247. Strobogrammatic Number II</summary>
<blockquote>
<p>Recursion; start from length 0 and 1, then add pairs to the left and right of the current number<br>
Run time: $O(n!)$, space: $O(n!)$</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">findStrobogrammatic</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> helper(n, n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">helper</span><span class="params">(<span class="keyword">int</span> targetLen, <span class="keyword">int</span> totalLen)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (targetLen == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ArrayList(Arrays.asList(<span class="string">&quot;&quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (targetLen == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ArrayList(Arrays.asList(<span class="string">&quot;1&quot;</span>, <span class="string">&quot;8&quot;</span>, <span class="string">&quot;0&quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;String&gt; sub = helper(targetLen - <span class="number">2</span>, totalLen); <span class="comment">// start from center</span></span><br><span class="line">        List&lt;String&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String str : sub) &#123;</span><br><span class="line">            <span class="keyword">if</span> (targetLen != totalLen) &#123; <span class="comment">// avoid last round adding 0</span></span><br><span class="line">                result.add(<span class="string">&quot;0&quot;</span> + str + <span class="string">&quot;0&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            result.add(<span class="string">&quot;1&quot;</span> + str + <span class="string">&quot;1&quot;</span>);</span><br><span class="line">            result.add(<span class="string">&quot;6&quot;</span> + str + <span class="string">&quot;9&quot;</span>);</span><br><span class="line">            result.add(<span class="string">&quot;9&quot;</span> + str + <span class="string">&quot;6&quot;</span>);</span><br><span class="line">            result.add(<span class="string">&quot;8&quot;</span> + str + <span class="string">&quot;8&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Iterative: check if length is even or odd<br>
Run time: $O(n!)$, space: $O(n!)$</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public List&lt;String&gt; findStrobogrammatic(int n) &#123;</span><br><span class="line">        List&lt;String&gt; result &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">        if (n % 2 &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            result.add(&quot;&quot;); &#x2F;&#x2F; middle element</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            result.add(&quot;1&quot;);</span><br><span class="line">            result.add(&quot;8&quot;);</span><br><span class="line">            result.add(&quot;0&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        while (n &gt;&#x3D; 2) &#123;</span><br><span class="line">            List&lt;String&gt; tmp &#x3D; result; &#x2F;&#x2F; use current list to build new ones</span><br><span class="line">            result &#x3D; new ArrayList&lt;String&gt;();</span><br><span class="line">            for (String str : tmp) &#123;</span><br><span class="line">                if (n &gt; 3) &#123; &#x2F;&#x2F; have to add outer number after adding 0</span><br><span class="line">                    result.add(&quot;0&quot; + str + &quot;0&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">                result.add(&quot;1&quot; + str + &quot;1&quot;);</span><br><span class="line">                result.add(&quot;8&quot; + str + &quot;8&quot;);</span><br><span class="line">                result.add(&quot;6&quot; + str + &quot;9&quot;);</span><br><span class="line">                result.add(&quot;9&quot; + str + &quot;6&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            n -&#x3D; 2;</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>222. Count Complete Tree Nodes</summary>
<p>First way: recursive, $O(n)$</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countNodes</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">1</span> + countNodes(root.left) + countNodes(root.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Second way: $O((log(n))^2) $</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countNodes</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> leftHeight = leftHeight(root);</span><br><span class="line">    <span class="keyword">int</span> rightHeight = rightHeight(root);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * case 1: When Height(Left sub-tree) = Height(right sub-tree)</span></span><br><span class="line"><span class="comment">     * 2^h - 1</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (leftHeight == rightHeight) <span class="keyword">return</span> (<span class="number">1</span> &lt;&lt; leftHeight) - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">1</span> + countNodes(root.left) + countNodes(root.right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">leftHeight</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> + leftHeight(root.left);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">rightHeight</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> + rightHeight(root.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<h3 id="Permutation">Permutation</h3>
<details>
<summary></summary>
<blockquote></blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>31. Next Permutation</summary>
<blockquote>
<p><code>i</code> records the starting index that breaks descending, -1 if the whole array is descending<br>
<code>i</code> starts from the second to last index. After while loop, if i is non-negative, find the rightmost first larger id <code>j</code>, and swap <code>i</code> and <code>j</code><br>
Reverse the array from index <code>i+1</code> to the last index</p>
</blockquote>
<p>Run time: $O(n)$, space: $O(1)$</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">nextPermutation</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums == <span class="keyword">null</span> || nums.length &lt;= <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> i = nums.length - <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &gt;= <span class="number">0</span> &amp;&amp; nums[i] &gt;= nums[i + <span class="number">1</span>]) i--; <span class="comment">// Find 1st id i that breaks descending order</span></span><br><span class="line">    <span class="keyword">if</span>(i &gt;= <span class="number">0</span>) &#123;                           <span class="comment">// If not entirely descending</span></span><br><span class="line">        <span class="keyword">int</span> j = nums.length - <span class="number">1</span>;              <span class="comment">// Start from the end</span></span><br><span class="line">        <span class="keyword">while</span>(nums[j] &lt;= nums[i]) j--;           <span class="comment">// Find rightmost first larger id j</span></span><br><span class="line">        swap(nums, i, j);                     <span class="comment">// Switch i and j</span></span><br><span class="line">    &#125;</span><br><span class="line">    reverse(nums, i + <span class="number">1</span>, nums.length - <span class="number">1</span>);       <span class="comment">// Reverse the descending sequence</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] A, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp = A[i];</span><br><span class="line">    A[i] = A[j];</span><br><span class="line">    A[j] = tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span>[] A, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; j) swap(A, i++, j--);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>1220. Count Vowels Permutation</summary>
<blockquote>
<p>Keep track of the order of alphabets that could be added to the current string, since based on the rule one must be followed by some others, so we accumulate combinations that ends with a particular letter.</p>
</blockquote>
<p>Run time: $O(n)$, space: $O(1)$</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countVowelPermutation</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span>[][] moves = &#123; &#123;<span class="number">1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">2</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>&#125;, &#123;<span class="number">2</span>, <span class="number">4</span>&#125;, &#123; <span class="number">0</span> &#125; &#125;;</span><br><span class="line">  <span class="keyword">int</span>[] v = &#123; <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span> &#125;;</span><br><span class="line">  <span class="keyword">while</span> (--n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">int</span>[] v1 = &#123; <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j : moves[i])&#123;</span><br><span class="line">            v1[j] = (v1[j] + v[i]) % <span class="number">1000000007</span>;</span><br><span class="line">          <span class="comment">// System.out.println(j+&quot; &quot;+v1[j]);</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    v = v1;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> (<span class="keyword">int</span>)(((<span class="keyword">long</span>)v[<span class="number">0</span>] + v[<span class="number">1</span>] + v[<span class="number">2</span>] + v[<span class="number">3</span>] + v[<span class="number">4</span>]) % <span class="number">1000000007</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<h2 id="Maps">Maps</h2>
<hr>
<details>
<summary></summary>
<blockquote></blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>1124. Longest Well-Performing Interval</summary>
<blockquote>
<p>Use a map to put <code>&lt;num of balanced performing days ended at i, i&gt;</code>. If today is greater than 8, increment the <code>score</code> by 1, otherwise decrement it by 1.<br>
If the score is positive, which means there’s more tiring days, just update the answer since it should be the maximum now. Otherwise, put the pair <code>&lt;current score, i&gt;</code> into the map if this key does not exist yet. If the map contains the key <code>score-1</code>, which is the balanced days less the last not-tiring day, update the answer if <code>i-seen.get(score-1)</code> is greater.</p>
</blockquote>
<p>Run time: $O(n)$, space: $O(n)$</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestWPI</span><span class="params">(<span class="keyword">int</span>[] hours)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>, score = <span class="number">0</span>, n = hours.length;</span><br><span class="line">    Map&lt;Integer, Integer&gt; seen = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(hours[i] &gt; <span class="number">8</span>) score++;</span><br><span class="line">        <span class="keyword">else</span> score--;</span><br><span class="line">        <span class="keyword">if</span> (score &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            res = i + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            seen.putIfAbsent(score, i);</span><br><span class="line">            <span class="keyword">if</span> (seen.containsKey(score-<span class="number">1</span>))</span><br><span class="line">                res = Math.max(res, i - seen.get(score-<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>588. Design In-Memory File System (Nordstrom FT, failed in 2019)</summary>
<blockquote>
<p><a href="https://massivealgorithms.blogspot.com/2017/05/leetcode-588-design-in-memory-file.html">Relevant link with problem description</a><br>
Use TreeMap to contain children nodes - so they are sorted.</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">TreeNode</span>&gt; </span>&#123;</span><br><span class="line">    String label;</span><br><span class="line">    <span class="keyword">boolean</span> isDir;</span><br><span class="line">    Map&lt;String, TreeNode&gt; dirContents = <span class="keyword">new</span> TreeMap&lt;&gt;();</span><br><span class="line">    String fileContents;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(TreeNode other)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> label.compareTo(other.label);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.hash(label);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object treeNode)</span> </span>&#123;</span><br><span class="line">        TreeNode other = (TreeNode) treeNode;</span><br><span class="line">        <span class="keyword">return</span> Objects.equals(label, other.label);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;    </span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Tre     </span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">ls</span><span class="params">(String path)</span> </span>&#123;</span><br><span class="line">    String[] labels = path.split(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">    TreeNode curr = (labels.length != <span class="number">0</span>) ? sentinel : sentinel.dirContents.get(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    List&lt;String&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(String label : labels) &#123;</span><br><span class="line">        curr = curr.dirContents.get(label);</span><br><span class="line">        System.out.println(<span class="string">&quot;&gt;&gt;&quot;</span> + curr);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(curr.isDir) &#123;</span><br><span class="line">        <span class="keyword">for</span>(String label : curr.dirContents.keySet()) &#123;</span><br><span class="line">            result.add(label);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        result.add(curr.label);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">mkdir</span><span class="params">(String path)</span> </span>&#123;</span><br><span class="line">    String[] labels = path.split(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">    TreeNode curr = sentinel;</span><br><span class="line">    <span class="keyword">int</span> currIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(String label : labels) &#123;</span><br><span class="line">        TreeNode next = curr.dirContents.get(label);</span><br><span class="line">        <span class="keyword">if</span>(next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        currIndex++;</span><br><span class="line">        curr = next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = currIndex; i &lt; labels.length; i++) &#123;</span><br><span class="line">        TreeNode newDir = <span class="keyword">new</span> TreeNode();</span><br><span class="line">        newDir.isDir = <span class="keyword">true</span>;</span><br><span class="line">        newDir.label = labels[i];</span><br><span class="line">        curr.dirContents.put(labels[i], newDir);</span><br><span class="line">        </span><br><span class="line">        curr = newDir;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addContentToFile</span><span class="params">(String filePath, String content)</span> </span>&#123;</span><br><span class="line">    String[] labels = filePath.split(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">    TreeNode curr = sentinel, prev = <span class="keyword">null</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(String label : labels) &#123;</span><br><span class="line">        prev = curr;</span><br><span class="line">        <span class="keyword">if</span>(curr == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        curr = curr.dirContents.get(label);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(curr == <span class="keyword">null</span>) &#123;</span><br><span class="line">        curr = <span class="keyword">new</span> TreeNode();</span><br><span class="line">        curr.isDir = <span class="keyword">false</span>;</span><br><span class="line">        curr.label = labels[labels.length - <span class="number">1</span>];</span><br><span class="line">        curr.fileContents = content;</span><br><span class="line">        prev.dirContents.put(curr.label, curr);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        curr.fileContents = curr.fileContents == <span class="keyword">null</span> ? content : curr.fileContents + content;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">readContentFromFile</span><span class="params">(String filePath)</span> </span>&#123;</span><br><span class="line">    String[] labels = filePath.split(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">    TreeNode curr = sentinel;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(String label : labels) &#123;</span><br><span class="line">        curr = curr.dirContents.get(label);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (curr.fileContents == <span class="keyword">null</span>) ? <span class="string">&quot;&quot;</span> : curr.fileContents;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Second way: Create a File class and each of them has a map containing file name and File</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">File</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> isFile = <span class="keyword">false</span>;</span><br><span class="line">    Map&lt;String, File&gt; children = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    String content = <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">File root = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">FileSystem</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    root = <span class="keyword">new</span> File();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">ls</span><span class="params">(String path)</span> </span>&#123;</span><br><span class="line">    String[] dirs = path.split(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">    File node = root;</span><br><span class="line">    List&lt;String&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    String name = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (String dir : dirs) &#123;</span><br><span class="line">        <span class="keyword">if</span> (dir.length() == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (!node.children.containsKey(dir)) &#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        node = node.children.get(dir);</span><br><span class="line">        name = dir;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (node.isFile) &#123;</span><br><span class="line">        result.add(name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (String key : node.children.keySet()) &#123;</span><br><span class="line">            result.add(key);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    Collections.sort(result);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">mkdir</span><span class="params">(String path)</span> </span>&#123;</span><br><span class="line">    String[] dirs = path.split(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">    File node = root;</span><br><span class="line">    <span class="keyword">for</span> (String dir : dirs) &#123;</span><br><span class="line">        <span class="keyword">if</span> (dir.length() == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (!node.children.containsKey(dir)) &#123;</span><br><span class="line">            File file = <span class="keyword">new</span> File();</span><br><span class="line">            node.children.put(dir, file);</span><br><span class="line">        &#125;</span><br><span class="line">        node = node.children.get(dir);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addContentToFile</span><span class="params">(String filePath, String content)</span> </span>&#123;</span><br><span class="line">    String[] dirs = filePath.split(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">    File node = root;</span><br><span class="line">    <span class="keyword">for</span> (String dir : dirs) &#123;</span><br><span class="line">        <span class="keyword">if</span> (dir.length() == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (!node.children.containsKey(dir)) &#123;</span><br><span class="line">            File file = <span class="keyword">new</span> File();</span><br><span class="line">            node.children.put(dir, file);</span><br><span class="line">        &#125;</span><br><span class="line">        node = node.children.get(dir);</span><br><span class="line">    &#125;</span><br><span class="line">    node.isFile = <span class="keyword">true</span>;</span><br><span class="line">    node.content += content;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">readContentFromFile</span><span class="params">(String filePath)</span> </span>&#123;</span><br><span class="line">    String[] dirs = filePath.split(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">    File node = root;</span><br><span class="line">    <span class="keyword">for</span> (String dir : dirs) &#123;</span><br><span class="line">        <span class="keyword">if</span> (dir.length() == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (!node.children.containsKey(dir)) &#123;</span><br><span class="line">            File file = <span class="keyword">new</span> File();</span><br><span class="line">            node.children.put(dir, file);</span><br><span class="line">        &#125;</span><br><span class="line">        node = node.children.get(dir);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> node.content;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>535. Encode and Decode TinyURL (M)</summary>
<blockquote>
<p>Use a map to store the decoded url and the original url, then use another map to store the reversed pair for duplication check</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Codec</span> </span>&#123;</span><br><span class="line">    Map&lt;String, String&gt; index = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line">    Map&lt;String, String&gt; revIndex = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line">    <span class="keyword">static</span> String BASE_HOST = <span class="string">&quot;http://tinyurl.com/&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Encodes a URL to a shortened URL.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">encode</span><span class="params">(String longUrl)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (revIndex.containsKey(longUrl)) <span class="keyword">return</span> BASE_HOST + revIndex.get(longUrl);</span><br><span class="line">        String charSet = <span class="string">&quot;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789&quot;</span>;</span><br><span class="line">        String key = <span class="keyword">null</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">int</span> r = (<span class="keyword">int</span>) (Math.random() * charSet.length());</span><br><span class="line">                sb.append(charSet.charAt(r));</span><br><span class="line">            &#125;</span><br><span class="line">            key = sb.toString();</span><br><span class="line">        &#125; <span class="keyword">while</span> (index.containsKey(key));</span><br><span class="line">        index.put(key, longUrl);</span><br><span class="line">        revIndex.put(longUrl, key);</span><br><span class="line">        <span class="keyword">return</span> BASE_HOST + key;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Decodes a shortened URL to its original URL.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">decode</span><span class="params">(String shortUrl)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> index.get(shortUrl.replace(BASE_HOST, <span class="string">&quot;&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>1153. String Transforms Into Another String (G)</summary>
<blockquote>
<p>Use a map to store &lt;char from str1, char from str2&gt;, and a set to store char from str2<br>
For each index, put char from str2 into the set, and check if the corresponding map is consistent (return false if not), put the key-value pair if not exist<br>
After the loop, if two strings are not equal and both of them have used all 26 characters, which implies there is no potential transformation, return false</p>
</blockquote>
<p>Runtime: $O(n)$, space: $O(n)$</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canConvert</span><span class="params">(String str1, String str2)</span></span>&#123;</span><br><span class="line">    Set&lt;Character&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    Map&lt;Character, Character&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str1.length(); i++)&#123;</span><br><span class="line">        <span class="keyword">char</span> c1 = str1.charAt(i), c2 = str2.charAt(i);</span><br><span class="line">       set.add(c2);</span><br><span class="line">       <span class="keyword">if</span>(map.containsKey(c1) &amp;&amp; map.get(c1) != c2) </span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">       map.put(c1, c2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!str1.equals(str2) &amp;&amp; map.size() == <span class="number">26</span> &amp;&amp; set.size() == <span class="number">26</span>) </span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">false</span>; <span class="comment">// both of strs have used all characters</span></span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>676. Implement Magic Dictionary (G)</summary>
<blockquote>
<p>For each word in dictionary, remove the char and put the rest of the word as key (e.g. “<em>ello&quot;, &quot;h</em>llo”, “he<em>lo&quot;, &quot;hel</em>o”, “hell*”), the removed char as the value. If the modified string exists, set the value as 0.<br>
When we search a word, we try to remove different char and see if the map contains this key, and the removed char is different.</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MagicDictionary</span> </span>&#123;</span><br><span class="line">    Map&lt;String, Character&gt; map;</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MagicDictionary</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Build a dictionary through a list of words */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildDict</span><span class="params">(String[] dict)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(String s: dict)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++)&#123;</span><br><span class="line">                String temp = s.substring(<span class="number">0</span>, i)+<span class="string">&quot;*&quot;</span>+s.substring(i+<span class="number">1</span>);</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span>(!map.containsKey(temp)) map.put(temp, s.charAt(i));</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(map.get(temp) != s.charAt(i)) map.put(temp, <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Returns if there is any word in the trie that equals to the given word after modifying exactly one character */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">search</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; word.length(); i++) &#123;</span><br><span class="line">            String temp = word.substring(<span class="number">0</span>, i)+<span class="string">&quot;*&quot;</span>+word.substring(i+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(temp) &amp;&amp; map.get(temp) != word.charAt(i))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>911. Online Election (G)</summary>
<blockquote>
<p>Use TreeMap</p>
</blockquote>
<p>Time complexity for constructor TopVotedCandidate(int[] persons, int[] times) is O(nlogn), and for q(int t) is O(logn).</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TopVotedCandidate</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> TreeMap&lt;Integer, Integer&gt; tm = <span class="keyword">new</span> TreeMap&lt;&gt;(); <span class="comment">// time and leading candidate</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TopVotedCandidate</span><span class="params">(<span class="keyword">int</span>[] persons, <span class="keyword">int</span>[] times)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] count = <span class="keyword">new</span> <span class="keyword">int</span>[persons.length]; <span class="comment">// count[i]: count of votes for persons[i].</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, max = -<span class="number">1</span>; i &lt; times.length; ++i) &#123;</span><br><span class="line">            ++count[persons[i]]; <span class="comment">// at times[i], persons[i] got a vote.</span></span><br><span class="line">            <span class="keyword">if</span> (max &lt;= count[persons[i]]) &#123; <span class="comment">// is persons[i] leading?</span></span><br><span class="line">                max = count[persons[i]]; <span class="comment">// update leading count.</span></span><br><span class="line">                tm.put(times[i], persons[i]); <span class="comment">// update leading candidate.</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">q</span><span class="params">(<span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> tm.floorEntry(t).getValue(); <span class="comment">// fetch the corresponding information. </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Binary Search</p>
</blockquote>
<p>Runtime: Constructor $O(n)$, q(int t) is $O(logn)$</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TopVotedCandidate</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;(); <span class="comment">// time and leading candidate</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] times;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TopVotedCandidate</span><span class="params">(<span class="keyword">int</span>[] persons, <span class="keyword">int</span>[] times)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.times = times;</span><br><span class="line">        <span class="keyword">int</span>[] count = <span class="keyword">new</span> <span class="keyword">int</span>[persons.length + <span class="number">1</span>]; <span class="comment">// count[i]: count of votes for persons[i].</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, winner = -<span class="number">1</span>; i &lt; times.length; ++i) &#123;</span><br><span class="line">            ++count[persons[i]]; <span class="comment">// at times[i], persons[i] got a vote.</span></span><br><span class="line">            <span class="comment">// is persons[i] leading? update winner.</span></span><br><span class="line">            <span class="keyword">if</span> (map.isEmpty() || count[winner] &lt;= count[persons[i]]) &#123; winner = persons[i]; &#125; </span><br><span class="line">            map.put(times[i], winner); <span class="comment">// update time and winner.</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">q</span><span class="params">(<span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> idx = Arrays.binarySearch(times, t); <span class="comment">// search for the time slot.</span></span><br><span class="line">        <span class="keyword">return</span> map.get(times[idx &lt; <span class="number">0</span> ? -idx - <span class="number">2</span> : idx]); <span class="comment">// fetch the corresponding information.</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your TopVotedCandidate object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * TopVotedCandidate obj = new TopVotedCandidate(persons, times);</span></span><br><span class="line"><span class="comment"> * int param_1 = obj.q(t);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>1146. Snapshot Array (G)</summary>
<blockquote>
<p>Use a list of map to store different versions of snapshots.<br>
Use a map to store the index and value when method set is called.<br>
Add the map to list when snap is called, reset the map, and return the last index in list</p>
</blockquote>
<p>Run time: $O(n)$, space: $O(n)$</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SnapshotArray</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Map&lt;Integer, Integer&gt;&gt; shot;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;Integer, Integer&gt; diff;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SnapshotArray</span><span class="params">(<span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">        shot  = <span class="keyword">new</span> ArrayList&lt;&gt;(length);</span><br><span class="line">        diff  = <span class="keyword">new</span> HashMap&lt;&gt;(length);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        diff.put(index, val);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">snap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        shot.add(diff);</span><br><span class="line">        diff = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">return</span> shot.size() - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> snap_id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = snap_id; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">             <span class="keyword">if</span> (shot.get(i).containsKey(index))   </span><br><span class="line">                 <span class="keyword">return</span> shot.get(i).get(index); </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Use a map to store &lt;current id+index, corresponding value&gt;<br>
Each time only search the id+index and return the value if exist</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SnapshotArray</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> snapId = <span class="number">0</span>;</span><br><span class="line">    Map&lt;String, Integer&gt; map;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SnapshotArray</span><span class="params">(<span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">        map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        String cur = snapId + <span class="string">&quot;,&quot;</span> + index;</span><br><span class="line">        map.put(cur, val);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">snap</span><span class="params">()</span> </span>&#123;       </span><br><span class="line">        <span class="keyword">return</span> snapId++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> snap_id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (snap_id &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            String temp = snap_id-- + <span class="string">&quot;,&quot;</span> + index;</span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(temp)) &#123;</span><br><span class="line">                <span class="keyword">return</span> map.get(temp);</span><br><span class="line">            &#125; </span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>1244. Design A Leaderboard</summary>
<blockquote>
<p>1.Use HashMap to record the people’s score<br>
2.Use TreeMap to find the topK in O(klogn) by traverse the treemap<br>
3.Reset we can just remove the key from the treemap which is O(log n), same for addScore().</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Leaderboard</span> </span>&#123;</span><br><span class="line">    Map&lt;Integer, Integer&gt; map;</span><br><span class="line">    TreeMap&lt;Integer, Integer&gt; sorted;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Leaderboard</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        sorted = <span class="keyword">new</span> TreeMap&lt;&gt;(Collections.reverseOrder());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addScore</span><span class="params">(<span class="keyword">int</span> playerId, <span class="keyword">int</span> score)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!map.containsKey(playerId)) &#123;</span><br><span class="line">            map.put(playerId, score);</span><br><span class="line">            sorted.put(score, sorted.getOrDefault(score, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> preScore = map.get(playerId);</span><br><span class="line">            sorted.put(preScore, sorted.get(preScore) - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (sorted.get(preScore) == <span class="number">0</span>) &#123;</span><br><span class="line">                sorted.remove(preScore);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> newScore = preScore + score;</span><br><span class="line">            map.put(playerId, newScore);</span><br><span class="line">            sorted.put(newScore, sorted.getOrDefault(newScore, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">(<span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> key : sorted.keySet()) &#123;</span><br><span class="line">            <span class="keyword">int</span> times = sorted.get(key);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; times; i++) &#123;</span><br><span class="line">                sum += key;</span><br><span class="line">                count++;</span><br><span class="line">                <span class="keyword">if</span> (count == K) <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (count == K) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reset</span><span class="params">(<span class="keyword">int</span> playerId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> preScore = map.get(playerId);</span><br><span class="line">        sorted.put(preScore, sorted.get(preScore) - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (sorted.get(preScore) == <span class="number">0</span>) &#123;</span><br><span class="line">            sorted.remove(preScore);</span><br><span class="line">        &#125;</span><br><span class="line">        map.remove(playerId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>My way: HashMap to store &lt;playerId, score&gt;, priority queue to store the score in decreasing order</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Leaderboard</span> </span>&#123;</span><br><span class="line">    Map&lt;Integer, Integer&gt; map;</span><br><span class="line">    PriorityQueue&lt;Integer&gt; pq;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Leaderboard</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        pq = <span class="keyword">new</span> PriorityQueue(Collections.reverseOrder());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addScore</span><span class="params">(<span class="keyword">int</span> playerId, <span class="keyword">int</span> score)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(map.containsKey(playerId)) &#123;</span><br><span class="line">            <span class="keyword">int</span> prev = map.get(playerId);</span><br><span class="line">            reset(playerId);</span><br><span class="line">            map.put(playerId, score+prev);</span><br><span class="line">            pq.add(score+prev);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            map.put(playerId, score);</span><br><span class="line">            pq.add(score);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">(<span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(K &gt; pq.size()) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        Object[] a = pq.toArray();</span><br><span class="line">        Integer[] temp = Arrays.copyOf(a, a.length, Integer[].class);</span><br><span class="line">        Arrays.sort(temp, Collections.reverseOrder());</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(K &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            sum += temp[i++];</span><br><span class="line">            K--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reset</span><span class="params">(<span class="keyword">int</span> playerId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(map.containsKey(playerId)) &#123;</span><br><span class="line">            pq.remove(map.get(playerId));</span><br><span class="line">            map.remove(playerId);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your Leaderboard object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * Leaderboard obj = new Leaderboard();</span></span><br><span class="line"><span class="comment"> * obj.addScore(playerId,score);</span></span><br><span class="line"><span class="comment"> * int param_2 = obj.top(K);</span></span><br><span class="line"><span class="comment"> * obj.reset(playerId);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>205. Isomorphic Strings (G)</summary>
<blockquote>
<p>Use a HashMap to store the conversion between two characters</p>
</blockquote>
<p>Run time: $O(n)$, space: $O(n)$</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isIsomorphic</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    HashMap&lt;Character, Character&gt; map = <span class="keyword">new</span> HashMap&lt;Character, Character&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i&lt; s.length(); i++)&#123;</span><br><span class="line">        <span class="keyword">char</span> a = s.charAt(i), b = t.charAt(i);</span><br><span class="line">        <span class="keyword">if</span>(map.containsKey(a))&#123;</span><br><span class="line">             <span class="keyword">if</span>(map.get(a).equals(b)) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(!map.containsValue(b)) map.put(a,b);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>1. Two Sum</summary>
<blockquote>
<p>Put &lt;value, index&gt; into the map, each time find if the target is in the map. If there is, get the index and put it in the first entry, with the current index in the second entry.</p>
</blockquote>
<p>Run time: $O(n)$, space: $O(n)$</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">    <span class="keyword">if</span>(nums == <span class="keyword">null</span> || nums.length &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;-<span class="number">1</span>,-<span class="number">1</span>&#125;;</span><br><span class="line">    Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums[i];</span><br><span class="line">        <span class="keyword">int</span> diff = target - n;</span><br><span class="line">        <span class="keyword">if</span>(map.containsKey(diff)) <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;map.get(diff), i&#125;;</span><br><span class="line">        map.put(n, i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;-<span class="number">1</span>,-<span class="number">1</span>&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>621. Task Scheduler</summary>
<blockquote>
<p>Put &lt;taskName, frequencies&gt; into the map, update the max<br>
Calculate the count using <code>(max-1)*(cooldown+1)</code></p>
</blockquote>
<p>Run time: $O(n)$, space: $O(n)$</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">leastInterval</span><span class="params">(<span class="keyword">char</span>[] tasks, <span class="keyword">int</span> cooldown)</span> </span>&#123;</span><br><span class="line">    HashMap&lt;Character, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> n = tasks.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> c : tasks) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!map.containsKey(c)) map.put(c, <span class="number">0</span>);</span><br><span class="line">        map.put(c, map.get(c) + <span class="number">1</span>);</span><br><span class="line">        max = Math.max(max, map.get(c));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> count = (max-<span class="number">1</span>) * (cooldown + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> extra = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> val : map.values())&#123;</span><br><span class="line">        <span class="keyword">if</span>(val &gt; max - <span class="number">1</span>) extra++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Math.max(count + extra, n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Simplified question: the order is given and fixed</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">processTasks</span><span class="params">(<span class="keyword">int</span>[] orderList, <span class="keyword">int</span> cooldown)</span> </span>&#123;</span><br><span class="line"><span class="comment">// key is the task Id, value is the recently time it should be put</span></span><br><span class="line">   Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">   <span class="keyword">int</span> time = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> id : orderList) &#123;</span><br><span class="line">     <span class="keyword">if</span> (map.containsKey(id)) &#123;</span><br><span class="line">       time = Math.max(map.get(id) + cooldown + <span class="number">1</span>, time);</span><br><span class="line">     &#125;</span><br><span class="line">     map.put(id, time++);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> time;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>347. Top K Frequent Elements</summary>
<blockquote>
<p>Use a hashmap (number, occurences) and an array of interger lists (index is occurences, store list of elements in the original array). Loop backwards to add all integers to the answer.</p>
</blockquote>
<p>Run time: $O(n)$, space: $O(n)$</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">topKFrequent</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt;[] bucket = <span class="keyword">new</span> List[nums.length+<span class="number">1</span>];</span><br><span class="line">    Map&lt;Integer, Integer&gt; frequencyMap = <span class="keyword">new</span> HashMap&lt;Integer, Integer&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> n : nums) frequencyMap.put(n, frequencyMap.getOrDefault(n, <span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> key: frequencyMap.keySet()) &#123;</span><br><span class="line">        <span class="keyword">int</span> frequency = frequencyMap.get(key);</span><br><span class="line">        <span class="keyword">if</span> (bucket[frequency] == <span class="keyword">null</span>) bucket[frequency] = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        bucket[frequency].add(key);</span><br><span class="line">    &#125;</span><br><span class="line">    List&lt;Integer&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> pos = bucket.length - <span class="number">1</span>; pos &gt;= <span class="number">0</span> &amp;&amp; ans.size() &lt; k; pos--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (bucket[pos] != <span class="keyword">null</span>) ans.addAll(bucket[pos]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>218. The Skyline Problem</summary>
<blockquote>
<p>Create a list and put [left, -height] and [right, height]<br>
Sort the intervals by left, then right, in increasing order<br>
Create a TreeMap and keep the keys in decreasing order<br>
For each value in the list, see if the height is in the map. If it’s left pair, then increment the occurrences. If it’s right pair, then decrement the occurrences or remove it<br>
Then get the first key (max one) from the treemap, and if this height is different from the previous height, add it to the result list.</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; getSkyline(<span class="keyword">int</span>[][] buildings) &#123;</span><br><span class="line">    List&lt;<span class="keyword">int</span>[]&gt; heights = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span>[] b: buildings) &#123;</span><br><span class="line">        heights.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;b[<span class="number">0</span>], -b[<span class="number">2</span>]&#125;);</span><br><span class="line">        heights.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;b[<span class="number">1</span>], b[<span class="number">2</span>]&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    Collections.sort(heights, (a, b) -&gt; (a[<span class="number">0</span>] == b[<span class="number">0</span>]) ? a[<span class="number">1</span>] - b[<span class="number">1</span>] : a[<span class="number">0</span>] - b[<span class="number">0</span>]);</span><br><span class="line">    TreeMap&lt;Integer, Integer&gt; heightMap = <span class="keyword">new</span> TreeMap&lt;&gt;(Collections.reverseOrder());</span><br><span class="line">    heightMap.put(<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> prevHeight = <span class="number">0</span>;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; skyLine = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span>[] h: heights) &#123;</span><br><span class="line">        <span class="keyword">if</span> (h[<span class="number">1</span>] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            Integer cnt = heightMap.get(-h[<span class="number">1</span>]);</span><br><span class="line">            cnt = ( cnt == <span class="keyword">null</span> ) ? <span class="number">1</span> : cnt + <span class="number">1</span>;</span><br><span class="line">            heightMap.put(-h[<span class="number">1</span>], cnt);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Integer cnt = heightMap.get(h[<span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">if</span> (cnt == <span class="number">1</span>) &#123;</span><br><span class="line">                heightMap.remove(h[<span class="number">1</span>]);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                heightMap.put(h[<span class="number">1</span>], cnt - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> currHeight = heightMap.firstKey();</span><br><span class="line">        <span class="keyword">if</span> (prevHeight != currHeight) &#123;</span><br><span class="line">            skyLine.add(Arrays.asList(h[<span class="number">0</span>], currHeight));</span><br><span class="line">            prevHeight = currHeight;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> skyLine;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>460. LFU Cache (G)</summary>
<blockquote>
<p>Store the following entries: &lt;key, value&gt;, &lt;key, freq&gt;, &lt;freq, list of keys&gt;.<br>
Use LinkedHashSet to record list of keys in insertion order</p>
</blockquote>
<p>Run time: $O(n\log n)$, space: $O(n)$</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LFUCache</span> </span>&#123;</span><br><span class="line">    HashMap&lt;Integer, Integer&gt; vals;</span><br><span class="line">    HashMap&lt;Integer, Integer&gt; counts;</span><br><span class="line">    HashMap&lt;Integer, LinkedHashSet&lt;Integer&gt;&gt; lists; <span class="comment">// count, </span></span><br><span class="line">    <span class="keyword">int</span> cap;</span><br><span class="line">    <span class="keyword">int</span> min = -<span class="number">1</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LFUCache</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        cap = capacity;</span><br><span class="line">        vals = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        counts = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        lists = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        lists.put(<span class="number">1</span>, <span class="keyword">new</span> LinkedHashSet&lt;&gt;());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!vals.containsKey(key))</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> count = counts.get(key);</span><br><span class="line">        counts.put(key, count+<span class="number">1</span>);</span><br><span class="line">        lists.get(count).remove(key);</span><br><span class="line">        <span class="keyword">if</span>(count==min &amp;&amp; lists.get(count).size()==<span class="number">0</span>)</span><br><span class="line">            min++;</span><br><span class="line">        <span class="keyword">if</span>(!lists.containsKey(count+<span class="number">1</span>))</span><br><span class="line">            lists.put(count+<span class="number">1</span>, <span class="keyword">new</span> LinkedHashSet&lt;&gt;());</span><br><span class="line">        lists.get(count+<span class="number">1</span>).add(key);</span><br><span class="line">        <span class="keyword">return</span> vals.get(key);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(cap&lt;=<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(vals.containsKey(key)) &#123;</span><br><span class="line">            vals.put(key, value);</span><br><span class="line">            get(key);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">if</span>(vals.size() &gt;= cap) &#123;</span><br><span class="line">            <span class="keyword">int</span> evit = lists.get(min).iterator().next();</span><br><span class="line">            lists.get(min).remove(evit);</span><br><span class="line">            vals.remove(evit);</span><br><span class="line">            counts.remove(evit);</span><br><span class="line">        &#125;</span><br><span class="line">        vals.put(key, value);</span><br><span class="line">        counts.put(key, <span class="number">1</span>);</span><br><span class="line">        min = <span class="number">1</span>;</span><br><span class="line">        lists.get(<span class="number">1</span>).add(key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>853. Car Fleet</summary>
<blockquote>
<p>So we use the distance to target as key and speed as value, iterate through all cars in order of their distances to the target.<br>
keep track of currently slowest one(which might block the car behind), if a car can catch up current slowest one, it will not cause a new group.<br>
Otherwise, we count a new group and update the info of slowest</p>
</blockquote>
<p>Run time: $O(n\log n)$, space: $O(n)$</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">carFleet</span><span class="params">(<span class="keyword">int</span> target, <span class="keyword">int</span>[] position, <span class="keyword">int</span>[] speed)</span> </span>&#123;</span><br><span class="line">    TreeMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> TreeMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span> n = position.length;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; ++i) map.put(target - position[i], speed[i]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">double</span> r = -<span class="number">1.0</span>;</span><br><span class="line"> <span class="comment">/*for all car this value must &gt; 0, so we can count for the car closest to target*/</span></span><br><span class="line">    <span class="keyword">for</span>(Map.Entry&lt;Integer, Integer&gt; entry: map.entrySet())&#123;</span><br><span class="line">        <span class="keyword">int</span> d = entry.getKey(); <span class="comment">// distance</span></span><br><span class="line">        <span class="keyword">int</span> s = entry.getValue(); <span class="comment">// speed</span></span><br><span class="line">        <span class="keyword">double</span> t = <span class="number">1.0</span>*d/s; <span class="comment">// time to target</span></span><br><span class="line">        <span class="keyword">if</span>(t&gt;r)&#123; <span class="comment">// this car is unable to catch up previous one, form a new group and update the value</span></span><br><span class="line">            ++count;</span><br><span class="line">            r = t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>340. Longest Substring with At Most K Distinct Characters</summary>
<blockquote></blockquote>
<p>Run time: $O(n)$, space: $O(n)$</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstringKDistinct</span><span class="params">(String s, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>, i=<span class="number">0</span>;</span><br><span class="line">    Map&lt;Character, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;s.length(); j++)&#123;</span><br><span class="line">        <span class="keyword">char</span> c = s.charAt(j);</span><br><span class="line">        map.put(c, map.getOrDefault(c, <span class="number">0</span>)+<span class="number">1</span>); <span class="comment">// count occurrences</span></span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span>(map.size()&lt;=k) result = Math.max(result, j-i+<span class="number">1</span>); <span class="comment">// num of unique chars</span></span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">while</span>(map.size() &gt; k)&#123;</span><br><span class="line">                <span class="keyword">char</span> l = s.charAt(i);</span><br><span class="line">                <span class="keyword">int</span> count = map.get(l);</span><br><span class="line">                <span class="keyword">if</span>(count==<span class="number">1</span>) map.remove(l);</span><br><span class="line">                <span class="keyword">else</span> map.put(l, map.get(l)-<span class="number">1</span>);</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>246. Strobogrammatic Number</summary>
<blockquote>
<p>Use map to record pairs of numbers, then use two pointers check one by one<br>
Run time: $O(n)$, space: $O(1)$</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isStrobogrammatic</span><span class="params">(String num)</span> </span>&#123;</span><br><span class="line">    Map&lt;Character, Character&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    map.put(<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;1&#x27;</span>);</span><br><span class="line">    map.put(<span class="string">&#x27;0&#x27;</span>,<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    map.put(<span class="string">&#x27;8&#x27;</span>,<span class="string">&#x27;8&#x27;</span>);</span><br><span class="line">    map.put(<span class="string">&#x27;6&#x27;</span>,<span class="string">&#x27;9&#x27;</span>);</span><br><span class="line">    map.put(<span class="string">&#x27;9&#x27;</span>,<span class="string">&#x27;6&#x27;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = num.length() - <span class="number">1</span>; <span class="comment">// two pointers</span></span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!map.containsKey(num.charAt(left)) || !map.get(num.charAt(left)).equals(num.charAt(right))) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        left++;</span><br><span class="line">        right--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>528. Random Pick with Weight</summary>
<blockquote>
<p>Use TreeMap to store the accumulated weight and index<br>
Use higherKey to get the key given the randomly generated key, return the index</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> weight = <span class="number">0</span>;</span><br><span class="line">    TreeMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> TreeMap&lt;&gt;();</span><br><span class="line">    Random rnd= <span class="keyword">new</span> Random();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Solution</span><span class="params">(<span class="keyword">int</span>[] w)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; w.length; i++)&#123;</span><br><span class="line">            weight += w[i];</span><br><span class="line">            map.put(weight, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pickIndex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// int key= map.ceilingKey(rnd.nextInt(cnt)+1); don&#x27;t forget to +1, because rand.nextInt(cnt) generate random integer in range [0,cnt-1]</span></span><br><span class="line">        <span class="keyword">int</span> key= map.higherKey(rnd.nextInt(weight));</span><br><span class="line">        <span class="keyword">return</span> map.get(key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>359. Logger Rate Limiter (G)</summary>
<blockquote>
<p>Use map to store message and timestamp, if the key exists and the previous timestamp is less than 10, then false, otherwise update timestamp and print<br>
Run time: $O(kn)$ ($k$ is time interval), space: $O(n)$</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Logger</span> </span>&#123;</span><br><span class="line">    Map&lt;String, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;(); <span class="comment">// msg : lst print timestamp</span></span><br><span class="line">    <span class="keyword">int</span> limiter = <span class="number">10</span>;</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Logger</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Returns true if the message should be printed in the given timestamp, otherwise returns false.</span></span><br><span class="line"><span class="comment">        If this method returns false, the message will not be printed.</span></span><br><span class="line"><span class="comment">        The timestamp is in seconds granularity. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">shouldPrintMessage</span><span class="params">(<span class="keyword">int</span> timestamp, String message)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!map.containsKey(message))&#123;</span><br><span class="line">            map.put(message, timestamp);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(timestamp - map.get(message) &gt;= limiter)&#123;</span><br><span class="line">                map.put(message, timestamp);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your Logger object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * Logger obj = new Logger();</span></span><br><span class="line"><span class="comment"> * boolean param_1 = obj.shouldPrintMessage(timestamp,message);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Logger</span> </span>&#123;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, Integer&gt; map;</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Logger</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">/** Returns true if the message should be printed in the given timestamp, otherwise returns false.</span></span><br><span class="line"><span class="comment">        If this method returns false, the message will not be printed.</span></span><br><span class="line"><span class="comment">        The timestamp is in seconds granularity. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">shouldPrintMessage</span><span class="params">(<span class="keyword">int</span> timestamp, String message)</span> </span>&#123;</span><br><span class="line">        prune(timestamp);</span><br><span class="line">        <span class="keyword">if</span> (!map.containsKey(message)) &#123;</span><br><span class="line">            map.put(message, timestamp);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">prune</span><span class="params">(<span class="keyword">int</span> timestamp)</span> </span>&#123;</span><br><span class="line">        Iterator&lt;String&gt; itr = map.keySet().iterator();</span><br><span class="line">        <span class="keyword">while</span> (itr.hasNext()) &#123;</span><br><span class="line">            String k = itr.next();</span><br><span class="line">            <span class="keyword">if</span> (map.get(k) + <span class="number">10</span> &lt;= timestamp) &#123;</span><br><span class="line">                itr.remove();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>843. Guess the Word (G)</summary>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">findSecretWord</span><span class="params">(String[] wordlist, Master master)</span> </span>&#123;</span><br><span class="line">        Arrays.sort(wordlist);</span><br><span class="line">        Map&lt;String, Integer&gt; badWords = <span class="keyword">new</span> HashMap();</span><br><span class="line">        <span class="keyword">for</span>(String word:wordlist) &#123;</span><br><span class="line">            <span class="keyword">if</span> (validateWord(word, badWords))&#123;</span><br><span class="line">                <span class="keyword">int</span> score = master.guess(word);</span><br><span class="line">                <span class="keyword">if</span> (score==<span class="number">6</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                badWords.put(word, score);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">validateWord</span><span class="params">(String candidate, Map&lt;String, Integer&gt; badWords)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> similarity = <span class="number">0</span>;</span><br><span class="line">        Integer score = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(String w:badWords.keySet()) &#123;</span><br><span class="line">            similarity = similarity(w, candidate);</span><br><span class="line">            score = badWords.get(w);</span><br><span class="line">            <span class="keyword">if</span> ( (score==<span class="number">0</span> &amp;&amp; similarity &gt; <span class="number">0</span>) || similarity != score )&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">similarity</span><span class="params">(String s1, String s2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;s1.length(); i++) &#123;</span><br><span class="line">          <span class="keyword">if</span> (s1.charAt(i)==s2.charAt(i)) &#123;</span><br><span class="line">              count++;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>380. Insert Delete GetRandom O(1) (G) (M)</summary>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RandomizedSet</span> </span>&#123;</span><br><span class="line">    ArrayList&lt;Integer&gt; nums;</span><br><span class="line">    HashMap&lt;Integer, Integer&gt; locs;</span><br><span class="line">    java.util.Random rand = <span class="keyword">new</span> java.util.Random();</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RandomizedSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        nums = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        locs = <span class="keyword">new</span> HashMap&lt;Integer, Integer&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Inserts a value to the set. Returns true if the set did not already contain the specified element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> contain = locs.containsKey(val);</span><br><span class="line">        <span class="keyword">if</span> ( contain ) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        locs.put( val, nums.size());</span><br><span class="line">        nums.add(val);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Removes a value from the set. Returns true if the set contained the specified element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> contain = locs.containsKey(val);</span><br><span class="line">        <span class="keyword">if</span> ( ! contain ) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span> loc = locs.get(val);</span><br><span class="line">        <span class="keyword">if</span> (loc &lt; nums.size() - <span class="number">1</span> ) &#123; <span class="comment">// not the last one than swap the last one with this val</span></span><br><span class="line">            <span class="keyword">int</span> lastone = nums.get(nums.size() - <span class="number">1</span> );</span><br><span class="line">            nums.set( loc , lastone );</span><br><span class="line">            locs.put(lastone, loc);</span><br><span class="line">        &#125;</span><br><span class="line">        locs.remove(val);</span><br><span class="line">        nums.remove(nums.size() - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Get a random element from the set. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getRandom</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> nums.get( rand.nextInt(nums.size()) );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>56. Merge Intervals (M)</summary>
<blockquote>
<p>Override compare method, then sort the array<br>
Then compare and merge the intervals</p>
</blockquote>
<p>Run time: $O(n\log n)$, space: $O(n^2)$</p>
<blockquote>
<p>Use TreeMap, put &lt;start, +1&gt; and &lt;end,-1&gt;<br>
If the value of the key is 0, which implies there’s overlap</p>
</blockquote>
<p>Run time: $O(n)$, space: $O(n)$</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[][] merge(<span class="keyword">int</span>[][] intervals) &#123;</span><br><span class="line">    <span class="keyword">if</span> (intervals == <span class="keyword">null</span> || intervals.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> TreeMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span>[] interval : intervals) &#123;</span><br><span class="line">        <span class="keyword">int</span> start = interval[<span class="number">0</span>], end = interval[<span class="number">1</span>];</span><br><span class="line">        map.put(start, map.getOrDefault(start, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        map.put(end, map.getOrDefault(end, <span class="number">0</span>) - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    List&lt;<span class="keyword">int</span>[]&gt; ans = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span> newStart = <span class="number">0</span>, count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (Integer key : map.keySet()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (count == <span class="number">0</span>) newStart = key;</span><br><span class="line">        count += map.get(key);</span><br><span class="line">        <span class="comment">// this count == 0 means a full interval has been completed</span></span><br><span class="line">        <span class="keyword">if</span> (count == <span class="number">0</span>) &#123;</span><br><span class="line">            ans.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;newStart, key&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans.toArray(<span class="keyword">new</span> <span class="keyword">int</span>[ans.size()][]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<h2 id="Others">Others</h2>
<hr>
<details>
<summary></summary>
<blockquote></blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">```</span><br><span class="line">&lt;/details&gt;</span><br><span class="line"></span><br><span class="line">&lt;details&gt;</span><br><span class="line">&lt;summary&gt;1281. Subtract the Product and Sum of Digits of an Integer&lt;/summary&gt;</span><br><span class="line"></span><br><span class="line">&gt; </span><br><span class="line"></span><br><span class="line">Run time: $O(n)$, space: $O(<span class="number">1</span>)$</span><br><span class="line"></span><br><span class="line">``` java</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">subtractProductAndSum</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> prod = <span class="number">1</span>, sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> temp = n % <span class="number">10</span>;</span><br><span class="line">            prod *= temp;</span><br><span class="line">            sum += temp;</span><br><span class="line">            n = n / <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> prod-sum;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>1007. Minimum Domino Rotations For Equal Row</summary>
<blockquote>
<p>Count the occurrence of all numbers in A and B, and also the number of domino with two same numbers.</p>
</blockquote>
<p>Try all possibilities from 1 to 6. If we can make number i in a whole row, it should satisfy that <code>countA[i] + countB[i] - same[i] = n</code>.</p>
<p>Run time: $O(n)$, space: $O(1)$</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minDominoRotations</span><span class="params">(<span class="keyword">int</span>[] A, <span class="keyword">int</span>[] B)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] countA = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">7</span>], countB = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">7</span>], same = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">7</span>];</span><br><span class="line">    <span class="keyword">int</span> n = A.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        countA[A[i]]++;</span><br><span class="line">        countB[B[i]]++;</span><br><span class="line">        <span class="keyword">if</span> (A[i] == B[i]) same[A[i]]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">6</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (countA[i] + countB[i] - same[i] == n) <span class="keyword">return</span> n - Math.max(countA[i], countB[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>1276. Number of Burgers with No Waste of Ingredients</summary>
<blockquote>
<p>Solve these two equations each time<br>
4 * jumbo + 2 * small = tomatoSlices<br>
jumbo + small = cheeseSlices</p>
</blockquote>
<p>Run time: $O(1)$, space: $O(1)$</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">numOfBurgers</span><span class="params">(<span class="keyword">int</span> tomatoSlices, <span class="keyword">int</span> cheeseSlices)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// need to solve 2 equations</span></span><br><span class="line">    <span class="comment">// 4 * jumbo + 2 * small = tomatoSlices, jumbo + small = cheeseSlices</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(tomatoSlices % <span class="number">2</span> == <span class="number">1</span>) <span class="keyword">return</span> ans;</span><br><span class="line">    <span class="keyword">int</span> jumbo = tomatoSlices - <span class="number">2</span> * cheeseSlices;</span><br><span class="line">    <span class="keyword">if</span>(jumbo &lt; <span class="number">0</span> || jumbo % <span class="number">2</span> == <span class="number">1</span>) <span class="keyword">return</span> ans;</span><br><span class="line">    jumbo /= <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> small = cheeseSlices - jumbo;</span><br><span class="line">    <span class="keyword">if</span>(small &lt; <span class="number">0</span>) <span class="keyword">return</span> ans;</span><br><span class="line">    </span><br><span class="line">    ans.add(jumbo);</span><br><span class="line">    ans.add(small);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">numOfBurgers</span><span class="params">(<span class="keyword">int</span> tomatoSlices, <span class="keyword">int</span> cheeseSlices)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tomatoSlices % <span class="number">2</span> == <span class="number">1</span> || tomatoSlices &lt; cheeseSlices) <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">    List&lt;Integer&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= cheeseSlices; i++)&#123; <span class="comment">// i is number of Jumbo</span></span><br><span class="line">        <span class="keyword">int</span> j = cheeseSlices - i;</span><br><span class="line">        <span class="keyword">if</span>(<span class="number">4</span>*i+<span class="number">2</span>*j == tomatoSlices)&#123;</span><br><span class="line">            ans.add(i);</span><br><span class="line">            ans.add(j);</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>1275. Find Winner on a Tic Tac Toe Game</summary>
<blockquote>
<p>Remember to separate different cases</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">tictactoe</span><span class="params">(<span class="keyword">int</span>[][] moves)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(moves.length &lt; <span class="number">5</span>) <span class="keyword">return</span> <span class="string">&quot;Pending&quot;</span>;</span><br><span class="line">    <span class="keyword">char</span>[][] board = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">3</span>][<span class="number">3</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; moves.length; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i % <span class="number">2</span> == <span class="number">0</span>) board[moves[i][<span class="number">0</span>]][moves[i][<span class="number">1</span>]] = <span class="string">&#x27;X&#x27;</span>;</span><br><span class="line">        <span class="keyword">else</span> board[moves[i][<span class="number">0</span>]][moves[i][<span class="number">1</span>]] = <span class="string">&#x27;O&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    String[] b = <span class="keyword">new</span> String[<span class="number">3</span>];</span><br><span class="line">    b[<span class="number">0</span>] = String.valueOf(board[<span class="number">0</span>]);</span><br><span class="line">    b[<span class="number">1</span>] = String.valueOf(board[<span class="number">1</span>]);</span><br><span class="line">    b[<span class="number">2</span>] = String.valueOf(board[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> xWin = isGameOver(b, <span class="string">&#x27;X&#x27;</span>);</span><br><span class="line">    <span class="keyword">boolean</span> oWin = isGameOver(b, <span class="string">&#x27;O&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span>(xWin) <span class="keyword">return</span> <span class="string">&quot;A&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(oWin) <span class="keyword">return</span> <span class="string">&quot;B&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(moves.length == <span class="number">9</span>) <span class="keyword">return</span> <span class="string">&quot;Draw&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Pending&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isGameOver</span><span class="params">(String[] board, <span class="keyword">char</span> player)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// check horizontal</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (board[i].charAt(<span class="number">0</span>) == player &amp;&amp; board[i].charAt(<span class="number">0</span>) == board[i].charAt(<span class="number">1</span>) &amp;&amp; board[i].charAt(<span class="number">1</span>) == board[i].charAt(<span class="number">2</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// check vertical</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (board[<span class="number">0</span>].charAt(j) == player &amp;&amp; board[<span class="number">0</span>].charAt(j) == board[<span class="number">1</span>].charAt(j) &amp;&amp; board[<span class="number">1</span>].charAt(j) == board[<span class="number">2</span>].charAt(j)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// check diagonal</span></span><br><span class="line">    <span class="keyword">if</span> (board[<span class="number">1</span>].charAt(<span class="number">1</span>) == player &amp;&amp; (board[<span class="number">0</span>].charAt(<span class="number">0</span>) == board[<span class="number">1</span>].charAt(<span class="number">1</span>) &amp;&amp; board[<span class="number">1</span>].charAt(<span class="number">1</span>) == board[<span class="number">2</span>].charAt(<span class="number">2</span>)</span><br><span class="line">            || board[<span class="number">0</span>].charAt(<span class="number">2</span>) == board[<span class="number">1</span>].charAt(<span class="number">1</span>) &amp;&amp; board[<span class="number">1</span>].charAt(<span class="number">1</span>) == board[<span class="number">2</span>].charAt(<span class="number">0</span>))) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>1093. Statistics from a Large Sample</summary>
<blockquote>
<p>First iteration: if the frequency count is not zero, update the min (only once), max, mode, and sum, number of elements<br>
Find out the average, calculate the median in two ways: <code>(total + 1) / 2</code> and <code>total / 2 + 1</code><br>
Second iteration: Keep track of the current number of elements, and compare with two medians, add first half and second half</p>
</blockquote>
<p>Run time: $O(n)$, space: $O(1)$</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">double</span>[] sampleStats(<span class="keyword">int</span>[] count) &#123;</span><br><span class="line">    <span class="keyword">int</span> total = <span class="number">0</span>, mode = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">double</span> median = <span class="number">0</span>, min = -<span class="number">1</span>, max = <span class="number">0</span>, avg = <span class="number">0</span>, sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">256</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (count[i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            total += count[i];</span><br><span class="line">            <span class="keyword">if</span> (min &lt; <span class="number">0</span>) min = i;</span><br><span class="line">            max = i;</span><br><span class="line">            sum += i * count[i];</span><br><span class="line">            <span class="keyword">if</span> (count[i] &gt; count[mode]) mode = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    avg = sum / total;</span><br><span class="line">    <span class="keyword">if</span> (total == <span class="number">1</span>) median = sum; <span class="comment">// single element.</span></span><br><span class="line">    <span class="keyword">int</span> m1 = (total + <span class="number">1</span>) / <span class="number">2</span>, m2 = total / <span class="number">2</span> + <span class="number">1</span>; <span class="comment">// m1-th and m2-th items are medians.</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, cnt = <span class="number">0</span>; total &gt; <span class="number">1</span> &amp;&amp; i &lt; <span class="number">256</span>; i++) &#123; <span class="comment">// more than 1 elements.</span></span><br><span class="line">        <span class="keyword">if</span> (cnt &lt; m1 &amp;&amp; cnt + count[i] &gt;= m1) <span class="comment">// find m1-th item.</span></span><br><span class="line">            median += i / <span class="number">2.0d</span>; <span class="comment">// add its half.</span></span><br><span class="line">        <span class="keyword">if</span> (cnt &lt; m2 &amp;&amp; cnt + count[i] &gt;= m2) <span class="comment">// find m2-th item.</span></span><br><span class="line">            median += i / <span class="number">2.0d</span>; <span class="comment">// add its half.</span></span><br><span class="line">        cnt += count[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">double</span>[]&#123;min, max, avg, median, mode&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>341. Flatten Nested List Iterator</summary>
<blockquote>
<p>Use stack and push all NestedIterator in the list, no matter if it is a list or not<br>
Then each time when hasNext() is called, if the top element is a list, push the elements in this list to the stack</p>
</blockquote>
<p>Run time: $O(1)$ for each method?, space: $O(n)$</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NestedIterator</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;NestedInteger&gt; stack;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NestedIterator</span><span class="params">(List&lt;NestedInteger&gt; nestedList)</span> </span>&#123;</span><br><span class="line">        stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        flattenList(nestedList);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(hasNext()) <span class="keyword">return</span> stack.pop().getInteger();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (stack.peek().isInteger()) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            flattenList(stack.pop().getList());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">flattenList</span><span class="params">(List&lt;NestedInteger&gt; list)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = list.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            stack.push(list.get(i));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>1267. Count Servers that Communicate</summary>
<blockquote>
<p>Use two maps to store the row and list of columns, the column and list of rows, then add to the set</p>
</blockquote>
<p>Run time: $O(n^2)$, space: $O(n^2)$</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countServers</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">    Map&lt;Integer, ArrayList&lt;Integer&gt;&gt; row = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    Map&lt;Integer, ArrayList&lt;Integer&gt;&gt; col = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    Set&lt;String&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span> m = grid.length, n = grid[<span class="number">0</span>].length;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(grid[i][j] == <span class="number">1</span>)&#123;</span><br><span class="line">                ArrayList&lt;Integer&gt; temp = row.getOrDefault(i, <span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">                temp.add(j);</span><br><span class="line">                row.put(i, temp);</span><br><span class="line">                ArrayList&lt;Integer&gt; temp2 = col.getOrDefault(j, <span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">                temp2.add(i);</span><br><span class="line">                col.put(j, temp2);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i: row.keySet())&#123;</span><br><span class="line">        <span class="keyword">if</span>(row.get(i).size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j: row.get(i))&#123;</span><br><span class="line">                String s = i+<span class="string">&quot; &quot;</span>+j;</span><br><span class="line">                <span class="keyword">if</span>(!set.contains(s)) set.add(s);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i: col.keySet())&#123;</span><br><span class="line">        <span class="keyword">if</span>(col.get(i).size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j: col.get(i))&#123;</span><br><span class="line">                String s = j+<span class="string">&quot; &quot;</span>+i;</span><br><span class="line">                <span class="keyword">if</span>(!set.contains(s)) set.add(s);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> set.size();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>1266. Minimum Time Visiting All Points</summary>
<blockquote>
<p>Traverse the input array, for each pair of neighboring points, comparing the absolute difference in x and y coordinates, the larger value is the minimum time need to travel between them; Sum these time.</p>
</blockquote>
<p>Run time: $O(n)$, space: $O(1)$</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minTimeToVisitAllPoints</span><span class="params">(<span class="keyword">int</span>[][] points)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; points.length; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] cur = points[i], prev = points[i - <span class="number">1</span>];</span><br><span class="line">        ans += Math.max(Math.abs(cur[<span class="number">0</span>] - prev[<span class="number">0</span>]), Math.abs(cur[<span class="number">1</span>] - prev[<span class="number">1</span>]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minTimeToVisitAllPoints</span><span class="params">(<span class="keyword">int</span>[][] points)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; points.length; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> dX = Math.abs(points[i][<span class="number">0</span>]-points[i-<span class="number">1</span>][<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">int</span> dY = Math.abs(points[i][<span class="number">1</span>]-points[i-<span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">int</span> minMove = Math.min(dX, dY);</span><br><span class="line">        ans += dX + dY - minMove;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>836. Rectangle Overlap (M)</summary>
<blockquote>
<p>Case 1:if the maximum of rec1 is less than or equal to the minimum from rec2 in the x<br>
Case 2:if the maximum of rec1 is less than or equal to the minimum from rec2 in the y<br>
Case 3: just swap rec1 and rec2 in Case 1<br>
Case 4:Just swap rec1 and rec2 in Case 2</p>
</blockquote>
<p>Run time: $O(1)$, space: $O(1)$</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isRectangleOverlap</span><span class="params">(<span class="keyword">int</span>[] rec1, <span class="keyword">int</span>[] rec2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> !(rec1[<span class="number">1</span>] &gt;= rec2[<span class="number">3</span>] <span class="comment">// higher</span></span><br><span class="line">            || rec1[<span class="number">3</span>] &lt;= rec2[<span class="number">1</span>] <span class="comment">// lower</span></span><br><span class="line">            || rec1[<span class="number">2</span>] &lt;= rec2[<span class="number">0</span>] <span class="comment">// lefter</span></span><br><span class="line">            || rec1[<span class="number">0</span>] &gt;= rec2[<span class="number">2</span>]); <span class="comment">// righter</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>794. Valid Tic-Tac-Toe State (M)</summary>
<blockquote>
<p>Since the board is 3x3, to check if the game is over, just brute force</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">validTicTacToe</span><span class="params">(String[] board)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (board.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// turns = 0 represents &#x27;X&#x27; will move, otherwise, &#x27;O&#x27; will move</span></span><br><span class="line">    <span class="keyword">int</span> turns = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// check whether &#x27;X&#x27; wins or &#x27;O&#x27; wins, or no players win</span></span><br><span class="line">    <span class="keyword">boolean</span> xWin = isGameOver(board, <span class="string">&#x27;X&#x27;</span>);</span><br><span class="line">    <span class="keyword">boolean</span> oWin = isGameOver(board, <span class="string">&#x27;O&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; board.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; board[<span class="number">0</span>].length(); j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (board[i].charAt(j) == <span class="string">&#x27;X&#x27;</span>) &#123;</span><br><span class="line">                turns++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (board[i].charAt(j) == <span class="string">&#x27;O&#x27;</span>) &#123;</span><br><span class="line">                turns--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Four conditions will be the invalid tic tac toe board:</span></span><br><span class="line"><span class="comment">     * 1. there are more &#x27;O&#x27; than &#x27;X&#x27;</span></span><br><span class="line"><span class="comment">     * 2. the board has 2 more &#x27;X&#x27; than &#x27;O&#x27;</span></span><br><span class="line"><span class="comment">     * 3. number of &#x27;X&#x27; is equal to number of &#x27;O&#x27;, but &#x27;X&#x27; wins, it is impossible because if &#x27;X&#x27; wins, the game is </span></span><br><span class="line"><span class="comment">     * over, &#x27;O&#x27; cannot play again, then number of &#x27;O&#x27; MUST less than &#x27;X&#x27;</span></span><br><span class="line"><span class="comment">     * 4. number of &#x27;X&#x27; is more than number of &#x27;O&#x27;, but &#x27;O&#x27; wins, it is impossible because if &#x27;O&#x27; wins, the game is</span></span><br><span class="line"><span class="comment">     * over, &#x27;X&#x27; cannot play again, then number of &#x27;X&#x27; CANNOT greater than &#x27;O&#x27;</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="keyword">if</span> (turns &lt; <span class="number">0</span> || turns &gt; <span class="number">1</span> || turns == <span class="number">0</span> &amp;&amp; xWin || turns == <span class="number">1</span> &amp;&amp; oWin) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isGameOver</span><span class="params">(String[] board, <span class="keyword">char</span> player)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// check horizontal</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (board[i].charAt(<span class="number">0</span>) == player &amp;&amp; board[i].charAt(<span class="number">0</span>) == board[i].charAt(<span class="number">1</span>) &amp;&amp; board[i].charAt(<span class="number">1</span>) == board[i].charAt(<span class="number">2</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// check vertical</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (board[<span class="number">0</span>].charAt(j) == player &amp;&amp; board[<span class="number">0</span>].charAt(j) == board[<span class="number">1</span>].charAt(j) &amp;&amp; board[<span class="number">1</span>].charAt(j) == board[<span class="number">2</span>].charAt(j)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// check diagonal</span></span><br><span class="line">    <span class="keyword">if</span> (board[<span class="number">1</span>].charAt(<span class="number">1</span>) == player &amp;&amp; (board[<span class="number">0</span>].charAt(<span class="number">0</span>) == board[<span class="number">1</span>].charAt(<span class="number">1</span>) &amp;&amp; board[<span class="number">1</span>].charAt(<span class="number">1</span>) == board[<span class="number">2</span>].charAt(<span class="number">2</span>)</span><br><span class="line">            || board[<span class="number">0</span>].charAt(<span class="number">2</span>) == board[<span class="number">1</span>].charAt(<span class="number">1</span>) &amp;&amp; board[<span class="number">1</span>].charAt(<span class="number">1</span>) == board[<span class="number">2</span>].charAt(<span class="number">0</span>))) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>69. Sqrt(x) (M)</summary>
<blockquote>
<p>In a while loop, when <code>i &gt; x / i</code>, update <code>i</code> to be <code>(i + x / i) / 2</code></p>
</blockquote>
<p>Run time: $O(\log n)$?, space: $O(1)$</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">mySqrt</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">long</span> i = x;</span><br><span class="line">    <span class="keyword">while</span>(i &gt; x / i) i = (i + x / i) / <span class="number">2</span>;	    	</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">int</span>) i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>227. Basic Calculator II (M)</summary>
<blockquote>
<p>Keep track of the last sign, the current number, temporary sum, and total sum</p>
</blockquote>
<p>Run time: $O(n)$, space: $O(1)$</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">calculate</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> tempSum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span> lastSign = <span class="string">&#x27;+&#x27;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">        <span class="keyword">char</span> c = s.charAt(i);</span><br><span class="line">        <span class="keyword">if</span> (Character.isDigit(c)) num = num * <span class="number">10</span> + (c-<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        <span class="keyword">if</span> (i == s.length() - <span class="number">1</span> || !Character.isDigit(c) &amp;&amp; c!=<span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">switch</span>(lastSign) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">                    sum += tempSum;</span><br><span class="line">                    tempSum = num;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">                    sum += tempSum;</span><br><span class="line">                    tempSum = -num;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">                    tempSum *= num;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>:</span><br><span class="line">                    tempSum /= num;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            lastSign = c;</span><br><span class="line">            num = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    sum += tempSum;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Use stack</p>
</blockquote>
<p>Run time: $O(n)$, space: $O(n)$</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">calculate</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line">    <span class="keyword">if</span>(s == <span class="keyword">null</span> || (len = s.length()) == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span> sign = <span class="string">&#x27;+&#x27;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(Character.isDigit(s.charAt(i))) num = num*<span class="number">10</span> + (s.charAt(i)-<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        <span class="keyword">if</span>((!Character.isDigit(s.charAt(i)) &amp;&amp; s.charAt(i) != <span class="string">&#x27; &#x27;</span>) || i == len-<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(sign==<span class="string">&#x27;-&#x27;</span>) stack.push(-num);</span><br><span class="line">            <span class="keyword">if</span>(sign==<span class="string">&#x27;+&#x27;</span>) stack.push(num);</span><br><span class="line">            <span class="keyword">if</span>(sign==<span class="string">&#x27;*&#x27;</span>) stack.push(stack.pop()*num);</span><br><span class="line">            <span class="keyword">if</span>(sign==<span class="string">&#x27;/&#x27;</span>) stack.push(stack.pop()/num);</span><br><span class="line">            sign = s.charAt(i);</span><br><span class="line">            num = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> re = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i: stack) re += i;</span><br><span class="line">    <span class="keyword">return</span> re;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>295. Find Median from Data Stream (M)</summary>
<blockquote>
<p>Use a max heap and min heap<br>
Every time we add a num, if max heap is empty, or the top element is greater than this one, add it. If not, add to the min heap. If the max heap size differs the min heap size by more than 1, move the largest element in max heap to min heap. If the min heap size is greater than the max heap size, move the smallest element in min heap to the max heap<br>
When finding the median, if the max heap size and min heap size are the same, get the average of top elements. Otherwise, return the top element in max heap</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MedianFinder</span> </span>&#123;</span><br><span class="line">     <span class="comment">/** initialize your data structure here. */</span></span><br><span class="line">    <span class="keyword">private</span> PriorityQueue&lt;Integer&gt; maxHeap;</span><br><span class="line">    <span class="keyword">private</span> PriorityQueue&lt;Integer&gt; minHeap;</span><br><span class="line">    <span class="comment">/** initialize your data structure here. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MedianFinder</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        maxHeap = <span class="keyword">new</span> PriorityQueue&lt;Integer&gt;((a,b) -&gt; b - a);</span><br><span class="line">        minHeap = <span class="keyword">new</span> PriorityQueue&lt;Integer&gt;((a,b) -&gt; a - b);</span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addNum</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(maxHeap.isEmpty() || maxHeap.peek() &gt;= num)&#123;</span><br><span class="line">            maxHeap.add(num);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            minHeap.add(num);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(minHeap.size() + <span class="number">1</span> &lt; maxHeap.size()) &#123;</span><br><span class="line">            minHeap.add(maxHeap.poll());</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(maxHeap.size() &lt; minHeap.size())&#123;</span><br><span class="line">            maxHeap.add(minHeap.poll());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">findMedian</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(maxHeap.size() == minHeap.size())&#123;</span><br><span class="line">            <span class="keyword">return</span> (maxHeap.peek() + minHeap.peek())/<span class="number">2.0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxHeap.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>716. Max Stack</summary>
<blockquote></blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MaxStack</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Stack&lt;Integer&gt; stack;</span><br><span class="line">    Stack&lt;Integer&gt; maxStack;</span><br><span class="line">    <span class="comment">/** initialize your data structure here. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MaxStack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        maxStack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> max = maxStack.isEmpty() ? x : maxStack.peek();</span><br><span class="line">        maxStack.push(max &gt; x ? max : x);</span><br><span class="line">        stack.push(x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        maxStack.pop();</span><br><span class="line">        <span class="keyword">return</span> stack.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stack.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">peekMax</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> maxStack.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">popMax</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> val = peekMax();</span><br><span class="line">        Stack&lt;Integer&gt; buffer = <span class="keyword">new</span> Stack();</span><br><span class="line">        <span class="keyword">while</span> (top() != val) &#123; buffer.push(pop()); &#125;</span><br><span class="line">        pop();</span><br><span class="line">        <span class="keyword">while</span> (!buffer.isEmpty()) &#123; push(buffer.pop()); &#125;</span><br><span class="line">        <span class="keyword">return</span> val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MaxStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MaxStack obj = new MaxStack();</span></span><br><span class="line"><span class="comment"> * obj.push(x);</span></span><br><span class="line"><span class="comment"> * int param_2 = obj.pop();</span></span><br><span class="line"><span class="comment"> * int param_3 = obj.top();</span></span><br><span class="line"><span class="comment"> * int param_4 = obj.peekMax();</span></span><br><span class="line"><span class="comment"> * int param_5 = obj.popMax();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>1238. Circular Permutation in Binary Representation</summary>
<blockquote>
<p>Generate one bit diff permutation list. Rotate the list to make it start from “start”.<br>
Use Collections.rotate() to make the code neater.</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">circularPermutation</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> start)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; res = oneBitDiffPermutation(n);</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (res.get(i) != start) i++;</span><br><span class="line">    Collections.rotate(res, -i);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">oneBitDiffPermutation</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    List&lt;Integer&gt; tmp = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    tmp.add(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">0</span>) <span class="keyword">return</span> tmp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = tmp.size() - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j --)&#123;</span><br><span class="line">            tmp.add(tmp.get(j) + (<span class="number">1</span> &lt;&lt; i));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>My way: same idea</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">circularPermutation</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> start)</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; arr = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    List&lt;Integer&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    arr.add(<span class="string">&quot;0&quot;</span>);  </span><br><span class="line">    arr.add(<span class="string">&quot;1&quot;</span>);  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> j;  </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; (<span class="number">1</span>&lt;&lt;n); i = i&lt;&lt;<span class="number">1</span>)&#123;  </span><br><span class="line">        <span class="keyword">for</span> (j = i-<span class="number">1</span> ; j &gt;= <span class="number">0</span> ; j--) arr.add(arr.get(j));  </span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span> ; j &lt; i ; j++) arr.set(j, <span class="string">&quot;0&quot;</span> + arr.get(j));  </span><br><span class="line">        <span class="keyword">for</span> (j = i ; j &lt; <span class="number">2</span>*i ; j++) arr.set(j, <span class="string">&quot;1&quot;</span> + arr.get(j));  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; arr.size() ; i++) ans.add(Integer.parseInt(arr.get(i), <span class="number">2</span>));</span><br><span class="line">    <span class="keyword">int</span> index = ans.indexOf(start);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = ans.get(<span class="number">0</span>);</span><br><span class="line">        ans.remove(<span class="number">0</span>);</span><br><span class="line">        ans.add(temp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>1237. Find Positive Integer Solution for a Given Equation</summary>
<blockquote>
<p>Rephrase the problem:<br>
Given a matrix, each row and each column is increasing.<br>
Find all coordinates (i,j) that A[i][j] == z</p>
</blockquote>
<p>Runtime: $O(X+Y)$, space: $O(X)$</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; findSolution(CustomFunction customfunction, <span class="keyword">int</span> z) &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">1</span>, y = <span class="number">1000</span>;</span><br><span class="line">    <span class="keyword">while</span> (x &lt;= <span class="number">1000</span> &amp;&amp; y &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> v = customfunction.f(x, y);</span><br><span class="line">        <span class="keyword">if</span> (v &gt; z) --y;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (v &lt; z) ++x;</span><br><span class="line">        <span class="keyword">else</span> res.add(Arrays.asList(x++, y--));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>My brute force way</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; findSolution(CustomFunction customfunction, <span class="keyword">int</span> z) &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> x = <span class="number">1</span>; x &lt;= <span class="number">1000</span>; x++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> y = <span class="number">1</span>; y &lt;= <span class="number">1000</span>; y++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(customfunction.f(x, y) == z)&#123;</span><br><span class="line">                List&lt;Integer&gt; temp = Arrays.asList(x, y);</span><br><span class="line">                ans.add(temp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>299. Bulls and Cows</summary>
<blockquote>
<p>Iterate over the numbers in secret and in guess and count all bulls right away. For cows maintain an array that stores count of the number appearances in secret and in guess. Increment cows when either number from secret was already seen in guest or vice versa.</p>
</blockquote>
<p>Runtime: $O(n)$, space: $O(1)$</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getHint</span><span class="params">(String secret, String guess)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> bulls = <span class="number">0</span>, cows = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span>[] numbers = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; secret.length(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (secret.charAt(i) == guess.charAt(i)) bulls++;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (numbers[secret.charAt(i)-<span class="string">&#x27;0&#x27;</span>]++ &lt; <span class="number">0</span>) cows++;</span><br><span class="line">            <span class="keyword">if</span> (numbers[guess.charAt(i)-<span class="string">&#x27;0&#x27;</span>]-- &gt; <span class="number">0</span>) cows++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bulls + <span class="string">&quot;A&quot;</span> + cows + <span class="string">&quot;B&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Slow and straightforward way</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getHint</span><span class="params">(String secret, String guess)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>((secret == <span class="keyword">null</span> &amp;&amp; guess == <span class="keyword">null</span>) || </span><br><span class="line">       secret.length() != guess.length()) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">int</span> bull = <span class="number">0</span>, cow = <span class="number">0</span>;</span><br><span class="line">    Map&lt;Character,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; secret.length(); i++)&#123;</span><br><span class="line">        <span class="keyword">char</span> c1 = secret.charAt(i), c2 = guess.charAt(i);</span><br><span class="line">        <span class="keyword">if</span>(c1 == c2) bull++;</span><br><span class="line">        <span class="keyword">else</span> map.put(c1, map.getOrDefault(c1, <span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; secret.length(); i++)&#123;</span><br><span class="line">        <span class="keyword">char</span> c1 = secret.charAt(i), c2 = guess.charAt(i);</span><br><span class="line">        <span class="keyword">if</span>(c1 != c2) &#123;</span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(c2))&#123;</span><br><span class="line">                cow++;</span><br><span class="line">                <span class="keyword">if</span>(map.get(c2) == <span class="number">1</span>) map.remove(c2);</span><br><span class="line">                <span class="keyword">else</span> map.put(c2, map.get(c2)-<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> String(bull+<span class="string">&quot;A&quot;</span>+cow+<span class="string">&quot;B&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>73. Set Matrix Zeroes</summary>
<blockquote>
<p>Two boolean variables to flag the first row and column, and mark the first entry in corresponding row and column to be zero</p>
</blockquote>
<p>Runtime: $O(n^2)$, space: $O(1)$ (in-place)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setZeroes</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> fr = <span class="keyword">false</span>,fc = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; matrix.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; matrix[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(matrix[i][j] == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span>(i == <span class="number">0</span>) fr = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">if</span>(j == <span class="number">0</span>) fc = <span class="keyword">true</span>;</span><br><span class="line">                matrix[<span class="number">0</span>][j] = <span class="number">0</span>;</span><br><span class="line">                matrix[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; matrix.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; matrix[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(matrix[i][<span class="number">0</span>] == <span class="number">0</span> || matrix[<span class="number">0</span>][j] == <span class="number">0</span>) &#123;</span><br><span class="line">                matrix[i][j] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(fr) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; matrix[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">            matrix[<span class="number">0</span>][j] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(fc) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; matrix.length; i++) &#123;</span><br><span class="line">            matrix[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>393. UTF-8 Validation</summary>
<blockquote>
<p>Rule 2:<br>
Record the count of consecutive of 1.<br>
Move the number 5 bit right, if it equals “110” means there is one ‘1’.<br>
Move the number 4 bit right, if it equals “1110” means there are two ‘1’.<br>
…<br>
Move the number 7 bit right, if it equals “1” means it is “10000000” which has no meaning, return false.<br>
Rule 1:<br>
If it is not started with “10”, return false;</p>
</blockquote>
<p>Runtime: $O(n)$, space: $O(1)$</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">validUtf8</span><span class="params">(<span class="keyword">int</span>[] data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> d:data)&#123;</span><br><span class="line">          <span class="keyword">if</span>(count == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>((d &gt;&gt; <span class="number">5</span>) == <span class="number">0b110</span>) count = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>((d &gt;&gt; <span class="number">4</span>) == <span class="number">0b1110</span>) count = <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>((d &gt;&gt; <span class="number">3</span>) == <span class="number">0b11110</span>) count = <span class="number">3</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>((d &gt;&gt; <span class="number">7</span>) ==  <span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>((d&gt;&gt;<span class="number">6</span>) != <span class="number">0b10</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">else</span> count--;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count == <span class="number">0</span>;</span><br><span class="line">    &#125;```</span><br><span class="line">&lt;/details&gt;</span><br><span class="line"></span><br><span class="line">&lt;details&gt;</span><br><span class="line">&lt;summary&gt;1188. Design Bounded Blocking Queue&lt;/summary&gt;</span><br><span class="line"></span><br><span class="line">&gt; Use AtomicInteger to keep track of current size</span><br><span class="line"></span><br><span class="line">``` java</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BoundedBlockingQueue</span>&lt;<span class="title">E</span>&gt; </span>&#123;  </span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> Queue&lt;E&gt; queue = <span class="keyword">new</span> LinkedList&lt;E&gt;();  </span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> capacity;  </span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger count = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);  </span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">BoundedBlockingQueue</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;  </span><br><span class="line">     <span class="keyword">if</span> (capacity &lt;= <span class="number">0</span>)  <span class="keyword">throw</span> <span class="keyword">new</span> InvalidArgumentException(<span class="string">&quot;The capacity of the queue must be &gt; 0.&quot;</span>);</span><br><span class="line">     <span class="keyword">this</span>.capacity = capacity;  </span><br><span class="line">   &#125;  </span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">     <span class="keyword">return</span> count.get();  </span><br><span class="line">   &#125;  </span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(E e)</span> <span class="keyword">throws</span> RuntimeException </span>&#123;  </span><br><span class="line">     <span class="keyword">if</span> (e == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">&quot;Null element is not allowed.&quot;</span>);  </span><br><span class="line">   </span><br><span class="line">     <span class="keyword">int</span> oldCount = -<span class="number">1</span>;</span><br><span class="line">     <span class="keyword">while</span> (count.get() == capacity) wait();  </span><br><span class="line">   </span><br><span class="line">     queue.add(e);  </span><br><span class="line">     oldCount = count.getAndIncrement();  </span><br><span class="line">     <span class="keyword">if</span> (oldCount == <span class="number">0</span>) &#123;</span><br><span class="line">       notifyAll(); <span class="comment">// notify other waiting threads (could be producers or consumers)  </span></span><br><span class="line">     &#125;</span><br><span class="line">   &#125;  </span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> E <span class="title">remove</span><span class="params">()</span> <span class="keyword">throws</span> NoSuchElementException </span>&#123;  </span><br><span class="line">     <span class="keyword">int</span> oldCount = -<span class="number">1</span>;</span><br><span class="line">     <span class="keyword">while</span> (count.get() == <span class="number">0</span>) wait();  </span><br><span class="line">  </span><br><span class="line">     E e = queue.remove();  </span><br><span class="line">     oldCount = count.getAndDecrement();  </span><br><span class="line">     <span class="keyword">if</span> (oldCount == <span class="keyword">this</span>.capacity) &#123;</span><br><span class="line">       notifyAll(); <span class="comment">// notify other waiting threads (could be producers or consumers)  </span></span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> e;</span><br><span class="line">   &#125; </span><br><span class="line"> </span><br><span class="line">   <span class="comment">/* Retrieves, but does not remove, the head of this queue, or returns null if this queue is empty. */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> E <span class="title">peek</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">     <span class="keyword">if</span> (count.get() == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">null</span>;  </span><br><span class="line">     <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">       <span class="keyword">return</span> queue.peek();  </span><br><span class="line">     &#125;</span><br><span class="line">   &#125;  </span><br><span class="line"> &#125;  </span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>829. Consecutive Numbers Sum</summary>
<blockquote></blockquote>
<p>Runtime: $O(\log n)$, space: $O(n)$</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">consecutiveNumbersSum</span><span class="params">(<span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">1</span>, count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (N % <span class="number">2</span> == <span class="number">0</span>) N /= <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i*i &lt;= N; ans *= count+<span class="number">1</span>, i += <span class="number">2</span>)&#123;</span><br><span class="line">        count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(N % i == <span class="number">0</span>)&#123;</span><br><span class="line">            N /= i;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(N == <span class="number">1</span>) <span class="keyword">return</span> ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>*ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>Roblox OA 1</summary>
<blockquote>
<p>Use BigInteger and pass the string and base to it, then convert to long</p>
</blockquote>
<p>Runtime: $O(n)$, space: $O(n)$</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">getNumber</span><span class="params">(SinglyLinkedListNode binary)</span> </span>&#123;</span><br><span class="line"><span class="comment">// Write your code here</span></span><br><span class="line">    String s = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">while</span>(binary != <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">int</span> n = binary.data;</span><br><span class="line">        s += Integer.toString(n);</span><br><span class="line">        binary = binary.next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> BigInteger(s, <span class="number">2</span>).longValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>Pure Storage OA</summary>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Complete the compute_number_score function below.</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">compute_number_score</span><span class="params">(<span class="keyword">int</span> number)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, score = <span class="number">0</span>, numSum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">char</span>[] arr = (<span class="string">&quot;&quot;</span>+number).toCharArray();</span><br><span class="line">        <span class="keyword">while</span>(i &lt; arr.length)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[i] == <span class="string">&#x27;7&#x27;</span>) score += <span class="number">1</span>; <span class="comment">// 7</span></span><br><span class="line">            <span class="keyword">if</span>((arr[i]-<span class="string">&#x27;0&#x27;</span>) % <span class="number">2</span> == <span class="number">0</span>) score += <span class="number">4</span>; <span class="comment">// even digit</span></span><br><span class="line">            numSum += (arr[i]-<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(numSum % <span class="number">3</span> == <span class="number">0</span>) score += <span class="number">2</span>; <span class="comment">// multiple of 3</span></span><br><span class="line"></span><br><span class="line">        i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> count5 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; arr.length-<span class="number">1</span>)&#123; <span class="comment">// consecutive 5s</span></span><br><span class="line">            <span class="keyword">if</span>(arr[i] == <span class="string">&#x27;5&#x27;</span> &amp;&amp; arr[i+<span class="number">1</span>] == <span class="string">&#x27;5&#x27;</span>) count5++;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        score += count5 * <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">        i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; arr.length)&#123; <span class="comment">// descending</span></span><br><span class="line">            len++;</span><br><span class="line">            <span class="keyword">while</span>(i+<span class="number">1</span> &lt; arr.length &amp;&amp; ((arr[i]-<span class="string">&#x27;0&#x27;</span>) - (arr[i+<span class="number">1</span>]-<span class="string">&#x27;0&#x27;</span>) == <span class="number">1</span>)) &#123;</span><br><span class="line">                len++;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            score += len*len;</span><br><span class="line">            len = <span class="number">0</span>;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> score;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Complete the check_log_history function below.</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">check_log_history</span><span class="params">(List&lt;String&gt; events)</span> </span>&#123;</span><br><span class="line">        Stack&lt;String&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        Set&lt;String&gt; keys = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; events.size(); i++)&#123;</span><br><span class="line">            String op = events.get(i).split(<span class="string">&quot; &quot;</span>)[<span class="number">0</span>];</span><br><span class="line">            String key = events.get(i).split(<span class="string">&quot; &quot;</span>)[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(op.equals(<span class="string">&quot;ACQUIRE&quot;</span>)) &#123;</span><br><span class="line">                <span class="keyword">if</span>(keys.contains(key)) <span class="keyword">return</span> i+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    stack.push(key);</span><br><span class="line">                    keys.add(key);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(op.equals(<span class="string">&quot;RELEASE&quot;</span>))&#123;</span><br><span class="line">                String lastKey = stack.peek();</span><br><span class="line">                <span class="keyword">if</span>(lastKey.equals(key)) &#123;</span><br><span class="line">                    stack.pop();</span><br><span class="line">                    keys.remove(key);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">return</span> i+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!stack.isEmpty()) <span class="keyword">return</span> events.size()+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>157. Read N Characters Given Read4</summary>
<blockquote>
<p>Iterative: read files by 4 chars each time, if less than 4 then it’s the end of file</p>
</blockquote>
<p>Runtime: $O(n)$, space: $O(n)$</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">char</span>[] buf, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">boolean</span> eof = <span class="keyword">false</span>;      <span class="comment">// end of file flag</span></span><br><span class="line">  <span class="keyword">int</span> total = <span class="number">0</span>;            <span class="comment">// total bytes have read</span></span><br><span class="line">  <span class="keyword">char</span>[] tmp = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">4</span>]; <span class="comment">// temp buffer</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (!eof &amp;&amp; total &lt; n) &#123;</span><br><span class="line">    <span class="keyword">int</span> count = read4(tmp);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// check if it&#x27;s the end of the file</span></span><br><span class="line">    eof = count &lt; <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// get the actual count</span></span><br><span class="line">    count = Math.min(count, n - total);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// copy from temp buffer to buf</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) </span><br><span class="line">      buf[total++] = tmp[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> total;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>158. Read N Characters Given Read4 II - Call multiple times</summary>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* The read4 API is defined in the parent class Reader4.</span></span><br><span class="line"><span class="comment">      int read4(char[] buf); */</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> <span class="keyword">extends</span> <span class="title">Reader4</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> buf Destination buffer</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> n   Maximum number of characters to read</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>    The number of characters read</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">char</span>[] buf4 = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">4</span>];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> buf4Index = <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> buf4Size = <span class="number">4</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">char</span>[] buf, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; n) &#123;</span><br><span class="line">            <span class="keyword">if</span> (buf4Index &gt;= buf4Size) &#123;</span><br><span class="line">               buf4Size = read4(buf4);</span><br><span class="line">               buf4Index = <span class="number">0</span>;</span><br><span class="line">               <span class="keyword">if</span> (buf4Size == <span class="number">0</span>) &#123;</span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">               &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            buf[i] = buf4[buf4Index];</span><br><span class="line">            buf4Index ++;</span><br><span class="line">            i ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<h2 id="Queues-Priority-Queues">Queues (Priority Queues)</h2>
<hr>
<details>
<summary></summary>
<blockquote></blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">```</span><br><span class="line">&lt;/details&gt;</span><br><span class="line"></span><br><span class="line">&lt;details&gt;</span><br><span class="line">&lt;summary&gt;<span class="function">DMV <span class="title">Hustle</span> <span class="params">(Okta OA <span class="number">2019</span>)</span>&lt;/summary&gt;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">&gt; </span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">``` java</span></span><br><span class="line"><span class="function">    <span class="keyword">public</span> <span class="keyword">int</span>[] <span class="title">solution</span><span class="params">(String[] customers, <span class="keyword">int</span> numWindows, <span class="keyword">int</span> queueSize)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[] ans = <span class="keyword">new</span> <span class="keyword">int</span>[numWindows+<span class="number">1</span>];</span><br><span class="line">        PriorityQueue&lt;<span class="keyword">int</span>[]&gt; pq = <span class="keyword">new</span> PriorityQueue&lt;&gt;((a, b) -&gt; a[<span class="number">1</span>] == b[<span class="number">1</span>] ? a[<span class="number">0</span>]-b[<span class="number">0</span>] : a[<span class="number">1</span>]-b[<span class="number">1</span>]); <span class="comment">// [id, endTime], sort by endTime</span></span><br><span class="line">    	Queue&lt;Integer&gt; q = <span class="keyword">new</span> LinkedList&lt;&gt;(); <span class="comment">// waitUntil time</span></span><br><span class="line">    	</span><br><span class="line">    	<span class="comment">// add all available windows</span></span><br><span class="line">    	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= numWindows; i++) pq.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;i, <span class="number">0</span>&#125;); </span><br><span class="line">	</span><br><span class="line">    	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; customers.length; i++)&#123;</span><br><span class="line">    	    <span class="keyword">int</span> arrTime = Integer.parseInt(customers[i].split(<span class="string">&quot;,&quot;</span>)[<span class="number">0</span>]);</span><br><span class="line">    	    <span class="keyword">int</span> serviceTime = Integer.parseInt(customers[i].split(<span class="string">&quot;,&quot;</span>)[<span class="number">1</span>]);</span><br><span class="line">    	    <span class="keyword">int</span> maxEnd = Integer.parseInt(customers[i].split(<span class="string">&quot;,&quot;</span>)[<span class="number">2</span>]);</span><br><span class="line">    	    <span class="keyword">int</span>[] curWindow = pq.poll();</span><br><span class="line">    	    </span><br><span class="line">    	    <span class="keyword">if</span>(arrTime &gt;= curWindow[<span class="number">1</span>])&#123; <span class="comment">// available when this customer arrives</span></span><br><span class="line">    	        curWindow[<span class="number">1</span>] = arrTime + serviceTime;</span><br><span class="line">    	        pq.add(curWindow);</span><br><span class="line">    	        ans[curWindow[<span class="number">0</span>]]++;</span><br><span class="line">    	        num++;</span><br><span class="line">    	    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(arrTime+maxEnd &lt; curWindow[<span class="number">1</span>]) &#123; <span class="comment">// exceed the tolerance time</span></span><br><span class="line">    	        pq.add(curWindow);</span><br><span class="line">    	        <span class="keyword">continue</span>;</span><br><span class="line">    	    &#125; <span class="keyword">else</span>&#123; <span class="comment">// wait and serve</span></span><br><span class="line">    	        <span class="keyword">while</span>(!q.isEmpty() &amp;&amp; q.peek() &lt;= arrTime) q.poll();</span><br><span class="line">    	        <span class="keyword">if</span>(q.size() &gt;= queueSize) <span class="keyword">continue</span>;</span><br><span class="line">    	        </span><br><span class="line">    	        curWindow[<span class="number">1</span>] += serviceTime;</span><br><span class="line">    	        pq.add(curWindow);</span><br><span class="line">    	        ans[curWindow[<span class="number">0</span>]]++;</span><br><span class="line">    	        num++;</span><br><span class="line">    	        q.add(curWindow[<span class="number">1</span>]); <span class="comment">// wait in the queue</span></span><br><span class="line">    	    &#125;</span><br><span class="line">    	&#125;</span><br><span class="line">    	ans[<span class="number">0</span>] = num;</span><br><span class="line">    	<span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>1094. Car Pooling (G)</summary>
<blockquote>
<p>Process all trips, adding passenger count to the start location, and removing it from the end location. After processing all trips, a positive value for the specific location tells that we are getting more passengers; negative - more empty seats.<br>
Finally, scan all stops and check if we ever exceed our vehicle capacity.</p>
</blockquote>
<p>Run time: $O(n)$, space: $O(n)$</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">carPooling</span><span class="params">(<span class="keyword">int</span>[][] trips, <span class="keyword">int</span> capacity)</span> </span>&#123;    </span><br><span class="line">    <span class="keyword">int</span> stops[] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">1001</span>]; </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> t[] : trips) &#123;</span><br><span class="line">        stops[t[<span class="number">1</span>]] += t[<span class="number">0</span>];</span><br><span class="line">        stops[t[<span class="number">2</span>]] -= t[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; capacity &gt;= <span class="number">0</span> &amp;&amp; i &lt; <span class="number">1001</span>; i++) capacity -= stops[i];</span><br><span class="line">    <span class="keyword">return</span> capacity &gt;= <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Save all time points and the change on current capacity<br>
Sort all the changes on the key of time points.<br>
Track the current capacity and return false if negative</p>
</blockquote>
<p>Run time: $O(n\log n)$, space: $O(n)$</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">carPooling</span><span class="params">(<span class="keyword">int</span>[][] trips, <span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">    Map&lt;Integer, Integer&gt; m = <span class="keyword">new</span> TreeMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span>[] t : trips) &#123;</span><br><span class="line">        m.put(t[<span class="number">1</span>], m.getOrDefault(t[<span class="number">1</span>], <span class="number">0</span>) + t[<span class="number">0</span>]);</span><br><span class="line">        m.put(t[<span class="number">2</span>], m.getOrDefault(t[<span class="number">2</span>], <span class="number">0</span>) - t[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> v : m.values()) &#123;</span><br><span class="line">        capacity -= v;</span><br><span class="line">        <span class="keyword">if</span> (capacity &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Sort the trips array by start location;<br>
Use a PriorityQueue to store the trips, order by ending location.<br>
Loop through the trips array, for each start location, keep polling out the arrays with correpoinding end location &lt;= current start location, for each polled out array, add the corresponding passengers to capacity; deduct passengers at current start location from capacity, if capacity &lt; 0, return false.<br>
Repeat 3 till end, if never encounter false, return true.</p>
</blockquote>
<p>Run time: $O(n\log n)$, space: $O(n)$</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">carPooling</span><span class="params">(<span class="keyword">int</span>[][] trips, <span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">    Arrays.sort(trips, Comparator.comparing(trip -&gt; trip[<span class="number">1</span>]));</span><br><span class="line">    PriorityQueue&lt;<span class="keyword">int</span>[]&gt; pq = <span class="keyword">new</span> PriorityQueue&lt;&gt;(Comparator.comparing(trip -&gt; trip[<span class="number">2</span>]));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span>[] trip : trips) &#123;</span><br><span class="line">        <span class="keyword">while</span> (!pq.isEmpty() &amp;&amp; trip[<span class="number">1</span>] &gt;= pq.peek()[<span class="number">2</span>]) &#123;<span class="comment">// any passengers need to get off?</span></span><br><span class="line">            capacity += pq.poll()[<span class="number">0</span>]; <span class="comment">// more capacity as passengers out.</span></span><br><span class="line">        &#125;</span><br><span class="line">        capacity -= trip[<span class="number">0</span>]; <span class="comment">// less capacity as passengers in.</span></span><br><span class="line">        <span class="keyword">if</span> (capacity &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>; <span class="comment">// not enough capacity.</span></span><br><span class="line">        pq.offer(trip); <span class="comment">// put into PriorityQueue the infomation at current location.</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>253	. Meeting Rooms II</summary>
<blockquote>
<p>Sort list by starting time, use PriorityQueue to store end time<br>
If current smallest one in the minHeap is earlier than the starting time in the array, poll it<br>
Return the size of minHeap</p>
</blockquote>
<p>Run time: $O(n\log n)$, space: $O(n)$</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minMeetingRooms</span><span class="params">(<span class="keyword">int</span>[][] meetings)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (meetings.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    Arrays.sort(meetings, Comparator.comparingInt(meeting -&gt; meeting[<span class="number">0</span>]));</span><br><span class="line">    Queue&lt;Integer&gt; minHeap = <span class="keyword">new</span> PriorityQueue&lt;&gt;();</span><br><span class="line">    minHeap.add(meetings[<span class="number">0</span>][<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; meetings.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (minHeap.peek() &lt;= meetings[i][<span class="number">0</span>])</span><br><span class="line">            minHeap.poll();</span><br><span class="line">        minHeap.add(meetings[i][<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> minHeap.size();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Sort array by starting time<br>
Use min heap sorted by ending time, add first interval into the heap<br>
For the rest of the intervals, see if the ending</p>
</blockquote>
<p>Run time: $O(n\log n)$, space: $O(n)$</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minMeetingRooms</span><span class="params">(Interval[] intervals)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(intervals == <span class="keyword">null</span> || intervals.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	Arrays.sort(intervals, (a,b) -&gt; a.start - b.start);</span><br><span class="line">	PriorityQueue&lt;Interval&gt; minHeap = <span class="keyword">new</span> PriorityQueue&lt;&gt;((a,b) -&gt; a.end - b.end);</span><br><span class="line">	minHeap.add(intervals[<span class="number">0</span>]);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; intervals.length; i++)&#123;</span><br><span class="line">		Interval current = intervals[i];</span><br><span class="line">		Interval earliest = minHeap.remove();</span><br><span class="line">		<span class="keyword">if</span>(current.start &gt;= earliest.end) earliest.end = current.end; <span class="comment">// no conlict</span></span><br><span class="line">		<span class="keyword">else</span> minHeap.add(current);</span><br><span class="line">		minHeap.add(earliest);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> minHeap.size();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<h2 id="Sliding-Window">Sliding Window</h2>
<hr>
<details>
<summary></summary>
<blockquote></blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">```</span><br><span class="line">&lt;/details&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;details&gt;</span><br><span class="line">&lt;summary&gt;438. Find All Anagrams in a String&lt;/summary&gt;</span><br><span class="line"></span><br><span class="line">&gt; </span><br><span class="line"></span><br><span class="line">Runtime: $O(n)$, space: $O(n)$</span><br><span class="line"></span><br><span class="line">``` java</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">findAnagrams</span><span class="params">(String s, String p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> matchSize = p.length();</span><br><span class="line">        <span class="keyword">int</span>[] map = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">256</span>];</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">// count the char number in p 计算p中各个字符的数量</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c:p.toCharArray()) map[c]++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// build window 开始进行sliding window</span></span><br><span class="line">        <span class="keyword">while</span> (right &lt; s.length())&#123;</span><br><span class="line">           <span class="comment">// this char exists in p  </span></span><br><span class="line">           <span class="comment">// 如果当前的char是存在于p中，则目标大小matchsize就得减少</span></span><br><span class="line">           <span class="comment">// 判断标准就是他的值不是为-1</span></span><br><span class="line">           <span class="keyword">if</span> (map[s.charAt(right)] &gt; <span class="number">0</span>)</span><br><span class="line">               matchSize --;</span><br><span class="line">            map[s.charAt(right)] --;</span><br><span class="line"></span><br><span class="line">           <span class="comment">// if the window size equals to p</span></span><br><span class="line">           <span class="comment">// 如果此时左右指针的差值等于p的长度</span></span><br><span class="line">           <span class="keyword">if</span> (right - left == p.length()-<span class="number">1</span>)&#123;</span><br><span class="line">               <span class="comment">// check matchSize equals to 0</span></span><br><span class="line">               <span class="comment">// 如果此时目标大小也是0，说明这就是需要的一个子串</span></span><br><span class="line">               <span class="keyword">if</span> (matchSize == <span class="number">0</span>)</span><br><span class="line">                   <span class="comment">// add the left index</span></span><br><span class="line">                   res.add(left);</span><br><span class="line"></span><br><span class="line">               <span class="comment">// move left pointer to start new search</span></span><br><span class="line">               <span class="comment">// 如果当这个字符原来是p中的话，现在移动指针需要还原以前原有的matchSize，开始新的搜索</span></span><br><span class="line">               <span class="keyword">if</span> (map[s.charAt(left)] &gt;= <span class="number">0</span>)</span><br><span class="line">                   matchSize ++;</span><br><span class="line">               <span class="comment">// 还原以前每个元素减去的1</span></span><br><span class="line">               map[s.charAt(left)]++;</span><br><span class="line">               left++;</span><br><span class="line">           &#125;</span><br><span class="line">          <span class="comment">// move right</span></span><br><span class="line">           <span class="comment">// 老哥们别忘了</span></span><br><span class="line">          right++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">findAnagrams</span><span class="params">(String s, String p)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span>(s == <span class="keyword">null</span> || p == <span class="keyword">null</span> || s.length() &lt; p.length()) <span class="keyword">return</span> ans;</span><br><span class="line">    <span class="keyword">int</span>[] a1 = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">    <span class="keyword">int</span>[] a2 = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">    <span class="keyword">int</span> pLen = p.length();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">char</span> c : p.toCharArray())&#123;</span><br><span class="line">        a1[c-<span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pLen; i++)&#123;</span><br><span class="line">        <span class="keyword">char</span> c = s.charAt(i);</span><br><span class="line">        a2[c-<span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(Arrays.equals(a1, a2)) ans.add(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = pLen; i &lt; s.length(); i++)&#123;</span><br><span class="line">        <span class="keyword">char</span> c = s.charAt(i);</span><br><span class="line">        a2[c-<span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        c = s.charAt(i - pLen);</span><br><span class="line">        a2[c-<span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">        <span class="keyword">if</span>(Arrays.equals(a1, a2)) ans.add(i - pLen + <span class="number">1</span>); <span class="comment">//O(26)</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>Longest Subarray having sum of elements at most K (G)</summary>
<blockquote>
<p>Relevant link: <a href="https://www.geeksforgeeks.org/longest-subarray-sum-elements-atmost-k/">GFG</a><br>
Given an array of integers, our goal is to find the length of largest subarray having sum of its elements at most <code>k</code> where <code>k&gt;0</code>.<br>
1.Traverse the array and check if on adding the current element its sum is less than or equal to k.</p>
</blockquote>
<ol start="2">
<li>If it’s less than k then add it to sum and increase the count.<br>
3.Else: Remove the first element of subarray and decrease the count.<br>
Again check if on adding the current element its sum is less than or equal to k.<br>
If it’s less than k then add it to sum and increase the count.</li>
<li>Keep track of Maximum count.</li>
</ol>
<p>Run time: $O(n)$, space: $O(1)$</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">atMostSum</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>; </span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>, maxcnt = <span class="number">0</span>; </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123; </span><br><span class="line">        <span class="comment">// If adding current element doesn&#x27;t </span></span><br><span class="line">        <span class="comment">// cross limit add it to current window </span></span><br><span class="line">        <span class="keyword">if</span> ((sum + arr[i]) &lt;= k) &#123; </span><br><span class="line">            sum += arr[i];  </span><br><span class="line">            cnt++; </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">// Else, remove first element of current </span></span><br><span class="line">        <span class="comment">// window. </span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(sum!=<span class="number">0</span>) &#123; </span><br><span class="line">        sum = sum - arr[i - cnt] + arr[i]; </span><br><span class="line">       &#125; </span><br><span class="line">        <span class="comment">// keep track of max length. </span></span><br><span class="line">        maxcnt = Math.max(cnt, maxcnt);  </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> maxcnt; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<blockquote>
<p>(Brute Force)<br>
Find all the subarrays whose sum is less than or equal to k and return the one with largest length.</p>
</blockquote>
<p>Run time: $O(n^2)$</p>
</details>
<details>
<summary>727. Minimum Window Substring (G)</summary>
<blockquote>
<p>Find minimum window substring from s that contains all characters in t.<br>
Need an indicator to show whether to move tail or head</p>
</blockquote>
<p>Run time: $O(n)$, space: $O(1)$</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">minWindow</span><span class="params">(String s, String t)</span></span>&#123;</span><br><span class="line">	Map&lt;Character, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">char</span> c: s.toCharArray()) map.put(temp, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">char</span> c: t.toCharArray())&#123;</span><br><span class="line">		<span class="keyword">if</span>(map.containsKey(c)) map.put(c, map.get(c)+<span class="number">1</span>);</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">return</span> <span class="string">&quot;&quot;</span>; <span class="comment">// does not contain all chars in t</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> start = <span class="number">0</span>, end = <span class="number">0</span>, minLen = Integer.MAX_VALUE, minStart = -<span class="number">1</span>, numOfTargets = t.length();</span><br><span class="line">	<span class="keyword">while</span>(end &lt; s.length())&#123;</span><br><span class="line">		<span class="keyword">char</span> c = s.charAt(end);</span><br><span class="line">		<span class="keyword">if</span>(map.get(c) &gt; <span class="number">0</span>) numOfTargets--; <span class="comment">// found a qualified char in s</span></span><br><span class="line">		map.put(c, map.get(c)-<span class="number">1</span>);</span><br><span class="line">		<span class="keyword">while</span>(numOfTargets == <span class="number">0</span>)&#123; <span class="comment">// the window satisfies the requirement</span></span><br><span class="line">			<span class="keyword">if</span>(minLen &gt; end - start + <span class="number">1</span>)&#123;</span><br><span class="line">				minLen = end - start + <span class="number">1</span>;</span><br><span class="line">				minStart = start;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">char</span> head = s.charAt(start);</span><br><span class="line">			<span class="keyword">if</span>(map.get(head) &gt;= <span class="number">0</span>) numOfTargets--;</span><br><span class="line">			map.put(head, map.get(head)+<span class="number">1</span>);</span><br><span class="line">			start++;</span><br><span class="line">		&#125;</span><br><span class="line">		end++; <span class="comment">// move tail of window forward</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> minStart == -<span class="number">1</span>? <span class="string">&quot;&quot;</span> : s.substring(minStart, minStart+minLen);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>1248. Count Number of Nice Subarrays</summary>
<blockquote>
<p>Sliding window: Exactly K times = at most K times - at most K - 1 times</p>
</blockquote>
<p>Run time: $O(n)$, space: $O(1)$</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numberOfSubarrays</span><span class="params">(<span class="keyword">int</span>[] A, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> atMost(A, k) - atMost(A, k - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">atMost</span><span class="params">(<span class="keyword">int</span>[] A, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>, i = <span class="number">0</span>, n = A.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">        k -= A[j] % <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span> (k &lt; <span class="number">0</span>)</span><br><span class="line">            k += A[i++] % <span class="number">2</span>;</span><br><span class="line">        res += j - i + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numberOfSubarrays</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>; </span><br><span class="line">    <span class="keyword">int</span> prefix[] = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length]; </span><br><span class="line">    <span class="keyword">int</span> odd = <span class="number">0</span>; </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// traverse in the array </span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123; </span><br><span class="line">        prefix[odd]++; </span><br><span class="line">        <span class="keyword">if</span> ((nums[i] &amp; <span class="number">1</span>) == <span class="number">1</span>) odd++; <span class="comment">// if odd </span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (odd &gt;= k) count += prefix[odd - k]; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> count; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>239. Sliding Window Maximum</summary>
<blockquote></blockquote>
<p>Run time: $O(n)$, space: depends</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">   <span class="keyword">public</span> <span class="keyword">int</span>[] maxSlidingWindow(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k) &#123;		</span><br><span class="line">	<span class="keyword">if</span> (nums == <span class="keyword">null</span> || k &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> n = nums.length;</span><br><span class="line">	<span class="keyword">int</span>[] r = <span class="keyword">new</span> <span class="keyword">int</span>[n-k+<span class="number">1</span>];</span><br><span class="line">	<span class="keyword">int</span> ri = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">// store index</span></span><br><span class="line">	Deque&lt;Integer&gt; q = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">		<span class="comment">// remove numbers out of range k</span></span><br><span class="line">		<span class="keyword">while</span> (!q.isEmpty() &amp;&amp; q.peek() &lt; i - k + <span class="number">1</span>) &#123;</span><br><span class="line">			q.poll();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// remove smaller numbers in k range as they are useless</span></span><br><span class="line">		<span class="keyword">while</span> (!q.isEmpty() &amp;&amp; nums[q.peekLast()] &lt; nums[i]) &#123;</span><br><span class="line">			q.pollLast();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// q contains index... r contains content</span></span><br><span class="line">		q.offer(i);</span><br><span class="line">		<span class="keyword">if</span> (i &gt;= k - <span class="number">1</span>) &#123;</span><br><span class="line">			r[ri++] = nums[q.peek()];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>159. Longest Substring with At Most Two Distinct Characters</summary>
<blockquote>
<p><code>i</code> records starting index, <code>j</code> records second distinct index<br>
First, we could simplify the problem by assuming that S contains two or more distinct characters, which means T must contain exactly two distinct characters. The brute force approach is O(n3) where n is the length of S. We can form every possible substring, and for each substring insert all characters into a Set which the Set’s size indicating the number of distinct characters. This could be easily improved to O(n2) by reusing the same Set when adding a character to form a new substring.</p>
</blockquote>
<p>The trick is to maintain a sliding window that always satisfies the invariant where there are always at most two distinct characters in it. When we add a new character that breaks this invariant, how can we move the begin pointer to satisfy the invariant? Using the above example, our first window is the substring “abba”. When we add the character ‘c’ into the sliding window, it breaks the invariant. Therefore, we have to readjust the window to satisfy the invariant again. The question is which starting point to choose so the invariant is satisfied.</p>
<p>Run time: $O(n)$, space: $O(n)$</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstringTwoDistinct</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">int</span> i = <span class="number">0</span>, j = -<span class="number">1</span>, maxLen = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt; s.length(); k++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (s.charAt(k) == s.charAt(k - <span class="number">1</span>)) <span class="keyword">continue</span>;</span><br><span class="line">      <span class="keyword">if</span> (j &gt;= <span class="number">0</span> &amp;&amp; s.charAt(j) != s.charAt(k)) &#123;</span><br><span class="line">         maxLen = Math.max(k - i, maxLen);</span><br><span class="line">		i = j + <span class="number">1</span>; </span><br><span class="line">      &#125;</span><br><span class="line">	j = k - <span class="number">1</span>; </span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> Math.max(s.length() - i, maxLen);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Follow up: at most k distinct characters</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstringTwoDistinct</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">int</span>[] count = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">256</span>];</span><br><span class="line">   <span class="keyword">int</span> i = <span class="number">0</span>, numDistinct = <span class="number">0</span>, maxLen = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; s.length(); j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (count[s.charAt(j)] == <span class="number">0</span>) numDistinct++;</span><br><span class="line">      count[s.charAt(j)]++;</span><br><span class="line">      <span class="keyword">while</span> (numDistinct &gt; <span class="number">2</span>) &#123;</span><br><span class="line">         count[s.charAt(i)]--;</span><br><span class="line">         <span class="keyword">if</span> (count[s.charAt(i)] == <span class="number">0</span>) numDistinct--;</span><br><span class="line">         i++;</span><br><span class="line">&#125;</span><br><span class="line">      maxLen = Math.max(j - i + <span class="number">1</span>, maxLen);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> maxLen;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<h2 id="Arrays-Matrices-List">Arrays, Matrices, List</h2>
<hr>
<details>
<summary></summary>
<blockquote></blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">```</span><br><span class="line">&lt;/details&gt;</span><br><span class="line"></span><br><span class="line">&lt;details&gt;</span><br><span class="line">&lt;summary&gt;287. Find the Duplicate Number&lt;/summary&gt;</span><br><span class="line"></span><br><span class="line">&gt; The problem is the same as find the cycle in LinkedList!</span><br><span class="line"></span><br><span class="line">Run time: $O(n)$, space: $O(<span class="number">1</span>)$</span><br><span class="line"></span><br><span class="line">``` java</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.length;</span><br><span class="line">    <span class="keyword">int</span> slow = n;</span><br><span class="line">    <span class="keyword">int</span> fast = n;</span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        slow = nums[slow-<span class="number">1</span>];</span><br><span class="line">        fast = nums[nums[fast-<span class="number">1</span>]-<span class="number">1</span>];</span><br><span class="line">    &#125;<span class="keyword">while</span>(slow != fast);</span><br><span class="line">    slow = n;</span><br><span class="line">    <span class="keyword">while</span>(slow != fast)&#123;</span><br><span class="line">        slow = nums[slow-<span class="number">1</span>];</span><br><span class="line">        fast = nums[fast-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> slow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>you perceive the indices as the values.<br>
Then count the number of values lesser than the mid<br>
If the if the count is lesser than mid, we assume the duplicate number should be on the higher side of the number scale.<br>
so we make low = mid + 1<br>
else we assume the duplicate number should be on the lower end of the number scale.<br>
so we make high = mid - 1<br>
We continue until low &lt;=hight no longer holds true.</p>
</blockquote>
<p>Run time: $O(\log n)$, space: $O(1)$</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> low = <span class="number">1</span>, high = nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = low + (high - low)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> a : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a &lt;= mid) cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cnt &lt;= mid) low = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> high = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> low;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>283. Move Zeroes</summary>
<blockquote>
<p>Keep track of the index of first zero position. Use a for loop, if the current number is not zero, swap with the zero index and increment the zero index.</p>
</blockquote>
<p>Run time: $O(n)$, space: $O(1)$</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">moveZeroes</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length &lt;= <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> cur = <span class="number">0</span>; <span class="comment">// zero position index</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i == cur)&#123;</span><br><span class="line">                cur++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> temp = nums[cur];</span><br><span class="line">            nums[cur++] = nums[i];</span><br><span class="line">            nums[i] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>54. Spiral Matrix (M)</summary>
<blockquote></blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">spiralOrder</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; ans = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span>(matrix.length == <span class="number">0</span>) <span class="keyword">return</span> ans;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> m = matrix.length, n = matrix[<span class="number">0</span>].length;</span><br><span class="line">    <span class="keyword">int</span> r = <span class="number">0</span>, c = <span class="number">0</span>;        </span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (r &lt; m &amp;&amp; c &lt; n)&#123;           </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = c; j &lt; n; j++) ans.add(matrix[r][j]);</span><br><span class="line">        r++; <span class="comment">// new starting row</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = r; j &lt; m; j++) ans.add(matrix[j][n-<span class="number">1</span>]);</span><br><span class="line">        n--; <span class="comment">// adjust row bound</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (r &lt; m) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = n-<span class="number">1</span>; j &gt;= c; j--) ans.add(matrix[m-<span class="number">1</span>][j]);</span><br><span class="line">        &#125;</span><br><span class="line">        m--; <span class="comment">// adjust col bound</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (c &lt; n) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = m-<span class="number">1</span>; j &gt;= r; j--) ans.add(matrix[j][c]);</span><br><span class="line">        &#125;</span><br><span class="line">        c++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Recursion way (asked in Point72 interview)</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">spiralOrder</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Check for edge cases for the matrix</span></span><br><span class="line">    <span class="keyword">if</span>(matrix == <span class="keyword">null</span> || matrix.length == <span class="number">0</span> || matrix[<span class="number">0</span>].length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">    </span><br><span class="line">    List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">    <span class="comment">// Run our recursion starting with the first and last eligible rows and the first and last eligible columns</span></span><br><span class="line">    spiralOut(res, matrix, <span class="number">0</span>, matrix.length - <span class="number">1</span>, <span class="number">0</span>, matrix[<span class="number">0</span>].length - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">spiralOut</span><span class="params">(List&lt;Integer&gt; res, <span class="keyword">int</span>[][] m, <span class="keyword">int</span> r1, <span class="keyword">int</span> r2, <span class="keyword">int</span> c1, <span class="keyword">int</span> c2)</span></span>&#123;</span><br><span class="line">    <span class="comment">// Return if we&#x27;ve exhausted all values to the point of invalid indices</span></span><br><span class="line">    <span class="keyword">if</span>(r1 &gt; r2 || c1 &gt; c2) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// TOP ROW: left to right</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> c = c1; c &lt;= c2; c++) res.add(m[r1][c]);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// RIGHT COLUMN: top to bottom</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> r = r1 + <span class="number">1</span>; r &lt;= r2; r++) res.add(m[r][c2]);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Return if we&#x27;ve processed the last row/column because we&#x27;d otherwise repeat values</span></span><br><span class="line">    <span class="keyword">if</span>(r1 == r2 || c1 == c2) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// BOTTOM ROW: right to left</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> c = c2 - <span class="number">1</span>; c &gt;= c1; c--) res.add(m[r2][c]);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// LEFT COLUMN: bottom to top</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> r = r2 - <span class="number">1</span>; r &gt;= r1 + <span class="number">1</span>; r--) res.add(m[r][c1]);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Recursion through the inner matrix</span></span><br><span class="line">    spiralOut(res, m, r1 + <span class="number">1</span>, r2 - <span class="number">1</span>, c1 + <span class="number">1</span>, c2 - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>1262. Greatest Sum Divisible by Three</summary>
<blockquote>
<p>Keep track of the minimum sums that are 1 mod 3 and 2 mod 3, and also update the total sum.</p>
</blockquote>
<p>Run time: $O(n)$, space: $O(1)$</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSumDivThree</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>, leftOne = <span class="number">20000</span>, leftTwo = <span class="number">20000</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> n:nums)&#123;</span><br><span class="line">        res+=n;</span><br><span class="line">        <span class="keyword">if</span>(n%<span class="number">3</span>==<span class="number">1</span>)&#123;</span><br><span class="line">            leftTwo = Math.min(leftTwo,leftOne+n);</span><br><span class="line">            leftOne = Math.min(leftOne,n);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(n%<span class="number">3</span>==<span class="number">2</span>) &#123;</span><br><span class="line">            leftOne = Math.min(leftOne,leftTwo+n);</span><br><span class="line">            leftTwo = Math.min(leftTwo,n);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(res%<span class="number">3</span>==<span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">    <span class="keyword">if</span>(res%<span class="number">3</span>==<span class="number">1</span>) <span class="keyword">return</span> res-leftOne;</span><br><span class="line">    <span class="keyword">return</span> res - leftTwo;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>1260. Shift 2D Grid</summary>
<blockquote>
<p>Number the cells from <code>0</code> to <code>m * n - 1</code>;<br>
In case <code>k &gt;= m * n</code>, use <code>k % (m * n)</code> to avoid those whole cycles of <code>m * n</code> operations;<br>
Since shifting right will put the last <code>k</code> cells in grid on the first k cells, we start from the <code>k</code>th cells from last, the index of which is <code>m * n - k % (m * n)</code>.</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; shiftGrid(<span class="keyword">int</span>[][] grid, <span class="keyword">int</span> k) &#123;</span><br><span class="line">    <span class="keyword">int</span> m = grid.length, n = grid[<span class="number">0</span>].length; </span><br><span class="line">    <span class="keyword">int</span> start = m * n - k % (m * n);</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt; m * n + start; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> j = i % (m * n), r = j / n, c = j % n;</span><br><span class="line">        <span class="keyword">if</span> ((i - start) % n == <span class="number">0</span>)</span><br><span class="line">            ans.add(<span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">        ans.peekLast().add(grid[r][c]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>665. Non-decreasing Array (M)</summary>
<blockquote>
<p>Keep track of the number of decreasing pairs<br>
First set the previous element to be -1, update it in each iteration<br>
If the current one is greater than the next one, check if the previous element plus 1 if greater than the next one or not, if it is, set the next one to be the current element plus 1</p>
</blockquote>
<p>Run time: $O(n)$, space: $O(1)$</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">checkPossibility</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> decreasingCount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> prev = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length-<span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] &gt; nums[i+<span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (prev+<span class="number">1</span> &gt; nums[i+<span class="number">1</span>]) nums[i+<span class="number">1</span>] = nums[i] + <span class="number">1</span>;</span><br><span class="line">            decreasingCount++;</span><br><span class="line">        &#125;</span><br><span class="line">        prev = nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> decreasingCount &lt;= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>325. Maximum Size Subarray Sum Equals K (G)</summary>
<blockquote>
<p>Use a map to store &lt;tempSum, index&gt; and iterate through the array<br>
If <code>sum-k</code> is in the map, update the longest length of subarray</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArrayLen</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    map.put(<span class="number">0</span>, -<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;nums.length; i++)&#123;</span><br><span class="line">        sum += nums[i];</span><br><span class="line">        <span class="keyword">if</span>(map.containsKey(sum - k))&#123;</span><br><span class="line">            result = Math.max(result, i - map.get(sum - k));</span><br><span class="line">        &#125;</span><br><span class="line">        map.putIfAbsent(sum, i);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>363. Max Sum of Rectangle No Larger Than K (G)</summary>
<blockquote>
<p>Use the same rule to get the all the submatrix prefixSum. The reason $\log n$` is here we use balanced BST here. (In java, TreeSet or TreeMap)</p>
</blockquote>
<p>Run time: $O(n^2 m\log m)$, space: $O(n)$, where $n$ is the col size and $m$ is row size</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSumSubmatrix</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> row = matrix.length;</span><br><span class="line">    <span class="keyword">int</span> col = matrix[<span class="number">0</span>].length;</span><br><span class="line">    <span class="keyword">int</span> result = Integer.MIN_VALUE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; col; j++) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] sum = <span class="keyword">new</span> <span class="keyword">int</span>[row];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> current = j; current &lt; col; current++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; i++) &#123;</span><br><span class="line">                sum[i] += matrix[i][current];</span><br><span class="line">            &#125;</span><br><span class="line">            result = Math.max(find(sum, k), result);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//O(MlgM) find the maxium gap</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span>[] sum, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result = Integer.MIN_VALUE;</span><br><span class="line">    TreeSet&lt;Integer&gt; set = <span class="keyword">new</span> TreeSet&lt;&gt;();</span><br><span class="line">    set.add(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> current = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sum.length; i++) &#123;</span><br><span class="line">        current += sum[i];</span><br><span class="line"></span><br><span class="line">        Integer target = set.ceiling(current - k); </span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(target != <span class="keyword">null</span>) &#123;</span><br><span class="line">            result = Math.max(result, current - target);</span><br><span class="line">        &#125;</span><br><span class="line">        set.add(current);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>Print shortest path to print a string on screen (G)</summary>
<blockquote>
<p>Relevant link: <a href="https://www.geeksforgeeks.org/print-shortest-path-print-string-screen/">GFG</a> Given a screen containing alphabets from A-Z, we can go from one character to another characters using a remote. The remote contains left, right, top and bottom keys. Find shortest possible path to type all characters of given string using the remote. Initial position is top left and all characters of input string should be printed in order.<br>
The idea is to consider screen as 2D-matrix of characters. Then we consider all characters of given string one by one and print out the shortest path between current character and next character in the matrix. In order to find shortest path, we consider the coordinates of current character and next character in the matrix. Based on the difference between x and y values of current and next character’s coordinates, we move left, right, top or bottom.</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Function to print shortest possible path to </span></span><br><span class="line"><span class="comment">// type all characters of given string using a remote </span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printPath</span><span class="params">(String str)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>; </span><br><span class="line">    <span class="keyword">int</span> curX = <span class="number">0</span>, curY = <span class="number">0</span>; <span class="comment">// start from character &#x27;A&#x27; present at position (0, 0) </span></span><br><span class="line">    <span class="keyword">while</span> (i &lt; str.length()) &#123; </span><br><span class="line">        <span class="comment">// find coordinates of next character </span></span><br><span class="line">        <span class="keyword">int</span> nextX = (str.charAt(i) - <span class="string">&#x27;A&#x27;</span>) / <span class="number">5</span>; </span><br><span class="line">        <span class="keyword">int</span> nextY = (str.charAt(i) - <span class="string">&#x27;B&#x27;</span> + <span class="number">1</span>) % <span class="number">5</span>; </span><br><span class="line">   </span><br><span class="line">        <span class="keyword">while</span> (curX &gt; nextX) &#123; <span class="comment">// Move Up if destination is above</span></span><br><span class="line">            System.out.println(<span class="string">&quot;Move Up&quot;</span>); </span><br><span class="line">            curX--; </span><br><span class="line">        &#125; </span><br><span class="line">   </span><br><span class="line">        <span class="keyword">while</span> (curY &gt; nextY) &#123; <span class="comment">// Move Left if destination is to the left </span></span><br><span class="line">            System.out.println(<span class="string">&quot;Move Left&quot;</span>); </span><br><span class="line">            curY--; </span><br><span class="line">        &#125; </span><br><span class="line">   </span><br><span class="line">        <span class="keyword">while</span> (curX &lt; nextX) &#123; <span class="comment">// Move down if destination is below </span></span><br><span class="line">            System.out.println(<span class="string">&quot;Move Down&quot;</span>); </span><br><span class="line">            curX++; </span><br><span class="line">        &#125; </span><br><span class="line">   </span><br><span class="line">        <span class="keyword">while</span> (curY &lt; nextY) &#123; <span class="comment">// Move Right if destination is to the right  </span></span><br><span class="line">            System.out.println(<span class="string">&quot;Move Right&quot;</span>); </span><br><span class="line">            curY++; </span><br><span class="line">        &#125; </span><br><span class="line">   </span><br><span class="line">        System.out.println(<span class="string">&quot;Press OK&quot;</span>); <span class="comment">// At this point, destination is reached  </span></span><br><span class="line">        i++; </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>36. Valid Sudoku (M)</summary>
<blockquote>
<p>In outer for loop, use three sets to store current row, column, and cube values<br>
For checking numbers in cube, the entry is <code>board[i+j/3][3*j%3+j%3]</code>.</p>
</blockquote>
<p>Run time: $O(n^2)$, space: $O(n^2)$</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidSudoku</span><span class="params">(<span class="keyword">char</span>[][] board)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;<span class="number">9</span>; i++)&#123;</span><br><span class="line">        HashSet&lt;Character&gt; rows = <span class="keyword">new</span> HashSet&lt;Character&gt;();</span><br><span class="line">        HashSet&lt;Character&gt; columns = <span class="keyword">new</span> HashSet&lt;Character&gt;();</span><br><span class="line">        HashSet&lt;Character&gt; cube = <span class="keyword">new</span> HashSet&lt;Character&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">9</span>;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(board[i][j]!=<span class="string">&#x27;.&#x27;</span> &amp;&amp; !rows.add(board[i][j]))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">if</span>(board[j][i]!=<span class="string">&#x27;.&#x27;</span> &amp;&amp; !columns.add(board[j][i]))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">int</span> RowIndex = <span class="number">3</span>*(i/<span class="number">3</span>);</span><br><span class="line">            <span class="keyword">int</span> ColIndex = <span class="number">3</span>*(i%<span class="number">3</span>);</span><br><span class="line">            <span class="keyword">if</span>(board[RowIndex + j/<span class="number">3</span>][ColIndex + j%<span class="number">3</span>]!=<span class="string">&#x27;.&#x27;</span> &amp;&amp; !cube.add(board[RowIndex + j/<span class="number">3</span>][ColIndex + j%<span class="number">3</span>]))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Use one set to store occurrences by adding string to differentiate entry</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidSudoku</span><span class="params">(<span class="keyword">char</span>[][] board)</span> </span>&#123;</span><br><span class="line">    Set seen = <span class="keyword">new</span> HashSet();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">9</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;<span class="number">9</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">char</span> number = board[i][j];</span><br><span class="line">            <span class="keyword">if</span> (number != <span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">                <span class="keyword">if</span> (!seen.add(number + <span class="string">&quot; in row &quot;</span> + i) ||</span><br><span class="line">                    !seen.add(number + <span class="string">&quot; in column &quot;</span> + j) ||</span><br><span class="line">                    !seen.add(number + <span class="string">&quot; in block &quot;</span> + i/<span class="number">3</span> + <span class="string">&quot;-&quot;</span> + j/<span class="number">3</span>))</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>658. Find K Closest Elements (G)</summary>
<blockquote>
<p>Binary search<br>
We can binary research <code>i</code><br>
We compare the distance between <code>x - A[mid]</code> and <code>A[mid - k] - x</code><br>
If <code>x - A[mid] &gt; A[mid + k] - x</code>,<br>
it means <code>A[mid + 1] ~ A[mid + k]</code> is better than <code>A[mid] ~ A[mid + k - 1]</code>,<br>
and we have mid smaller than the right <code>i</code>.<br>
So assign <code>left = mid + 1</code>.</p>
</blockquote>
<p>Run time: $O(log(N - K))$ to binary research and find result, $O(K)$ to create the returned list.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">findClosestElements</span><span class="params">(<span class="keyword">int</span>[] A, <span class="keyword">int</span> k, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = A.length - k;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (x - A[mid] &gt; A[mid + k] - x)</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            right = mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Arrays.stream(A, left, left + k).boxed().collect(Collectors.toList());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Use two pointers to find the bound of qualified subarray<br>
While the bound &gt;= k, if the distance of lo and x is greater than that of hi and x, move lo, otherwise move hi</p>
</blockquote>
<p>Run time: $O(n)$, space: $O(n)$</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">findClosestElements</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> k, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">int</span> lo = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> hi = arr.length - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (hi - lo &gt;= k) &#123;</span><br><span class="line">	<span class="keyword">if</span> (Math.abs(arr[lo] - x) &gt; Math.abs(arr[hi] - x)) &#123;</span><br><span class="line">		lo++;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		hi--;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">List&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;(k);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = lo; i &lt;= hi; i++) &#123;</span><br><span class="line">	result.add(arr[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>1250. Check If It Is a Good Array</summary>
<blockquote>
<p>Chinese Remainder Theorem</p>
</blockquote>
<p>Run time: $O(n)$, space: $O(1)$</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isGoodArray</span><span class="params">(<span class="keyword">int</span>[] A)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = A[<span class="number">0</span>], y;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> a: A) &#123;</span><br><span class="line">        <span class="keyword">while</span> (a &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            y = x % a;</span><br><span class="line">            x = a;</span><br><span class="line">            a = y;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x == <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isGoodArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> g = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        g = gcd(g, nums[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (g == <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">gcd</span><span class="params">(<span class="keyword">long</span> a, <span class="keyword">long</span> b)</span> </span>&#123; </span><br><span class="line">  <span class="keyword">if</span> (b == <span class="number">0</span>) <span class="keyword">return</span> a; </span><br><span class="line">  <span class="keyword">return</span> gcd(b, a % b);  </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>1243. Array Transformation</summary>
<blockquote>
<p>Use a flag to indicate if this round has no change</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">transformArray</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(arr == <span class="keyword">null</span> || arr.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">    <span class="keyword">if</span>(arr.length == <span class="number">1</span>) <span class="keyword">return</span> Arrays.asList(arr[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">if</span>(arr.length == <span class="number">2</span>) <span class="keyword">return</span> Arrays.asList(arr[<span class="number">0</span>], arr[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">int</span> prev = arr[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">boolean</span> noChange = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">while</span>(!noChange)&#123;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.length-<span class="number">1</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> temp = arr[i], next = arr[i+<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(temp &lt; prev &amp;&amp; temp &lt; next) arr[i]++;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(temp &gt; prev &amp;&amp; temp &gt; next) arr[i]--;</span><br><span class="line">            <span class="comment">// System.out.println(i+&quot; &quot;+Arrays.toString(arr));</span></span><br><span class="line">            <span class="keyword">if</span>(temp != arr[i]) num++;</span><br><span class="line">            <span class="keyword">if</span>(i == arr.length-<span class="number">2</span>) prev = arr[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">else</span> prev = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(num == <span class="number">0</span>) noChange = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(); </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> t : arr) list.add(t); </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> list; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">transformArray</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] ans = <span class="keyword">new</span> <span class="keyword">int</span>[arr.length];</span><br><span class="line">    <span class="keyword">while</span> (!Arrays.equals(ans, arr)) &#123;</span><br><span class="line">        ans = arr.clone();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.length - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ans[i - <span class="number">1</span>] &lt; ans[i] &amp;&amp; ans[i] &gt; ans[i + <span class="number">1</span>]) &#123;</span><br><span class="line">                --arr[i];</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> ( ans[i - <span class="number">1</span>] &gt; ans[i] &amp;&amp; ans[i] &lt; ans[i + <span class="number">1</span>]) &#123;</span><br><span class="line">                ++arr[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr.length &lt; <span class="number">3</span> ? arr : Arrays.stream(ans).boxed().collect(Collectors.toList());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>560. Subarray Sum Equals K</summary>
<blockquote>
<p>Use HashMap to put &lt;sum, num occurrences&gt;, first put &lt;0, 1&gt;<br>
Calculate the accumulated sum, and see if the map contains <code>sum-k</code><br>
If there is, get the number of occurrences and add to the count<br>
Then put this sum and update the number of occurrences</p>
</blockquote>
<p>Run time: $O(n)$, space: $O(n)$</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">subarraySum</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>, result = <span class="number">0</span>;</span><br><span class="line">    Map&lt;Integer, Integer&gt; preSum = <span class="keyword">new</span> HashMap&lt;&gt;(); <span class="comment">// sum, num of occurences</span></span><br><span class="line">    preSum.put(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        sum += nums[i];</span><br><span class="line">        <span class="keyword">if</span> (preSum.containsKey(sum - k)) result += preSum.get(sum - k);</span><br><span class="line"></span><br><span class="line">        preSum.put(sum, preSum.getOrDefault(sum, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Normal way<br>
Run time: $O(n^2)$, space: $O(1)$</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">subarraySum</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> minLength = nums.length;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] == k) count++;</span><br><span class="line">        <span class="keyword">int</span> temp = nums[i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i-<span class="number">1</span>; j &gt;= <span class="number">0</span>; j--)&#123;</span><br><span class="line">            temp += nums[j];</span><br><span class="line">            <span class="keyword">if</span>(temp == k) count++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>88. Merge Sorted Array (M)</summary>
<blockquote>
<p><code>i</code> records last index in <code>nums1</code>, <code>j</code> records last valid index in <code>nums1</code>; <code>k</code> records last index in <code>nums2</code></p>
</blockquote>
<p>Run time: $O(n)$, space: $O(1)$</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span> m, <span class="keyword">int</span>[] nums2, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = m+n-<span class="number">1</span>, j = m-<span class="number">1</span>, k = n-<span class="number">1</span>; i&gt;=<span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (j &lt; <span class="number">0</span>) nums1[i] = nums2[k--];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (k &lt; <span class="number">0</span>) <span class="keyword">continue</span>; <span class="comment">// rest numbers in nums1 is sorted already</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nums1[j] &gt; nums2[k]) nums1[i] = nums1[j--];</span><br><span class="line">        <span class="keyword">else</span> nums1[i] = nums2[k--];</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>238. Product of Array Except Self</summary>
<blockquote>
<p>Use one array to keep track of the products of all previous numbers<br>
Then a backward loop and a variable to accumlate the product</p>
</blockquote>
<p>Run time: $O(n)$, space: $O(1)$</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] productExceptSelf(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.length;</span><br><span class="line">    <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">    res[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) res[i] = res[i-<span class="number">1</span>] * nums[i-<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> right = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        res[i] *= right;</span><br><span class="line">        right *= nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>62. Unique Paths</summary>
<blockquote>
<p>Same way, use fewer space</p>
</blockquote>
<p>Run time: $O(mn)$, space: $O(n)$</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (m == <span class="number">0</span> || n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (m == <span class="number">1</span> || n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) dp[i] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; j++) dp[j] += dp[j - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Straightforward way (this is also called DP???)</p>
</blockquote>
<p>Run time: $O(mn)$, space: $O(mn)$</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(m == <span class="number">0</span> || n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span>[][] path = <span class="keyword">new</span> <span class="keyword">int</span>[m][n];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) path[<span class="number">0</span>][j] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) path[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; j++)&#123;</span><br><span class="line">            path[i][j] = path[i][j-<span class="number">1</span>] + path[i-<span class="number">1</span>][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> path[m-<span class="number">1</span>][n-<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Math way, binomial coefficient, might not work as expected when <code>m,n</code> is pretty large</p>
</blockquote>
<p>Run time: $O(n)$, space: $O(1)$</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> value = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        value *= ((<span class="keyword">double</span>) (m + i - <span class="number">1</span>) / (<span class="keyword">double</span>) i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">int</span>) Math.round(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>33. Search in Rotated Sorted Array</summary>
<blockquote>
<p>Use binary search to find the target, need start and end indices<br>
If start is smaller than mid, then this range is in order; otherwise right part is in order<br>
If target is in the ordered range, update the start/end index<br>
More ways: <a href="https://leetcode.wang/leetCode-33-Search-in-Rotated-Sorted-Array.html">link</a></p>
</blockquote>
<p>Run time: $O(\log n)$, space: $O(1)$</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> end = nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (start &lt;= end) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (start + end) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (target == nums[mid]) <span class="keyword">return</span> mid;</span><br><span class="line">        <span class="keyword">if</span> (nums[start] &lt;= nums[mid]) &#123; <span class="comment">// left part is in increasing order</span></span><br><span class="line">            <span class="comment">// target is here</span></span><br><span class="line">            <span class="keyword">if</span> (target &gt;= nums[start] &amp;&amp; target &lt; nums[mid]) end = mid - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> start = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// right part is in increasing order</span></span><br><span class="line">            <span class="keyword">if</span> (target &gt; nums[mid] &amp;&amp; target &lt;= nums[end]) start = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> end = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>523. Continuous Subarray Sum</summary>
<blockquote>
<p>Use map to record <code>tempSum mod k</code> and the current index<br>
If the  tempSum is in the map, which means that the range <code>(i,j]</code> is a qualified subarray.</p>
</blockquote>
<p>Run time: $O(n)$, space: $O(n)$</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">checkSubarraySum</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;Integer, Integer&gt;()&#123;&#123;put(<span class="number">0</span>,-<span class="number">1</span>);&#125;&#125;;</span><br><span class="line">    <span class="keyword">int</span> tempSum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">        tempSum += nums[i];</span><br><span class="line">        <span class="keyword">if</span> (k != <span class="number">0</span>) tempSum %= k; <span class="comment">// get tempSum mod k if k is not zero </span></span><br><span class="line">        Integer prev = map.get(tempSum); <span class="comment">// get the corresponding index</span></span><br><span class="line">        <span class="keyword">if</span> (prev != <span class="keyword">null</span>) &#123; <span class="comment">// exist before, the range of subarray is qualified</span></span><br><span class="line">            <span class="keyword">if</span> (i - prev &gt; <span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> map.put(tempSum, i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>59. Spiral Matrix II</summary>
<blockquote>
<p>Set four bounds: rowBegin, rowEnd, colBegin, colEnd. Follow the direction and use four for loops to fill in the number.</p>
</blockquote>
<p>Run time: $O(n^2)$, space: $O(n^2)$</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[][] generateMatrix(<span class="keyword">int</span> n) &#123;</span><br><span class="line">    <span class="keyword">int</span>[][] res = <span class="keyword">new</span> <span class="keyword">int</span>[n][n];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> cur = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> rowBegin = <span class="number">0</span>, rowEnd = n - <span class="number">1</span>, colBegin = <span class="number">0</span>, colEnd = n - <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(cur &lt;= n*n) &#123;</span><br><span class="line">            <span class="keyword">int</span> i = rowBegin, j = colBegin;</span><br><span class="line">            <span class="comment">//left to right</span></span><br><span class="line">            <span class="keyword">for</span>(j = colBegin ; j &lt;= colEnd; j++) res[rowBegin][j] = cur++;</span><br><span class="line">            rowBegin++;</span><br><span class="line">            <span class="comment">//top to bottom</span></span><br><span class="line">            <span class="keyword">for</span>(i = rowBegin ; i &lt;= rowEnd; i++) res[i][colEnd] = cur++;</span><br><span class="line">            colEnd--;</span><br><span class="line">            <span class="comment">//right to left</span></span><br><span class="line">            <span class="keyword">for</span>(j = colEnd ; j &gt;= colBegin; j--) res[rowEnd][j] = cur++;</span><br><span class="line">            rowEnd--;</span><br><span class="line">            <span class="comment">//bot to top</span></span><br><span class="line">            <span class="keyword">for</span>(i = rowEnd; i &gt;= rowBegin; i--) res[i][colBegin] = cur++;</span><br><span class="line">            colBegin++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>215. Kth Largest Element in an Array (M)</summary>
<blockquote>
<p>Quick select: two pointers, move from two sides of array, sort and see if the element is found</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> quickSelect(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>, k);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">quickSelect</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> low, <span class="keyword">int</span> high, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pivot = low;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// use quick sort&#x27;s idea</span></span><br><span class="line">    <span class="comment">// put nums that are &lt;= pivot to the left</span></span><br><span class="line">    <span class="comment">// put nums that are  &gt; pivot to the right</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = low; j &lt; high; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[j] &lt;= nums[high]) swap(nums, pivot++, j);</span><br><span class="line">    &#125;</span><br><span class="line">    swap(nums, pivot, high);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// count the nums that are &gt; pivot from high</span></span><br><span class="line">    <span class="keyword">int</span> count = high - pivot + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// pivot is the one!</span></span><br><span class="line">    <span class="keyword">if</span> (count == k) <span class="keyword">return</span> nums[pivot];</span><br><span class="line">    <span class="comment">// pivot is too small, so it must be on the right</span></span><br><span class="line">    <span class="keyword">if</span> (count &gt; k) <span class="keyword">return</span> quickSelect(nums, pivot + <span class="number">1</span>, high, k);</span><br><span class="line">    <span class="comment">// pivot is too big, so it must be on the left</span></span><br><span class="line">    <span class="keyword">return</span> quickSelect(nums, low, pivot - <span class="number">1</span>, k - count);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = nums[i];</span><br><span class="line">    nums[i] = nums[j];</span><br><span class="line">    nums[j] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    k = nums.length - k; <span class="comment">// convert to index of k largest</span></span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>, r = nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">        <span class="keyword">int</span> i = l; <span class="comment">// partition [l,r] by A[l]: [l,i]&lt;A[l], [i+1,j)&gt;=A[l]</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = l + <span class="number">1</span>; j &lt;= r; j++)</span><br><span class="line">            <span class="keyword">if</span> (nums[j] &lt; nums[l]) swap(nums, j, ++i);</span><br><span class="line">        swap(nums, l, i);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (k &lt; i) r = i - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (k &gt; i) l = i + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>; <span class="comment">// k is invalid</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = a[i];</span><br><span class="line">    a[i] = a[j];</span><br><span class="line">    a[j] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Common way: sort the array then loop and find the element</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(k &gt; nums.length) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    Arrays.sort(nums);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = nums.length-<span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i == nums.length-k) <span class="keyword">return</span> nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>128. Longest Consecutive Sequence</summary>
<blockquote>
<p>Use a hashset and put all elements in<br>
Then loop through the array, set the left and right pointer, if removing this element from the set is successful, then increment/decrement by 1. After two while loops, use <code>right-left-2+1</code> to find the current length.</p>
</blockquote>
<p>Run time: $O(n)$, space: $O(n)$</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestConsecutive</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    Set&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> n : nums) set.add(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> n : nums)&#123;</span><br><span class="line">        <span class="keyword">int</span> left = n-<span class="number">1</span>, right = n+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(set.remove(left)) left--;</span><br><span class="line">        <span class="keyword">while</span>(set.remove(right)) right++;</span><br><span class="line">        ans = Math.max(ans, right-left-<span class="number">2</span>+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>334. Increasing Triplet Subsequence</summary>
<blockquote>
<p>It is the same is finding the two min elements and see if there is a third one<br>
If it’s the minimum, update; else if it is smaller than the second minimum, update<br>
else, there exists an increasing triplet subsequence!</p>
</blockquote>
<p>Run time: $O(n)$, space: $O(1)$</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">increasingTriplet</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> min = Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">int</span> min2 = Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> num : nums)&#123;</span><br><span class="line">        <span class="keyword">if</span>(num &lt;= min) min = num;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(num &lt; min2) min2 = num;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(num &gt; min2) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>1144. Decrease Elements To Make Array Zigzag</summary>
<blockquote></blockquote>
<p>Run time: $O(n)$, space: $O(1)$</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">movesToMakeZigzag</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res[] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>],  n = nums.length, left, right;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        left = i &gt; <span class="number">0</span> ? nums[i - <span class="number">1</span>] : <span class="number">1001</span>;</span><br><span class="line">        right = i + <span class="number">1</span> &lt; n ? nums[i + <span class="number">1</span>] : <span class="number">1001</span>;</span><br><span class="line">        res[i % <span class="number">2</span>] += Math.max(<span class="number">0</span>, nums[i] - Math.min(left, right) + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Math.min(res[<span class="number">0</span>], res[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>Roblox OA 2</summary>
<blockquote>
<p>GFG link: <a href="https://www.geeksforgeeks.org/maximum-value-array-m-range-increment-operations/">Maximum value in an array after m range increment operations</a></p>
</blockquote>
<p>Run time: $O(m+n)$, space: $O(n)$</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">listMax</span><span class="params">(<span class="keyword">int</span> n, List&lt;List&lt;Integer&gt;&gt; operations)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span>[] a = <span class="keyword">new</span> <span class="keyword">long</span>[n+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">long</span> max = <span class="number">0</span>, sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; operations.size(); i++)&#123;</span><br><span class="line">        List&lt;Integer&gt; op = operations.get(i);</span><br><span class="line">        <span class="keyword">int</span> start = op.get(<span class="number">0</span>)-<span class="number">1</span>, end = op.get(<span class="number">1</span>)-<span class="number">1</span>, num = op.get(<span class="number">2</span>);</span><br><span class="line">        a[start] += num; </span><br><span class="line">        a[end + <span class="number">1</span>] -= num; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123; </span><br><span class="line">        sum += a[i]; </span><br><span class="line">        max = Math.max(max, sum); </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>1217. Play with Chips</summary>
<blockquote>
<p>Since only when moving odd steps, the cost will be one, we only need to keep track of two possible answers.</p>
</blockquote>
<p>Run time: $O(n)$, space: $O(1)$</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minCostToMoveChips</span><span class="params">(<span class="keyword">int</span>[] chips)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] cnt = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> chip : chips)</span><br><span class="line">        ++cnt[chip % <span class="number">2</span>];</span><br><span class="line">    <span class="keyword">return</span> Math.min(cnt[<span class="number">0</span>], cnt[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Brute force: loop through every possible solution and find the min one</p>
</blockquote>
<p>Run time: $O(n^2)$, space: $O(1)$</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minCostToMoveChips</span><span class="params">(<span class="keyword">int</span>[] chips)</span> </span>&#123;</span><br><span class="line">    Set&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> c: chips) set.add(c);</span><br><span class="line">    <span class="keyword">int</span> min = Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> loc: set)&#123;</span><br><span class="line">        <span class="keyword">int</span> total = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> c: chips)&#123;</span><br><span class="line">            <span class="keyword">int</span> dist = Math.abs(c - loc);</span><br><span class="line">            total += dist % <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        min = Math.min(min, total);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> min;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>15. 3Sum</summary>
<blockquote>
<p>Loop from index 0 to length-2<br>
Two pointers from i+1 and length-1<br>
Once find an answer, move two pointers to skip duplicates, then increment/decrement</p>
</blockquote>
<p>Run time: $O(n^2)$, space: depends</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; threeSum(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">    Arrays.sort(nums);</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> LinkedList&lt;&gt;(); </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length-<span class="number">2</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">0</span> || (i &gt; <span class="number">0</span> &amp;&amp; nums[i] != nums[i-<span class="number">1</span>])) &#123; <span class="comment">// skip duplicate</span></span><br><span class="line">            <span class="keyword">int</span> lo = i+<span class="number">1</span>, hi = nums.length-<span class="number">1</span>, sum = <span class="number">0</span> - nums[i];</span><br><span class="line">            <span class="keyword">while</span> (lo &lt; hi) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[lo] + nums[hi] == sum) &#123;</span><br><span class="line">                    res.add(Arrays.asList(nums[i], nums[lo], nums[hi]));</span><br><span class="line">                    <span class="keyword">while</span> (lo &lt; hi &amp;&amp; nums[lo] == nums[lo+<span class="number">1</span>]) lo++;</span><br><span class="line">                    <span class="keyword">while</span> (lo &lt; hi &amp;&amp; nums[hi] == nums[hi-<span class="number">1</span>]) hi--;</span><br><span class="line">                    lo++; hi--;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[lo] + nums[hi] &lt; sum) lo++;</span><br><span class="line">                <span class="keyword">else</span> hi--;</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>766. Toeplitz Matrix</summary>
<blockquote>
<p>Loop through first row and column, check edge cases<br>
Run time: $O(n^2)$, space: $O(1)$</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isToeplitzMatrix</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(matrix.length == <span class="number">1</span> || matrix[<span class="number">0</span>].length == <span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; matrix.length; i++)&#123; <span class="comment">// left part</span></span><br><span class="line">        <span class="keyword">int</span> curr = matrix[i][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; matrix.length &amp;&amp; j-i &lt; matrix[<span class="number">0</span>].length; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(matrix[j][j-i] != curr) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; matrix[<span class="number">0</span>].length; i++)&#123; <span class="comment">// right part</span></span><br><span class="line">        <span class="keyword">int</span> curr = matrix[<span class="number">0</span>][i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i+<span class="number">1</span>; j-i &lt; matrix.length &amp;&amp; j &lt; matrix[<span class="number">0</span>].length; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(matrix[j-i][j] != curr) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>163. Missing Ranges</summary>
<blockquote>
<p>One loop, one variable to keep track of the current starting range<br>
Skip duplicate, increment by 1 if the same<br>
Otherwise, find the range between the var and the current num minus 1<br>
Then update the var<br>
Run time: $O(n)$, space: $O(n)$</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">findMissingRanges</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> lower, <span class="keyword">int</span> upper)</span> </span>&#123;</span><br><span class="line">	List&lt;String&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    	<span class="keyword">int</span> start = lower;        </span><br><span class="line">   	 <span class="keyword">if</span>(lower==Integer.MAX_VALUE) <span class="keyword">return</span> result; <span class="comment">// no need to continue</span></span><br><span class="line">	 <span class="keyword">for</span>(inti i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">	 	<span class="keyword">if</span>(i &lt; nums.length-<span class="number">1</span> &amp;&amp; nums[i] == nums[i+<span class="number">1</span>]) <span class="keyword">continue</span>; <span class="comment">// skip duplicate</span></span><br><span class="line">		<span class="keyword">if</span>(nums[i] == start) start++; <span class="comment">// found in the array</span></span><br><span class="line">		<span class="keyword">else</span>&#123; <span class="comment">// there is a gap between start and current num</span></span><br><span class="line">			result.add(getRange(start, nums[i]-<span class="number">1</span>));</span><br><span class="line">			<span class="keyword">if</span>(nums[i] == Integer.MAX_VALUE) <span class="keyword">return</span> result;</span><br><span class="line">			start = nums[i] + <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	 &#125;</span><br><span class="line">	 </span><br><span class="line">	 <span class="keyword">if</span>(start &lt;= upper) result.add(getRange(start, upper));</span><br><span class="line">	 <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> String <span class="title">getRange</span><span class="params">(<span class="keyword">int</span> n1, <span class="keyword">int</span> n2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> n1 == n2 ? String.valueOf(n1) : String.format(<span class="string">&quot;%d-&gt;%d&quot;</span> , n1, n2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>57. Insert Interval</summary>
<blockquote>
<p>One pointer, three while loops, one way<br>
Create a list and put all intervals that end before the new interval<br>
For the list that starts before or on the end time of the new interval, get min of starting time, get max of ending time<br>
Add the rest of the intervals to the list<br>
Run time: $O(n)$, space: $O(n)$</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[][] insert(<span class="keyword">int</span>[][] intervals, <span class="keyword">int</span>[] newInterval) &#123;</span><br><span class="line">    List&lt;<span class="keyword">int</span>[]&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, n = intervals.length;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; n &amp;&amp; intervals[i][<span class="number">1</span>] &lt; newInterval[<span class="number">0</span>])&#123;</span><br><span class="line">        ans.add(intervals[i]);</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; n &amp;&amp; intervals[i][<span class="number">0</span>] &lt;= newInterval[<span class="number">1</span>])&#123;</span><br><span class="line">        newInterval[<span class="number">0</span>] = Math.min(intervals[i][<span class="number">0</span>], newInterval[<span class="number">0</span>]);</span><br><span class="line">        newInterval[<span class="number">1</span>] = Math.max(intervals[i][<span class="number">1</span>], newInterval[<span class="number">1</span>]);</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    ans.add(newInterval);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(i &lt; n)&#123;</span><br><span class="line">        ans.add(intervals[i]);</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    n = ans.size();</span><br><span class="line">    <span class="keyword">int</span>[][] newIntervals = <span class="keyword">new</span> <span class="keyword">int</span>[n][<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; n; k++)&#123;</span><br><span class="line">        newIntervals[k][<span class="number">0</span>] = ans.get(k)[<span class="number">0</span>];</span><br><span class="line">        newIntervals[k][<span class="number">1</span>] = ans.get(k)[<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newIntervals;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>308. Range Sum Query 2D - Mutable</summary>
<blockquote>
<p>Use two matrices; one for copying original matrix, one for calculating accumulating column sum<br>
When updating specific entry, loop through all rows on the same column, and update the value<br>
When summing the region, looping through col1 to col2, add the difference between row2 and row1</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NumMatrix</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] colSum;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] matrix;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NumMatrix</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.matrix = matrix;</span><br><span class="line">        <span class="keyword">if</span> (matrix == <span class="keyword">null</span> || matrix.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (matrix[<span class="number">0</span>] == <span class="keyword">null</span> || matrix[<span class="number">0</span>].length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> m = matrix.length;</span><br><span class="line">        <span class="keyword">int</span> n = matrix[<span class="number">0</span>].length;</span><br><span class="line">        colSum = <span class="keyword">new</span> <span class="keyword">int</span>[m + <span class="number">1</span>][n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                colSum[i][j] = colSum[i - <span class="number">1</span>][j] + matrix[i - <span class="number">1</span>][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> row, <span class="keyword">int</span> col, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = row + <span class="number">1</span>; i &lt; colSum.length; i++) &#123;</span><br><span class="line">            colSum[i][col] = colSum[i][col] - matrix[row][col] + val;</span><br><span class="line">        &#125;</span><br><span class="line">        matrix[row][col] = val;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sumRegion</span><span class="params">(<span class="keyword">int</span> row1, <span class="keyword">int</span> col1, <span class="keyword">int</span> row2, <span class="keyword">int</span> col2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = col1; j &lt;= col2; j++) &#123;</span><br><span class="line">            sum += colSum[row2 + <span class="number">1</span>][j] - colSum[row1][j]; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>939. Minimum Area Rectangle</summary>
<blockquote>
<p>Use Map&lt;Integer, Set<Integer>&gt; to store x-value, and set of y-values<br>
Then use nested for loop, skip points with same x or y values, see if they can form a rectangle, then update the min<br>
Run time: $O(n^2)$, space: $O(n^2)$</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minAreaRect</span><span class="params">(<span class="keyword">int</span>[][] points)</span> </span>&#123;</span><br><span class="line">    Map&lt;Integer, Set&lt;Integer&gt;&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span>[] a: points)&#123;</span><br><span class="line">        Set&lt;Integer&gt; set = map.getOrDefault(a[<span class="number">0</span>], <span class="keyword">new</span> HashSet());</span><br><span class="line">        set.add(a[<span class="number">1</span>]); <span class="comment">// or say if not exist, then put a new set,</span></span><br><span class="line">        map.put(a[<span class="number">0</span>], set); <span class="comment">// then do map.get(a[0]).add(a[1]);</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> min = Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span>[] a1: points)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span>[] a2: points)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a1[<span class="number">0</span>] == a2[<span class="number">0</span>] || a1[<span class="number">1</span>] == a2[<span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(map.get(a1[<span class="number">0</span>]).contains(a2[<span class="number">1</span>]) &amp;&amp; </span><br><span class="line">              map.get(a2[<span class="number">0</span>]).contains(a1[<span class="number">1</span>]))&#123; <span class="comment">// form a rectangle</span></span><br><span class="line">                min = Math.min(min, Math.abs((a1[<span class="number">0</span>]-a2[<span class="number">0</span>])*(a1[<span class="number">1</span>]-a2[<span class="number">1</span>])));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(min == Integer.MAX_VALUE) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> min;</span><br></pre></td></tr></table></figure>
</details>
<h2 id="Strings">Strings</h2>
<hr>
<details>
<summary></summary>
<blockquote></blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>647. Palindromic Substrings</summary>
<blockquote>
<p>Extend palindrome on each char (2 cases), and keep track of the number</p>
</blockquote>
<p>Run time: $O(n^2)$, space: $O(1)$</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countSubstrings</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s == <span class="keyword">null</span> || s.length() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(s.length() == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++)&#123;</span><br><span class="line">        count += numPalin(s, i, i) + numPalin(s, i-<span class="number">1</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">numPalin</span><span class="params">(String s, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i &gt; j) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> c = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &gt;= <span class="number">0</span> &amp;&amp; j &lt; s.length() &amp;&amp; s.charAt(i) == s.charAt(j))&#123;</span><br><span class="line">        i--;</span><br><span class="line">        j++;</span><br><span class="line">        c++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>DP way: <code>dp[i + 1][j - 1]</code> is referred to the string in between <code>dp[i][j]</code>, which is the last status before expanding to <code>dp[i][j]</code>, that’s why we are using dp.<br>
For <code>j - i &lt; 3</code>, think that you have a string AXA, and <code>j-i</code> here is <code>2</code>, since A is matched with A, X does not matter here.<br>
So when the strings in between is less than or equal to 1 char, we can ignore it.</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countSubstrings</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = s.length();</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">boolean</span>[][] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[n][n];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; n; j++) &#123;</span><br><span class="line">            dp[i][j] = s.charAt(i) == s.charAt(j) &amp;&amp; (j - i &lt; <span class="number">3</span> || dp[i + <span class="number">1</span>][j - <span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">if</span>(dp[i][j]) res++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>71. Simplify Path</summary>
<blockquote>
<p>Elegant solution! Split the original string by “/”. Push the element to stack if it is not <code>..</code>, <code>.</code>, or empty. If it is <code>..</code>, then pop the top element from the stack.<br>
Then append “/” and each element to the string builder. If in the end the string builder is empty, return <code>/</code>.</p>
</blockquote>
<p>Run time: $O(n)$, space: $O(n)$</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">simplifyPath</span><span class="params">(String path)</span> </span>&#123;</span><br><span class="line">    StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    Stack&lt;String&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (String dir : path.split(<span class="string">&quot;/&quot;</span>))&#123;</span><br><span class="line">        <span class="keyword">if</span> (dir.equals(<span class="string">&quot;..&quot;</span>) &amp;&amp; !stack.isEmpty()) &#123;</span><br><span class="line">            stack.pop();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!dir.equals(<span class="string">&quot;..&quot;</span>) &amp;&amp; !dir.equals(<span class="string">&quot;.&quot;</span>)&amp;&amp; !dir.equals(<span class="string">&quot;&quot;</span>))&#123;</span><br><span class="line">            stack.push(dir);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(String s : stack) sb.append(<span class="string">&quot;/&quot;</span>+ s);</span><br><span class="line">    <span class="keyword">return</span> sb.length() == <span class="number">0</span>? <span class="string">&quot;/&quot;</span>: sb.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>482. License Key Formatting (M)</summary>
<blockquote>
<p>First remove all <code>-</code> and change to upper case<br>
Create StringBuilder variable and initialize the index to be <code>length-K</code><br>
Decrement <code>i</code> by <code>K</code> each time we have inserted <code>-</code></p>
</blockquote>
<p>Run time: $O(n)$, space: $O(n)$</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> String <span class="title">licenseKeyFormatting</span><span class="params">(String S, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">    S = S.replaceAll(<span class="string">&quot;-&quot;</span>, <span class="string">&quot;&quot;</span>).toUpperCase();</span><br><span class="line">    StringBuilder sb = <span class="keyword">new</span> StringBuilder(S);</span><br><span class="line">    <span class="comment">// Starting from the end of sb, and going backwards. </span></span><br><span class="line">    <span class="keyword">int</span> i = sb.length() - K;</span><br><span class="line">    <span class="keyword">while</span>(i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        sb.insert(i, <span class="string">&#x27;-&#x27;</span>);</span><br><span class="line">        i -= K;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sb.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>680. Valid Palindrome II (FB intern, failed in 2018)</summary>
<blockquote>
<p>Use a boolean to flag whether one character has been removed or not</p>
</blockquote>
<p>Run time: $O(n)$, space: $O(1)$</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">validPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s == <span class="keyword">null</span> || s.length() &lt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">return</span> helper(s, <span class="number">0</span>, s.length()-<span class="number">1</span>, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">helper</span><span class="params">(String s, <span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">boolean</span> del)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i == j) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt;= j)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.charAt(i) == s.charAt(j))&#123;</span><br><span class="line">            i++;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!del)&#123;</span><br><span class="line">            <span class="keyword">return</span> helper(s, i+<span class="number">1</span>, j, <span class="keyword">true</span>) || helper(s, i, j-<span class="number">1</span>, <span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>12. Integer to Roman (M)</summary>
<blockquote></blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">intToRoman</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">int</span>[] values =&#123;<span class="number">1000</span>, <span class="number">900</span>, <span class="number">500</span>, <span class="number">400</span>, <span class="number">100</span>, <span class="number">90</span>, <span class="number">50</span>, <span class="number">40</span>, <span class="number">10</span>, <span class="number">9</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">1</span>&#125;;</span><br><span class="line">    String[] tokens=&#123;<span class="string">&quot;M&quot;</span>, <span class="string">&quot;CM&quot;</span>,<span class="string">&quot;D&quot;</span>,<span class="string">&quot;CD&quot;</span>,<span class="string">&quot;C&quot;</span>,<span class="string">&quot;XC&quot;</span>,<span class="string">&quot;L&quot;</span>,<span class="string">&quot;XL&quot;</span>,<span class="string">&quot;X&quot;</span>,<span class="string">&quot;IX&quot;</span>,<span class="string">&quot;V&quot;</span>,<span class="string">&quot;IV&quot;</span>, <span class="string">&quot;I&quot;</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(num &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">// if greater than values[i], could repeat multi times, not increment i here</span></span><br><span class="line">        <span class="keyword">if</span>(num &gt;= values[i])&#123;</span><br><span class="line">            num-= values[i];</span><br><span class="line">            sb.append(tokens[i]);</span><br><span class="line">        &#125; <span class="keyword">else</span>  i++; <span class="comment">// if less than values[i], safely move forward </span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sb.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">intToRoman</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    String M[] = &#123;<span class="string">&quot;&quot;</span>, <span class="string">&quot;M&quot;</span>, <span class="string">&quot;MM&quot;</span>, <span class="string">&quot;MMM&quot;</span>&#125;;</span><br><span class="line">    String C[] = &#123;<span class="string">&quot;&quot;</span>, <span class="string">&quot;C&quot;</span>, <span class="string">&quot;CC&quot;</span>, <span class="string">&quot;CCC&quot;</span>, <span class="string">&quot;CD&quot;</span>, <span class="string">&quot;D&quot;</span>, <span class="string">&quot;DC&quot;</span>, <span class="string">&quot;DCC&quot;</span>, <span class="string">&quot;DCCC&quot;</span>, <span class="string">&quot;CM&quot;</span>&#125;;</span><br><span class="line">    String X[] = &#123;<span class="string">&quot;&quot;</span>, <span class="string">&quot;X&quot;</span>, <span class="string">&quot;XX&quot;</span>, <span class="string">&quot;XXX&quot;</span>, <span class="string">&quot;XL&quot;</span>, <span class="string">&quot;L&quot;</span>, <span class="string">&quot;LX&quot;</span>, <span class="string">&quot;LXX&quot;</span>, <span class="string">&quot;LXXX&quot;</span>, <span class="string">&quot;XC&quot;</span>&#125;;</span><br><span class="line">    String I[] = &#123;<span class="string">&quot;&quot;</span>, <span class="string">&quot;I&quot;</span>, <span class="string">&quot;II&quot;</span>, <span class="string">&quot;III&quot;</span>, <span class="string">&quot;IV&quot;</span>, <span class="string">&quot;V&quot;</span>, <span class="string">&quot;VI&quot;</span>, <span class="string">&quot;VII&quot;</span>, <span class="string">&quot;VIII&quot;</span>, <span class="string">&quot;IX&quot;</span>&#125;;</span><br><span class="line">    <span class="keyword">return</span> M[num/<span class="number">1000</span>] + C[(num%<span class="number">1000</span>)/<span class="number">100</span>]+ X[(num%<span class="number">100</span>)/<span class="number">10</span>] + I[num%<span class="number">10</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>1055. Shortest Way to Form String (G)</summary>
<blockquote>
<p>// inverted index data structure<br>
// dict[i][c - ‘a’] represents the earliest index &gt;= i where character c occurs in source.<br>
// time complexity:  O(M + N) 97.67% 1ms --&gt; M is the length of source, N is the length of target<br>
// space complexity: O(M) 100%</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">shortestWay</span><span class="params">(String source, String target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span>[] s = source.toCharArray();</span><br><span class="line">    <span class="keyword">char</span>[] t = target.toCharArray();</span><br><span class="line">    <span class="keyword">int</span> M = s.length;</span><br><span class="line">    <span class="keyword">int</span> N = t.length;</span><br><span class="line">    <span class="keyword">int</span>[][] dict = <span class="keyword">new</span> <span class="keyword">int</span>[M][<span class="number">26</span>];</span><br><span class="line">    Arrays.fill(dict[M-<span class="number">1</span>], -<span class="number">1</span>); <span class="comment">// -1 means no that char in source</span></span><br><span class="line">    dict[M - <span class="number">1</span>][s[M - <span class="number">1</span>] - <span class="string">&#x27;a&#x27;</span>] = M - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> x = M - <span class="number">2</span>; x &gt;= <span class="number">0</span>; --x) &#123;</span><br><span class="line">        dict[x] = Arrays.copyOf(dict[x + <span class="number">1</span>], <span class="number">26</span>);</span><br><span class="line">        dict[x][s[x] - <span class="string">&#x27;a&#x27;</span>] = x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">char</span> c: t) &#123;</span><br><span class="line">        <span class="keyword">if</span>(dict[<span class="number">0</span>][c - <span class="string">&#x27;a&#x27;</span>] == -<span class="number">1</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(dict[idx][c - <span class="string">&#x27;a&#x27;</span>] == -<span class="number">1</span>) &#123;</span><br><span class="line">            ++ans;</span><br><span class="line">            idx = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        idx = dict[idx][c - <span class="string">&#x27;a&#x27;</span>] + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(idx == M) &#123;</span><br><span class="line">            ++ans;</span><br><span class="line">            idx = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans + (idx == <span class="number">0</span> ? <span class="number">0</span> : <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>把字符串S里的所有字符统计一下，记录它们出现的位置<br>
然后一个个字符去扫描t<br>
假设t是abcabab,<br>
一开始找到了a的最左边的Index 0,<br>
那我在找第二个字母b的时候，b必须要出现在之前index的后面<br>
第三个字母c，也必须出现在前面的index的后面<br>
所以扫描的时候记录一下之前找到的index就可以了<br>
为了快速查找，用treeset实现o(logn)找index</p>
</blockquote>
<p>Run time: $O(n\log n)$, space: $O(n)$</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">shortestWay</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line">    Map&lt;Character, TreeSet&lt;Integer&gt;&gt; map = <span class="keyword">new</span> HashMap();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">        <span class="keyword">char</span> c = s.charAt(i);</span><br><span class="line">        TreeSet&lt;Integer&gt; set = map.getOrDefault(c, <span class="keyword">new</span> TreeSet());</span><br><span class="line">        set.add(i);</span><br><span class="line">        map.put(c, set);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">1</span>, prev = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; t.length(); i++) &#123;</span><br><span class="line">        <span class="keyword">char</span> c = t.charAt(i);</span><br><span class="line">        TreeSet&lt;Integer&gt; set = map.get(c);</span><br><span class="line">        <span class="keyword">if</span>(set == <span class="keyword">null</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        Integer high = set.higher(prev);</span><br><span class="line">        <span class="keyword">if</span>(high != <span class="keyword">null</span>) &#123;</span><br><span class="line">            prev = high;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            res++;</span><br><span class="line">            prev = set.first();</span><br><span class="line">        &#125;            </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Brute force: check each substring one by one</p>
</blockquote>
<p>Run time: $O(mn)$, space: $O(1)$, where $m$ is the length of source, $n$ is the length of target</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">shortestWay</span><span class="params">(String source, String target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t = <span class="number">0</span>, res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (t &lt; target.length()) &#123;</span><br><span class="line">        <span class="keyword">int</span> start = t;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> s = <span class="number">0</span>; s &lt; source.length(); s++) </span><br><span class="line">            <span class="keyword">if</span> (t &lt; target.length() &amp;&amp; target.charAt(t) == source.charAt(s)) t++;</span><br><span class="line">        <span class="keyword">if</span> (start == t) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        res++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>678. Valid Parenthesis String (G)</summary>
<blockquote>
<p><code>low</code>: take ‘*’ as ‘)’, if there are some ‘(’ not matched; <code>high</code>: take ‘*’ as ‘(’</p>
</blockquote>
<p>if <code>high</code> &lt; 0 means too much ‘)’<br>
if <code>low</code> &gt; 0 , after the count finished, means too much ‘(’</p>
<p>Since low take ‘*’ as ‘)’, there might be too much ‘)’, so that low might less than 0. That’s why <code>low--</code> should happen only <code>low&gt;0</code>. This can thought as, low only take as much as '('s ‘)’ and ignore other ‘)’ s. This will not cause problem since: ‘*’ can be treated as empty; <code>high</code> has deal with the situation that too much ‘)’ exist</p>
<p>Run time: $O(n)$, space: $O(1)$</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">checkValidString</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> low = <span class="number">0</span>, high = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s.charAt(i) == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">            low++;</span><br><span class="line">            high++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s.charAt(i) == <span class="string">&#x27;)&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (low &gt; <span class="number">0</span>) low--;</span><br><span class="line">            high--;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (low &gt; <span class="number">0</span>) low--;</span><br><span class="line">            high++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (high &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> low == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Dynamic programming<br>
How to check valid parenthesis w/ only ( and )? Easy. Count each char from left to right. When we see (, count++; when we see ) count–; if count &lt; 0, it is invalid () is more than (); At last, count should == 0.<br>
This problem added *. The easiest way is to try 3 possible ways when we see it. Return true if one of them is valid.</p>
</blockquote>
<p>Run time: $O(n^2)$, space: $O(n^2)$</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Boolean[][] dp;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">checkValidString</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    dp = <span class="keyword">new</span> Boolean[s.length() + <span class="number">1</span>][s.length() + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> check(s, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">check</span><span class="params">(String s, <span class="keyword">int</span> start, <span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (count &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">int</span> y = count;</span><br><span class="line">    <span class="keyword">if</span> (dp[start][y] != <span class="keyword">null</span>) <span class="keyword">return</span> dp[start][y];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt; s.length(); i++) &#123;</span><br><span class="line">        <span class="keyword">char</span> c = s.charAt(i);</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;)&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (count &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            count--;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">            dp[start][y] = (check(s, i + <span class="number">1</span>, count + <span class="number">1</span>) || check(s, i + <span class="number">1</span>, count - <span class="number">1</span>) || check(s, i + <span class="number">1</span>, count));</span><br><span class="line">            <span class="keyword">return</span> dp[start][y];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    dp[start][y] = (count == <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> dp[start][y];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>524. Longest Word in Dictionary through Deleting (G)</summary>
<blockquote>
<p>Compare each word, if it works, check if it is smaller lexicographical order or longer</p>
</blockquote>
<p>Run time: $O(n\log n)$, space: $O(1)$, where $n$ is the length of dictionary</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">findLongestWord</span><span class="params">(String s, List&lt;String&gt; d)</span> </span>&#123;</span><br><span class="line">    String longest = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (String dictWord : d) &#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : s.toCharArray()) </span><br><span class="line">            <span class="keyword">if</span> (i &lt; dictWord.length() &amp;&amp; c == dictWord.charAt(i)) i++;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (i == dictWord.length() &amp;&amp; dictWord.length() &gt;= longest.length()) </span><br><span class="line">            <span class="keyword">if</span> (dictWord.length() &gt; longest.length() || dictWord.compareTo(longest) &lt; <span class="number">0</span>)</span><br><span class="line">                longest = dictWord;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> longest;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Sort the dictionary by lexicographical order first</p>
</blockquote>
<p>Run time: $O(n)$, space: $O(1)$, where $n$ is the length of dictionary</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">findLongestWord</span><span class="params">(String s, List&lt;String&gt; d)</span> </span>&#123;</span><br><span class="line">    Collections.sort(d, (a,b) -&gt; a.length() != b.length() ? -Integer.compare(a.length(), b.length()) :  a.compareTo(b));</span><br><span class="line">    <span class="keyword">for</span> (String dictWord : d) &#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : s.toCharArray()) </span><br><span class="line">            <span class="keyword">if</span> (i &lt; dictWord.length() &amp;&amp; c == dictWord.charAt(i)) i++;</span><br><span class="line">        <span class="keyword">if</span> (i == dictWord.length()) <span class="keyword">return</span> dictWord;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>My way</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">findLongestWord</span><span class="params">(String s, List&lt;String&gt; d)</span> </span>&#123;</span><br><span class="line">    String ans = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(String str: d)&#123;</span><br><span class="line">        <span class="keyword">if</span>(helper(s, str))&#123;</span><br><span class="line">            <span class="keyword">if</span>(ans.length() &lt; str.length()) ans = str; </span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(ans.length() == str.length() &amp;&amp; ans.compareTo(str) &gt; <span class="number">0</span>) ans = str; </span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">helper</span><span class="params">(String s, String str)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s.length() &lt; str.length()) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">char</span> c: s.toCharArray())&#123;</span><br><span class="line">        <span class="keyword">if</span>(i &lt; str.length() &amp;&amp; str.charAt(i) == c) i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(i == str.length()) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>809. Expressive Words (G)</summary>
<blockquote>
<p>Use a helper function to check is this word can be extended<br>
If the original word is longer than the extended one, return false<br>
For each comparison, if the character are not the same, return false<br>
Otherwise move the index until not the same or reach the end<br>
Calculate the number of repeated words<br>
If the repeated length in extended word is less than 3 and it is not equal to the word in list, false<br>
If the repeated length in extended word &gt;= 3 and it is smaller than the word in list, false</p>
</blockquote>
<p>Run time: $O(mn)$, space: $O(1)$ , where $m$ is length of longest word, $n$ is number of words</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">expressiveWords</span><span class="params">(String S, String[] words)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; words.length; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(canExtend(S, words[i])) count++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">canExtend</span><span class="params">(String S, String word)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S.length() &lt; word.length()) <span class="keyword">return</span> <span class="keyword">false</span>; <span class="comment">// impossible</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> indexS = <span class="number">0</span>, indexW = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(indexS &lt; S.length() &amp;&amp; indexW &lt; word.length())&#123;</span><br><span class="line">        <span class="keyword">int</span> initialS = indexS, initialW = indexW;</span><br><span class="line">        <span class="keyword">char</span> s = S.charAt(indexS), w = word.charAt(indexW);</span><br><span class="line">        <span class="keyword">if</span>(s != w) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">while</span>(indexW &lt; word.length() &amp;&amp; s == word.charAt(indexW)) indexW++;</span><br><span class="line">            <span class="keyword">while</span>(indexS &lt; S.length() &amp;&amp; s == S.charAt(indexS)) indexS++;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">int</span> cnt1 = indexS - initialS;</span><br><span class="line">            <span class="keyword">int</span> cnt2 = indexW - initialW;</span><br><span class="line">            <span class="keyword">if</span>(cnt1 &lt; <span class="number">3</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(cnt1 != cnt2) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>(cnt1 &lt; cnt2) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> indexS == S.length() &amp;&amp; indexW == word.length();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>1249. Minimum Remove to Make Valid Parentheses</summary>
<blockquote>
<p>Edited the code to append all characters except those invalid open parentheses, then reverse the stringbuilder. This will achieve O(N) with slight headache.<br>
A new StringBuilder is created for the result, but you could reuse the first one by replacing the ( in place and prune the starting open number of chars.</p>
</blockquote>
<p>Run time: $O(n)$, space: $O(n)$</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">minRemoveToMakeValid</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">int</span> open = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> c : s.toCharArray()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">&#x27;(&#x27;</span>) </span><br><span class="line">            open++;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;)&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (open == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">            open--;</span><br><span class="line">        &#125;</span><br><span class="line">        sb.append(c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    StringBuilder result = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = sb.length() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sb.charAt(i) == <span class="string">&#x27;(&#x27;</span> &amp;&amp; open-- &gt; <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">        result.append(sb.charAt(i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result.reverse().toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>The intuition is counting the number of invalid ( and removing the invalid ) in the first pass.<br>
If there are open number of invalid ( left, we just need to remove them from the end in the second pass.</p>
</blockquote>
<p>Run time: $O(n)$, space: $O(n)$</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">minRemoveToMakeValid</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    String input = s;</span><br><span class="line">    <span class="keyword">char</span>[] p = <span class="keyword">new</span> <span class="keyword">char</span>[]&#123;<span class="string">&#x27;(&#x27;</span>,<span class="string">&#x27;)&#x27;</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>;</span><br><span class="line">    StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i =<span class="number">0</span>; i&lt;input.length(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (input.charAt(i) == p[<span class="number">0</span>]) &#123;</span><br><span class="line">            l++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (input.charAt(i) == p[<span class="number">1</span>]) &#123;</span><br><span class="line">            l--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (l&lt;<span class="number">0</span>) &#123;</span><br><span class="line">            l++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            sb.append(input.charAt(i));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (l != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> StringBuilder(minRemoveToMakeValid(sb.reverse().toString(), <span class="keyword">new</span> <span class="keyword">char</span>[]&#123;<span class="string">&#x27;)&#x27;</span>, <span class="string">&#x27;(&#x27;</span>&#125;)).reverse().toString();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sb.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>1247. Minimum Swaps to Make Strings Equal</summary>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minimumSwap</span><span class="params">(String s1, String s2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n1 = s1.length(), n2 = s2.length();</span><br><span class="line">    <span class="keyword">if</span>(n1 != n2) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> count1 = <span class="number">0</span>, count2 = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n1; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s1.charAt(i) != s2.charAt(i))&#123;</span><br><span class="line">            <span class="keyword">if</span>(s1.charAt(i) == <span class="string">&#x27;x&#x27;</span>) count1 ++;</span><br><span class="line">            <span class="keyword">else</span> count2 ++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>((count1 + count2) % <span class="number">2</span> == <span class="number">1</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    ans += count1/<span class="number">2</span> + count2/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(count1 % <span class="number">2</span> == <span class="number">0</span>) <span class="keyword">return</span> ans;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> ans + <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Count the number of x-y and y-x pairs separately<br>
Also check if the total number of x and total number of y is even or not<br>
Answer: half num of x-y + half num of y-x+ 1 if x-y is odd + 1 if y-x is odd</p>
</blockquote>
<p>Run time: $O(n)$, space: $O(1)$</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minimumSwap</span><span class="params">(String s1, String s2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s1.length() != s2.length()) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(s1.equals(s2)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">int</span>[] swap = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s1.length(); i++)&#123;</span><br><span class="line">        <span class="keyword">char</span> c1 = s1.charAt(i), c2 = s2.charAt(i);</span><br><span class="line">        <span class="keyword">if</span>(c1 == <span class="string">&#x27;x&#x27;</span>) a[<span class="number">0</span>]++;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (c1 == <span class="string">&#x27;y&#x27;</span>) a[<span class="number">1</span>]++;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(c2 == <span class="string">&#x27;x&#x27;</span>) a[<span class="number">0</span>]++;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (c2 == <span class="string">&#x27;y&#x27;</span>) a[<span class="number">1</span>]++;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(c1 == <span class="string">&#x27;x&#x27;</span> &amp;&amp; c2 == <span class="string">&#x27;y&#x27;</span>) swap[<span class="number">0</span>]++;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(c1 == <span class="string">&#x27;y&#x27;</span> &amp;&amp; c2 == <span class="string">&#x27;x&#x27;</span>) swap[<span class="number">1</span>]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(a[<span class="number">0</span>] % <span class="number">2</span> == <span class="number">1</span> || a[<span class="number">1</span>] % <span class="number">2</span> == <span class="number">1</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> swap[<span class="number">0</span>]/<span class="number">2</span>+swap[<span class="number">1</span>]/<span class="number">2</span>+swap[<span class="number">0</span>]%<span class="number">2</span>+swap[<span class="number">1</span>]%<span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>5. Longest Palindromic Substring (M)</summary>
<blockquote>
<p>Helper method to find the current longest substring (2 cases)</p>
</blockquote>
<p>Run time: $O(n^2)$, space: $O(n)$</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        String max = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            String s1 = extend(s, i, i), s2 = extend(s, i, i + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (s1.length() &gt; max.length()) max = s1;</span><br><span class="line">            <span class="keyword">if</span> (s2.length() &gt; max.length()) max = s2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">extend</span><span class="params">(String s, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">0</span> &lt;= i &amp;&amp; j &lt; s.length()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i) != s.charAt(j)) <span class="keyword">break</span>;</span><br><span class="line">            i--;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.substring(i + <span class="number">1</span>, j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Stupid recursive way written by myself</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    String ans = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++)&#123;</span><br><span class="line">        String temp = s.substring(i,i+<span class="number">1</span>);</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> j = s.length() -<span class="number">1</span>; j&gt;=i; j--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(isPalin(s,i,j)) temp = s.substring(i,j+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>(ans.length() &lt; temp.length()) ans = temp;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalin</span><span class="params">(String a, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(lo == hi)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(lo +<span class="number">1</span> == hi)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a.charAt(lo) == a.charAt(hi)) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a.charAt(lo) == a.charAt(hi) &amp;&amp; isPalin(a,lo+<span class="number">1</span>,hi-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>32. Longest Valid Parentheses</summary>
<blockquote>
<p>Use stack to record the starting index for a possible sequence of valid parentheses<br>
Push the index when there’s no match, otherwise pop the element and update the max length</p>
</blockquote>
<p>Run time: $O(n)$, space: $O(n)$</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestValidParentheses</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    LinkedList&lt;Integer&gt; stack = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">    stack.push(-<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s.charAt(i) == <span class="string">&#x27;)&#x27;</span> &amp;&amp; stack.size() &gt; <span class="number">1</span> &amp;&amp; s.charAt(stack.peek()) == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">            stack.pop();</span><br><span class="line">            result = Math.max(result, i - stack.peek());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            stack.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>224. Basic Calculator</summary>
<blockquote>
<p>Use stack to store the value and sign<br>
If it is digit, then continue checking if there’s other digits, then compute the result and add to the result<br>
If it is <code>+/-</code>, set the sign variable to be 1/-1.<br>
If it is <code>(</code>, push the result and current sign to the stack, and reset result and sign<br>
If it is <code>)</code>, compute the result. The first popped element will be sign, the next one will be result</p>
</blockquote>
<p>Run time: $O(n)$, space: $O(n)$</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">calculate</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> len = s.length(), sign = <span class="number">1</span>, result = <span class="number">0</span>;</span><br><span class="line">Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">	<span class="keyword">if</span> (Character.isDigit(s.charAt(i))) &#123;</span><br><span class="line">		<span class="keyword">int</span> sum = s.charAt(i) - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">		<span class="keyword">while</span> (i + <span class="number">1</span> &lt; len &amp;&amp; Character.isDigit(s.charAt(i + <span class="number">1</span>))) &#123;</span><br><span class="line">			sum = sum * <span class="number">10</span> + s.charAt(i + <span class="number">1</span>) - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">			i++;</span><br><span class="line">		&#125;</span><br><span class="line">		result += sum * sign;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (s.charAt(i) == <span class="string">&#x27;+&#x27;</span>) sign = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (s.charAt(i) == <span class="string">&#x27;-&#x27;</span>) sign = -<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (s.charAt(i) == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">		stack.push(result);</span><br><span class="line">		stack.push(sign);</span><br><span class="line">		result = <span class="number">0</span>;</span><br><span class="line">		sign = <span class="number">1</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (s.charAt(i) == <span class="string">&#x27;)&#x27;</span>) &#123;</span><br><span class="line">		result = result * stack.pop() + stack.pop();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>273. Integer to English Words</summary>
<blockquote>
<p>List possible formats: less than ten, twenty, hundred, thousand, million, billion<br>
Then list the general string cases for less than ten, twenty, hundred<br>
Check edge case when input is 0<br>
Helper function to recursive translate number from largest digit to smallest digit, trim in the end</p>
</blockquote>
<p>Run time: $O(n)$, space: $O(n)$</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String[] below10 = <span class="keyword">new</span> String[]&#123;<span class="string">&quot;&quot;</span>, <span class="string">&quot;One&quot;</span>, <span class="string">&quot;Two&quot;</span>, <span class="string">&quot;Three&quot;</span>, </span><br><span class="line">                                                  <span class="string">&quot;Four&quot;</span>, <span class="string">&quot;Five&quot;</span>, <span class="string">&quot;Six&quot;</span>, <span class="string">&quot;Seven&quot;</span>, </span><br><span class="line">                                                 <span class="string">&quot;Eight&quot;</span>, <span class="string">&quot;Nine&quot;</span>&#125;;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String[] below20 = <span class="keyword">new</span> String[]&#123;<span class="string">&quot;Ten&quot;</span>, <span class="string">&quot;Eleven&quot;</span>, <span class="string">&quot;Twelve&quot;</span>, <span class="string">&quot;Thirteen&quot;</span>, </span><br><span class="line">                                                  <span class="string">&quot;Fourteen&quot;</span>, <span class="string">&quot;Fifteen&quot;</span>, <span class="string">&quot;Sixteen&quot;</span>, <span class="string">&quot;Seventeen&quot;</span>, </span><br><span class="line">                                                 <span class="string">&quot;Eighteen&quot;</span>, <span class="string">&quot;Nineteen&quot;</span>&#125;;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String[] below100 = <span class="keyword">new</span> String[]&#123;<span class="string">&quot;&quot;</span>, <span class="string">&quot;Ten&quot;</span>, <span class="string">&quot;Twenty&quot;</span>, <span class="string">&quot;Thirty&quot;</span>, <span class="string">&quot;Forty&quot;</span>, </span><br><span class="line">                                                   <span class="string">&quot;Fifty&quot;</span>, <span class="string">&quot;Sixty&quot;</span>, <span class="string">&quot;Seventy&quot;</span>, <span class="string">&quot;Eighty&quot;</span>, <span class="string">&quot;Ninety&quot;</span>&#125;;</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">numberToWords</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(num == <span class="number">0</span>) <span class="keyword">return</span> <span class="string">&quot;Zero&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> helper(num);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">helper</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">        String result = <span class="keyword">new</span> String();</span><br><span class="line">        <span class="keyword">if</span> (num &lt; <span class="number">10</span>) result = below10[num];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (num &lt; <span class="number">20</span>) result = below20[num-<span class="number">10</span>];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (num &lt; <span class="number">100</span>) result = below100[num/<span class="number">10</span>]+<span class="string">&quot; &quot;</span>+helper(num%<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (num &lt; <span class="number">1000</span>) result = helper(num/<span class="number">100</span>)+<span class="string">&quot; Hundred &quot;</span>+helper(num%<span class="number">100</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (num &lt; <span class="number">1000000</span>) result = helper(num/<span class="number">1000</span>)+<span class="string">&quot; Thousand &quot;</span>+helper(num%<span class="number">1000</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (num &lt; <span class="number">1000000000</span>) result = helper(num/<span class="number">1000000</span>)+<span class="string">&quot; Million &quot;</span>+helper(num%<span class="number">1000000</span>);</span><br><span class="line">        <span class="keyword">else</span> result = helper(num/<span class="number">1000000000</span>)+<span class="string">&quot; Billion &quot;</span>+helper(num%<span class="number">1000000000</span>);</span><br><span class="line">        <span class="keyword">return</span> result.trim(); <span class="comment">// delete extra space</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>67. Add Binary</summary>
<blockquote>
<p>Use one while loop to get the sum of each digit (if applicable) and carry-in<br>
Mod 2 and appended, divided by 2 and stored to carry-in<br>
At last, if carry-in is 1, append it, and reverse and to string</p>
</blockquote>
<p>Run time: $O(n)$, space: $O(n)$</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">addBinary</span><span class="params">(String a, String b)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// String ans = &quot;&quot;;</span></span><br><span class="line">    StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">int</span> ptr1 = a.length()-<span class="number">1</span>, ptr2 = b.length()-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> carryin = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(ptr1 &gt;= <span class="number">0</span> || ptr2 &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = carryin;</span><br><span class="line">        <span class="keyword">if</span>(ptr2 &gt;= <span class="number">0</span>) sum += b.charAt(ptr2--)-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span>(ptr1 &gt;= <span class="number">0</span>) sum += a.charAt(ptr1--)-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        sb.append(sum % <span class="number">2</span>);</span><br><span class="line">        carryin = sum / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(carryin != <span class="number">0</span>) sb.append(carryin);</span><br><span class="line">    <span class="keyword">return</span> sb.reverse().toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>125. Valid Palindrome (M)</summary>
<blockquote>
<p>Use while loop to skip non-letter or non-digit</p>
</blockquote>
<p>Run time: $O(n)$, space: $O(1)$</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> start = <span class="number">0</span>; </span><br><span class="line">    <span class="keyword">int</span> end = s.length() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(start &lt;= end) &#123;</span><br><span class="line">        <span class="keyword">while</span>(start &lt;= end &amp;&amp; !Character.isLetterOrDigit(s.charAt(start))) &#123;</span><br><span class="line">            start++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(start &lt;= end &amp;&amp; !Character.isLetterOrDigit(s.charAt(end))) &#123;</span><br><span class="line">            end--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(start &lt;= end &amp;&amp; Character.toLowerCase(s.charAt(start)) != Character.toLowerCase(s.charAt(end))) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        start++;</span><br><span class="line">        end--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>68. Text Justification</summary>
<blockquote>
<p>Walk through each word, if current row is empty, then add it<br>
else if there is enough space for this word with a space, append space and add this word<br>
otherwise, adjust the space in the line, add this line to answer, create a new line<br>
In the end, adjust the last line and add to the answer<br>
Run time: $O(n)$, space: $O(n)$</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">fullJustify</span><span class="params">(String[] words, <span class="keyword">int</span> maxWidth)</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (words.length == <span class="number">0</span>) <span class="keyword">return</span> ans; <span class="comment">// check empty</span></span><br><span class="line">    </span><br><span class="line">    StringBuilder cur = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; words.length; i++) &#123;</span><br><span class="line">        String w = words[i];</span><br><span class="line">        <span class="keyword">if</span> (cur.length() == <span class="number">0</span>) &#123; <span class="comment">// first word in the line</span></span><br><span class="line">            cur.append(w);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (maxWidth - cur.length() &gt;= w.length() + <span class="number">1</span>) &#123;</span><br><span class="line">            cur.append(<span class="string">&#x27; &#x27;</span>).append(w); <span class="comment">// can fit this word</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            format(cur, maxWidth, <span class="keyword">false</span>); <span class="comment">// fix current line</span></span><br><span class="line">            ans.add(cur.toString());</span><br><span class="line">            cur.setLength(<span class="number">0</span>); <span class="comment">// new line</span></span><br><span class="line">            i--; <span class="comment">// go back to the same word</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    format(cur, maxWidth, <span class="keyword">true</span>);</span><br><span class="line">    ans.add(cur.toString());</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">format</span><span class="params">(StringBuilder cur, <span class="keyword">int</span> maxWidth,  <span class="keyword">boolean</span> leftJustify)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> hasSpace = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cur.length(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cur.charAt(i) == <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">            hasSpace = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (leftJustify || !hasSpace) &#123; <span class="comment">// last line</span></span><br><span class="line">        <span class="keyword">while</span> (cur.length() &lt; maxWidth) cur.append(<span class="string">&#x27; &#x27;</span>); <span class="comment">// add space</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> si = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (cur.length() &lt; maxWidth) &#123;</span><br><span class="line">            <span class="keyword">while</span> (cur.charAt(si) != <span class="string">&#x27; &#x27;</span> || cur.charAt(si-<span class="number">1</span>) == <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">                si++;</span><br><span class="line">                <span class="keyword">if</span> (si == cur.length()) si = <span class="number">1</span>;</span><br><span class="line">            &#125; </span><br><span class="line">            cur.insert(si, <span class="string">&#x27; &#x27;</span>);</span><br><span class="line">            <span class="keyword">if</span>(si == cur.length()) si = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> si++;</span><br><span class="line">            <span class="comment">// si = si == curr.length() ? 1 : si+1;</span></span><br><span class="line">        &#125;                        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>3. Longest Substring Without Repeating Characters</summary>
<blockquote>
<p>More efficient way!<br>
Run time: $O(n)$, space: $O(n)$</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// sanity check</span></span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.length() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span>[] chars = s.toCharArray();</span><br><span class="line">    <span class="keyword">int</span>[] counts = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">256</span>];</span><br><span class="line">    <span class="keyword">int</span> begin = <span class="number">0</span>, maxLen = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; chars.length; ++i) &#123;</span><br><span class="line">        counts[chars[i]]++;</span><br><span class="line">        <span class="keyword">if</span> (counts[chars[i]] == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (begin &lt; i &amp;&amp; counts[chars[i]] == <span class="number">2</span>) counts[chars[begin++]]--;</span><br><span class="line">        &#125;</span><br><span class="line">        maxLen = Math.max(i-begin+<span class="number">1</span>, maxLen);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxLen;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Find the max length starting with each char in the string<br>
Run time: $O(n^2)$, space: $O(n)$</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s.length() == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    Map&lt;Character, Integer&gt; map;</span><br><span class="line">    <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++)&#123;</span><br><span class="line">        map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> j = i;</span><br><span class="line">        <span class="keyword">while</span>(j &lt; s.length())&#123;</span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(s.charAt(j))) &#123;</span><br><span class="line">                max = Math.max(max, j-i);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> map.put(s.charAt(j), <span class="number">0</span>);</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(j == s.length()) max = Math.max(max, j-i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>767. Reorganize String</summary>
<blockquote>
<p>Map to record occurrences, max heap to store Map.Entry and order the chars<br>
Run time: $O(n\log n)$, space: $O(n)$</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">reorganizeString</span><span class="params">(String S)</span> </span>&#123;</span><br><span class="line">    StringBuilder res = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    Map&lt;Character, Integer&gt; hm = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> c : S.toCharArray()) hm.put(c, hm.getOrDefault(c, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    PriorityQueue&lt;Map.Entry&lt;Character, Integer&gt;&gt; pq = <span class="keyword">new</span> PriorityQueue&lt;&gt;((a, b) -&gt; b.getValue() - a.getValue());</span><br><span class="line">    pq.addAll(hm.entrySet());</span><br><span class="line">    Map.Entry&lt;Character, Integer&gt; prev = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">while</span> (!pq.isEmpty()) &#123;</span><br><span class="line">        Map.Entry&lt;Character, Integer&gt; entry = pq.poll();</span><br><span class="line">        <span class="keyword">if</span> (prev != <span class="keyword">null</span> &amp;&amp; prev.getValue() &gt; <span class="number">0</span>) pq.offer(prev);</span><br><span class="line"></span><br><span class="line">        res.append((<span class="keyword">char</span>) entry.getKey());</span><br><span class="line">        entry.setValue(entry.getValue() - <span class="number">1</span>);</span><br><span class="line">        prev = entry;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (res.length() == S.length()) ? res.toString() : <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<details>
<summary>844. Backspace String Compare
</summary>
<blockquote>
<p>Use StringBuilder to add/delete char (setLength)<br>
Run time: $O(n)$, space: $O(n)$</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">backspaceCompare</span><span class="params">(String S, String T)</span> </span>&#123;</span><br><span class="line">    String s = buildStr(S), t = buildStr(T);</span><br><span class="line">    <span class="keyword">return</span> s.equals(t);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">String <span class="title">buildStr</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">    StringBuilder sbS = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">char</span> c: s.toCharArray())&#123;</span><br><span class="line">        <span class="keyword">if</span>(c == <span class="string">&#x27;#&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(sbS.length() &gt;= <span class="number">1</span>) sbS.setLength(sbS.length()-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> sbS.append(c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sbS.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Two pointers<br>
Run time: $O(n)$, space: $O(1)$</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">backspaceCompare</span><span class="params">(String S, String T)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = S.length()-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> j = T.length()-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> countS = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> countT = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &gt;= <span class="number">0</span> || j &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (i &gt;= <span class="number">0</span> &amp;&amp; (countS &gt; <span class="number">0</span> || S.charAt(i) == <span class="string">&#x27;#&#x27;</span>)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (S.charAt(i) == <span class="string">&#x27;#&#x27;</span>) countS++;</span><br><span class="line">            <span class="keyword">else</span> countS--;</span><br><span class="line">            i--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">char</span> left = i &lt; <span class="number">0</span> ? <span class="string">&#x27;@&#x27;</span> : S.charAt(i);</span><br><span class="line">        <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; (countT &gt; <span class="number">0</span> || T.charAt(j) == <span class="string">&#x27;#&#x27;</span>)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (T.charAt(j) == <span class="string">&#x27;#&#x27;</span>) countT++;</span><br><span class="line">            <span class="keyword">else</span> countT--;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">char</span> right = j &lt; <span class="number">0</span> ? <span class="string">&#x27;@&#x27;</span> : T.charAt(j);</span><br><span class="line">        <span class="keyword">if</span> (left != right) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        i--;</span><br><span class="line">        j--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
]]></content>
  </entry>
</search>
